# [文件操作与模板](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/7)
> 计算机中为了便于数据的管理和检索，引入了“文件”的概念。在程序中，要使用一个文件，先要打开，打开后才能读写，读写完后要关闭。本模块将介绍C++流类相应的成员函数来实现文件操作的功能。此外，你还将学习到如何通过编写模板进行泛型程序设计，所谓“泛型”就是算法只要实现一遍，就能适用于多种数据类型。也可以说，泛型程序设计就是大量编写模板、使用模板的程序设计。
## 1. 文件操作
- 大家好，在这一小节中呢，我们来看一下文件操作。 说起这个文件呢，大家可能会觉得，这是我们在 操作计算机的时候最熟悉，但是偶尔又觉得很陌生的一个概念。 那么我们在这一小节中呢就具体来看一看如何利用C++语言来处理文件的一些操作。 我们知道呢，我们所有的数据 在计算机上保存的时候它其实都是具有一定的这样层次化的结构的， 当然呢，我们一个数据在计算机实质上被保存的就是这样的一个个0,1的 比特位。它是每位这样存放的。 但是呢我们具体如果去处理每个比特位的话呢那么可能在很多时候这个数据在构建的时候就会变得非常的繁琐，并且具有很强的不规律性。 所以我们进一步就把这8个比特位呢构成的称之为叫做字节。 **那么每一个byte呢它对应描述了一定的内容， 而这些各个字节组成的一些具体的内容呢我们又把它称之为叫做域或者记录**。 这里我们举了一个学生记录的例子。 
    ```C++
    //例如：学生记录
    int ID;
    char name[10];
    int age;
    int rank[10];
    ```
  在这个记录中间呢它就包含了每一个学生的学号， 姓名，年龄，以及它相应所在的班或者年纪的一个排位。 那么有了这样一系列的数据之后呢我们就会看到，其实我们会把所有的这些数据的记录呢顺序的写入到了一个相应的文件里头。 那么我们就会把这样的一个文件称之为叫做顺序文件。 
- 那么顺序文件它的本质呢实际上就是一个由有限的字符构成的一个顺序的字符流，它其实就是一个流的结构。那么我们之前呢一直在使用C++中间这样一个流的读入和读出这样的一个操作， 那么文件呢实际上你也可以把它看成就是一个顺序的字符流。 所以呢**在C++标准库中间的话呢，有相应的这样三个类， 分别是叫做ifstream，ofstream，和fstream 这样三个类，来去操作整个的文件。 那么我们就把这样的三个类呢称之为叫做文件流类**。 
  - 那么文件流类本身呢对于这个ifstream来讲的话， 它主要就是用于将文件呢读取，从文件中间呢，去读取数据。 
  - 而ofstream呢它主要就是去实现将文件中呢写入数据。 
  - 那么相应的这个fstream呢它呢既可以用于从文件中间呢去读取数据， 又可应用于向文件中呢写入数据。 
- 那么我们来具体看一下这样的三个类的相互关系。 我们可以用这样的一张图来进行表示。 
    ```C++
                                ios
                               ↙   ↘
                             ↙       ↘
                        istream     ostream
                         ↙   ↘       ↙   ↘
                       ↙       ↘   ↙       ↘      
                   ifstream   iostream   ofstream
                                 ↓
                              fstream                                    
    ```
  那么可以看到呢，ifstream这个类 它呢是和这个fstream这个类都是由这个istream这个类派生出来的。 所以我们说呢，本身这个istream这个类它所包含的成员函数呢 这个ifstream这个派生出来的新类呢也一样都包含。 同样的呢，对于ofstream来说呢，也是一样。 它和ofstream呢都是由这个ostream 来派生出来的。所以呢，在这样三类中间的一些成员函数比如说这个 operater << 这个流提取符，还有相应的这个operater >> 流插入符，以及呢我们之前可能常用的一些像 getline，这样的函数呢它都是可以去进行使用的。 
- 那么要注意呢，我们在做这个文件的操作的时候 一定呢，在做任何操作的时候都会要遵循这样的一个顺序。 
  - 首先第一步就是要去打开一个文件。 不管你是去使用这个文件，还是去创建一个新的文件， 都必须要这样。首先要先打开一个文件。在打开这个文件的过程中间呢， 需要去通过指定这样的一个文件名去建立呢文件本身和这个文件的流对象 直接的一个关联的关系。那么同时呢还要去具体的指明这个文件的使用方式， 当然我们会在后面的这个iii中间具体的看到。 
  - 那么第二步呢就是去具体的读写这个文件。 我们会在每个文件当中呢有个这样的所谓读写指针的这样一个指针，用来呢去做 对于这个文件当中相应的这个位置来进行一些读写的操作。 
  - 那么最后一步就记得说呢我们每创建或者使用一个文件之后， 无论对它是否进行了任何的操作，那么我们最后都要去进行关闭。我们必须把这个文件close起来 才可以。
- 我们来具体看一下。在建立这个顺序文件的时候呢，我们通常会有这样的一个操作。
    ```C++
    #include <fstream>          //包含头文件
    ofstream outFile("clients.dat",ios::out|ios::binary);       //打开文件                                  
    ```
  当然我们首先呢就是要去引入本身的这个文件的处理的这个类，那么它呢就是fstream，保护这样的一个头文件， 那么我们通过这个fstream中间呢派生出来的这个 ofstream这个类呢去定义了它相应的一个对象outFile， 我们看到，ofstream呢实际上是在fstream中间定义的一个类， 那么outFile呢是可以看成是ofstream类的一个对应的具体的对象。 那么我们用这个对象具体的 怎么样去建立一个文件呢？我们要 在这个对应的参数里面去传递要建立的这个文件的这个 文件名，比方在这里呢，我们就要去建立一个叫做clients.dat的一个文件。 那么同时呢，我们还需要去定义这样的一个所谓叫做打开并建立文件的一个选项， 用来去描述以什么样的方式去处理这个文件。 在这里头呢，它可能会有一系列的这种选择项，比如在这个中间我们标注，ios::out 那么它就是表示呢输出的这个文件本身 它是要输出到这个文件并且呢要删除原有的一些内容。 那么如果你去写这个ios:app的话呢，就说 我们呢会要希望输出到这个文件，但是会要保留已有的内容。那么新加入的内容呢，就写在这个文件的尾部。 同时呢，你还可以去定义说我是以什么样的形式去打开这个文件。 比方在我们这个例子中间呢，我们希望它是以 二进制的形式来打开具体这个文件。那么我们就要去写ios::binary 这样的一个标记。 除了刚才那样的方式， 就是去定义一个对应的 ofstream的一个对象，然后呢通过去初始化传递参数建立相应的这个文件的话呢，
- 我们还有第二种方式，第二种方式呢 我们可以直接首先这样显示的去定义一个对象， 直接去创建一个对象。
    ```C++
    //也可以先创建ofstream对象，再用open函数打开
    ofstram fout;
    fout.open("test.out",ios::out|ios::binary);
    //判断是否打开成功
    if(!fout) {
        cerr << "File open error!" << endl;
    }  
    //文件可以给出绝对路径，也可以给出相对路径
    //没有交代路径信息，就是在当前文件夹下找文件                              
    ```
  有了这个对象之后呢，我们利用这样的open的一个函数作用在fout这样的一个对象上，用open函数本身呢去打开相应的我们 需要操作的这个文件。这里呢，我们可能需要去操作 test.out这样的一个文件。那么注意就是我们呢 去创建打开一个文件的时候我们通常需要去判定一下 它是否能够成功的打开，如果呢 这个fout本身呢它没有成功打开的话，那么我们就需要去 输出一个提示说，File open error!这通常是我们用来去做文件操作的一个基本的环节。 那么另外还要注意的就是我们在这里头给出的这个文件名， 那当然在这两个例子里头给出的都是一个相对的文件的一个名称， 那么你也可以给出一个绝对的路径，既可以是绝对的路径，也可以是相对的一个路径。那么如果没有去交代路径信息的话，在现在我们这两个例子中间，那么你就在当前的这个文件夹下面去找相应的文件就可以了。 
- 我们刚才提到说，在第二步，文件已经被打开之后， 那么我们在对这个文件进行读写的时候呢，实际上会存在这样的一个叫做读写的指针， 我们通过对输入的文件呢有一个读指针， 或是对于一个输出的文件有一个写指针。 那么对于既有输入又有输出的这样一个文件的话呢 我们需要呢去建立一个读写指针。 通过利用这个指针呢，就可以标识当前这个文件操作的一个位置。 那么指针指到哪里，我们的读写操作呢就在哪里来进行。 我们来看一下，我们在文件读写当中如何去利用指针来进行相应的操作。 比方在这个一系列的代码中间呢，
    ```C++
    ofstream fout("a1.out",ios::app);
    long location = fout.tellp();               //取得写指针的位置
    location = 10L;                             //给出的相应的这个常量值后面要标记一下L
    fout.seekp(location);                       //将写指针移动到10字节处
    fout.seekp(location,ios::beg);              //从头数location
    fout.seekp(location,ios::cur);              //从当前位置数location
    fout.seekp(location,ios::end);              //从尾部数location     
    /location可以为负值，这样就可以从末尾数起                      
    ```
  我们就可以看到， 我们首先呢就是去打开了一个文件，a1.out， 我们去定义了一个ofstream类型的一个对象fout 那么之后呢，我们就去要用这样的一个函数呢叫做tellp 我们去获得了对应这个写指针的一个位置。我们利用tellp这个函数作为一个fout 这个对象上，那么获得的相应的这个location他就是对应的这个写指针的一个位置 那么有了这样的一个location之后呢，我们呢也 可以对它进行相应的赋值，至于这也location呢，它是属于一个long类型的 所以我们在对它进行赋值的时候，给出的相应的这个常量值后面要标记一下L 那么有了相应的这个指针位置的时候，我们就 可以在对应的这个文件当中去做一系列这样的一个操作 比方说呢，在这样的一个语句中间，我们可以看到我们想做的事呢是将这个指针 移动到我这个location所指定的位置上。在这个例子当中呢 应该我们对location赋值为10lL，我一呢我们就是把它相应的移动 第十个字节的地方。那么我们记着，我们对指针进行操作的时候可以标用这样的一个函数 叫做seekp，seekp到某一个位置上 那么同样的，出了具体去指定这个位置 之外呢，我们还可以去指定这个指针的位置相应是从哪里来 开始计数的。比方说我们可以去定义他 这个起始位置呢是从头开始，那么我们就可以在这个seekp 后面的这个指针，除了具体的 指针的这个位置数值之外呢，去我们还可以定义它相应的起始点 在这个例子当中呢ios：：beg就 说明它是从beginning开始的，是从相应的这个文件头开始数起的 那么你也可以呢 从这个count位置，也就是标志ios：： cur呢就可以指出我相应的这个位置呢，相应的 我要去做的这个指针的操作是从当前这个location开始偏移 具体的这个 location值就可以了。那么同样呢，你也可以从末位开始数起。那么只要用ios：：end就可以了 那么注意，location本身呢可以为负值的。这样也保证呢我们可以从末位开始数起 
- 那么同理，我们干才讲到的是写指针 
    ```C++
    ifstream fin("a1.in",ios::in);
    long location = fout.tellg();               //取得读指针的位置
    location = 10L;                             //给出的相应的这个常量值后面要标记一下L
    fout.seekg(location);                       //将读指针移动到10字节处
    fout.seekg(location,ios::beg);              //从头数location
    fout.seekg(location,ios::cur);              //从当前位置数location
    fout.seekg(location,ios::end);              //从尾部数location     
    /location可以为负值，这样就可以从末尾数起                      
    ```
  那么我们对于读指针而言呢，为I时还有完全一样的这个操作 只不过刚才呢是这个tellp，那么在读指针中间的话呢，我们就要 tellg，但是注意一点就是，我们在调用tellg的时候呢要用 他的这个对象fin，那么他呢是这个ifstream的一个类的 一个具体地识别化我们要调用这个不同的类 来声明相应的这个对象，才能获取相应的这个 读写指针。那么在读指针的位置上之后呢我们就要去 使用这个ifstream的类具体的识别化 那么同理呢也是一样，我们可以定义一系列的这个seekg的一个操作。
- 那么这个操作呢他都是去作用在这个fin 这样的一个对象上面的 那么我们对二进制文件来进行读写的时候呢 我们有了相应的这个指针的位置的指向之后 我们就可以进一步的来去做事。
    ```C++
    //二进制文件读写，直接写二进制数据，记事本看未必正确   
    int x = 10;
    fout.seekp(20,ios::beg);
    fout.write((const char*)(&x),sizeof(int));    

    fin.seekg(0,ios::beg);
    fin.read((char*)(&x),sizeof(int));            
    ```
  比方说我们有了一个写指针具体位置的一个定义。我们从beginning开始 希望呢写指针呢从beginning开始之后的20个字节位置开始写起 那么具体怎么写，我们就可以去 调用相应的这个成员函数write去把相应的我们需要写入的这部分 比如说某一个字串，那么就具体写进去通过这个 参数传递进来写进去，而具体写的大小呢可以是 对应的这个sizeof（int）这样的一个大小 那么同理呢，我们也可以用这个 read的这个函数去去读相应的这个文件 那么相应的这个文件的话呢，我们就可以去利用这个 seekg这个函数去获得这个读指针相应的位置，那么在这个例子里面呢，我们从文件的头开始 然后依次呢去读出相应的我们需要看到的数据 那么要注意一点就是二进制文件的读写呢，他 本身是直接去写或者读二进制数据的 那么如果我们写入一个二进制数据的时候呢，你如果直接拿记事本来看呢，有些时候是未必正确的 我们来看一个具体的例子 
    ```C++
    //下面的程序从键盘输入几个学生的姓名和成绩，并以二进制文件形式存起来
    #include <iostream>
    #include <fstream>
    #include <cstring>
    using namespace::std;

    class CStudent {
        public:
            char szName[20];
            int nScore;
    };

    int main()
    {
        CStudent s;
        ofstream OutFile("h:\\students.dat",ios::out|ios::binary);
        while(cin >> s.szName >> s.nScore) {
            if(stricmp(s.szName,"exit") == 0)           //名字为exit则结束
                break;
            OutFile.write((char*) &s,sizeof(s));
        }
        OutFile.close();
        return 0;
    }
    ```  
  我们呢希望利用这个下面的程序使得从键盘 键入的几个学生的姓名和成绩呢以二进制的形式 把文件呢，就是以二进制文件的形式呢来进行存放 那么我们相应的就去include这个iostream fstream以及cstring 那么完了之后呢我们就定义了这样的一个类叫做cstudent 那么cstudent这个类呢，它很简单。它就包含了两个成员 的变量。一个是szname，一个放姓名的一个 字符型的数组，完了呢相应的是存放他相应每个学生的一个成绩nscore 我们看一下，我们如何最简单的去 写一个这样的一个学生姓名和成绩的这样的一个文件 我们同样呢在main函数里面呢定义了一个cstudent对象s 那么我们接着呢就要去做打开文件这个操作 那么在这里头呢我们是去利用定义了一个ofstream类型的一个对象outfile 那么在outfile初始化的时候呢去传递了相应的文件名以及他相应的这个打开的 形式 那么它实际上就是一个在c盘目录下存放的 pap文件的一个叫student.dat的一个文件 那么这个文件本身呢他的这个 我们写入的形式呢是以，注意，是以二进制形式来进行写入的 那么有了这样的一个文件打开的操作之后呢，我们就可以从外界 键入这个相应的学生的姓名和成绩。我们在while循环当中呢 每一次去输入相应的这个学生的姓名和成绩 一旦输入成功之后呢，就近到这个while循环里面去。当然你中间还要去 判断一步因为我们最后希望我们的这个程序呢，是以有了这个exit的字符 来进行终止。所以我们就要在这里判断一步，看看这个 stncmp这个函数，用这个函数去看一看 s.szName本身是不是跟exit相 一致的。如果是一致的话呢，则表 明说我这个文件的输入已经结束了，那么我们就break了 那么否则的话我们每一次传递进来的这个szName和这个 nScore之后呢，那么我会相应的把这个对应的这个对象 写入到我刚才打开的这个文件里面去。我利用的就是这个OutFile的对象 调用它相应的这个write函数 那么我写入的大小是什么呢，我写入这个一个相应的字串。那么这个字串它实际上就是 s这个对象的引用，那么具体的大小呢，我们可以sizeof(s)一下 那么有了这样一系列的输入之后直到我们到了exit这个字串 通过比较之后发现说这个，诶，程序已经终止 那么我们就可以再调用OutFile.close 这样的一个函数，去关闭相应我们刚刚打开的这个students.pap的这个file 有了这样的一个操作之后呢，整个文件的这个写入过程就结束了 我们看到，我们的输入如果是这样的。 四行，分别是Tom 60, Jack 80, Jane 40，以及最后的exit 0 那么有了这样的一个有一系列输入之后呢，我们通过刚才那个程序就可以相应的 把这一系列的输入写入到我自己定义的这样的一个文件当中 
- 当然注意，因为呢写入的这个形式是以二进制的形式来写入的 所以如果呢，你拿这个记事本打开的话，你会发现一系列的这个 看起来比较乱码的一个形式 那么在这一头呢我们也是要解释一下，对于一个文本文件和二进制文件来讲的话 那么他打开文件的时候在某些时候是会有区别的 那么如果他在Unix或者Linux下，那么这两者呢是没有去别的 但是在Windows情况的平台下，那么每一个文本的文件它是以这个\r\n，这样两个转义字符来作为换行符的 那么当你读出的时候，系统呢会自动的将这个 0x0d0a,将这个十六进制的这个0d0a自动转换，读成一个0a 那么同时写入的时候呢也会相应的对于这个0a 这样的一个值呢，系统会自动地认为他变成了一个换行符，所以会在前面 添加一个iiii,所以因为有了这样的操作呢可能会导致我们的二进制文件本身 如果以文本形式打开呢显示会和你的预期呢有一定的差别， 所以我们说呢我们**对二进制文件来进行读写的时候呢，最好是能够保持一致， 也就是说以二进制的形式去写入那么就以二进制的形式来读出**， 
- 那么有了刚才的那个写入的操作之后呢如果我们想具体看一看这个student.dat文件当中的存放 到底你写进去了哪些内容的话呢？我们就可以自己写一个这样二进制文件读取的一个程序， 
    ```C++
    #include <iostream>
    #include <fstream>
    #include <cstring>
    using namespace::std;

    class CStudent {
        public:
            char szName[20];
            int nScore;
    };

    int main()
    {
        CStudent s;
        ofstream OutFile("students.dat",ios::out|ios::binary);              //若没有此文件会自动创建
        while(cin >> s.szName >> s.nScore) {
            if(stricmp(s.szName,"exit") == 0)           //名字为exit则结束
                break;
            OutFile.write((char*) &s,sizeof(s));
        }
        OutFile.close();
        ifstream inFile("students.dat",ios::in|ios::binary);
        if(!inFile) {
            cout << "error" << endl;
            return 0;
        }
        while(inFile.read((char*) &s,sizeof(s))) {
            int nReadedBytes = inFile.gcount();         //读了多少字节
            cout << s.szName << " " << s.nScore << endl;
        }
        inFile.close();
        system("pause");
        return 0;
    }
    ```  
  除了刚才这个cstudent类之外呢那么我们main函数里头 也同样的确定一个ifstream类的一个对象， inFile啊这个file本身呢我们定义，它是以这个二进制形式来进行读取的 当然我们还要来判断一下说这个本身打开这个文件是否成功啊， 而如果本身这个打开的操作呢是有问题的是否的， 那我们就要相应的cout一个error， 如果没有任何问题呢那么我们就去相应的去调用这个 inFile.read这个函数，那么把对应这个和S这个大小 相应的内容呢把它读取出来那么在这个屏幕上呢 显示出来，也就是说，我们去cout s.szName 和 s.score 那么注意就在这里头呢我们还额外展示一个语句就是说除了呢 inFile除了去调用read这个函数之外呢，我还可以去调用相应的这个 gcount这样的一个函数,那么这个函数作用在inFile这个对象上，那么你就可以看到说我刚刚 读了多少个字节，当然这个本身这个语句对我整个这个程序没有任何的这个影响，我们在这里头只是 就简单的说明一下，啊最后呢有了这一系列的这个读出的操作结束之后， 注意一定要去close相应的这样file 那么就是inFile.close. 那么有了这样的一个程序之后，我们就可以相应的把刚才一系列的输入 读取出来就会看到，这样对应的二进制读出方式呢是没有任何问题的 那么我们在两个例子当中呢又看到我们如何对一个文件进行二进制 形式的一个写入或者是对一个文件具体以二进制的形式来进行读出， 
- 那么在很多时候呢我们通常会对一个文件同时要进行这个读或者写的操作 那么在这种情况下我们来看第三个例子， 我们在这个程序当中呢希望实现把这个之前这个student.dat文件中间保存的 第三个学生的名字Jane呢改为Mike， 那么这就会需要呢我们对相应的student.dat 文件呢进行一个写入的操作， 同时呢我们还要希望去 review一下我们写入的这个结果是否正确也就是说把相应 我们修改后的文件呢来进行一个读出的操作 那么就要求呢我们对这个二进制文件呢要同时进行写或者读的操作， 那么来看一下具体的程序实现， 
    ```C++
    #include <iostream>
    #include <fstream>
    #include <cstring>
    using namespace::std;

    class CStudent {
        public:
            char szName[20];
            int nScore;
    };

    int main()
    {
        CStudent s;
        fstream ioFile("students.dat",ios::out|ios::in|ios::binary);
        if(!ioFile) {
            cout << "error" << endl;
            return 0;
        }
        ioFile.seekp(2 * sizeof(s),ios::beg);               //定位写指针到第三个记录
        ioFile.write("Mike",strlen("Mike") + 1);
        ioFile.seekg(0,ios::beg);                           //定位都指针到开头
        while(ioFile.read((char*) &s,sizeof(s))) {
            cout << s.szName << " " << s.nScore << endl;
        }
        ioFile.close();  
        system("pause");
        return 0;
    }
    ```  
  还是刚才那个cstudent类啊，而这个类里面的还是包含了相应的学生名以及他的分数， 我们用cstudent类呢去定义了一个对象S， 那么有了这个s之后呢，我们又定义了相应的 这个fstream类型的一个对象称为叫做iofile啊， 这个iofile呢它不同于刚才的两个例子当中的 具体是这个ifstream的对象，或者是ofstream的对象， 它是这个fstream的对象，那么这个iofile本身呢，这个对象它是同时可以进行读或者写操作的， 那么它用来操作的文件呢还是student.dat这个文件， 那么我们看到它可以读可以写， 然后呢可以呢是以这个二进制的形式来进行操作的， 那么同样我们也去判断一下这个文件的打开是否会有问题， 如果没有问题之后呢那么我们就具体看一下说我们的这个 相应的写指针，啊我们第一步当然是去判断我对应 需要去修改Mike的那个位置，所以我们都要去seekp 这个函数呢在iofile这个对象身上，那么它 通过去适用这个函数实现这个效果呢是我希望能够从文件的头开始 数过两个这样student，这样cstudenta这样s的这样一个记录呃， 那么也就是让我们的写指针对应定位在这个第三个记录的起始位置， 那么当你一旦确定了相应的写指针的位置之后呢我就可以调用 相应的write函数，那么我们write函数写入的字串呢就是我们希望 去新写入Mike这个字串， 那么有了这个写入之后呢我还希望看一看说 我的整个的这个写入过程是否有效或者说写入的是否正确， 那么我希望能够去读取整个新的这个student.dat, 那么我就需呢再去用iofile. seekg啊我们需要去定位这个读指针， 那么这个读指针从哪里开始呢，我们就从这个文件的开始， 那么填一量呢是0， 那么有了这样一个读指针的确定位置之后呢，我就可以相应的去调用这个read函数， 那么依次地把我对应的这个文件当中的所有的这个cstudent类型的对象 s的这样一个记录呢依次地读取出来， 那么在读取之后呢我就把它们相应的cout在屏幕上啊 分别是cout, s.szName 以及 s.nScore, 那么有了这样的一系列操作之后呢，全部读取完毕之后，那么我就记着一定要 这个不管是这个是同时可以读取的文件还是说读文件或者写文件， 最后都要去做这个Close的操作，那么就iofile.close, 那么有了这样的一个程序的执行之后呢 我们就会看到刚才我们在student.dat文件里面所记录的 Jane的记录呢中间的姓名就会被修改为Mike。 
- 那么这里呢我们强调一下，我们呢 不管是处理什么样的文件是写还是读啊我们都要最后去显示关闭这个文件，因为如果文件呢不能够正常关闭的话呢可能会引起写入内容呢产生一些问题， 所以呢我们要在每一个这个呃 写入的文件或者是读出的文件当中呢都让它，最后都要去写这个 fin.close 或者是fout.close. 
- 我们最后来看一个例子啊，
    ```C++
    //例子：mycopy 程序，文件拷贝
    //用法示例：
    //输入：
    //mycopy 源文件名 目标文件名       。。。。就能将源文件复制到目标文件
    //例如：mycopy src.dat dest.dat
    //即将 src.dat 拷贝到 dest.dat
    //如果 dest.dat 原来就有，则原来的文件会被覆盖
    #include <iostream>
    #include <fstream>
    using namespace::std;
    int main(int argc,char *argv[])
    {
        if(argc != 3) {                                         //3个才符合输入规则
            cout << "File name missing!" << endl;
            return 0;
        }
        ifstream inFile(argv[1],ios::binary|ios::in);           //二进制读模式打开
        if(!inFile) {
            cout << "Source file open error." << endl;
            return 0;
        }
        ofstream outFile(argv[2],ios::binary|ios::out);         //二进制写模式打开
        if(!outFile) {
            cout << "New file open error." << endl;
            inFile.close();                                     //打开的文件一定要关闭
            return 0;
        }  
        char c;
        while(inFile.get(c)) {                                  //每次读取一个字符
            putFile.put(c);                                     //每次写入一个字符
        }    
        outFile.close();
        inFile.close();
        return 0;  
    }    
    ```
  我们希望完成的一个工作呢是说 我们是去自己实现一个mycopy的一个程序，那么它能够完成的工作是什么呢， 我们可以去调用mycopy这个程序之后实现把这个原文件拷贝 到这个目标文件中间去啊，也就是说去把src.dat 拷到这个dest.dat的这个文件当中去， 那么如果dest.dat呢本身里面是有数据的话呢，那么原来这个数据文件呢会被覆盖掉， 那么有了这样一个呃希望能够实现的 一个目标之后我们来具体看一看这个程序是怎么样去实现的， 我们之前呢在第一节就郭老师在很久远的第一讲当中有给大家介绍这个 命令行程序的一个写法，我们知道说呢每一个main函数呢后面实际上它对应是由 两个参数的，它分别去记录你的这个命令行这个操作的时候 相应的这个参数的个数以及相应的这个参数的字串， 那么在这个程序当中呢，我们就希望能够在命令行参数中间去输入这样的 一个语句，那么它就可以直接实现这样的一个拷贝的工作， 那么我们在这个main函数里面当然首先第一步就要去判断一下 我的这个命令时候正确，如果我输进来的这个参数 不止三个或者是少于三个，也就是说不符合我这个对应的语句的话，那么我就会报错，file name missing, 那么如果通过正常的输入了这个对应的呃我们这个指令之后， 命令行参数之后呢，那么我首先要做的第一件事 就是去打开我用来去读取的这个文件啊，我们要去 首先要去读相应的文件，那么我当然知道要去定义这个ifstream类这么一个对象， 这个inFile啊,那么具体这个file的名称是什么呢就是我命令行参数传进来的这个 第二个参数也就是这个argv[1]啊, 那么下面相应的我说以这个二进制形式来进行读取的， 那么同理我也呢对这个要写入的这个文件 也要进行打开的操作，我必须同时去打开相应的这个写文件 才能狗把这个相应的我要拷贝的内容复制进去啊所以呢我在这里头呢就 用ofstream这个类去定义了相应的这个对象outFile, 那么outFile它打开的文件名是什么呢，是我传进来的第三个参数啊argv[2], 那么它也是以二进制的形式来进行传递的， 那么有了这样的两步这个输入和输出相应的这个文件的这个打开之后 那么我们就可以做依次进行拷贝的这样一个工作啊，我们定义了一个对应的char类型的一个字符c， 那么我在这个程序当中呢，每一次都会让这个 inFile呢去调用它相应的这个操作的函数get啊, 这个get它的作用呢就是去读取一个字符，啊读取一个c, 之后呢再把这个c对应地写到这个outFile.put里面，去调用 put这个函数，相应地把每一个字符呢写进去，那么依次呢这样的循环直到 这个文件当中呢所有字符被写入为止，那么有了这样的一个操作完了之后呢， 我就可以去相应地去close掉我的这个outfile和这个 inFile啊，有了这样两步操作呢那么我们就整个的这个 文件读写过程呢就能够完成，那么也可以相应的实现 将我的这个source.dat拷贝给这个desternation.的这个dat的作用， 那么要注意呢，我们在这个例子当中呢只是为了给大家描述一下我们这个文件去做打开， 然后去做拷贝，并且最后把它关闭这样的一个过程，当然我们在程序设计的时候呢，实际当中你根本不可能 去写对于每一个文件的拷贝只每一次去拷贝这样一个字符，当大家可以回去想一想说 我应该以什么样的方式去做这个文件拷贝的工作 会看起来会更有效一些 
## 2. 函数模板
- 大家好,在这一小节中我们来学习一下函数模版， 有同学看到这个标题呢，可能会觉得挺奇怪的， 我们已经在计算概论或是一些先前的课程当中呢 对于函数这个概念呢烂熟于心了， 什么时候又冒出一个叫做所谓模版的概念， 那么其实看到模版这个词呢，你就应该感到窃喜了， 因为对于大家学习呢，你已经进入到了一个更为高阶的阶段， 也就是说我们通过模版的使用就正式开始了所谓的叫做 泛型程序设计这样的一个模块的学习。 
- 那么所谓泛型程序设计呢，它英文就叫做这Generic Programming， 实际上所谓的泛型程序设计就是指我的算法在实现的时候 并不会具体的要求操作的数据的类型， 啊我不去指定相应的这个数据类型， 那么所谓泛型呢，你可以认为说是算法实现一遍， 但是它可以适用于多种数据结构， 既然是泛化的，那么它并没有具体地指明某一个 数据类型只适用于我现在当前设计的这个算法，我这个算法呢是一个普适性的， 那么有了这样一个泛型程序设计呢，它的好处在于可以 非常大的程度上去减少重复代码的编写， 那么一般来说一个资深的程序员相对于那些刚刚 入行的这个新手来讲就在于他是否能够去编写大量的模板 利用这个模板去实现这样泛型的这样程序设计， 那么我们通常讲呢**模板分为两类，一个呢叫做函数模板，一个叫做类模板**。 那么泛型程序设计呢是我们可以认为跟之前所讲到的 这个叠加序设计当中，这个抽象，封装，继承和多态 这样四大类可以并体的一个非常具有特色的一个概念。 那么下面呢我们就具体来看一看函数模板。 
- 所谓函数模板呢我们首先就要看一个具体的例子， 
    ```C++
    //为了交换两个int变量的值，需要编写如下Swap函数：
    void Swap(int &x,int &y)
    {
        int tmp = x;
        x = y;
        y = tmp;
    }
    //为了交换两个double变量的值，需要编写如下Swap函数：
    void Swap(double &x,double &y)
    {
        double tmp = x;
        x = y;
        y = tmp;
    }
    //能否只写一个Swap，就能交换各种类型的变量？
    //用函数模板解决
    template<class 类型参数1，class 类型参数2，.....>
    返回值类型 模板名（形参表）
    {
        函数体
    }
    ```
  我们呢在为了实现这个交换两个int型变量的值的时候呢通常大家 第一步就会想到要去写一个叫做swap的一个函数啊，这个swap函数 它要做的事是什么呢，它就是把相应的这样两个需要交换的 这个变量的引用作为参数呢传递进来， 然后在这个函数体当中呢去定义一个临时的变量tmp, 然后去实现一个把x付给tmp，然后把y付给x，最后把tmp付给y的这样一个啊 交换的一个过程。那么这是一个最简单的去实现int型变量的一个函数， 但是同时你有时候可能会在同样一大段大量的程序当中遇到还要去交换两个 double型的一个变量，那么在没有其他操作的情况下， 那么我们只能再去写一个swap函数，啊因为我们有了函数重载这样一个 概念，所以我们可以让它的这个函数名是同名的， 但是呢因为传入的参数不一样， 我如果需要去交换两个double型的变量的话 那我们就当然传进来两个double变量的这个引用， 啊那么我们同样也是去建立了一系列的这样一个操作 去实现了这样两个double型变量值的交换， 那么这个时候就大家就会有一个想法了，既然呢我都是写的这样一个相应的swap的一个函数， 并且呢在函数体当中实际的一个操纵呢其是都是一致的， 都是通过去建立一个临时变量作为传递 交换了两个传入的这个参数的具体的值，那我是否能够直只写 一个swap函数就可以满足交换各种类型的变量呢？ 这个想法呢实际上是可以实现的。那么这就 需要引入函数模版这个概念来进行解决， 那么所谓的函数模版呢就是我们定义在这个函数的时候 并不会去显示的去标记具体他传递参数的这个类型 而是标记了这样用这样一个关键字 template去标记说我是一个函数的模板啊 或者说是我在函数上层构建一个一般意义上的这样一个例子， 那么它被称为叫做模板，那么具体这个函数它传递的这个参数的类型是什么呢？ 我就把它都声明在这个template这个关键字后面啊，给出一个尖括号， 那么它里面分别去标记，class类型参数一，class参数二，直到把所有的这个类型 依次地这个声明完为止，完了之后呢我就在这个相应的这个函数模版当中去定义这个模版名，啊完了之后就去传递相应的形参表， 以及去定义函数所包含的返回值以及函数体， 那么这是一个函数模版的一般意义上的一个语法中间的一个定义， 我们来看一个具体的例子。
    ```C++
    //交换两个变量的函数模板：
    template<class T>
    void Swap(T &x,T &y)
    {
        T tmp = x;
        x = y;
        y = tmp;
    }

    //用函数模板语法
    template<class 类型参数1，class 类型参数2，.....>
    返回值类型 模板名（形参表）
    {
        函数体
    }
    ```  
  还是刚才那个swap的函数， 还是我如果能把它延伸写成一个函数模版的时候， 我应该具体怎么样去干呢，我实际上就用template这样一个关键字 去申明说我有一个类型参数，叫做class T， 啊这个类型呢是一个t来标记的，那么我在这个swap 这样一个函数模版的这个具体这个模版的定义的时候呢， 我就不需要去定义我传进来的这两个参数的类型分别是什么， 我只需要去标记如果它们是同样类型那么我们都用T来进行标记， 也就是说我传进来了一个T类型的一个参数x和y， 那么同样的我在这个函数体里面也会定一个T类型的临时的 这样一个参数tmp 然后利用 其他的这个相应的一些操作把X付给tmp，把Y赋给X，把temp赋给Y 这样三个语句来实现我的这个函数模版swap这样一个交换 两个参数对应的这个变量值的一个具体的实现， 那么大家可以看到在这个函数模版当中我并没有具体显示的定义说它是 适用于哪一个类型的x和y，啊它可以既是T，既可以是int的， T也可以是double的， 所以呢我们就可以通过这个例子可以显式的看到说我如果自己定义一个函数模板的话 那么我就可以通过写这样一个swap函数 来实现说去交换多种数据结构类型的这样一个变量的一个操作， 我们来看我们怎么样去用这个函数模版，
    ```C++
    int main()
    {
        int n = 1,m = 2;
        Swap(n,m);                  //编译器自动生成 void Swap(int &, int &) 函数
        double f = 1.2, g = 2.3;
        Swap(f,g);                  //编译器自动生成 void Swap(double &, double &) 函数
        return 0;
    }
    ```    
  啊我定义了这样一个swap一个函数模版之后， 那么如果我需要去交换相应的两个int型的变量n和m的话那么我只需要在这个 本身的函数模版的使用的时候，传递参数n和m， 那么这个时候呢编译器就会自动生成去替我生成void 这个swap int， 两个int的这个对应的这个变量引用 作为参数的这样一个函数， 那么它实际上呢，就是去具体地将其 原来的这个t 分别呢作用为int类型的这样一个整形的这样一个变量， 那么有了这样两个int型的整型变量作为参数的话呢 那么编译器就会自动地生成相应的这个具体的这个函数是swap， 那么我就可以直接来进行后续的这个程序的这个交换，两个int型 成员变量，两个int类型的啊这个变量的这样一个操作， 那么同样的，如果我需要去交换两个double型的 这个变量f和g， 那么我的编译器也会相应地将这个T的替换成DOUBLE这个类型 那么我的这个程序实际在调用的时候它就是去掉用这个swap，double 这个x和double- y，这样一个函数，那么它实现的功能呢， 也是将这样两个double类型的变量实现了一个交换的这样一个工作。 
- 那么我们刚才看到的例子当中呢，我们的这个template 后面定义的这个参数类型呢是只有一个就是T，class T， 那么我们有些时候呢在定义函数的时候其参数的 类型可能是不一致的话啊，我们可能有多种情况被传递进来 那么我们就可以相应地在函数模版中间定义不只一个类型的参数 ,比如说这里 
    ```C++
    //函数模板中可以有不止一个类型参数
    template<class T1, class T2>
    T2 print(T1 arg1, T2 arg2)
    {
        cout << arg1 << " " << arg2 << endl;
        return arg2;
    }
    ```    
  我们去定义了这个class t1和class t2， 那么通过定义两个类型的参数的话我就可以相应的 更为丰富的去定义我的这个定义的这个函数模版中间包含的参数啊， 比如说我认为这个arg 1的类型是T1, arg 2 的类型是T2， 并且呢这个函数的返回值呢也是一个t2类型的这样一个函数模版，print， 那么有了刚才这样一系列介绍之后呢我们来看一个具体的例子啊。 
    ```C++
    //求数组最大元素的MaxElement函数模板
    template<class T>
    T MaxElement(T a[],int size)            //size是数组元素个数
    {
        T tmpMax = a[0];
        for(int i; i < size; ++i) 
            if(tmpMax < a[i])
                tmpMax = a[i];
        return tmpMax;
    }
    ```    
  我可能需要去写一个，去求得数组中间的最大元素的这样一个函数模版称为叫做MaxElement， 那么MaxElement它呢只需要定义一个 类型参数，也就是Class T，因为我这一系列的数组的类型都是一致的， 那么在这个maxelement这样的一个函数模板当中传递的第一个参数呢就是T类型的这个数组A 除此之外呢我还传递了一个int size， 这个int size呢它本身是 用来标记整个这个数组元素中间包含的个数的。 那么除此之外呢我的这个maxelement因为我获得的是这个数组中间最大的那个元素， 所以我的返回值呢，返回的就是这个数组元素中间的一个，所以那么显然它就是以T这个形式来进行返回的。 那么有了这样的这个模板，函数模板的这样一个定义之后我 具体在这个函数模板里面实现的话呢，就是首先将第一个 这个数组的首元素赋值给我的定义的这个T类型的这个tmpmax,我定义的tmpmax去标记 我当前最大的那个元素，完了之后呢我依次去读取相应的 这个数组里面的每一个元素去和tmpmax比较， 如果本身这个tmpmax呢它是 发现比我当前读的这个数组元素要小的话，我就将 这个当前的这个数组元素赋给tmpmax， 那么经过这样一系列的比较之后呢我就得到了这个数组中间最大的那个，把这个tmpmax呢 返回给，作为返回值，返回出来 就可以了，所以这就是这个MaxElement这个函数模板的例子。 
- 那么注意呢，**函数模板本身它也是可以重载的**， 也就是说，只要两个函数模板它们自身的形参表不同， 就可以，虽然它们是同名的，但是它也表达了是不同的模板， 比方说，我们在这个例子当中，
    ```C++
    template<class T1, class T2>
    void print(T1 arg1, T2 arg2)
    {
        cout << arg1 << " " << arg2 << endl;
    }

    template<class T>
    void print(T arg1, T arg2)
    {
        cout << arg1 << " " << arg2 << endl;
    }    
    ```    
  我们写了两个print的 模板，那么这两个模板呢， 因为其参数本身的类型不一致， 第一个模板呢它包含了两种类型，T1和T2， 传递了两个不同的类型的参数，而在第二个例子当中呢它只有一个 T作为这个类型参数，那么我们就只传递了，虽然它传递的是两个 参数，但是其类型呢都是T类型，所以呢我们说这样两个Print函数的模板呢它是不同的。 
- 我们在函数模板，有了函数模板之后呢就会发现 我们在做重载的时候，可能会出现这样的一系列情况，也就是说，在程序里面会有同名的这个普通的函数还有同名的这个模板函数， 那么具体如果我具体写了一个函数，C++编译器是如何去 匹配实现具体选用哪一个函数或者函数模板来进行这个程序的这个具体的执行呢？我们说，编译器呢需要遵循这样的一个优先的方式，
  - 第一步呢 就是去寻找参数完全匹配的普通函数，即便我有这个通过模板函数实例化出来的函数，那么也是先不考虑的。 我们首先考虑的就是普通函数，如果参数完全匹配的话，那就优先去匹配这个普通函数， 
  - 那么如果没有这个普通函数，那么就会去匹配参数完全匹配的模板函数。那么如果有一致的模板函数也可以。 
  - 如果既没有参数一致的普通函数也没有参数一致的模板函数呢 那么我们就具体来看一下，就是它会让这个实参经过自动类型转换能够匹配的普通函数也是可以的。
  - 那么如果通过上述三步操作 仍然没有找到合适的这个函数来进行使用的话，那么就会报错。 
- 我们来看一个具体，去看这个函数模板调用顺序的一个例子。 
    ```C++
    template<class T>
    T Max(T a, T b)
    {
        cout << "Template Max 1" << endl;
        return 0;
    }

    template<class T, class T2>
    T Max(T a, T2 b)
    {
        cout << "Template Max 2" << endl;
        return 0;
    }    

    double Max(double a, double b)
    {
        cout << "MyMax" << endl;
        return 0;        
    }

    int main()
    {
        int i = 4, j = 5;
        Max(1.2,3.4);                   //调用 Max(double,double) 函数
        Max(i,j);                       //调用第一个 T Max(T a, T b) 模板生成的函数
        Max(1.2,3);                     //调用第二个 T Max(T a, T2 b) 模板生成的函数
        return 0;
    }
    ```    
  我们定义了一个模板，称为叫做max 那么它呢首先只包含了一个类型参数T， 那么我们在这个里头，在这个max第一个这个max的这个 函数模板当中呢它传载了两个参数，都是T类型的， 形参分别是T类型的A和T类型的B， 那么在这个max里头呢它只去cout了一个语句叫做template Max1 那么我们同样的还定义了一个同名的这个函数 模板，也称为叫做max。 但是呢它包含了两个不同的 这个类型参数，分别是T和T2， 那么用这个T和T2呢分别去定义了这个相应的参数，形参a和b， 那么同时它的返回值呢也是这个T类型。 在这个第二个函数模板里头的话呢那么它定义的就是 cout语句下templateMax2这样的语句的输出。 那么同样呢我的这个程序当中还包含了另外一个函数，称为叫做 max，这个max呢是一个普通的函数，那么这个 普通函数呢，它的参数呢，就是形参呢是两个double型的， 变量，那么返回值呢也是一个double。 那么在这个max普通函数的这个函数体里面呢 我们就让它去cout一下max这样的一个字串。 那么有了这样两个这个函数模板以及一个相应的普通函数 遵循我们刚才所讲的编译器所执行的一系列的操作，我们来看一看， 具体在这个main函数里头，我们定义了一个 这个首先定义了一个Int i和j，这样两个整型的变量， 那么接着呢我们就去调用了max括号1.2和3.4， 那么我们可以看到我们传递的这两个实参呢是两个double型的， 是两个double型的这样的一个 参数。所以呢那么我们通过去匹配相应的两个函数， 首先我们第一步想到的就是首先第一步要去匹配一个普通函数， 看看有没有具有参数完全一致的普通函数， 哎我们发现说我们恰巧在程序当中就定义了 一个这样的max函数，那么它的参数就是两个double型的 这个变量，所以呢对于这个语句而言我们去执行的就是 max(double, double)这样的一个普通的函数，接着呢我们去传递了一个 max，调用了一个max括号i,j这样的一个函数。那么i和j呢 因为它定义的都是int型的这样的变量，所以呢我们看到说 我们没有 相应匹配的这个普通函数能够直接进行调用，那么第二步呢 我们就去看有没有合适的参数类型完全匹配的这个模板函数 我们发现说我们在前面定义了两个模板， 分别呢，一个是传递的参数都是一致的T，还有一个呢是传递了一个T1和T2， 那么在这个语句里头我们显然呢是要去调用第一个模板 生成的这个具体的函数，因为它只传递了一个同样类型的这个T类型的参数。 那么相应的第三个max呢它就会去调用，因为它的参数本身是1.2和3， 一个是double型的，一个是int型的，所以呢它就去调用了第二个max的这个模板生成的函数，那么它对应定义呢就是有 T和T2这样两个不同的参数。 那么我们看到，所以对于这样的一个函数来讲的话它的运行结果呢虽然都是调用了不同的max， 那么运行结果是不一样的，分别呢去执行了mymax，templatemax1, 和templatemax2，这样三个语句。 
- 那么此外呢我们要注意我们在去编写这个函数模板的时候 一定要去注意这个赋值本身的这个兼容性的一个原则。不要因为类型参数的选取问题引起了二义性。
    ```C++
    //复制兼容原则引起函数模板中类型参数的二义性
    template<class T>
    T myFunction(T arg1, T arg2)
    {
        cout << arg1 << " " << arg2 << endl;
        return arg1;
    }
    ....
    myFunction(5,7);            //ok: replace T with int
    myFunction(5.8,7.8);        //ok: replace T with double
    myFunction(5,8.6);          //error: replace T with int or double?   二义性
    ```    
  我们看到如果我们写了一个函数的模板称为叫做myfunction， 那么myfunction本身呢它包含了两个参数arg1和arg2， 那么这样两个参数呢它的类型是完全一致的，都是我们定义的这个class t, 那么这个时候如果我们要去使用这个myfunction 传递的参数是5和7的话，那么这个T自然就会被 实例化为成一个int类型。 同样的，如果我们这个实参分别是5.8和8.4的话，那么也没有问题。 T呢就会被自动的替换为成W，换成double， 但是呢如果这个时候你的这个myfunction传递的参数是5,和8.4的话 那么就会遇到问题了，编译器并不知道说这样的一个T 它因为既是arg1的类型又是arg2的类型，那么 当你的参数分别是两种不同类型的时候， 具体这个T是会应该赋值，会被替换为int还是会被替换为成double呢， 这样就会存在一个参数二义性的问题。 **因此呢我们对于这样的函数模板的设计的时候就应该把它设计成为两种， 那么使用多个类型参数呢可以有效的避免 这个参数的二义性**，
    ```C++
    //复制兼容原则引起函数模板中类型参数的二义性
    template<class T1, class T2>
    T1 myFunction(T1 arg1, T2 arg2)
    {
        cout << arg1 << " " << arg2 << endl;
        return arg1;
    }
    ....
    myFunction(5,7);            //ok: replace T1 and T2 with int
    myFunction(5.8,7.8);        //ok: replace T1 and T2 with double
    myFunction(5,8.6);          //ok: replace T1 with int, T2 with double
    ```    
  当我们是从新写这个myfunction的时候 我们的参数的这个类型分别是T1和T2， 那么这时候这个函数模板本身就具有了更强的灵活性， 那么还是前两个语句没有问题，相应的T1，T2呢是可以被赋值成一致的， 但是当你遇到这两个参数类型不一致的时候， 那么T1就可以自然被赋值为int，被替换为int， T2呢就会被替换成double,那么这个程序本身呢就不会出错了。 
## 3. 类模板
- 大家好，在这一小节中啊，我们来进一步学习一下类模板。 我们在上一小节中呢，已经知道说，众多个函数可以被抽象成一个函数模板。 那么类呢，它也可以进一步，虽然累这个概念本身就是从若干个对象中间呢，抽象出来的， 那么，若干个类呢，还可以把它也写成一个模板，这样程序呢，会进一步地简化。 我没来看一下。
- 那么类模板的提出呢，其实即使希望能够去定义一批相似的类。 那么通过去定义一批相似的类呢，就可以生产一个叫作类模板的概念。 那么有了这个类模板之后呢，具体我通过去实例化不同的这个 相应的参数，就可以得到、生成若干个不同的类来。 我们来具体看一下。 我们呢可能会去定义一个类，它表征的是一个数组啊。这个数组呢它是一种非常常见的数据元素， 那么这个数据类型本身呢，它的元素呢可以是整型 的，也可以是某一个学生类啊，也可以是字符串。 那么这样一系列若干个不同的数组，怎么样能够 去能够以一个呃，统一的形式来进行表达呢？ 我们就需要去定义一个称为叫作数组类， 啊。这个数组类呢，它自身能够提供一些相应的基本操作。 比方说呢，你可以去查看数组的长度 len， 你可以去获得其中的一个元素getElement 啊，只要通过传入具体的一个 index 信息就可以。 你也可以去 set 其中的一个元素啊，对它进行赋值。 那么有了这样的一系列的这些，这个操作的时候呢，你会发现说，我的这个具体的数组本身， 它实际上是可以作用在很多若干个不同的数据类型上的。 那么我就可以通过对这个数组的这个类呢，来进行进一步的抽象，来得到一个类模板。 那么要注意就是，我们在使用类模板的时候呢， 我们要给这个相应的类，它定义的时候，会给它一个或者多个的参数。 那么这些参数呢，它可以表示为不同的数据结构的，啊，比方说以 刚才这个数组类，那么这个数组类本身，它的元素类型呢， 是不同的，但是呢，它的其它的这些内容都是完全相同的。 我们在去调用类模板的时候呢，通过去指定参数， 相应的编译器呢，就会去根据参数，具体地对 相应的这个数据类型呢，实现自动地这个生成。 那么有了这样的这个过程呢， 自动生成相应的这个，把它生成为出来的这个类呢， 就称为叫作模板类，啊。也就是说，我们通过类模板具体指定参数之后，由编译器生成的那个相应的类，我们称为叫作模板类。
- 那么在C++当中呢，具体的这个类模板的写法呢，其实跟我们之前看到的这个函数模板非常类似。 
    ```C++
    //C++的类模板的写法如下：
    template<类型参数表>
    class 类模板名
    {
        成员函数和成员变量
    }；

    //类型参数表的写法就是：
    class 类型参数1，类型参数2，......

    //类模板里的成员函数，如果在类模板外面定义时，
    template<类型参数表>
    返回值类型 类模板名<类型参数名列表>::成员函数名（参数表）
    {
        ....
    }

    //用类模板定义对象的写法如下：
    类模板名<真是类型参数表> 对象名（构造函数实际参数表）;

    //如果类模板有无参构造函数，那么也可以只写：
    类模板名<真实类型参数表> 对象名；
    ```    
  我们首先也还是利用 template 这关键字呢去声明一系列的这个类型参数表，啊。这个类型 参数表你可以写若干个，只要你希望表达不同的参数，那么都把它写在这个类型参数表里头就可以了。 完了之后呢，利用 class 去声明一个类模板名。 完了之后在这个类模板当中呢，去定义相应的成员函数和成员变量。 那么要注意，我们有些时候呢，会把这个 这个相应的这个成员函数呢，放在这个类模板之外来定义。 那么和之前写类的这个成员函数是一样的。我们就需要在这个 呃，写在外面的这个成员函数前面呢加一个作用域，啊，标记说是这个对应 类模板它所包含的的成员函数名。 那么要注意就是我们需要在这个，对应的类模板名后面要跟上相应的这个类型参数 名列表，啊。 那么要注意就是说，这个具体的参数列表呢， 它可能呢是需要，就如果它本身是包含了这个 对应的参数的话呢，那么我们就需要去定义对象的时候，就要 去利用这个类模板名，后面跟上一系列的这个具体的 真实的类型参数表，来定义相应的这个对象，啊。 完了之后呢，构造函数呢要实际地去传递这个参数表。 那么如果本身你的这个类模板呢是 有这个无参构造函数的，啊，有这个无参的构造函数，那么相应你也可以在定义对象的时候呢， 不去显示的去写这些参数，具体是怎么样去构造的。 我们来看一个具体的例子。
     ```C++
    //Pair类模板：
    template<class T1, class T2>
    class Pair {
        public:
            T1 key;                 //关键字
            T2 value；              //值
            Pair(T1 k, T2 v):key(k),value(v) {}
            bool operator<(const Pair<T1,T2> &p) const;
    };
    template<class T1, class T2>
    bool Pair<T1,T2>::operator<(const Pair<T1,T2> &p) const         //Pair的成员函数 operator<
    {
        return key < p.key;         //小的意思就是关键字小
    }

    int main()
    {
        Pair<string,int> student("Tom",19);         //实例化出一个类 Pair<string,int>
        cout << student.key << " " << student.value;//输出：Tom 19
        return 0;
    }
    ```     
  我们呢，需要定义一个叫作 Parir 类的这样的一个模板。 这个类模板呢，它包含了两个类型参数，T1 和 T2。 那么我们在这个类里面分别用 T1和 T2 去标记这个 Pair 类里面的一个 关键字 key 和 value ，啊。这个 key 是 T1 类型的，value 呢是 这个 T2 类型的。 有了这样两个这个 key 和 value 之后呢，我们就看到 我们还定义了一个相应的 Pair 的构造函数，啊。 那么它传递的这个 k 和 v 呢，分别也是 T1 和 T2 类型的。 这个 k 和 v 两个参数值就是用来去初始化， key 和 value 的。也就是说在这个构造函数里面，通过 传递这样两个 T1 T2类型的参数， k 和 v ， 分别去初始化这个 T1 类型的 k ，和 T2 类型的 value。 除此之外呢，我还在这个程序里面呢，去定义了一个运算符重载，operator< ，那么这个运算符重载它本身的这个对应的这个传递的参数呢，也是一个 Pair 类型的一个指针的引用，啊。 p。 **那么注意呢，这个 operator< 呢，因为我只是去实现了一个比较大小，它不会去改变带比较大小的这样对象的这个值，所以呢我会把它定义为是一个 const 类型的。** 那么有了这样的一个 Pair 类的一个模板的定义之后，我们就来具体看一看，它的成员函数是怎么实现的啊。如果我需要在这个类模板外部去实现这个 operator< 的话呢，那么那么我们刚才强调了，我们需要在前面去标记这样的一个，啊， 具体的类模板的一个作用域，啊，标明说它是属于 Pair 类的这样模板的这样的一个函数。 那么对应呢，也需要去标记相应的类型参数，T1 和 T2 ，啊。 那么实际上我们在这个成员函数里头它所实现的功能呢， 就是去 return 对应的这个 k 以及 p指向的这个 key 中间 更小的那个值。 那么我们来看有了这个 Pair 类的这个模板之后，我具体会怎么样去使用呢？ 那么我在这个 main 函数里头，就要去具体地实例化 出一个 类 Pair 的一个这个模板类来。 那么我们刚才看到，我的这个 Pair 的这个类模板当中它有两个参数。 这两个参数呢，这个类型呢分别是 T1 和 T2 。那么我在实例化的时候呢，我就会去相应地去 给它 这个替换为具体的这个数据类型。 在我们这个例子当中呢，T1 就被替换为是 string ，T2 呢就变成了 int。 那么我定义的这个 Pair 呢，它是具体的这个是一个什么样的对象呢？是一个 student 这样的一个对象。 这个对象呢，它呢本身呢实际上呢是包含了 两个类型，两个值，啊。具体的，分别是，用来呢， 一个字串 Tom 来标记这个 student 姓名以及他相应的这个年龄，啊，19。 那么我们看到说，我们通过去指定这个 T1 和 T2 类型，将刚才的这个 Pair 类的这样的一个模板 把它实例化为一个具体的类，那么它就是这个 Pair <string,int> ， 那么利用这个类呢，就可以具体实例化一个对象 student ， 那么这个 student 这个.k 和 .value 呢，就可以直接去访问和输出了。 所以我们在这个程序当中呢，当然 输出就是 Tom 19，啊，我们相应地去输出我们对应的这个 呃，类模板，相应实例化出的这个模板类的对象 student。 
- 那么我们在用类模板来声明对象的时候呢，我们注意到，实际上编译器本身呢，它就是一个由类模板生成类的过程。 我们把这个过程，我们刚才这个 Pair 的这个类模板，生成具体的这个 Pair < string 和 int 这样的一个过程呢，称为叫作类模板的实例化。 那么编译器呢，会自动地去用具体的这个数据类型， 来替换类模板当中我们定义的这个类型参数， 并且呢去生成相应的这个模板类的这个代码，因为我们用类模板实例化之后产生的就是一个模板类。 所以呢，我们说，注意区别类模板实例化得到的 那个类叫做模板类。一个叫做类模板，一个叫做模板类。 那么类模板呢，是一个模板更泛化意义上的一个概念。而模板类，就是 将这个具体的这个类模板实例化得到那个类，就称为叫做模板类。 那么有了这样的一个模板类之后呢，我们就会看到 通过指定不同的这个类型参数的话，就可以相应地去生成 若干个不同的模板类来。 
- 那么我们要强调一下的就是，我们是使用同一个类模板 同一个类模板来生成了两个模板类。虽然它源于同一个类模板， 但是呢，因为它是两个不同的模板类，所以这两个类之间的对象呢，是不兼容的。 比方说，
    ```C++
    //同一个类模板的两个模板类是不兼容的
    Pair<string,int> *p;
    Pair<string,double> a;
    p = &a;                 //wrong
    ```    
  我这里定义了两个， 都是通过Pair这个类模板来进行实例化的模板类，分别类型呢，是<string, int>和<string, double>。 那么定义呢，一个是对应的指针p，一个是对象a。 那么如果我这个时候，想让我的这个指针p指向a，是不可以的。因为 编译器会发现说，这样两个类是不一样的，虽然它是来源于不同的类模板， 但是它具体的这个替换的参数呢，是不一样的。 
- 那么类模，就是类模板本身呢，它的成员函数呢，还可以是一个函数的模板。也就是说，我在模板里头又包含了函数模板。 那么我们来看，
    ```C++
    //函数模板作为类模板的成员，成员函数只有在被调用的时候才会被实例化。
    #include <iostream>
    using namespace::std;
    template<class T>
    class A {
        public: 
            template<class T2>
            void Func(T2 t)
            {
                cout << t;              //成员函数模板
            }
    };

    int main()
    {
        A<int> a;
        a.Func('K');                    //成员函数模板Func被实例化,输出：K
        return 0;
    }
    //若函数模板改为
    //template<class T>
    //void Func(T t) {cout << t;}
    //将报错 "declaration of 'class T' shadows template parm 'class T'"
    ```   
  我们如果写了一个class A，它呢，就是一个类模板，那么它的这个参数呢， 是class T，啊。那么这个类模板本身，它包含了一个 函数，叫做Func。 这个函数本身，它呢，又是一个函数模板。 也就是说，这个函数本身的这个类型呢，也是不固定的。 那么我在这个函数模板里头呢，只需要输出相应的这个t就可以了。 那么要注意的就是，我们要强调一下， 我们在这个程序里面呢，它对应的这个类模板的类型参数，和这个函数模板的类型参数呢，是不能一致的。 如果呢，你在这个函数模板里头，也去使用了这个class T来去定义这个对应的参数类型的话呢，那么编译器会报错。 那么这个程序的话呢，因为我们在这个Class A里面去定义了一个相应的函数模板。 那么如果我具体实例化，生成相应的这个模板类，我把这个t 替换为int的时候，我对应定义了一个变量，对应定义了一个对象a， 那么这个a呢，就可以去调用相应的Func这个函数，这个函数里面的这个 对应的这个t值呢，那么它的类型呢，实际上应该是一个char类型的一个字串。 我相应就是把，对应的这个成员函数Func呢，也实例化了。 那么这样的话呢，我们就可以看到，我们在一个类模板里头，实际上是可以去使用函数模板的。 那么这个程序呢，就会相应地输出这个K。 
- 那么我们要注意，我们在使用类模板的时候，这个类型参数，本身的这个参数的声明呢，实际上中间可以包含一些非类型的参数。
    ```C++
    //类模板的参数声明中可以包括 非类型参数
    template<class T, int elementsNumber>
    //非类型参数：用来说明类模板中的属性
    //类型参数：用来说明类模板中的属性类型，成员操作的参数类型和返回值类型
    ```   
  就是说，这个参数表里面， 实际上，不一定都要去写相应的类型参数。它还可以包含一些这种常量的值。 那么，不是常量的，它可以包含一些这种这个非类型的参数。 那么对于这个非类型参数来讲的话呢，它其实主要是用来说明这个类模板当中 这个属性的，而这个类型参数呢，是用来说明这个类模板当中的 具体的这个属性类型，成员的操作的一些参数的类型，或者是返回值的类型等等， 那么这两个值呢，本身的作用呢，是不太一样的。 那么我们可以看到，
    ```C++
    //类模板的“<类型参数表>”中可以出现非类型参数
    template<class T, int size>
    class CArray {
        private:
            T array[size];
        public:
            void Print()
            {
                for(int i = 0; i < size; ++i)
                    cout << array[i] << endl;
            }
    }
    ```     
  这个类模板的类型参数表中间如果出现了一些非类型的参数， 比方说，我们这里定义了一个类模板，称为叫做array。 那么这个array呢，它除了定义了class T这样的一个类型参数之外，还包含了一个 int size这样的一个非类型的参数，那么这个int size，它用来标记什么呢？ 它其实就是用来去标记这个array的大小，这个size呢，它是一个固定的属性。 所以呢，我们就可以用一个非类型的参数来进行标记。 那么不管对于任何一个数组来讲，每个数组，它虽然里面这个类型的成员， 可能会不一样， 就是成员的类型可能会不一样，但是它对应呢，每一个数组都一定会包含这样的一个个数的一个特性。 那么这个特性，就可以去使用这个非类型参数来进行标记。 
- 那么要注意呢，我们刚才提到，每一个类模板，它在具体实例化的时候， 如果它实例化的这个类型参数的这个类型不一致的话，那么它是两个不同的这个模板类。那么同样的，如果你的这个非类型参数的值不一样，那么它对应呢，也是不一样的。 所以呢，我们看到说，
    ```C++
    CArray<double,40> a2;
    CArray<int,50> a3;
    //注意：
    //CArray<double,40>和CArray<int,50>完全是两个类，这两个类之间不能相互赋值
    ```   
  这里当然a2和a3显然是不一样，因为它们传递的这个类型参数，一个是double，一个是int。 但是呢，如果我现在前面两个都是int，只是这个非类型参数不一致的话呢，它表征的也是，完全两个不一样的类。 
- 那么在类模板当中呢，它也包含有继承这样的一个方式。 那么类模板的继承呢，它有四种形式。 
  - 一种叫做从类模板本身去派生出类模板， 
  - 另外呢，你可以从模板类，所谓模板类，我们刚才反复强调， 就是在类模板当中的这个类型，或者非类型的参数实例化之后的这个类。 可以通过模板类本身，来派生出类模板。 
  - 当然你也可以从普通类里面呢，派生出类模板。 
  - 最后呢，也可以由模板类派生出普通的类来。 
- 所以我们看到说呢，我们有这样的四种形式，分别是
  - 类模板派生类模板， 
  - 模板类派生类模板，
  - 普通类派生类模板，
  - 模板类派生普通类，
- 这样四种方式。 我们来具体看一下， 在第一种，类模板从类模板中派生的例子呢， 
    ```C++
    //类模板派生类模板
    template<class T1, class T2>
    class A {
        private:
            T1 v1;
            T2 v2;
    };

    template<class T1, class T2>
    class B:public A<T2,T1> {
        private:
            T1 v3;
            T2 v4;
    };   

    template<class T>
    class C:public B<T,T> {
        private:
            T1 v5;
    };  

    int main()
    {
        B<int,double> obj1;
        C<int> obj2;
        return 0;
    }
    //------实例化过程--------------------------
    class B<int,double>:public A<double,int> {
        private:
            int v3;
            double v4;
    };  
    class A<double,int> {
        private:
            double v1;
            int v2;
    };       
    ```   
  我们可以看到，如果我们定义了一系列的这个类模板， 首先第一个呢，就是class A，class A里面包含了两个类型参数，分别是T1和T2. 那么T1和T2呢，就分别定义了class A这个类模板当中的两个成员变量，v1和v2。 那么有了这样一个class A这样的一个父类之后呢，我可以呢，派生出来一个class B。 class B它也是一个类模板，它是由这个class A呢，派生出来的。 那么，这个class B呢，它所包含的类型参数，跟class A呢，是一致的， 分别也是T1和T2。那么我们定义呢，这个class B当中的这个， 除了这个原来既从A里面继承的这些成员变 量之外，它还有v3和v4两个成员变量。 那么进而呢，我们又派生了一个class C，它是从class B里面去派生的。 当然因为class C呢，它自身只有一个类型参数T， 所以呢，我们在去具体实例化这个 类B的时候呢，我们只具体传递了一个 这个参数类型T，它用来定义的呢，是这个 v5，那么有了这样的一系列的这个派生的这个 类模板之后呢，我们来看一下。我们呢，可以去定义一个由class B这样的一个类模板 通过去将其T1替换成int， T2替换成double，那么得到的这样一个类， 具体的这个模板类，所定义的对象，obj1。 之后呢，我们还可以去定义一个C。 具体的这个C模板类， 类模板定义的这样一个模板类，啊，它的具体的这个实例化对象，obj2. 我们来看，实际上对于这个， class B来讲，如果把它 定义成取T1替换为 int，T2替换为double的话，那么相应地它实际上也会去替换 它对应的这个 父类，a中间的这两个类型参数，T1和T2。那么也就是说它定义了int型的 实例化了一个int型的一个v3和double型的v4。那么 相应地呢，这个类a呢，也会具体地实例化成 这个double型的v1和int型的v2。 我们看到呢，
- 第二种情况就是让类模板从模板类里面派生。也就是说，我已经将一个具体的类从一个类模板里面呢，派生了，实例化了出来。 从这个实例化后的模板类里面，去派生一个类模板。比方说这里，
    ```C++
    //类模板从模板类派生
    template<class T1, class T2>
    class A {
        T1 v1;
        T2 v2;
    };

    template<class T>
    class B:public A<int,double> {
        T v
    };

    int main()
    {
        B<char> obj1;           //自动生成两个模板类：A<int,double>和B<char>
        return 0;
    }
    ```   
  我们定义了一个， 类模板class A，那么它包括了两个类型参数T1和T2， 分别去定义相应的成员变量，v1和v2。 那么我可以首先就将这个类模板实例化，变成一个模板类， 这个模板类，对应的T1呢，就是int， T2呢，就是double。那么有了这样的一个实例化后的模板 类之后呢，我又定义了一个类模板，称为叫做class B。 这个class B呢，它包含了一个类型参数T。 可以用这个T呢，具体地去定义其相应地派生类的成员变量v。 那么有了这样的一个对应的定义之后呢， 我们看到，如果我们在main函数里面去定义了一个， 类模板B，具体这个实例化的这个， 模板类，它呢，是将T替换成为char类型的这样一个对象， obj1的时候，我们实际上呢，会自动地生成两个 模板类，分别是A<int, double>和B<char>，也就是说 我这个类的对象呢，它本身，是包含了这样两个模板类所定义的那些一系列的特性。 
- 那么第三种，就比较简单了，它是指说类模板呢，是从普通类那里派生的。
    ```C++
    //类模板从普通类派生
    class A {
        private:
            int v1;
    };

    template<class T>
    class B:public A {
        private:
            T v;
    }

    int main()
    {
        B<char> obj1;
        return 0;
    }
    ```   
  我定义了一个普通类class A，包含了一个int型成员变量v1，那么它作为父类，又派生出来一个类模板，class B，这个class B呢，它除了包含这个父类里面的这个int v1之外呢，它还定义了一个这样T类型的一个成员变量v， 那么我也可以直接去实例化，将这个T呢， 实例化成一个char类型的一个这样的一个字符。 
- 那么最后一种呢，就是普通类从这个模板类里面派生出来，也就是说我可以从一个模板类可以派生一个普通类。 
    ```C++
    //普通类从模板类派生
    template<class T>
    class A {
        private:
            T v1;
            int n;
    };

    class B:public A<int> {
        private:
            double v;
    }

    int main()
    {
        B obj1;
        return 0;
    }
    ``` 
  那么我定义了一个模板类，class A，那么它包含了这个 成员变量v1呢，是以这个T类型作为这个参数来， 类型参数来定义的，那么我可以呢，通过去具体的这个实例化，具体的这个模板类，我让这个T1 替换成为是int，这样的一个模板类 ，在实例化了之后呢，就可以作为我的这个普通类class B的一个父类， 来进行这个派生。那么class B呢，就继承了相应的这个模板类A<int>它所包含的一系列的这个成员变量这个属性。那么我在这个main函数里面，只需要去对应的实例化或者定义，具体类B的这个对象 obj1，就可以了。而这个obj1呢，因为它是一个普通类的一个对象， 所以它不需要传递任何的这个类型参数，那么它所包含的这个特征呢，也是具体了这个模板类A所包含的这个int v1和int n以及double v 这样三个成员变量。 
## 4. string类
- 大家好，在这一小节中我们来了解一下string类， 之所以把string类放在这一节教学中间呢是因为string类本身就是一个模板类， 当然很多同学呢可能不知道，它本身其实就是由一个类模板实力化得到的， 同时呢因为string类自身呢是一个好用的类库， 那么我们在很多场合下去进行这个字符串处理的时候呢都会用到它。 所以呢我们在这一次课程中间简单的给大家介绍一下它的一些使用的方式。 那么在我们整个视频片段当中呢还有一些额外的内容可能不会在视频当中去讲述到大家呢可以在扩展的这个讲义当中pdf里面呢看到其相应的内容。 
- 那么我们刚提到了string类自身的其实就是一个模板类， 那么这个模板类呢它就是通过定义这个 `typedef basic_string<char> string` .然后利用这个类型参数这个char来具体地实力化出来的一个类string， 那么这个类呢本身它所要包含的使用的时候就需要去包含头文件string，
    ```C++
    //string类有多个构造函数，用法示例如下
    string s1();                        //s1 = "";
    strings2("Hello");                  //s2 = "Hello"
    string s3(4,'K');                   //s3 = "KKKK"
    string s4("12345",1,3);             //s4 = "234",即“12345”的从下标1开始，长度为3的字串
    string month = "March";

    //string类没有接受一个整形参数或一个字符型战术的构造函数。
    string s1('K');                     //wrong
    string s2(123);                     //wrong
    string s3 = 'c';                    //wrong
    string s4 = 1;                      //wrong
    ``` 
  我们在对这个string对象来进行初始化的时候呢通常会有两种形式 一种呢就是去调用一个包含一个参数的构造函数， 比方说我们可以将一个字串作为完整的一个参数传递给s1，这样的一个string类型的一个对象， 那么可以用它来进行初始化，同样呢我们可以去使用一个两个参数的一个构造函数， 那么第一个参数呢它所定义的就是对应的这个字符出现的个数 而第二个参数呢它就是去定义对应的字符， 那么我们可以利用这样一系列若干多个字符组成的这样一个字串呢去初始化s2。 当然你也可以直接利用这个呃赋值号，那么赋值号它所实现的是将这个字串 初始化给相应的string类型定义的这样一个对象。 那么注意一下就是我们在使用string类的时候呢是不能够 因为本身类别没有提供以字符或者是整数 为参数的构造函数啊，构造函数只有刚刚提到的那两种。 所以呢如果你想简单的，直接将一个字符初始化给一个string对象， 或者将一个整数初始化给一个string对象呢都是不可以的。 所以当我们要去实现一个字符复制给 一个字串这个string的话呢，我们需要这么去写啊，我们需要首先 去定义好一个string类型的对象s， 然后再利用这个赋值语句将这个字符呢n赋值给相应的这个对象。 
- 此外呢如果我们再去这个构造string时候， 
    ```C++
    //构造的string太长而无法表达，会抛出length_error异常
    //string对象的长度用成员函数length()读取
    string("hello");
    cout << s.length() << endl;
    //string支持流读取运算符
    string stringObject;
    cin >> stringObject;
    //string支持getline函数
    string s;
    getline(cin,s); 
    ```
  如果本身的这个string呢太长无法表达的话呢那么相应会抛出这样一个叫做length error 的异常，如果我们希望去 求得这个string对象的长度的话呢那么我门去可以使用这个 函数成员函数就是string类的这个成员函数length来进行读取， 直接用s.length就可以获得相应的这个字串的长度。 那么因为本身string呢它是支持这个流读取运算的， 所以呢如果我定义了一个string类型的对象， stringObject这样一个对象的话了,那么我的这个cin 是直接可以直接输出 相应的这个啊可以直接的输入相应的这个值给到这个string 这个类型对象中间的， 因为这个流读取呢是运算符 它是能够在运算中得到支持。同时呢，string类这本身它也是支持getline这样的函数的， 也就是说如果你定义了一个string 类型的对象s，你希望能够直接getline一行进来， 我可以直接去写getline（cin.s）那么就可以实现这个读取的这样一个功能。 
- 另外呢string本身是可以支持这个赋值号的， 
    ```C++
    //用‘=’赋值
    string s1("cat"),s2;
    s2 = s1;
    //用assign成员函数复制
    string s1("cat"),s3;
    s3.assign(s1);
    //用assign函数部分复制
    string s1("catpig"),s3;
    s3.assign(s1,1,3);              //从s1中下标为1的字符开始复制3个字符给s3
    ```
  这个等于号的赋值呢可以实现将一个string类型的对象呢具体的内容复制给另外一个对象， 我们看到，如果我们定义了一个 对象s1,那么它是利用这个cat这个字串来进行初始化的， 那么我可以直接将s1赋值给s2， S2这个字串，这个string这个对象呢也就 被被复制为cat这样一个字串, 那么同样的我也可以利用string类自身类的一个成员函数 assign来实现复制啊，那么assign它同样能够达到， 这个赋值号的一个效果，如果我去定义了一个对象S3 那么去将这个assign这个成员函数作用在S3上的话 那么它所传递的这个参数S1呢就可以将S1对象里面包含的字串 完全复制给S3，同样呢assign成员函数还可以实现部分复制， 我可以呢定义一个S1，叫做catpig这样的一个字串， 那么我可以实现什么样的功能来利用assign，我可以将s1中间下标为一的那个字符开始 复制三个字符给S3，也就是说我并不是将S1里面全部内容都复制给S3 只是将其标记的这一部分内容复制过去， 同时呢string本身还可以支持单个字符的复制， 
    ```C++
    //d单个字符复制
    s2[5] = s1[3] = 'a';
    //逐个访问string对象中的字符
    string s1("hello");
    for(int i = 0; i < s1.length; i++) {
        cout << s1.at(i) << endl;           //成员函数会做范围检查，如果超出范围，会抛出out_of_range异常，而下标运算符不做范围检查
    } 
    ```  
  啊也就是说是string类呢它本身是支持这个方方括号这个运算符的， 所以它可以获得单个对应字符的一个读取 那么我可以把相应的这个某一个字符复制给 对应的string类型中间对象中间的某一个具体的位， 除此之外那我们还可以去逐个地访问string中间的字符， 那么我们可以去使用成员函数at啊，使用成员函数at也可以达到我们刚才去分别访问 我的这个string对象中间每一个字符这样的功能。 那么要注意就是这个at本身呢是会，成员函数本身是会去做这个范围检查的， 如果我们访问的这个范围，它超出了我string类型，这个对象包含的这个范围的话， 它会抛出 out of range 这个异常，但是如果你去直接使用这个方括号这个下标运算符的话呢， 那么如果我访问的位置超出范围呢，它也是不会提示的。 这需要程序员自身来保证你不会超出访问范围。 
- 那么这个string本身的这个类呢，它可以使用这个加号运算符的功能， 
    ```C++
    //用 + 运算符连接字符串
    string s1("good"),s2("morning!");
    s1 += s2;
    cout << s1;
    //用成员函数 append 连接字符串
    string s1("good"),s2("morning!");
    s1.append(s2);
    cout << s1;
    s2.append(s1,3,s1.size());          //s1.size()得到s1的字符数
    cout << s2;                         //下标为3开始，s1.size()个字符，如果字符串没有足够的字符，则复制到字符串最后一个字符
    } 
    ```  
  那么这个加号呢它是可以实现将两个字符串连接起来的这样一个作用，那么如果说呢，我这里定义了一个字串用good来进行初始化，那么第二个字串呢s2用morning来进行这个初始化，那么相应的话那我们就可以利用S1， 这个等于S1加上s2这样的一个操作， 实现将Good morning这样两个字串 连接在一起赋值给S1的一个效果。 那么同样的我在这边呢也可以利用成员函数append， 那么append也能够实现这个连接两个字串的功能，同时呢它还可以去实现 这个将相应指定位置的这个字串呢连接起来，比方说我这边去写了一个 S2 append append，那么对应传递的是什么呢，传的是S1 那么相应呢它是将下标从3开始啊， 然后对应传，这个传递多少呢，传递S1.size的字符，那么如果 字符号串内部呢本身内部没有足够的字符的话呢，它会复制到最后，这个字串的最后一个字符。 
- 此外呢，string本身还可以去实现这个关系运算符的对比， 我可以利用这样一些关系呢直接去比较string类的大小呃， 
    ```C++
    //用关系运算符比较string的大小
    //==,>,>=,<,<=,!=
    //返回值都是bool类型，成立返回true，否则返回false
    //例如：
    string s1("hello"),s2("hello"),s3("hell");
    bool b = (s1 == s2);
    cout << b << endl;              //1
    b = (s1 == s3);
    cout << b << endl;              //0
    b = (s1 > s3);
    cout << b << endl;              //1
    ```  
  那么返回的这个类型呢都是bool型的一个这个变量， bool型的这样一个类型，那么 如果本身成立，比较大小如果 比较大小之后如果是成立的话返回时TRUE，否则的就会是FALSE，比方说在下面这个例子当中， 我的S1呢被初始化为了hello，S2呢也是hello， S3呢是help， 那么我看到说，在我的这个程序中间，如果我现在 判断一下S1是否等于S2，啊那么返回值呢付给B， 完事它相应的输出B，那么我们看到因为S1和S2是两个一模一样的字串，那么自然b就会使 这个回值是TRUE，啊那么同样的判断S1和S3是否相等 另外S1和S3显示两个不同的字串是吧，那么返回的就是False， 那么第三个我们可以用S1和S3进行比大小 我们看到说呢，S1本身它包这个字串hello包含的字符数呢大于S3包含的字符数 所以我们在比较大小的时候呢会发现说它所包含的这个元素个数更大，那么它是大于S3的， 所以返回的b呢也是1，那么所以整个这个程序输出的就是1,0,1 
- 除此之外呢string呢还可以利用成员函数 substring这样一个成员函数去访问其对应的一个子串。 
    ```C++
    //成员函数 substr()
    string s1("hello world"),s2;
    s2 = s1.substr(4,5);            //下标4开始5个字符
    cout << s2 << end;              //输出： o wor
    ```  
  如果我定义了一个s1这样的string类型的对象， 那么它是用hello world这样的一个很长的子串来进行初始化的。 那么我还除此之外定义了一个s2这个对象。 这个对象呢我希望用s1的一段，其中的一段来进行赋值。 那么我就可以调用substr()这样的一个这个子串的这样的一个成员函数，它实际上表达的意思就是说它会从下标为4的 这个字符开始然后呢赋值5个字符。 所以如果我们这时候对应输出s2的话会看到相应的 hello world第4个字符呢 应该是o，那么完了之后呢，这个复制5个字符，那也就是 o到r，所以对应打印输出呢就是o wor。 
- 除此之外呢，string这个类里面还提供了一系列的 成员函数可以去寻找相应的这个字符。 
    ```C++
    //成员函数 find()
    string s1("hello world");
    s1.find("lo");
    //在s1中从前向后查找"lo"第一次出现的地方
    //如果找到，返回"lo"开始的位置，即l所在的位置下标
    //如果找不到，返回string::npos(string中定义的静态常量)

    //成员函数 rfind()
    string s1("hello world");
    s1.find("lo");
    //在s1中从后向前查找"lo"第一次出现的地方
    //如果找到，返回"lo"开始的位置，即l所在的位置下标
    //如果找不到，返回string::npos(string中定义的静态常量)    
    ```  
  比方说它包含了成员函数find，那么find话呢 它所做的事就是从对应的这个作用的对象上面 从前往后去找相应的待查找的字串 出现的地方。第一次出现的地方呢就是会作为这个函数的返回值。 如果找到的话呢，返回的就是这个l所在的这个位置的下标， 如果找不到呢，它就会返回一个 string::npos，non position这样一个在string类里面定义了一个静态的常量。 那么相应的如果你去使用这个rfind它实际上 做的事呢就是从后往前找， find是从前往后找，rfind是从后往前找。那么找到的也是l所在的位置下标。 
- 另外呢你还可以去find_first_of， 
    ```C++
    //成员函数 find_first_of()
    string s1("hello world");
    s1.find_first_of("abcd");
    //在s1中从前向后查找"abcd"中任何一个字符第一次出现的地方。如果找到，返回找到字母的位置；如果找不到，返回string::npos

    //成员函数 find_last_of()
    string s1("hello world");
    s1.find_last_of("abcd");
    //在s1中查找"abcd"中任何一个字符最后一次出现的地方。如果找到，返回找到字母的位置；如果找不到，返回string::npos   
    ``` 
  也就说你希望能够去查找在参数指定的这个字串中间任何一个字符第一次出现的地方。 那么你就可以去利用find_first_of，也就说在这个hello world里头要利用 find_first_of可以去判断一下abcd这个字串中间的任何一个字符是否出现在hello world里， 那么同时呢你也可以find_last_of，比如说 我们在abcd这个字串当中，会有任意一个字符，最后一次出现的地方。 另外呢如果你在find_first_of中间加了一个 not的话，那么它所查找的是说 在这个字串当中不在abcd中间出现的字母的第一次出现的位置。 那么同样的，find_not_last_of呢就是在 从后向前查找的时候，不在abcd这个参数字串的第一次出现的地方。 
- 那么在了解了上述一系列在string中间去寻找相应字串的成员函数后呢，我们来具体看一个程序的例子。 看看说这些函数都是具体怎么样去作用的。 我们在这个代码中间呢，
    ```C++
    //寻找strig中的字符
    string s1("hello worlld");

    cout << s1.find("ll") << endl;                          //2
    cout << s1.find("abc") << endl;                         //返回无符号位的（-1），如32位机器中为4294967295

    cout << s1.rfind("ll") << endl;                         //9
    cout << s1.rfind("abc") << endl;                        //同上

    cout << s1.find_first_of("abcde") << endl;              //1
    cout << s1.find_first_of("abc") << endl;                //同上    

    cout << s1.find_last_of("abcde") << endl;               //11  
    cout << s1.find_last_of("abc") << endl;                 //同上

    cout << s1.find_first_not_of("abcde") << endl;          //0
    cout << s1.find_first_not_of("hello world") << endl;    //同上

    cout << s1.find_last_not_of("abcde") << endl;           //10
    cout << s1.find_last_not_of("hello world") << endl;     //同上    
    ``` 
  定义了一个string类型的对象s1， 那么它呢用Hello worlld这样的一个字串来进行初始化。 那么注意一下，这个worlld呢它本身实际上是一个错字啦。它中间包含了一对，double l 那么这个设计呢主要是为了让我们看到后续的一些语句的输出来专门设计的。 那么在这个s1这样的一个Hello worlld字串当中呢 我们首先做的事就是去从前向后find double l 这样的一个很短的一个字串。 那么double l这个字串呢从前向后第一次出现的位置呢自然就是在hello里面， 所以呢，我们返回的这个位置是double l的第一个l所指向的那个下标。那么由于下标是从0开始，所以这个返回的是2. 那么同样呢我们也可以去查找abc这个字串。 这个字串从前向后去寻找呢， 你会发现它并没有出现在Hello worlld里头，所以呢它的返回值就是我们说的之前的那个常量。 那么我除了去从前向后查找double l之外呢，我还可以 从后向前reverse find double l这个字串。 这时候这个double l就出现在了我们之前挖坑的这个worlld这对 double l上面当然注意，这个double l呢虽然是从后向前来寻找， 但是返回的那个对应的下标呢仍然是第一个l的位置。 所以呢它是返回的是9. 那么同理呢如果你从后向前去查找abc，也是查不到的。所以它也是返回的一个常量标记值。 那么除了去查找这样的一个完整的字符串之外呢， 我还可以去查找对应这个字串里面的某一个字符， 如果我去查找abcde这个字串中间的任何一个字符 第一次出现的位置，那么我会看到说呢， 我在abcde这几个字串中间的字符呢，有一个e 它实际上是会在hello worlld这个字符串里面呢 会出现的，那么它第一次出现的这个位置在哪里呢，它出现在hello这个e的位置上， 所以它的下标呢是e 同时呢你也可以去查找abc这个字串中间的任何一个字符 第一次出现的位置。那么我们看到abc中间这三个字符都没有出现在hello worlld里面 所以呢它的这个返回值也是一个常量。 此外呢，我们还可以从后向前来查找。find_last_of 那么abcde这个字串里面这5个字符那么显然是 d这个字符首先出现在了worlld的最后，那么它返回的值呢下标值就是1， 那么同理，abcd这个字串，它不管是从前向后还是从后向前，这三个字符呢都没有出现在hello worlld里面，所以它返回的仍然是一个静态的值。 那么除了发现这个返回对应的这个字符出现的第一次的位置 之外呢，我们还可以去find_first_not_of， 也就说，我们去看一下，在这个没有包含 这个字符串中间的任何的字符的相应的位置 出现在哪里。也就说我的这个hello worlld里头的所有字符 如果没有出现在我的这个参数的字符串里头， 那么它对应的第一个字符的位置在哪， 那么显然abcde里面没有包含第一个h，所以那么我就显然返回的就是第一个h 这个位置，所以它就是下标是0， 那么如果我这样去对应呢去设置一个hello worlld 这样的一个字串中间的任何一个字符，没有出现在s1里面， 那么这时候你会发现s1里面所有的字符都出现在我的这个参数的这个集合里面了。 因此它的返回值就是常量。 那么同样的我还可以从后向前去寻找。 那么find_not_last_of也是一样的。 我会发现说呢从后向前，第一个从后向前的字符呢 是d那么d呢它出现在了我的这个参数的集合当中， 那么第二个值l呢它没有出现，所以返回值是10. 那么同理也是一样，如果你去查找hello worlld这个参数， 对应的这个字串中间的所有字符它都出现在了相应s1的 这个对象中间，因此它的返回值就是一个常量。 所以这段小的程序是为了让大家看到说string类型中间 我们最常用到的就是关于字符串匹配的这些问题。 那么它可以返回相应我们需要得到的对应的位置。 
- 那么除此之外呢，我们在string这个中间呢还可以使用成员函数erase 来替换string中间的字符。
    ```C++
    //成员函数 erase()
    //去掉下标5及之后的字符
    string s1("hello worlld");
    s1.erase(5);
    cout << s1;
    cout << s1.length();
    cout << s1.size();          //输出：hello55
    ``` 
  比方说我i定义了一个string类型的这个对象s1还是hello worlld这样的一个字串，那么如果我erase了其中的这个下标为5以及之后的这个字符，如果我擦除掉了之后的字符的话呢 那么我们看相应的输出是什么呢？相应的输出首先我cout了s1， 就是我相应输出了下标为5之后的 hello这样的一个具体的字串， 完了之后hello字串呢它是以下标为5来划界， 5之后的相应的字符都被erase掉了。那么如果我这时候呢去 求取一下s1这个对象在erase之后的length， 同样你也可以使用size这样的一个成员函数去返回相应的这个字串的长度。 
- 那么同样的呢你也可以利用这个find我们刚才提到这个函数 具体去看一看指定说它从哪一位去开始查找。 
    ```C++
    //成员函数 find() 
    //分别从下标1，2，3开始查找"ll"
    string s1("hello worlld");
    cout << s1.find("ll",1) << endl;        //输出：2
    cout << s1.find("ll",2) << endl;        //输出：2
    cout << s1.find("ll",3) << endl;        //输出：9
    ``` 
  比方说我在这里第一次希望去查找这个double l的时候呢 我希望是从前向后，从下标1开始去查找， 下标1.也就是说从e开始查找。这时候它返回的值就应该是相应的ll对应的这个位置，那么它当然返回的就是2，因为我ll是 下标为2的，那么同样的，我如果从下标为2开始查找，也就是说从l开始， 那么它也能够返回2，但是如果我从下标为3开始， 也就说，我从第二个l开始查找，那么这之后的字串 在前面这些位置上都并没有直接包含两个l，那么 当你去查找ll这个字串的时候它自然就会找到word里面包含的这个ll 所以它返回的是9，所以呢如果我们希望去从这个字串的 某一个指定位置之后才开始查找的话，就可以去使用find这个成员函数。 
- 除此之外呢，我们也可以利用这个replace的成员函数去替换string中间的这个字符。
    ```C++
    //成员函数 replace() 
    //将s1中下标2开始的3个字符换成"haha"
    string s1("hello worlld");
    s1.replace(2,3,"haha");                 
    cout << s1;                             //输出：hehaha world
    ``` 
  比方说我们希望能够去替换s1对应这个hello world这个字串中间从下标2开始 连续3个字符被替换成haha这样的一个字串， 那么我们就可以调用s2.replace然后呢 去相应的标记其开始的位置 以及多少个字串被替换。那么这个程序的话我们对应就可以看到， 我们的这个hello中间的这个 从第一个l也就是下标为2这个位置呢开始被替换掉， 替换了几个字符呢？替换了3个字符，也就是ll和o， 那么被替换成谁了呢？被替换成了haha，这样的一个第三个参数传递进来的字串， 那么除此之外呢，后面就是原先这个s1包含的这个字串的内容。 
- 那么注意呢我们也可以去使用 进一步使用replace后面的这个haha的这个参数， 也就说，我希望把haha这个字串中间的某一部分字符赋值给s1,这也是可以的。 
    ```C++
    //成员函数 replace() 
    //将s1中下标2开始的3个字符换成"haha"中下标1开始的2个字符
    string s1("hello worlld");
    s1.replace(2,3,"haha",1,2);             
    cout << s1;                             //输出：heah world
    ``` 
  我可以去使用haha中间下标为1的这个字符开始，也就说从a开始， 赋值几个字符呢？赋值两个字符，所以呢，同样的，我们对于刚才的这个函数来讲的话呢，它的输出呢就是hello前面的he，它从 第二个字符开始，标下标为2的这个字符开始复制，替换， 那么替换的内容是什么呢，是haha里面的这个从第一个字符下标为a开始，包含两个字符来替换进来，所以就是a和h那么在string中间呢，还可以实现插入字符这样的功能。 
- 我们只需要去使用成员函数insert就能够实现将一个字符串插入到另外一个字符串当中，或者是将一个字符串的部分插入到其相应当中的一个功能，我们来看一下具体的实现，
    ```C++
    //成员函数 insert() 
    string s1("hello worlld");
    string s2("show insert");
    s1.insert(5,s2);                        //将s2插入s1下标5的位置
    cout << s1 << endl;                     //输出：helloshow insert worlld
    s1.insert(2,s2,5,3);                    //将s2中下标5开始的3个字符插入s1下标2的位置       
    cout << s1;                             //输出：heinslloshow insert worlld
    ``` 
  我们定义了一个string类型的对象s1,和另外一个string类型的对象s2， 那么他们分别用hello world和show insert呢这样两个字串来进行初始化， 那么如果我希望呢，能够将这个 s2插入到s1下标为5的位置的话呢， 那么我就需要去使用s1.insert这样的一个成员函数， 那么第一个传递的参数呢就是我对应插入的s1的位置， 那也就是下标为5，下标为5的话呢实际上也就是对应在s1里头空格这个位置。 插入的具体内容是什么呢，可以将s2整个字串插入进来。 我们看一下，如果这个时候我打印输出s1的话，那么我会看到我在hello后面会 相应的插入show insert这样的一个s2的字串完了之后呢才是s1的后续字串。同时呢，我还可以去相应的插入指定s2当中的一段，如果我继续想在s1当这个 以及输出出来的这个字串里面进一步去插入呢那么我可以去 实现insert谁呢，具体insert s2当中下标为5 开始的3个字符，也就说我在这里面两个参数分别描述的是插入的这个，待插入的这个字符串中间的起始位置以及它的字长。那么相应它插入哪，插入到S1下标为2的位置，我们定义 第一个参数是插入的这个位置，所以在刚才这个s1字串的基础上我们相应在这个e后面 又插入了这个3个字符也就是insert里面的三个字符，ins，完了之后我们再把后续的这个字串就放在这里就可以了。
- 如果我们需要去将这个string中间的字符串转换成为C语言char *的字符串的时候 我们要去使用这个成员函数c_str()， 
    ```C++
    //成员函数 c_str()    
    //s1.c_str()返回传统的const char* 类型的字符串，且该字符串以'\0'结尾
    string s1("hello world");
    printf("%s\n",s1.c_str());              //输出：hello world                       
    ``` 
  这个函数它能够将我们定义的这个string类型的对象 比如说我们这里去初始化了一个S1对象是hello world， 我们希望能够将这个字串以普通的char * 的形式打印输出出来的话，那么我们就需要用s1.c_str()， 那么使用了这个函数之后它的返回值呢是一个const char* 类型的一个字符串，并且它在末尾增添了一个\0这样一个运算符， 结束符，所以它就能够将之前的这个 string类型的字符串呢转换成为char *类型的字符串。 所以这个程序的输出呢 就是我们对应的hello world. 
## 5. 输入输出
- 接下来讲讲跟输入输出有关的杂事 有些同学关心我会接下来该怎么喝水。我暂时还没有找到更大的水桶，所以喝不了水了 所以不好意思露脸了。今天我们就听听我的声音吧 在这个C++里面，有好些跟输入输出相关的类。他们都在iostream里面定义的 这下面的就是基类ios 然后从ios派生出istream，派生出ostream。那我们知道 cin就是istream对应的对象，cout就是ostream的对象。然后istream派生出ifstream ifstream呢就是对文件进行读操作的。ostream派生出ofstream。ofstream呢 是用来对文件进行写操作的。然后istream和ostream共同派生出iostream iostream呢又派生出fstream。fstream呢可以用来打开文件进行读操作也进行写操作。 这里列出了各个类他们的对象。
    ```C++
    //与输入输出流操作相关的类
    istream是用于输入的流类，cin就是该类的对象
    ostream是用于输出的流类，cout就是该类的对象
    ifstream是用于从文件读取数据的类
    ofstream是用于向文件写入数据的类
    iostream是既能用于输入，又能用于输出的类
    fstream是既能从文件读取数据，又能向文件写入数据的类   

    //标准流对象
    输入流对象：cin 与标准输入设备相连
    输出流对象：cout 与标准输出设备相连
               cerr 与标准错误输出设备相连
               clog 与标准错误输出设备相连
    缺省情况下：
        cerr << "Hello World" << endl;
        clog << "Hello World" << endl;
    和
        cout << "Hello World" << endl;  一样
    ``` 
  我们知道了cin是istream的对象。cout是ostream的对象。 那iostream里面除了这个cin，cout，还会有一些其他的对象。比如cerr和clog我们知道cin叫做标准输入，cout也称为标准输出 那cerr就称为标准错误输出。clog基本上跟cerr是差不多的啦，也是标准错误输出。那我们在缺省的情况下不管你把一个东西输出到cerr，输出到clog，还是输到cout，效果都是一样的。反正这些注意， 都会出现在题目上。
- cin它对于标准输入流，他可以用来从键盘读取数据， 也可以被重定向为从文件中读取数据，等会儿我们再看重定向cout对于标准输出流，他用于向屏幕输出数据，也可以被重定向为向文件写入数据 cerr和clog呢可以用来对屏幕输出出错信息 cerr和clog有一点小区别，跟缓冲区有关，我们不说它我们看一个重定向的例子。
    ```C++
    //输出重定向
    #include <iostream>
    using namespace::std;

    int main()
    {
        int x,y;
        cin >> x >> y;
        freopen("test,txt","w",stdout);             //将标准输入重定向到test.txt文件
        if(y == 0)                                  //除数为0则在屏幕上输出错误信息
            cerr << "error." << endl;
        else
            cout << x/y;                            //输出结果到test.txt
        return 0;
    }                     
    ``` 
  输出重定向 在这里程序里面我们有这条语句freopen("test.txt","w"stdout) 这条语句酒吧标准输出重定向到test.txt文件 这条语句的效果是什么呢 大家知道这个cout代表标准输出设备。缺省的情况下也就是屏幕。把它交给cout输出的东西 也会出现在屏幕上。但是呢，我们通过这条语句，把这个标准输出设备stdout重定向到了这个test.txt 这边的w代表写，那么在这种情况下你交给cout输出的东西就会出现在test.txt这个文件里，他不会出现在屏幕上了。那我们看看这个程序呢，他读出，读入x,y，然后如果y 等于0的话，就要输出一个error。这个error是交给cerr进行输出的。cerr是什么啊，是标准错误输出设备。他缺省的情况下呢就是屏幕。就是说这个error就会出现在屏幕上。这个cerr并没有被重定向，但下面这个cout被重定向了。所以说只要y不为零的话呢x除以y的商就会被输出到test.txt 里面去。通过这个例子我们看到这个cerr还是挺有用的啊。假设有时候你的一个程序 输出的结果是一个文件。就是你想把你的程序输出结果放到一个文件里面，那你要通 过对这个cout进行重定向，然后把数据都交给cout输出，就能达到这个效果。但这个程序呢中间可能还要 输出一些调试信息。这个调试信息你并不希望他出现在这个结果的文件里头，而希望他出现在屏幕上。 这个怎么办呢。你如果把调试信息交给cout输出，那岂不是调试信息也拍到文件里了。所以解决问题的办法就是 我们把cout重定向了，但是呢我们没有把cerr重定向。然后我把调试信息交给cerr输出，这样我们这个程序的 一些正确的结果就会被重定向到文件里面，而那些调试信息呢还是通过cerr输出到了这个屏幕上。 
- 那实际上这个标准输出可以被重定向，标准输入也可以被重定向。
    ```C++
    //输入重定向
    #include <iostream>
    using namespace::std;

    int main()
    {
        double f;
        int n;
        freopen("t.txt","r",stdin);             //cin被改为从t.txt中读取数据
        con >> f >> n;
        cout << f << "," << n << endl;
        return 0;
    }                            
    ``` 
  像这个freopen("t.txt","r"stdin) r代表读，stdin代表标准输入设备，那这个标准输入设备被重定向以后呢 以后我们再从cin读取数据，cin读取数据的语句就不会被停下来 等待用户从键盘敲入数据。cin就直接从文件里面去读取数据了。所以家属有一个t.txt 它的内容是3.14 123，好，那我们这个程序运行起来的时候啊，就不会停下来等待用户输入而是直接 从文件里面把3.14就读到f里面去，把123读到n里面去。当你输出的时候 就是3.14 123了。
- 那我们输入输出的地方呢我们统称为输入流 那我们知道这个键盘也是输入流的来源。一个文件也可以是输入流 尤其是我们可以把这个标准输入重定向成从文件里面读取数据， 那文件就是个输入流了。那有的时候我们不会需要 读取文件的内容。直到这个文件的内容被读完了我这个程序就结束 那我们在做从文件里面输入的时候 怎么样才知道文件的数据都已经读完了呢 那如果我们是经过了吧标准输入重定向成一个文件以后，并且用cin 从文件里面读取数据，那么我们就需要判断文件的结束，具体的办法就是这么写。
    ```C++
    //判断输入流结束
    //可以用如下方法判断输入流结束：
    int x;
    while(cin >> x) {                           //输入没有结束，条件就为真
        ....
    }     

    //右移运算符在istream类里面的重载
    istream &operator>>(int a)
    {
        .....
        rerurn *this;                           //强制类型转换运算符的重载把返回的这个cin对象强制转换成bool类型的值
    }    

    //如果是从文件输入，比如前面有freopen("some.txt","r",stdin),那么读到文件尾部，输入流就算结束
    //如果从键盘输入，则在单独一行输入 Ctrl + Z 代表输入流结束。UNIX/Linux 输入 Ctrl + D                   
    ``` 
  假设我现在要从一个文件里面不停地读入整数，那我怎么知道这个文件是不是已经读完了呢 我们 用一个while循环读入整数。这么写就行了。当文件结束的时候 也就是输入流结束的时候，这个表达式的返回值是 false，于是循环就可以结束。那这样说起来是比较奇怪的，因为我们前面讲过这个右移一串符在h类里面的重改，它应该是这样的。 它的返回值是什么是，是fstream的引用。也就是说这个表达式它的返回值应该是 istream的引用，自然就是cin的引用。也就是cin。那cin怎么能够作为 这个条件，它的值可以为true也可以为false呢。按理说这是说不过去的。 但实际上这里面又碰到了一个以前没有说过的 叫，难一点的知识，叫做强制类型转换运算符的重载。也就是说这个表达式它的返回值虽然是cin 但是在istream里面 有一个强制类型转换运算符的重载就能够把这个cin对象强制转换成bool类型的值。所以当输入流结束的时候 这个心被转换出拉力的布尔类型的纸就是false。这个循环就结束了 那么关于类型强制转换运算符的重载， 同学们有兴趣的可以去看教材，或者上网搜一搜 这里就不讲了 那说到这个输入流的结束，输入流到底什么样才算结束。那么如果这个输入流是从 文件的话，比如说我们通过重定向把标准输入 定向为是从文件里面读取数据，那么着这个文件结束的时候，输入流自然的就结束了 那如果这个输入流是从键盘输入的，那怎么样才算结束呢 也就是说，如果你在键盘桥数据的时候，在单独的一行 就你敲了一个回车，下面新开一行了然后你在敲一个Ctrl+Z 这个时候输入流就会结束了 
- 下面再来看一些istream类的几个重要的成员函数 其中一个是getline。getline呢它有两个版本。是重载的。 第一个版本我们看，它是从输入流中读取bufsize减一这么多个字符到缓冲区buf 或者读到碰到|n为止 那么读取了bufsize减一这么多个字符 或者碰到|n这两个条件，哪个先到就算哪个。那个条件先碰到了 getline函数就返回了。它的读取就结束了。 那getline的第二个版本比第一个版本多了一个 第三个参数，就是delin。就是一个字符。这个字符称为分隔符 那第二个版本呢，他从输入流中读取bufsize减一个字符到缓冲区buf 或者说还没有读取这么多个字符，但是呢已经碰到了这个分隔符，那么这个读取也结束 反正这两个条件也是哪个先到算哪个 那主意这两个函数有共同点。就是他们都会自动会在buf中 读入的数据当中添加一个结尾的|0 而且这个输入流里面的|n或者这个分隔符都不会被读到buf里面去 虽然不会被读到buf里面去呢，这个|n或者这个 分隔符都会被从输入流中取走，也就是删掉 那如果在输入流里面的|n或者 分隔符之前字符个数达到或者超过了bufsize个 那这次能读入数据，但是实际上他也会产生出错。出错的结果是 影响了下一次的读入，也就是说虽然本次读入能够完成，数据也能读进来，但是之后你再去用 cin做仍和读取操作就都会失败了。注意是之后再用cin做仍和的读取操作 那我们 有时候经常就会用cin.getline一行一行的从输入流里面读取数据 然后怎么判断输入流是否结束呢，就可以用这个表达式 如果数据结束了，那么cin.getline它的返回值 也是false 再来看一些其他的istream类的重要成员函数 这一个eof我们可以用 这个cin.eof来判断输入流是不是已经结束了 istream还有一个peak，很好玩的一个 成员函数。它能够返回输入流里面的下一个字符，但这个字符呢并不会被从流中去掉 这个很有用因为有的时候我们想根据输入流中的下一个东西是个整数还是个字符串然后我希望根据这点不同我在程序里面如果发现是整数 我就cin一个整数，如果发现是一个字符串我就cin一个 这个字符串 但是问题是你不读取一个字符出来看一下它是一个数字还是一个字符你就不知道它是一个 整数还是字符串。那你如果从输入流里面读取了一个字符以后呢 你虽然能判断出他是一个整数还是一个字符串，但这个字符已经被你读取进来了。当你下一次再要 从输入流里面读取整数和字符串的时候呢就已经撒掉了头一个字符，那这个结果就不对了 所以有时候你会觉得哎呀多读了一个字符很麻烦 你只peek了这个成员函数 就提供给你了一个手段去看一下输入流里面的 下一个字符是什么然后再决定我下一步要适应一个整数还是适应一个字符串 这是好的。那 istream还有一个putback成员函数。它能把一个字符放回到输入流里面去。你读出来觉得后悔了还可以塞回去 当然你可以把仍和一个其他字符放入这个流里面也可以 这个字符就会被放到输入流的头部，最前面的地方 然后这个ignore ignore成员函数能够从流中删掉最多nCount个字符。就直接把这些字符从输入流里面去掉了 或者说 还没有删掉nCount个字符的时候就已经碰到了这个 ‘delim那这个ignore也就算完成任务了 那这个’delim它的值是eof。eof就代表这个输入流的结束 eof一般来说它的值是一。总之呢这个函数是用来 跳过输入流里面的一些这个字符的。这个getline是这个采用的一个 istream的成员函数。我们下面补充一个在使用getline的过程当中会经常碰到的一个问题 大家看这个程序。这个程序先读入一个整数x 然后用getline的办法读取一整行 我们假设我们这一整行不会超过90个字符，不会达到90个字符，然后把整行输入 这个程序在处理不同输入的情况下可能不会导致一些问题。我们看 如果我们输入12空格abcd，这个代表回车 代表回车，那这个时候输出的结果是空格abcd。这个 很好解释。这个12被读到了x里面，然后getline呢 就直接从12后面开始。他不会跳过去空格。连着空格一起 一直读到函末，所以把空格以及abcd读到buf里面去。那我们输出结果大概就是就是空格abcd 但是如果你输入那个，程序运行的时候你输入一个12敲个回车 你正打算输入第二行的时候这个程序他就突然结束了 它会输出一个12然后后面这个buf输出的是什么呢，看上去什么都没有 那为什么会程序就立即结束，还没有等你输第二行就结束了呢。这是因为 你又cin又x读了一个12以后 然后你又敲了回车。他这个回车实际上它是位于输入流里面的 它并不会由于执行了cin又一x而被读出来 那回车还在输入流里面的时候你再执行cin.getline 那我们知道这个getline它是碰到回车 就立即结束了对不对，那12后面跟了一个回车再执行getline的时候 cin马上碰到了回车于是getline结束了。那这个时候不会有仍和字符被读到buf里面去 你尽管getline语句并没有读取仍和数据到buf，getline依然回到了buf 里面添加一个杠零，等于就说buf的里面的 头一个字符就是杠零。那也就是说buf是一个空串。在这里输出的时候就是一个空的东西 不会输出一大堆乱七八糟的内容 那关于输入输出还有一点 需要知道的东西就是所谓的流超重算值。那这部分内容呢这边繁琐 讲起来又没意思又啰嗦，听起来也很无聊 还不如让大家自己看，所以这部分关于流超重算值的内容我们就只提供PPT，就不在 讲述了。大家自己回去 
