# [从C走进C++](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/2)
> C++是在C语言的基础上创建的一门功能更为强大的面向对象程序设计语言。在正式开始C++程序设计学习之初，我们首先回顾C语言中的高级内容，包括函数指针、命令行参数、位运算和动态内存分配，并在此基础上对C语言进行扩充，引入了引用、const关键字和常量、内联函数和重载函数、函数缺省参数等内容，为后续的C++程序设计的学习打下基础。面向对象的程序设计更接近于真实世界，它要分析待解决的问题中，有哪些类事物，每类事物都有哪些特点，不同的事物种类之间是什么关系，事物之间如何相互作用。本模块将初步介绍面向对象的程序设计的基本内容，尤其是“类”和“对象”这两个重要概念。PS：我们这门课程一直处在不断地建设与优化当中，吸取了很多以往课程的经典视频，所以如果你看到视频中出现了不同课程的名字，也不要惊讶哦，因为你正在集百家所长：）
## 1. 函数指针
- 同学们好，我是郭炜。 很高兴给大家上程序设计实习课，那今天呢，我也是第一次在家里边呢上课，感觉很休闲啊！ 那我也希望同学们也能够在休闲中，就把课听了，把东西都学会了。 不过在家里录课呢，可能偶尔大家会听见一两声狗叫，不要觉得奇怪啊。 那我们这门课主要内容是要讲C＋＋，但讲C++之前，我还是希望能够把C语言里面一些比较高级的内容再给大家重提一遍。如果你已经会了，就可以跳过不听。 

- 那我们首先要讲的就是这个函数指针。那指针大家都知道咯, 就是用来指向这个变量的地址的，对吧？但实际上呢，在这个程序运行期间，每一个函数，它也会占用一片连续的内存空间。 那每一个函数，它都会有一个起始地址。 那在C语言和C＋＋语言里面，我们可以把一个函数的起始地址赋值给一个指针， 那这样的一个指针就称为函数指针。 我们有了函数指针以后，我们就可以用来通过函数指针，调用它所指向的这个函数了。比方说这一个， 每一个函数体，都有一个起始地址。函数指针指向起始地址，通过函数指针， 就能调用它所指向的那一个函数。那在C语言里面，怎么定义一个函数指针呢？ 再来看下面这个写法。首先你当然要交代这个 指针变量的名字，对吧？然后呢，你还要交代，这个函数指针指向的函数， 它是什么样的。那一个函数是什么样的如何描述？ 当然就是这个函数的返回值是什么类型，以及这个函数，它有哪些参数。 所以，我们在定义函数指针的时候呢，我们要指出这个函数指针所指向的那个函数它的返回值的类型是什么。 然后我们还要指出，这个函数指针所指向的那个函数，它的参数表是什么样的。 这个就是函数指针的写法。具体的例子， 比方说，我们来一个 int(*pf)(int,char); 那么在这一条语句里面，我们就定义了一个函数指针，这个指针的名字叫pf。 那pf所指向的函数是什么样的呢？ pf所指向的函数它的返回值是int类型的。 然后这个函数它有两个参数，一个是int，一个是char，这样我们就完整定义了一个指针。 那接下来我们就要看看这个函数指针怎么来使用了。 就是我们可以用一个原型匹配的函数的名字，给一个函数指针进行赋值。 啊，把函数指针写在赋值号左边，一个原型，跟这个函数指针匹配的函数的名字，写在赋值号右边。 经过赋值以后，我们就可以通过函数指针调用它所指向的函数了。 那么调用的时候的具体的写法就是函数指针名，后面跟这个参数表，实参表，就可以了。看下面这个程序。 
    ```C++
    #include <stdio.h>

    void PrintMin(int a,int b)
    {
        if(a < b){
            printf("%d",a);
        }else{
            printf("%d",b);
        }
    }

    int main()
    {
        void (*pf)(int,int);
        int x = 4,y = 5;
        pf = PrintMin;
        pf(x,y);
        return 0;
    }
    ```
  我们有一个函数，叫PrintMin，它的返回值是void 的，然后它有两个整型参数。 这个函数，把两个参数里面相对较小的那个给打出来。 在main里面，我们定义了一个函数指针，它的名字叫pf。 在定义的时候我们说明了，这个函数指针所指向的函数它的返回值是void类型的。 这个函数呢，它有两个参数都是int类型的。那显然我们可以说PrintMin这个函数， 它和pf这个指针是匹配的，也就是说我们可以让pf指向PrintMin，对吧? 那接下来，我们就把PrintMin赋值给这个pf了。 然后我们就可以通过pf去调用pf所指向的那个函数。具体的写法就是这样。 因此说这条语句就调用了pf所指向的那个函数，也就是PrintMin。 那当然结果就是什么呢？打出x，y里面，较小的那一个。 啊，大家看。pf指向了PrintMin，啊， 这条赋值运算所产生的结果就是这样，然后我们就可以调用，pf所指向PrintMin函数，输出的结果呢，当然就是4。
- 那同学们可能就会问了，这个，我们要调用的函数，直接用它的名字就行了，干嘛要通过一个函数指针呢？ 这不是多此一举吗？实际上当然不是，函数指针是有大用处的。 比方说我们从C语言里面一个特别常用的库函数， qsort，就能够看出函数指针的必要性。qsort就是快速排序的这个函数。 这个，快速排序的库函数qsort，它能够对任意类型的数组进行排序。就是不管你这个数组里面的元素是什么类型，都可以用qsort这个库函数来对这个数组进行排序。我们注意到这个qsort，它有一些参数， base, elem, 等等啊。 它有比较情况奇怪的一个参数就是这个pfCompare， 啊，看上去很复杂。那你学过了函数指针，你会知道，这个参数实际上是什么呀？ 实际上是一个函数指针。这个参数的名字叫做pfCompare， 然后这个函数指针所指向的函数是什么样的呢？ 啊，pfCompare所指向的函数应该是返回值类型为int。 然后这个函数呢，应该有两个参数，这两个参数的类型都是这个const void* 。 那至于这个const嘛，后面还会讲，现在如果你不理解，你就假装没看见，就把参数类型就当作void* 好了。 就这样一个qsort能够对任意类型的数组进行排序。
- 啊，如果你想让别人把你对一个数组进行排序，你得告诉别人有关这个数组的一些信息。 啊，那你要提供哪些信息呢？
  - 首先，我们肯定要让别人知道这个数组的起始地址。 你都不知道数组放在哪儿，那你还排什么呢？ 
  - 第二点，你得让人家知道这个数组里面一共有多少个元素。 
  - 第三点，你还得要告诉别人，这个数组里面，每一个元素的大小。   
  - 啊，知道了每一个元素的大小，又知道了数组的起始地址，那当然，就可以算出来每一个数组元素都放在什么地方。 啊，数组排序是需要把数组元素找到、比较、然后交换位置。 
  - 然后，最后一点很重要，就是你还得告诉别人用什么规则来决定两个元素到底哪一个在前，哪一个在后?
- 所以我们调用qsort函数的时候，实际上我们得向qsort的函数提供下面4条信息， 那qsort才能对这个类型任意的这个数组进行排序。 也就是说qsort的第一个参数 base，实际上它就是指明了这个 数组的这个起始地址。啊，我们调用qsort的时候，可以把数组的名字写在这儿。 第二个参数nelem，实际上代表的就是数组元素的个数。 第三个参数width，实际上说的就是这个数组 元素到底有多大。啊，每一个有多少个字节。 那最后一个参数，pfCompare， 啊，最后一个参数pfCompare，它是一个函数指针。那这个函数指针呢， 它实际上会指向一个比较函数。这个比较函数的作用， 就是告诉qsort，如何去判定两个元素，到底哪一个应该排在前面， 哪一个应该排在后面。啊，所以pfCompare指向比较函数的地址。 这个比较函数呢，是程序员自己编写的。它必须遵循这样一种格式， 就是说它的返回值一定是这个int，然后它必须有两个类型为const void* 这样的参数。 大家知道，排序的过程，实际上就是在不断地比较数组元素，并且交换它们的位置，这样一个过程。 那qsort的函数在执行期间呢，它要比较两个数组元素的时候， 就会通过pfCompare这个指针，去调用 程序员自己编写的比较函数。那调用比较函数的时候呢， 会把待比较的两个元素的地址，作为参数，传递给比较函数。 然后qsort根据比较函数的执行结果，也就是那个返回值， 来判断待比较的两个元素，到底哪个应该在前，哪个应该在后。 就假设这个qsort的执行期间要比较a[0] 和 a[1]这两个元素,那么qsort就会 通过pfCompare， 去调用比较函数，并且调用比较函数的时候呢，以e1和e2， 也就是a[0] 和a[1]的地址作为参数。到了比较函数这儿呢， 比较函数的第一个参数elem1，就会指向a[0]，elem2就会指向a[1]。 那如果你要让qsort，根据这个函数的执行结果， 就能判断，到底* elem1在前面，还是* elem2在前面。 那么比较函数的编写就必须遵循一个规则。这个规则就是 如果，* elem1应该排在* elem2的前面， 那在这个时候，函数的返回值就应该是一个负的整数。 也就是说qsort看到，唉， 比较函数返回值是个负整数了，那它就认为第一个元素，待比较的第一个元素应该在前，待比较的第二个元素应该在后。 那如果* elem1和* elem2哪个排在前面都行，那么比较函数的返回值就应该是0。 如果* elem1应该排在* elem2的后面，那这个时候 比较函数的返回值就应该是一个正整数。 下面我们看一个具体的实例。这个实例呢，它的功能就是 调用qsort的库函数，把一个unsigned int数组按照个位数从小到大进行排序。 那，比方说8，23，15，这三个数，按照个位数从小到大排序， 结果就应该是23，15，8。 
    ```C++
    #include <stdio.h>
    #include <stdlib.h>
    #define NUM 5
    int MyCompare(const void *elem1,const void *elem2)
    {
        unsigned int *p1,*p2;
        p1 = (unsigned int*)elem1;      //" *elem1 "非法
        p2 = (unsigned int*)elem2;      //" *elem2 "非法    
        return (*p1%10) - (*p2%10);    
    }

    int main()
    {
        unsigned int an[NUM] = {8,123,11,10,4};
        qsort(an,NUM,sizeof(unsigned int),MyCompare);
        for(int i = 0;i < NUM;i++)
            printf("%d",an[i]);         //输出结果：10 11 123 4 8
        return 0;
    }
    ```
  在这个程序里面，首先我们需要编写一个比较函数，叫做 MyCompare。我们看到，它的返回值是int，然后它有两个参数都是const void* 类型的。 那我们在这里elem1和elem2自然就指向了待比较的 两个元素。那我们在这个MyCompare里面就应该把这两个元素取出来进行比较，对吧？问题是 你写* elem1这样的做法呢，它是编译不过的。因为， elem1 是void* 的这种指针，那你写一个* elem1的话， 编译器不知道elem1指向的那一个元素到底是多少个字节，因为它是void* 类型的，所以编译器不知道elem1指向的元素是多少个字节。那你写* elem1， 编译器就不知道这个东西，到底是多大，所以它是非法的。但是我们作为程序员，我们心里知道是， * elem1指向的东西，是一个unsigned int类型的这个 元素。所以我们需要对elem1进行强制类型转换， 把它强制转换成一个unsigned int* 的指针，再赋值给一个p1，p1是一个unsigned int* 类型的。 那接下来我们通过* p1就能够取得elem1所指向的 那个元素了。所以对于这个elem2当然我们也是同样处理。 总之我们通过* p1，*p2就能够拿到待比较的两个元素。 接下来我们就要关注一下这个返回值。那谁的 个位数小，谁就应该排在前面，那当然我们返回值就是写两个 待比较元素个位数的差是什么，对吧？那么个位数小的， 小的个位数减去大的个位数，值是负数，那么就说明，个位数小的应该排在前面。 接下来我们在main函数里面来看看， MyCompare比较函数如何起作用。在这里我们调用了 qsort。第一个参数就是待排序数组的地址。 第二个参数是元素个数，第三个参数是每一个元素占的字节数。 那第四个参数本来应该是一个函数指针，那我们知道，函数的名字跟函数指针它的类型是匹配的， 所以我们在这里放一个函数的名字，MyCompare。这个MyCompare， 函数的形式，正好跟qsort的第四个参数， 那个函数指针所指向的函数，它的形式是一致的，所以在这里是没有问题的。 于是， qsort在执行期间，通过这个第四个参数，就能够找到MyCompare 这个函数，来进行元素的比较。呃，所以这个程序输出的结果就是把 这个an按照个位数从小到大排序，结果就是10，11，123，4，8。那么大家看到， 函数指针还是挺有用的吧！ 
## 2. 命令行参数
- 接下来我们说点简单的东西，轻松一下。 就是这个命令行参数。要说到它，是因为我们在后续的作业里面会用到。 大家知道我们在Windows里面运行一个程序，就是双击它的图标，啊，实际上还有另外一种运行程序的方式， 叫做以命令行方式运行程序。当然在Linux里面也是有的啊。 这种方式在Windows里面的做法就是按一下这个， 同时按住Windows键和R键，那么就会弹出下面这样一个窗口。然后，我们直接在这里面敲comand， 啊，c，m，d，点确定。然后呢，就会弹出下面这样一个黑窗口。啊，这个黑窗口，我们就 称之为命令行窗口。然后在这个黑窗口里面呢，我们就可以命令行方式来运行程序。

- 具体做法，比方说我们 在这敲notepad sample.txt。这时候，我们要运行的就是notepad这个程序。 notepad这个程序就是记事本了。我们这么一敲的话，如果你当前文件夹里面真的有sample.txt， 结果呢，就会变这样。就是notepad这个应用程序 就会启动，并且打开了sample. txt这个文件。 这时候我们就看到啊，我们在命令行敲了notepad sample.txt， 那么notepad这个应用程序在启动的时候，它显然是知道用户想要打开sample.txt这个程序的，对吧。所以它就打开了这个文件。 那notepad它是如何得知用户在以命令行方式运行程序的时候，在它后面敲进去的这个文字呢？啊，那么这串文字我们就可以称之为命令行参数。 就是用户在CMD窗口，就是那个黑窗口， 输入可执行文件名的方式启动程序的时候，啊，跟在可执行文件名后面，还可以有若干个字符串。 这些个字符串呢，统称为命令行参数。 那命令行参数可以有多个，用空格分离。比方说我们在这个命令行窗口上敲 copy file1.txt file2.txt。这实际上是启动了copy这个程序，它能够把fiel1拷贝到file2里面去。 那在这样一个命令行里面，copy， 呃，copy，还有这个file1.txt ， file2.txt，都是命令行的参数。 

- 那我们这个，假设你自己编写一个copy程序。那你编写的这个copy程序里面， 就应该要能够获得这些命令行的参数，对吧。怎么样能获得这个参数呢？ 啊，我们要求。 想获得命令行参数的这个C程序，或者C++程序，它的main函数的形式需要改一下。啊，变成 下面这种形式，啊，就多了两个参数。那这个参数呢，argc， 这个参数它是整型的，它代表启动程序时， 命令行参数的个数。那注意，这个个数呢，它是包含这个程序的， 呃，本身的这个文件名的，比方说那个notepad，或者是什么copy，它都包含， 它是包含这个程序的名称的。那所以argc的值至少就是1，啊。 然后，我们再看第二个参数，argv。argv呢，它是一个指针数组。 它是，这边写着char型，然后后边有一个子数组嘛，所以它是一个指针数组。 那这个它的类型准确的说也可以说是char* 类型，啊。 这，那argv是一个指针数组，这指针数组里面每一个元素都，当然都是一个char* 类型的这个指针。 那在这个程序启动的时候，这个操作系统就已经把用户在 命令行敲进去的那些参数，存在了某个地方了。那程序启动的时候呢，main函数的这两个参数 是谁给的呢？是操作系统给的。啊。操作系统通过argc告诉你这个程序一共有多少个 命令行参数。操作系统把所有的命令行的一些字符串都存在某个地方。然后呢，操作系统传进来一个 argv这个数组。在这个数组里面，每一个元素都分别指向一个 命令行的参数，也就是一个字符串。比方说，这个argv[0]就指向 第一个命令行参数，啊它是一个字符串，那当然就是可执行程序的文件名了，就是argv[0]。 那argv[1]呢指向第二个命令行参数，也是一个字符串。以此类推。 所以我们看一个例子程序。
    ```C++
    #include <stdio.h>
 
    int main(int argc,char *argv[])
    {
        for(int i = 0;i < argc;i++)
            printf("%s\n",argv[i]);
        return 0;
    }
    ```
  在这个例子程序里面， main函数是这种形式的。 然后我们通过一个循环，遍历哪个数组啊，遍历argv这个数组。 然后把argv数组里面的每个元素，argv[i]是个什么啊，是个char* 类型 的指针，对吧。char*类型的指针，它指向一个字符串。那我们用这条语句就能够把 这个字符串给它拿出来。那么，那么， 这个循环实际上就遍历了argv这个数组。这个数组里面有多少个元素啊，有argc这么多个元素。 这个循环遍历了这个argv数组，把数组里面 每一个元素所指向的字符串都打出来。那每一个元素所指向的字符串就是一个命令行参数。 所以，这样一个程序，如果你把它编译成sample.exe，exe，然后你在控制台，也就是那个黑窗口里面敲 sample para1 para2 s.txt 5 “hello world"，啊，你敲这样一大串东西。 那大家看看这一大串东西里面有多少个命令行参数啊？你数一下，就是 一、二、三、四，s.txt是一个啊，六，六个命令行参数。 那这时候程序执行的时候，argc的值当然就是6了。 然后这个循环把每个命令行参数都打出来了，所以程序输出结果就是sample，para1，para2， s.txt，hello world。就把每一个命令行参数都给打出来了。那这个命令行参数呢，它本身是用空格来分隔的。 如果一个命令行参数内部就有空格，怎么办呢？ 那答案也很简单，就是我们用引号给它括起来就行了。 
## 3. 位运算
- 接下来呢我们来说说位运算， 有时候我们想要对这个一个整数类型的变量，比如说int, char,long之类的这样的变量我们想对其中的某一些位进行操作。 比方说我们想判断一个整数变量它中间的某一位是否为1， 或者我们想只修改一个整数变量中间的某一位，而保留其他的位都不变， 那这样的事情，如果没有位运算的话，做起来是很困难的。那还好呢，c和c++语言提供了六种位运算，每一种位运算用一个不同的操作的符来完成。这六种位运算呢是按位与，是双目的。 按位或，按位异或， 按位非，这个按位非是单目的。非就是取反的意思。 还有左移，右移。下面呢我们来分别看看这六种位运算 怎么做的。
- 先说这个按位与， 按位与呢它的规则就是，把参与运算的两个操作数跟各对应的二进制位进行与操作。 与操作的特点就是说，两个1进行与，结果就是1. 除此之外，1和0与，或者0和0与，结果都是0. 比方说，这个表达式，21与上18 它的值呢就是16。为什么是16呢？我们把21、 18都用二进制表示。21前面一大堆0，最后这八位是0001 0101。18的二进制表示形式就是这样，我们也是关注最后的几个八位。那执行这个与操作，我们说做的是按位与，那就是说1和0进行与的结果呢，就是0。然后0和1与的结果也是0。然后0和0当然与的结果也是0了，然后这个1和1与的结果呢 就是1。剩下的个位全部都是0了。 那也就是说21和18与出来的结果就是这个东西。 这个东西是多少呢？当然就是这个16。 那按位与它有什么作用呢？我们通常用这个按位与操作来把一个变量里面的某些位清0 而且在这个同时呢，还能保留其他位不变。此外我们也可以用与操作来做到获取变量中的某一位。你想知道一个变量里面的中间的某一位是1还是0，你可以用与操作来完成。 那我们先看这个， 如果需要将int型的变量n的低八位全部置成0，而其他位不变，我们可以怎么做啊？ 我们可以做这样一个事情。n等于n与上一个常数，这个常数是，用符号的常数是0x然后6个f两个0 那我们就要先看这个常数。这个常数它有什么特点啊？这个常数它的低八位全部都是0，就是最右边的八位全部都是0，对吧？然后它的高24位全部都是1。 那我们把n与上加一个常数，结果会是什么样的呢？我们考虑 n的低八位和这个常数的低八位进行与操作， 因为这个常数的低八位都是0，所以与出来的结果低八位肯定就是0，就是这个，这个表达式的值，它的低八位肯定就是0。然后这个n的高24位要跟24个1进行与操作。 那我们知道1跟1与起来就是1，0跟1与起来就是0。那也就说一个位a，它跟1进行与操作结果仍然是a。 所以说这个表达式算出来的结果，它的高24位呢应该跟n的高24位呢 是一致的。那我们看看把这个表达式的值赋值给n，实际上就做到什么呀，把变量n的低八位全部变成0，高的24位呢保持不变。 那这样一个式子有更简练的写法就是n与等于0x六个f两个0 这个与等于实际上它的性质就跟什么加的减的是差不多的，它会修改n的值。 那注意，如果这个n是short类型的， 那short类型只有16个位码，那这个时候我们要使n的低八位变成0，剩下的全部维持不变的话，那我们就这么写就行了。 就是n与等于0xff00 这个常数呢只需要是一个16位的就行了 那如果我们想要判断一个int类型变量n的第七位，这个第七位指的是从右往左，从0开始数的 我们要判断这个第七位到底是1还是0，该怎么办呢？ 实际上我们只需要看表达式 n与上0x80它的值还是不是等于0x80就可以了。 为什么啊？我们把0x80二进制形式写出来是这样，它的高24个0我就不写了。 总之0x80这个常量里面呢，只有 第七位是1，其他位全部都是0，对吧？ 那么我们让n与上0x80这个表达式结果会是怎么样啊？ 这个表达式的结果肯定，除了第七位有可能是1以外，其他所有的位都是0 那第七位到底是1还是0跟什么有关系呢？当然它只跟n的第七位 是1还是0有关系。如果n的第七位是1，那么n与上0x80 它的第七位也是1；如果n的第七位是0，n与上0x80它的第七位也是0 所以说我们就判断一下n与上0x80它的值 如果是等于0x80那就说明什么？说明原来n的第七位就是1， 如果这个表达式的值不是0x80，那说明原来n的第七位的值就是0。
- 接下来呢我们看按位或这个操作。 那按位或它实际上就把两个操作数的各个对应的 二进制位进行或操作，那或操作的规则是什么啊？就是1和0 或起来结果就是1，两个1或起来结果也是1，然后两个0或起来结果就是0. 只要两个操作数里面只要有一个是1，或的结果就是1 那我们看21或上18这个表达式的值是什么？是23， 那为什么是23呢？我们把21的二进制形式和18的二进制形式都写出来， 然后我们来进行按位或的操作。这个1或上0，结果当然就是1.然后这个0或上1， 结果也是1。然后这个1,0也一样的。然后这边0或上0，结果是0 1或上1，结果是1 然后21或上18，结果就是这一大串数字。这一大串数字实际上就是什么？ 就是23。这就是或运算。 那或运算的作用呢就是 通常我们用它来做什么？ 用来将某变量中的某些位置1且保留其他位置不变。 前面学的那个与运算可以用来把某个变量中的某些位 清0，也就变成0，然后保留其他位不变。那或运算呢是用来把变量中的某些位置成1，然后保留其他位不变 比方说我要把int类型变量n的低八位全部置成1， 而其余位保留不变，那我可以做什么？我们可以让n或等于0xff 那我们知道0xff它是低八位全是1， 其他部位全是0，那我们把这个数或到n上去以后呢 这会改变n的值对吧？那n的值的这个 n的值经过和0xff 进行或运算以后，它的低八位肯定就会变成1了对吧？ 因为任何一个数或上1的话结果还是1，所以不管 n的低八位是什么，跟0xff一或的话，低八位全部都变成1了。 那么这个进行或操作以后，n的高24位变成什么样了呢？ n的高24位是跟24个0进行或操作， 那我们说a或上0它的结果是什么啊？ 就是a对吧？1或上0等于0或上0等于0，所以a或上 0它的结果就是a。因此我们让n的24位， 高24位跟24个0进行或操作，结果当然n的高24位就会保留不变。 
- 再来看看这个按位异或，这个位的异或它的特点就是两个操作数，只有在这个不相同的时候，结果才会是1。 两个操作数如果相同，结果就会是0。这就是异或。 异或就是不相同的时候才是1，相同的时候就是0 我们看到21异或18它的值是多少呢？是7，就是二进位数111。为什么是7呢？ 我们21写出来在这儿，18也写出来了。21,18，那我们进行异或，按位异或。 1和0异或，这两个不相同，所以结果就是1嘛。 然后0和1异或，结果也是1,1和0异或成1。 然后0和0异或，这两个操作是相同的，那结果就是0 1和1异或，结果也是0，因为它们相同的。 所以21异或18结果就是这样一个东西，那就是 7。**按位异或我们可以用它来把将某个变量中的某些位取反 然后保留其他位不变**。比如说我们要把这个int类型变量的n低八位 取反而其他位不变，怎么办呢？我们只需要让n异或等于 0xff就行了。为什么呢？我们看这个 1跟1异或，结果是0，0跟1异或，结果是1，对吧？就说正好反过来了。 那可以想象，这个0xff低8位全是1，那我们，那跟异或等于0xff， 就是拿n的低8位跟1，和八个1去异或， 那当然结果就使得n的低8位反过来了，对吧。那 那一个a异或上0，结果会是什么呢？ 呃，结果还是a，是不变的，啊，1异或上0，结果是1，0异或上0， 结果是0，是吧， 那么n的高24位都是跟0再来异或，那也就是说n的高24位都会保持不变。抑或运算有一个特点啊，很重要，就是a异或b等于c， 那么就会有c异或b等于a以及c异或a等于b， 那怎么证明它呢？那很简单了，就是我们穷举a和b 所有可能的取值，就4种情况，对吧，1,0,0,1,一共四种情况， 把这四种情况都穷举了，你就能证明出这条了啊。这个是有这个规律，那这个规律呢我们可以用它来进行最简单的 这个数据加密和揭秘，那么比如说a是要加密的这个 数据啊，它是原文，我们可以用b作这个秘钥，那a异或上b呢， 就生成了一个密文c，啊，那，那如果从这个密文c解出这个原文a呢？ 那你手头如果有这个秘钥b那么你就直接拿 c异或上这个秘钥b不就算出a了吗？这就是最最简单的一种 加密这个方法， 另外异或运算还有个很好玩的特点，就是它 通过异或运算啊，我们就可以实现不通过临时变量就能 交换两个变量的值，哎，是不是有点神奇啊，那么看这个例子，那么a等于，b等于7，我们让a=a^b， 然后再让b=b^a，然后再让a=a^b，结果你会发现，啊，a变成了7，b变成了5， 就a，b呢就交换了。 那这个为什么能实现这样一个效果呢？ 实际上你也可以证明，证明也知道那就是用穷举法，你就穷举a和b的这个所有可能的情况，就是a要么， a和b，有的是0有的是1，一共有4种情况，对吧，因为两个整型变量进行异或，它们是按位异或的。 某两位异或的结果跟其他位是没有关系的，所有我们要 证明这个一个这一大串代码 能够把a,b的值交换，实际上我们就把a和b都看做单个的位，然后穷举一下它们所有可能的组合，发现是对的， 哎这就证明出来了。
- 呃，再接下来看这个按位非， 波浪线这个运算符。非呢是单目运算符，它是能够把操作步骤中的二进制 位0变成1，然后1变成0，就是取反。 比方说，这个表达式~21 它的值是什么东西呢？呃，是一个整型数，如果你把它看做一个ii整型数的话写出来就是这样一个东西， 啊，为什么呢？我们看21写出来 是这一大串，对吧，然后~21么，就是把它 21里面的每一个二进制位都取反，那取反就是0变成1,1变成0 那然后呢，就产生这样的一个结果对吧，1变成0,0变成1 啊。这个 1110嘛就是e，1010就是a， 这样。
- 再看这个左移运算符，啊， 左移运算符如何起作用呢？我们看这个表达式a << b， 那这个时候要求a和b都是整数类型的，那这个表达式a << b的值是什么啊？ 就是把a的各个二进制位全部左移b位以后 得到的值，b是一个整数，那，那，就说相当于把一个把a里面的二进制位 整体的往左边移动b位，那肯定有一些 高位就会被移出去了对吧，那， 然后呢，低位就空了，那这个时候怎么处理呢，那高位就直接丢弃了，低位呢，就从右边补进来的就是0， 当然这个表达式呢它肯定不会去修改a的值， 那我们来看这个，比如说这个9<<4，啊， 这个表达式的值算出来是什么呢，那我们就把9的二进制写出来， 是这一大串啊，实际上就是这1001吧， 那我们把这上面一大串的二进制位整体都左移四位，变成什么样了呢？ 呃，就变成这样了，这个1001就跑到，跑到这来了，是吧，那这时候右边 空出的四位用什么来填补呢？用4个0来进行填补啊， 那这一串东西就是十进制的144，啊，所以9<<4它的结果就是这个144. 那要注意的就是 实际上啊，我们把一个数左移一位，实际上就等于把这个数乘以2了，对吧， 那左移n位，当然就等于乘以2的n次方， 那要注意的一点就是这个左移操作啊，比这个乘法操作速度要快得多， 所以如果你要做的乘法操作是乘以2的整数次幂的话， 那你不妨用左移来实现，会比作乘法快很多很多。 
- 再来看看这个右移运算啊，它的运算符是两个大于号， 那这个a >> b，它的值是什么呢？就是把a的各个二进制位全部右移b位后得到的值。 那右移的时候，移出最后边的那些位直接就丢掉了。 那就是左边空出来的位用什么来填补呢？ 这个很有一定的讲究，嗯，比如对于有符号的数啊， 比如说log, int, short, char这一类有符号的数，那在右移的时候，符号位 也就是那个最高位会一起向右移动，并且呢，在这个大多数C和C++编译器里面啊， 它这样处理右移的，就是如果原来的那个符号位为1，那右移的时候，右边， 啊，左边补充进来的那个高位就都是1， 如果这个被右移的数它的符号位是0， 那么右移的时候，左边补充出来的那些位就都是0. 大多数编译器都是这么规定的。 那实际上你把一个整数右移n位，就相当于把这个整数呢除以2的n次方，啊，这个跟左移的情况有点类似。 但这里面除的话有可能除不尽，所以这个右移的情况算出来的结果呢是往小里取整，那我们看比方说负的25右移4位，呃， 就相当于把-25除以2的4次方，也就是16， 那-25除以16应该是负的一点多，对吧，那这时候我们要往小里面取整，你把它取整变成-1就是往大里取整了，那我们往小里面取整就是把它变成-2，啊，所以这个这是一个规律啊，不是规定，你最后，你自己去算一下算出来的结果它就是 -2，啊，它是规律不是规定。这要，那总体我们把这个负二右移四位，来算它的结果呢，往小里取整，结果就是-1。 啊，因为右移四位是除以16它算出来是零点几。 负的零点几，往小里取整就变成-1. 下面我们看一个具体的这个位运算的左移右移的这个程序。在这个程序里面我们看，n1它的值是15， n2呢是个short类型的，啊，它是一个负数，负的15，然后这个n3是一个unsinged short，是无符号的数， 它的值是0xffe0， 这个n1和n2都是有符号的，啊，char c=15， char,char c那c它自然也是有符号的，嗯，然后我们要做的事情是等于是把n1右移了两位，然后把n2右移三位，把n3右移4位， 然后c右移三位，然后我们把这些结果都给它打出来，啊，把修改以后的结果也打出来， 那这个程序它的输出结果会是这样的就是 n1=3,n2=ffffffffe,就是六个，七个f，一个e n3=ffe,c=1为什么会是这样呢？ 我们来分析一下啊，注意，这是他们的初始值，在这，也就是说n1一开始是什么啊，是，是第四位为1，其他都是0是吧， 就是这个是15，就是这样的，那 n1>>=2，就是把n1整体往右移两位， 它变成什么呀？自然就变成3，这个4个1，右移以后丢了两个1， 啊，还有两个1在这边，当然这边的高位补进来的是什么啊， 是0，为什么是0呢？因为按照我们前面说的规则，对于有符号的数补进来的实际上就是那个符号位，那这里符号位是0，那补进来的就是0. 好了，我们看这个n2， n2它的初始值是什么啊，是-15，是吧，-15表示成二进制的形式就是这样的， 那关于这个负数的二进制表示形式呢我们专门有一个PPT可以大家下载回去看啊，这个也不属于C++的内容，所以就，不仔细说了。 总之吧，这个n2它的符号，它是一个负数所以它的符号位是1，它的二进制表示形式是这样对吧？ 那我们把n2给它右移三位，那变成什么样呢？那变成这个东西，就是我们看到这个4个1 啊，跑到了这块来，啊，就是，就是，从这个一开始到， 到，到这，这4个，然后 左边补进来的是什么呢？左边补进来的是符号位嘛，补进来的全部都是符号位，那也是说，左边补进来的全部都是1 ，就左边补进来3个1，那就变成这样一个东西，啊，这个，这个东西，你把它写成十六进制当然 就是，啊，啊，7个F，1个e，啊，就是 -2，我们再看n3，n3注意了，它是， unsigned short，它是无符号的， 短整数，啊，它的二进制形式写起来就是这样， 啊，那我们把这个n3右移四位，按照前面说的规则，无符号， 的数，啊，右移的时候，这个高位，就是左边， 补进来的总是0，所以说，你把这个n3右移四位， 的话，啊，空出来的四位，对吧，空出来的四位补进来的全都是0，然后这四个0被丢弃，那就成了这样一个， 结果，啊，就是ffe，十六进制就是ffe， 然后再看c，c它的值是， 15，啊，那c的值写起来，二进制形式，就是0000 1111，啊，那我们把c ，!!!,给它右移3位，那变成什么呢， 啊，它是有符号数，但是它的符号位是0，所以补进来的高位就是， 3,3个0，因此最后结果， 就是，就这样一个东西，就是，就是吗，就是1，
- 来看一个思考题，啊，这个思考题用， 位运算来解决，就有两个整型变量a 和n，啊，n是0到31 之间的，要求你写一个表达式，啊，使得这个表达式的值呢 ，和a的第n位相同，啊，实际上就是，让你用很方便 的方法，判断n的，a的第n位是0，还是1，那我会马上公布答案，但是希望大家在这里，按一下 暂停，想一想， 然后再看答案，啊，那解法就是这样一个表达式，a 左移，啊，a右移n位的结果，再&1，啊， 为什么这样一个表达式，它的值就和a的第n位相同 呢，那我们来看看， 假设a是这样的，啊，它的符号位，最高位是b31 ,然后它的第n位在这，啊，这是最右边的那 位，是第0位，那么，这个a右移n变成， 什么样了呢？啊，a右移n，把a全部右移n位，那当然这个， bn，就是这个第n位，就跑到了， 最右边，对吧，然后左边可以补进来一些符号位，中间变成什么样子，我们实际上都不关心， 不管它，再看这个a右移n的结果， 再&1，那1是一个什么东西啊，1是最右边为1， 其他31位全都为0的一个参数，那这样一个， 东西跟上面这个a右移n的结果，进行&操作， 那当然&操作的结果就是，左边的31位全部都变成0了，啊，因为左边31位都是跟， 0进行&操作吗，然后，啊，然后最右边的那一位，它是跟1进行&操作，所以它的结果， 依然是这个bn, 这个bn是什么？原来在这，这bn呢就是， a的第n位，那我们看到整个表达式的值， 是一个什么样的数啊，是一个左31位全都为，为0，右边的， 那一位，最右边的那一位，跟a的第n位相同的，这样一个数， 啊，那这个表达式的结果，它要么是0，要么是1，当然， 它就是跟a的第n位是相同的， 对吧，就这个bn，那实际上这个题呢，在这个n的值不会是31的情况下，还有另外一种解法，就是这样的，啊，我们来分析一下， 这种解法，就是说，它首先把1，啊，左移了n位，那得到的是一个 什么样的数呢？就是，除了第n位是1，其他所有位都为0， 的这样一个数，然后把这样一个数跟a进行&操作，会得到一个什么样的 数呢？仍然就是，除了第n位是a的第n位，其他所有位都为0， 的这样一个数，啊，然后我们再把这整个的一样，一个数呢，再右移n位，产生的效果是， 什么，啊，就是，整个的结果就是最右边的那一位，就等于， a的第n位，然后其他所有的位， 都是0，啊，那这样的一个整个表达式的结果，当然就是跟a的第n位 相同了，那这里面为什么说，n的值不能是31啊，因为n的值如果是31的话，我们看到 这个表达式，产生的结果是一个第31位 为1的一个，一个数，对吧，然后你把这个数跟a进行这个 啊，&操作 &出来的结果呢，它的第31位，也是有可能是1的，那这时候就成， 了符号位是1了，符号位是1，你在进行右移操作，有可能右边，左边补进来是符号位，那整个结果就不会说，啊，左边全部都是0了，这样就会出问题了，总之，这个位运算是很重要的，它的速度非常快，啊，能够很好的 提高你的程序的这个效率，就是，我当过ACM竞赛的这个教练，看到一些很牛的学生 他们的代码，啊，虽然他的算法是不正确的，不能够 在这个，啊，有效的时间算出答案，但是由于他 采用了位运算进行了优化，所以使得他程序的运算的速度，提高了很快，使得这个程序 即便不对，最后交上去，也不会超时，也能够混过去。 
## 4. 引用
- C++对C语言有很多功能上的扩展呐， 大部分扩展呢都是为了实现面向对象的这种机制。 那也有一些扩展呢，它跟面向对象的关系不太大，而且这些扩展呢也比较简单。所以我们可以先学一点这部分的内容。 那我们第一个要讲的概念呢是引用。 下面的这个写法它就定义了一个引用，类型名&引用名等于某个变量名， 这条语句定义了一个引用，并且把它初始化成引用某个变量， 具体的例子在这。  int &r = n， 这个时候呢，r就是一个引用，它引用了n，r的类型是什么呢？ 是int &，注意是int &， r引用了n，那到底是什么意思呢？ 啊，我们说某一个变量的引用它就等价于这个变量， 它相当于这个变量的一个别名， 也就是说，如果我引用了你，那我跟你就是一回事了。那我打自己一耳光，你会觉得脸上疼。 你要是吃到了好吃的东西，我也会觉得很香。是等价的。看这个例子。
    ```C++
    int n = 7;
    int &r = n;
    r =4;
    cout << r;      //输出4
    cout << n;      //输出4
    n = 5;
    cout << r;
    ```
  我们让r引用了n， 然后我们对r进行赋值。然后我们把r的值给它输出， 那毫无悬念，当然就是4对吧，那么输出n的值，这个时候应该是多少呢？ 注意，我们已经说了，r引用了n，r跟n就是一回事了，那我们前面对r进行了赋值， 也会改变n的值。所以这条语句输出的结果就是4. 接下来我们对n进行了赋值，然后再输出r， 那么r数出来应该是多少啊？ 很显然，n跟r是一回事，n改了，r也该了，所以输出结果就是5. 
- 那我们使用引用的时候，有三条需要注意的地方，
  - 第一点，我们定义引用的时候，一定要将其初始化成引用某个变量。 啊，你只能让它初始化成引用某一个变量，它不能引用别的一些东西。 
  - 第二条，就这个引用一旦初始化以后啊，它就一直引用那个初始化的变量，它不会再引用别的变量了。也就是说这个引用它是从一而终的。 要注意了。
  - 第三条，就是引用， 它只能引用变量，不能引用常量和表达式。 
- 我们再看下面一个例子。 
    ```C++
    double a = 4,b =5;
    double &r1 = a;
    double &r2 = r1;        //r2也引用a
    r2 = 10;
    cout << a << endl;      //输出10
    r1 = b;                 //r1并没有引用b
    cout << a << endl;      //输出5
    ```
  啊，在这个例子里面，我们让r1引用了a， 然后呢，r2又被初始化成r1， 那么实际上这个时候r2它也引用了这个a， 然后我们对r2进行赋值，这个时候我们会影响到谁呢？ 我知道了，r2和r1都引用了a，那你对r2进行赋值， 当然也就会影响到a，所以我们输出a的时候结果是多少呢？ 是10。然后，我们再将r1等于b， 这个时候是否r1就变成了引用了b呢？ 不是，对吧，前面说了。引用是从一而终的。 那r1一开始它引用了a，它后面就一直引用a了。 你让r1等于b，它的含义并不是r1去引用了b， 而是用b对r1进行赋值。 也就是说，r1以及r1所引用的东西， 它的值都变成跟b相等了。 那r1引用了谁啊？r1引用了a，所以我们在下面输出a的时候，我们会发现a的值跟b是相等的。 b是5对吧？所以输出的值就是5. 这既是引用的概念。 
- 下面我们看一个比较有说服力的例子，能够说明引用是比较好用的。 我们考虑在C语言里面，我们如何编写交换两个整形变量的值的函数呢？ 我们能否这样编写呢？
    ```C++
    /*方式一*/
    void swap(int a,int b)
    {
        int tmp;
        tmp = a;
        a = b;
        b = tmp;
    }
    int n1,n2;
    swap(n1,n2);        //n1,n2的值不会被交换

    /*方式二*/
    void swap(int *a,int *b)
    {
        int tmp;
        tmp = *a;
        *a = *b;
        *b = tmp;        
    }
    int n1,n2;
    swap(&n1,&n2);      //n1,n2的值被交换
    ```
  啊，swap( int a, int b)，啊， 然后在这里面交换a和b的值，接下来我们有两个n1和n2变量的值需要交换，我们调用swap(n1, n2) 这时候大家，我想大家是知道的，n1和n2的值并不会因为调用了这条函数而被改变，对吧？ 为什么呢？因为我们 C语言里面学过，a,b是形参，n1,n2是实参， 在这个函数里面，形参的值修改了，它不会影响到实参n1,n2对吧。 那好了如果在C语言里面我们就是要写一个swap函数它能交换n1,n2的值，该怎么办呢？回忆一下。 我们写swap，然后两个参数是指针，啊， 然后在这里面我们对这里两个指针所指向的内容进行了交换， 然后我们调用swap的时候，哎，这个参数不再是n1和n2了，而是& n1和& n2 也就是说，这时候参数变成了n1和n2的地址。 在这种情况下，我们知道，这个swap函数执行完以后n1和n2的值确实是会被修改的。 但这一一个函数以及它调用的方式看上去都比较丑陋啦， 又多了这两个运算符，然后里面一大堆的星号，看上去很丑。 那有了C++的引用的概念以后， 我们新的swap函数写起来就可以看上去体面的多了，
    ```C++
    /*C++引用 方式*/
    void swap(int &a,int &b)
    {
        int tmp;
        tmp = a;
        a = b;
        b = tmp;
    }
    int n1,n2;
    swap(n1,n2);        //n1,n2的值被交换
    ```
  啊，这时候我们用两个引用作为参数， 作为swap参数，然后呢在这里面交换两个参数a,b的值， 而且我们调用swap的时候，调用swap函数的时候，直接就用n1和n2作为参数就可以了。 用不着取地址的运算符了。那么这个swap函数执行完以后， 我们发现，n1和n2的值它确实会被修改。 为什么可以达到这样的效果呢？这就是引用的一个魔力了。 我们看到，进到ii， 它就引用了n1，是吧？b呢，是不是就引用了n2， 那根据我们对引用概念的解释，一个ii的东西是一回事，是等价的。 那么也就是说，在这个swap函数里面，a它就是等价于n1， b它也是等价于n2， 也就是说在这个函数里面我们修改了a的值，修改了b的值， 直接也会导致这个n1和n2的值被修改。 所以说执行完这个swap函数调用语句以后， n1和n2的值就被交换了。 
- 再看一种引用的比较，看上去比较炫的这个用法，啊，就是**引用可以作为函数的返回值**， 
    ```C++
    int n = 4;
    int &SetValue() 
    {
        return;
    }
    int main()
    {
        SetValue() = 40;
        cout << n;      //输出：40
        return 0;
    }
    ```
  这里有个全局变量，这里有一个看上去比较奇怪的函数，SetValue它的返回值 是一个整型的引用。然后它返回的值呢又是n， 那这时候我就问问大家，这个函数的返回值是一个引用，它引用了谁呢？ 啊，你在这里写了return n，那很显然，这个函数的返回值就引用了n，那一个函数的返回值是引用， 能够带来什么好处呢？ 直观的说，我们就可以把这个函数调用写在赋值号的左边，啊，我们对一个函数调用返回的结果可以进行赋值， 看上去很神奇，对吧？呃， 这时候，这条语句产生的效果是什么呢？由于 SetValue它的返回值是一个引用，而这个引用又引用了全局变量n， 那么这个时候，我们对SetValue的返回值进行赋值，实际上就是等价于对n进行赋值。 所以我们输出n的时候我们看到，n的值变成了40。 那这个函数返回值把它写成引用， 在这个例子里面并不能很充分的说明它到底有什么作用，对吧？ 你为什么要把一个函数调用表达式写在赋值号的左边呢？有什么意义呢？ 这个大家可以先不明觉厉，啊，等到学到后面了，大家学会了，就会喜大普奔了。 我们以后再讲。
- 那引用还有一种用法，就是常引用。 也就是说我们在定义引用的时候，前面可以加const的关键字， 这个时候这个引用就变成了常引用。比方说这里一个r，前面加了const的关键字， 这个r就是一个常引用。那r的类型是什么呢？r的类型就是const in & 哎对了。那常引用有什么特点啊？ 常引用的特点，不能通过常引用去修改其引用的内容。 比方说，
    ```C++
    int n = 100;
    const int &r = n;
    r = 200;        //编译出错
    n = 300;        //没问题
    ```
  这个r是一个常引用，它引用了一个n，对吧？ 那我们让r等于200，这条赋值语句，哎，会编译出错， 为什么呀？因为r是一个常引用，而你这一条语句是试图通过r去修改它所引用的东西，也就是n的值，对吧？所以编译就会出错。 至于n=300，这个就没有问题， 因为我们只是说了，不能通过常引用去修改其引用的内容， 并不是说，它引用的内容就绝对不能被修改。 可以用其他方式被修改的。我们还要注意这个常引用和非常引用的转换问题。 就是我们假设T是一个一种类型的名字，那么**const T &和T &是不同的这个类型**。 那T &类型的引用或者T类型的变量可以用来初始化 const T &类型的引用，那反过来，const T &类型的常变量，啊，常变量的概念以后再说了， 以及这个const T &类型的引用，我们就不能够用来初始化 T &类型的引用，除非我们进行一下强制类型转换。大家在这里先记住这一条就可以了。 那下一小节的内容就是const的用法。就是我们刚才提到的const。 
## 5. const关键字和常量
- 下面来看一下Const的关键字的这个用法。 它的最常见的这一个用法就是用来定义常量。 那我们知道define也可以用来定义常量，但是学了C＋＋以后呢， 建议大家多用const，少用点define， 因为 const 呢，它是有类型的，啊，便于类型检查。 
    ```C++
    const int MSX_VAL = 23;
    const double Pi = 3.14;
    const char *SCHOOL_NAME = "Peking University";
    ```
  然后这个const int MAX_VAL 等于23, 那就定义了一个常量，整形常量，MAX_VAL，它的值是23。 下面这个const double Pi = 3.14 当然就是一个浮点型的常量。 那还可以有这个 char＊ 类型的常量，啊，字符串指针的常量，SCHOOL_NAME, SCHOOL_NAME呢，就是一个常量指针，它指向的字符串为 Peking University。 
- 好了下面我们再看这个常量的第2种用法。Const的第二种用法，就是用来定义常量指针。我们在定义一个指针的时候前面可以加一个const的关键字，那么这个p指针，就成为一个常量指针，就是说， p是指向于n的。 那常量指针跟非常量指针的差别在哪儿呢？ 
    ```C++
    int n,m;
    const int *P = &n;
    *p = 5;     //编译出错
    n =4;       //ok
    p = &m;     //ok,常量指针的指向可以变化
    ```
  差别是在于我们不可以通过常量指针去修改其所指向的内容。 啊，注意，是不可以通过这个指针去修改，而不是说它指向的内容不能修改。 回到我们这个p这个例子，＊p等于5, 这个就是试图通过p去修改它所指向的内容，对吧？ 这个时候呢，p是一个const int ＊类型的指针， 它是一个常量指针，所以我们试图通过一个常量指针去修改其指向的内容，这个是不允许的， 编译的时候就会出错。 那n的值可以不可以被修改呢？当然没有问题。那p还可不可以指向别的地方呢？ 也没有问题。啊，我们只是不能通过p去修改它所指向的内容而已。 
- 我们还要注意一点, 就是不能把常量指针赋值给非常量指针， 反过来，是可以的。大家看，
    ```C++
    const int *p1;
    int *p2;        //ok
    p2 =p1;         //error
    p2 = (int*)p1;  //ok,强制类型转换
    ```
  这里有p1, p2, 两个指针。一个是常量的， 一个不是常量的。那么p1等于p2这样的赋值语句就 没有问题。你可以把一个 非常量的指针赋值给一个常量指针， 但是p2 等于p1, 这就不行。啊，你不能把一个常量的指针，赋值给一个非常量的指针。 为什么不行呢？这是因为一个常量指针所指向的地方，我们倾向于这个地方的内容，尽量不要修改。 那你如果随随便便地就把它赋值给一个非常量的指针，比如说这个p2, 那我们以后就可以通过修改p2所指向的内容， 就使得p1所指向的内容也被修改了。 那p1所指向的内容可能是倾向于不因该被修改的。所以这个时候就会产生一点不安全的这个因素。那么如果我就是想要把一个常量指针所指向的东西，让一个非常量的指针去指着，能不能够做得到呢？当然也可以，我们可以进行强制类型转换。 比如在这儿，p1是一个const int ＊的指针, 我们可以把它强制转换成一个int＊的指针， 然后再赋值给这个p2，这个时候就没有问题了。
- 那我们在写函数的时候，有时常常会把它的参数写成一个常量的指针。 为什么会这么做呢？啊，这是因为我们写这函数的时候，我们心里认为，这个p所指向的内容，它不应该在这函数里面被修改，如果是这样的话，我们就把p写成const指针。那么，在这个函数里面，如果出现了像这样一条有可能修改p的内容的语句，编译的时候，就会出错。
    ```C++
    void MyPrintf(const char *p)
    {
        strcpy(p,"this");       //编译出错
        printf("%s",p);         //ok
    }
    ```
  像这个printf这样一条语句，它只是把p所指向的内容打出来， 它不会修改p所指向的内容，那这样的语句就是没有问题的。 那这strcpy它会修改p指向的内容，所以不行。那编译器是如何发现这条语句是不妥的呢？这是因为strcpy这个函数，它的第一个参数的类型，实际上是char＊。 啊，strcpy的第一个型它的类型是char＊。那我们给进去的这个参数p，它的类型是什么呢？是const char＊。那我们前面已经说过了，我们不能够把一个const char＊的指针， 去用它给一个char＊类型的指针赋值。所以说， 这个p的类型跟char＊是不匹配的，因此这一条语句编译的时候就会出错。 那总之它就可以避免你在函数内部不小心写出了能改变参数指针所指向的地方的内容，这样的语句。 
- 那常量const的关键值的第3个用处，可以用来定义常引用，这个时候我们常引用的概念我们前面已经说过了，所以就不再讲。 
## 6. 动态内存分配
- 接下来我们讲一讲这个动态内存分配。呃，我们知道同一个程序， 有的时候，它运行的时候，可能需要很大的内存空间，来处理很大的数据。 那有的时候，它运行时呢，又只需要处理很小的数据，并不需要很大的存储空间。 那如果你总是开一个很大的数据，按照最大的空间需求来开这个数据的话， 你会造成浪费。比较好的做法就是以实际运行的时候需要多少空间， 就按照这个需要去动态内存分配。呃，按照这个需要去进行空间的动态内存分配，这是比较有效率的这个做法。 那，那我们知道，C语言里面是有这样的机制的，我们可以用这个malloc这样的库函数来完成动态内存分配。 那么在C++里面呢，就要用new运算符来实现这个动态内存分配。 那new运算符，它有这个两种用法。 第一种用法是动态分配一个变量的存储空间，它的写法是 P=new T。 在这里呢，P是一个指针。 T代表一个类型的名字，比方说是int啊，double啊，都可以。 那么这个时候呢，P它就是类型为T* 的这个指针了。 这条语句它的作用就是动态分配出一片大小为sizeof（T）字节的内存空间。 然后，并且把这个内存的起始地址赋值给P。 我们看具体的例子。int* pn；pn=new int; 啊，那这条语句呢就动态分配出一个整型变量那么大的存储空间，并且把这个动态分配出来的存储空间的地址放在pn里面。 那接下来我们就可以通过pn去修改刚才new出来的这片存储空间里面的内容了。啊，* pn = 5就往刚才new出来的存储空间里面写了个5。 
- 下面我们再看这个， new运算符的第二种用法，就是分配一个数组。啊，我们知道有时候你只动态分配一个变量这么大的空间是不够用的。对吧。比如说你需要分配好大一片存储空间，这个时候呢，我们就可以用P = new T[N]这个办法， 动态分配一整个数组出来。 那么在这个写法里面，T依然是类型名，P是类型为T* 的这个，这个指针。 然后呢，这个N是，它是一个值为整型的变量或者是常量，或者是表达式，都可以。 N它代表要分配的数组元素的个数。我们说这条语句是分配出一整个数组，对吧。那你到底要分配的这个数组里面有多少个元素呢？ 这个元素的个数就由这个N来决定。那N它可以使整型表达式。 这条语句动态分配出一片大小为N* sizeof（T）这么多个字节的这个内存空间， 并且把这个内存空间的起始地址赋值给这个P。 然后，我们通过P就可以去访问刚才动态分配出来的这片存储空间了。 我们看具体的 动态分配一个数组的这个例子。啊。还是pn， 啊，i=5。然后，pn=new int[i* 20]. 啊，这个时候呢，分配出来的这个数组里面有多少个元素呢？ 它有i* 20这么多个元素，对吧。那就是100个元素。 然后，我们可以访问下标为0的那个元素，pn[0]=20。啊。 你还可以访问下标为100的那个元素。那当然我们知道这条语句从 语法上来讲，没有什么问题。啊，但是从这个程序执行起来呢，走到这条语句的时候就有可能出错，因为我们 动态分配的那个数组它只有100个元素。一个100个元素的数组，它的数组元素的最大下标， 最大的合法下标应该是多少呢？应该是99，而不是100，对吧。所以这条语句 编译没问题，但运行的时候可能导致这个数组越界的这个错误。 
- 另外，我还想强调的一点就是这个new 运算符，它的返回值的类型是什么。 大家看这两个表达式，new T，new T[n]。 实际上这两个表达式类型都是， 返回值的类型都是T* 。啊，我们假定T是某种类型的名字，int， double之类的啊。那这两个表达式它的返回值的类型都是T* 。 我们从下面这个写法也能够得到印证。对吧。这个int* p， p的类型是int* 。 然后呢，这个赋值号右边new int，那它的类型当然就是，也是int* ，这样两边类型才能够匹配，对吧。 所以我们记住，new它的运算，new运算符它的返回值类型就是它后面这个类型的指针，new T，new T[n]，返回值的类型都是T*。
- 我们，你前面看到了用new运算符去动态分配存储空间。 这个存，存储空间光分配出来， 分配完了还要用它。那用完以后也不是说就放在那，就不管它了。 动态分布的存储空间，我们用完以后必须要把它释放掉。 如果你动态分配的存储空间， 不进行释放的话，那么这片存储空间就会一直被你这个程序占用。 就不能够，操作系统就不能够把这片存储空间交给别的应用程序使用。 那如果你的程序总是反复的在动态分配存储空间， 而却总不释放的话，那你的这个程序占用的内存空间就会越来越多。那最后就有可能导致操作系统，或者是别的应用程序的运行的内存空间都不够。这时候，你的系统就有可能崩溃，或者是特别慢。所以我们new出来的存储空间，只要我们用完了，就一定要把它释放掉。那如何 释放呢？在c++里面，我们是用delete运算符来进行释放动态分配的存储空间的。 那delete运算符它的写法很简单，delete指针。 啊，这里面有个前提。 这个前提就是，这个指针必须指向的是一片动态分配的存储空间。 如果它指向的一个你自己定义出来的数组，那这样的delete语句是语法上没有错，但是运行的时候就有可能导致 你的程序出错。我们看具体的例子。p = new int， 然后，我们使用了p。接着我们假定这个new出来的存储空间就没有用了， 那么我们就要把它释放掉。怎么释放呢？delete p，因为p指向了 刚才new出来的这一片存储空间。delete p就可以把它释放掉。 大家要注意的是，这种释放操作你只能做一次。 如果你已经delete p了，你再delete 一次， 这个时候这条语句运行的时候就很可能导致你程序出现异常。 所以大家牢记，一片动态分配的存储空间它不能够被delete两次。 
- 那刚才我们看到的那个例子是delete一个动态分配出来的变量，对吧。 那我们有时候动态分配的是一整个数组，这个数组如何，动态分配出来的数组如何被回收呢？ 通用也是使用delete运算符，只不过这个时候呢，我们在使用delete的时候，在指针前面要加一个中括号。 这种用法就代表着这个指针指向的是动态分配出来的一个数组。 啊，在这种情况下指针必须指向动态分配出来的数组。 那释放动态分配的数组， 用delete的时候，后面必须跟这个中括号。比如看这，p=new int[20]， 动态分配了一个数组，对吧。那我们使用这个数组。 啊，我们回收它的存储空间，delete [] p。不要忘了这个中括号。如果没有中括号， 呃，你的程序编译啊，运行，都不会有什么错误的感觉，但是实际上会导致，呃， new出来的存储空间并没有被完全的释放，啊。那， 那动态分配的存储空间如果没有被回收的话，就会成为这个内存的垃圾碎片。 这部分，这部分内存在这个运行期间，就不会被其他应用程序，或者被你自己再利用了，等于就浪费掉了。 这是我们需要避免的。 那下一小节的内容就是内联函数、函数重载和函数缺省参数。 
## 7. 内联函数和重载函数
- 接下来咱们讲内联函数、函数重载和函数缺省参数。 我们先说这内联函数。 大家知道这个函数调用是有一些额外开销的。 因为我们在调用一个函数的时候，首先要把参数放到栈里面去， 返回地址也要放到栈里面去。 然后，这个函数执行完返回以后呢，还要从栈里面取出返回地址，然后再跳转到返回地址去执行。 啊，这些是需要时间的，这些大概总共需要大概几条指令吧。 那一般情况下，函数里面的指令都很多，那么这些函， 带来函数额外开销的这些几条指令呢，相对来说就显得并不是很浪费时间。但是，如果你的函数本身就只有几条语句，执行非常快， 而且你这个函数还要执行很多次，那么在这种情况下， 调用函数所产生的那个额外开销就会显得比较大了。啊。 那C++语言它是特别讲究效率的一种语言。啊。 所谓这个时间就是金钱，效率就是生命。C++语言在这个效率方面可以说是锱铢必较的。 所以C++的设计者认为这点函数调用的额外开销都是不能忍的。所以C++的设计者设计了一种叫作内联函数的这个机制。 目的在于减少函数调用的开销。什么叫内联函数呢？ 就是编译器它处理对内联函数的调用的这种语句的时候， 啊，它不是像普通的函数调用语句那样，啊，生成一大堆指令， 把参数放到栈里面去，把这个返回值放到栈里面去，然后跳转到， 到，到这个函数的地址去执行。它不是这样执行指令的。 编译器所做的事情，它是把整个函数的函数体的里面的代码 直接插在调用语句的这个地方。 它不会去产生调用函数的语句。我们说，调用函数的语句会导致额外的开销，对吧，因为要把参数入栈等等。 而对于内联函数来说，你调用了内联函数， 那么编译器在编译你这条调用语句的时候，它并不生成 调用函数的语句。它是直接把内联函数的函数体的代码直接贴在调用的地方。 那我们怎么样写一个内联函数呢？ 我们在函数定义前面加一个“inline”关键字，就可以定义一个内联函数了。 比如说这个max函数，
    ```C++
    inline int Max(int a,int b)
    {
        if(a > b)
            return b;
    }
    ```
  前面加个inline关键字，那这个max就是一个内联函数。我们看到这个max函数，它本身的指令就很简单，就那么一两条语句。 那这样一个max函数如果在反复，如果被反复多次执行的话， 我们可以感觉调用这个max所产生的额外开销， 跟这个函数本身在执行的过程中所产生的开销几乎都是差不多的。 那么这样就是一个浪费了，对吧。所以我们只要把这种简单的函数写成inline， 就能够提高这个函数执行的这个效率。 
- 那当然这样子也带来一些这个坏处，对吧。凡事有利必有弊。 它带来的坏处是什么呢？就是你这个可执行程序的体积就会增大。因为你写了调用max的语句的时候， 啊，编译器就会把这个max函数的整个函数体啊，都塞在你这个调用语句处。那这个 函数体里面的指令数量有可能比这个函数调用本身的那些指令数量要多的，这个时候你的可执行程序的体积有可能就越位增大。比如说，我们这样调用max。那么编译器怎么处理这条语句呢？ 它会把它编译成大概是下面这幅样子。大家看，是不是相当于把这个函数体里面的代码做做变换， 换到这来。 就没有再生成参数入栈、返回地址入栈这些操作了。
- 下面我再看这个参数重载。 什么叫函数重载呢?就是一个或者多个函数，名字相同， 然而参数个数或者参数类型不同，这个就叫做函数的重载。 啊，总之就是名字相同，但是参数表不同，这个就叫函数的重载。 那我们看到下面的三个函数它就是重载关系。
    ```C++
    int Max(double f1,double f2) {}
    int Max(int n1,int n2) {}
    int Max(int n1,int n2,int n2) {}
    ```
  这三个函数名字都叫max。 但是它们的参数表是不一样的。第一个max是用来求两个浮点数里卖弄最大的那个。 第二个max是求两个整型数里面最大的那个。 第三个max是用来求三个整型数里面最大的那个。 那它们都是求最大值，对吧。所以它们的名字都叫max是很顺理成章的。 但是我们知道在C语言里面，你不能够写两个函数它的名字相同，对吧。 那这个时候就会带来麻烦。就比方说你就得想，奥，这个是求两个double类型的这个值的最，变量的最大值的。那我们就要叫它 max of 2 double。这个就叫max of 2 int。这个就叫max of 3 int。 这是非常啰嗦啊。有时候你自己都不记得你写的某一个max函数到底叫什么名字了。 那在C++里面有了重载的这个，函数重载的这个机制呢， 我们可以让函数取相同的名字，只要是求最大值的都叫max。 啊，这些函数只要参数表不一样，就不会产生重复定义的这个错误。 那么，这样所带来的好，好处是显而易见的。 就是它使得函数的命名变得简单，容易记忆，对吧。 我们都叫max，不用max of 3 int， max of 2 int，什么之类的了。 那，那我们写了三个max，然后我在调用max的时候， 那编译器怎么知道我们要到，调用的到底是哪一个max函数呢？ 这相信大家也猜都能猜出来。 编译器是根据调用语句中的是实参的个数和类型来判断到底应该哪一个max函数被调用，对吧。 你调用一个max函数，你心里想的是，我要求两个整型变量里面最大的那个，当然你肯定给的参数就是两个整型参数，对吧。 那这个时候编译器就能够匹配了，哎，有一个max，它有，它的参数是两个整型的，它跟你想要调用的那个， 它跟你给出的两个整型参数是匹配的，所以这个时候你要调用的当然就是这个max。 我们看例子，
    ```C++
    Max(3.4,2.5);       //调用 1
    Max(2,4);           //调用 2
    Max(1,2,3);         //调用 3
    Max(3,2.5);         //error 二义性
    ```  
  啊。 三个max函数，编号为（1）、（2）、（3）。 max（3.4，2.5），这个时候到底调用哪一个max呢？ 很显然这两个参数都是double类型的，那当然就是调用（1）号max， 对吧。这max（2，4），哎，两个整型参数的max是哪一个呢？ 是（2）号，所以调用（2）。这个max （1，2，3），那就调用（3）号max，对吧。 没有什么歧义。但问题来了，如果你写一个max（3，2.4），这个时候要怎么办啊？ 有两种处理方法。你可以说我把这个3 啊，转换成一个浮点数。那么看起来就应该是调用第（1）个max了。 当然你也可以说我把这个2.4去掉尾巴，变成 一个整数，那时候，那么这种情况下似乎调用的应该是（2）号的max。 那编译器它在这种情况下就不自作主张了。啊，它就直接报二义性的错误。 它告诉你，我不知道该怎么办。你没有说清楚到底要调用哪一个max。 这是我们在使用重载函数的时候必须要注意到的，啊。 
- 另外还有一点要强调的就是重载函数，它一定是名字相同， 但是参数表不同的。 如果有两个函数，名字也一样，参数表也一样，只不过是返回值的类型不同，这个叫重载吗？它不叫重载，它叫重复定义。 
## 8. 函数缺省参数
- 在C++里面，函数的参数是可以有缺省的值的。 也就是说我们在定义一个函数的时候，可以让最右边的连续若干个参数给它赋一个缺省值。 那我们调用这个函数的时候啊，那些有缺省值的参数的位置我们就可以不写参数， 那不写参数的情况下，编译器就用这个缺省值去代替你没有写的参数。 
    ```C++
    void func(int x1,int x2 = 2,int x3 = 3) {}
    func(10);       //等效于func(10,2,3)
    func(10,8);     //等效于func(10,8,3)   
    func(10,,8);    //不行，只能最右边的连续若干个参数缺省
    ```  
  那比方说我们看这个func，这func的函数它的最右边的两个参数x2和x3,都有缺省值，一个是2一个是3 那我们用func（10）这种方式来调用func函数的时候，我们没有给出第二个参数和第三个参数这个时候编译也不会出错，编译器就用缺省值2去代替x2这个参数， 用缺省值3去作为x3的一个参数。所以这条语句就等价于func(10,2,3) 那如果我们给出了前两个参数，第三个参数没有给也是没有问题的，那么第三个参数x3就是用3来代替了。 但是如果你给的第一个参数和第三个参数，但是只是空出了第二个参数想要缺省不给， 这个在C++里面是不允许的，在C++里面，我们只能最右边的连续若干个参数可以缺省掉。我们调用一个函数的时候就是这样的。 
- 那函数参数有缺省值到底有什么意义呢？实际上C++里面有好多的这个机制都是为了用来提高程序的可扩充性。可读性、可扩充性、可维护性等等。 那函数参数可缺省的目的在于提高程序的可扩充性。 它当然不会是仅仅是让你少敲几个参数这么一点点有点弱智的用处，它的用处其实挺大的。就是有时候我们在写程序的时候，程序的功能可能要不断地扩大， 那时候就会经常发生这种情况，就是有时候我们要增加某项功能，因此某一个函数我们可能就要往里头增加参数， 如果我们为某一个函数增加了参数， 很显然那这个程序里面原先调用的这个参数的那些语句，我们都需要把它找出来一一地改掉，补上新增的参数。 这其实是挺麻烦的。我举一个例子， 比方说一个这个绘图程序，绘图程序需要绘画圆啊方、矩形啊等等这类形状， 那你肯定需要写一个cycle，画圆的这个函数。假设你这个绘图程序最早是很土的，画的东西都是黑色的，画出来的圆也是一圈黑色的， 那这个时候，画圆的这个函数cycle它就没有颜色这个参数。 但是后来你这个软件卖得很好，你需要不断加入新功能，那么画圆的这个函数就需要添加一个颜色参数了，因为这时候你需要画彩色的圆。 好了，现在你给画圆的这个函数添加了一个颜色这个参数，那么原先里面的程序里面所有调用cycle函数的这些语句 你肯定都要找出来为它添加这个颜色参数，对吧？但实际上我们知道， 在你这个程序里面，可能有好多的场合本来就只是需要画一个黑色的圆的， 哪怕你程序扩充了，它也只需要画一个黑色的圆， 不需要别的颜色，那么你就要需要改动cycle函数以后，你就需要把这些只画黑色圆的那些cycle调用语句也找出来，给它补上一个黑色的这个颜色参数，那这是就是挺费劲的一件事情。 那有了函数缺省参数以后呢，我们就可以为cycle函数添加那个颜色参数的时候给它一个缺省的值，这个缺省的值就是黑色， 颜色可以用整形来代表对吧？那有了这个缺省的值黑色以后， 那么在我这个，原来这个程序里面本该画黑色圆圈的那些语句我就可以不要动了，反正那些语句它缺了一个参数。当然这些语句本来就只需要画黑色的圆。 你缺了颜色那个参数， 编译器自动就会用黑色去代替缺省的那个参数，那画出来的圆也就是黑色的。你可以因此就少改很多个cycle调用语句。 这就起到了节省修改量的这个目的，那你的程序功能增加了， 你所做的修改并不是很多，那就说明你的程序的扩充性比较好 
## 9. 面向对象程序设计方法
- 大家好，欢迎来到北京大学程序设计实习网站课程， 我是北京大学计算机科学技术研究所的刘家瑛， 很高兴和你一起分享本学期的程序设计之旅。 在正式掀起C++大门之前呢，我想先在这一小节和大家简单聊一聊什么是面向对象的程序设计方法。 来到我们这门课的同学都默认大家呢有一定的程序设计基础， 虽然不都像是郭老师一样的码神，但至少，都像我一样，勤勤恳恳做过码农。 写过或长或短的程序。 
- 当你编写这些程序，让代码在IDE里面编译运行的时候， 你是否考虑过这样的一个问题？ 现有的结构化程序设计是否满足你对与程序设计的需要呢？ 有同学就会问了，什么是结构化的程序设计方法呢？ 其实结构化的程序设计的基本思想就是将一个复杂的大问题层层的分解开进行模块化， 生成了若干个小的子问题， 那么将一个庞大的程序划分成为不同的功能模块， 若干个函数来形成， 那么没一个模块呢，都可以由不同的开发人员设计来实现。 同时呢，他们要共同约定好相互的通讯和协作接口就可以了。 所以结构化的程序设计呢就是这样一种，自顶向下逐步求精的过程。 那么**图灵奖的获得者，PASCAL语言的设计发明人Worth曾经就结构化程序设计设计呢， 做过一个非常精辟的概括。 这就是我们所熟悉的程序等于数据结构加上算法。 其中数据结构呢对应就是我们编写代码时候的变量， 算法呢，就是以函数的形式来实现的**。 在程序设计当中呢，算法其实就是来操作数据结构的。 但是在结构化程序设计设计中呢，算法呢和数据结构又是完全分离开的。 我们很难知道说具体某一个算法操作了哪几个数据结构， 或者某一个数据结构是由哪几个算法来进行处理的。 所以呢，在结构化的程序设计设计当中，我们所熟悉的程序模式呢就是这样的一张图。 程序终结呢包含了一个main函数和若干个函数以及子函数。那么函数直接呢有着一定的调用关系。 为了去描述程序整个的一些状态，我们还去定义了一系列的全局变量， 那么这样的一个关系图呢，随着程序规模的不断变大，会变得非常错综复杂难以说明， 就不要说去进一步的进行开发和维护了。 所以呢，我们在结构化程序设计设计当中会遇到许多问题， 总结起来呢， 有不得不面对的四大囧境。 首先就是理解难，随着程序规模的增加，程序变得非常难以理解。 很难一下子在程序当中呢看出具体某个数据结构和函数直接是一个什么样的关系。 任何两个函数之间存在着怎么样的调用关系呢？也很难清楚的知道。 其次就是修改难。因为结构化设计本身是没有封装的概念的。 所以如果我们想要修改其中某一个变量定义的时候， 就必须把所有访问该变量的语句全部找出来才能修改。 这样呢，非常不利于程序本身的维护和扩充。 第三，就是查错难。 当某个数据结构的值不正常的时候，因为本身程序呢关系错综复杂， 很难找出到底是哪个函数所导致的。最后就是重用难。 我们在编写程序的时候，通常呢是希望可以使用一些现有程序当中已经有的或者类似的实现。 在结构化的程序设计设计当中呢，随着程序规模的不断增大， 由于程序关系本身错综复杂， 所以想要抽取其中需要的部分代码就会变得十分的困难。 所以结构化程序设计设计所面临的四大问题中间严重制约了软件业本身的开发。 所以呢，面向对象的程序设计方法就应运而生了。 我们经常会说，业界需要面向对象。 因为软件业的目标呢是更快、更正确、 更经济地去建立软件。我们希望更高效地实现函数的复用。更清晰的实现变量函数之间的关系。 我们希望使得程序呢更加易于修改和维护。 那么面向对象的程序设计方法本身它继承了结构化设计的优点， 同时呢又克服了结构化程序设计当中的一些不足。 它的设计思路呢更加接近于我们的现实生活。 我经常在班上开玩笑给同学们讲，说，面向对象是一种生活态度。 因为不同于结构化的程序设计，将一个大的问题进行逐层的模块化， 面向对象的程序设计呢，针对需要解决的问题 通常是去分析说这之间呢包含了哪些具体的事物， 每个事物都有哪些的特点。不同事物种类之间又存在着怎么样的关系。 事物间呢，又是如何去作用的。 所以有了这样的一类的事物呢，面向对象的程序设计方法呢也就变得更加直观化了。 我们刚刚ii提出的那个等式呢，就在面向对象程序设计时进行了一定的修改。 **那么每一个面向对象的程序呢其实就是去构建不同的类，而设计程序过程的这个过程呢，本身就是一个去设计类的过程**。 所以呢，对于面向对象的程序设计方法， 就是将一类客观事物的共同属性呢归纳出来， 形成一个数据结构，当然你可以用多个变量去描述这一类事物的属性， 同时呢，也可以讲这一类事物所能进行的一些行为和操作归纳出来， 形成一个个函数，同时呢，这些函数又可以来操作具体的数据结构。那么这样的一个过程呢我们把它称之为叫做抽象。之后呢，我们可以通过一些语法形式将数据结构和算法呢对应的捆绑在一起， 形成一个叫做类， 那么是的数据结构和操作 这些数据结构的算法呈现出这样的一个非常紧密的关系的过程呢 我们把它称之为叫做封装。那么对于抽象， 封装这两个呢，就是面向对象程序设计当中 的一个基本概念。除此之外呢，还有两个基本概念，分别是继承和多态。 那么这两个特征呢我们将会在后续的课程中间给大家进行介绍。 那么有了这样的一个类的设计之后，我们就会看到，在面向对象的程序当中， 就会包含一个main函数之外呢，会有一系列的类， 在每一个类之内呢，又包含了一些特定的数据结构和相应的函数关系。 那么每个类和每个类之间呢， 它们也存在着一定的关系。 但是由于有了这样类的一个封装， 我们就可以看到整个程序呢就变得非常清晰化和条理化，那么在后续的程序开发当中，我们也会了解到，它呢会带来更进一步的好处。 
- 那么在想到面向对象的程序设计时呢， 我就一下联想到最近非常流行的一部电影。叫做Despicable Me里面的一个例子。 如果你是Gru的话，面对手下这样千姿百态的minion，你会怎么去处理呢？ 如果你希望去创建一个新的minion， 或者去修改一个现有的minion,你会怎么做呢？ 你总不可能说把这样一类问题去进行 功能模块划分，或者说去对现有的minion去进行一定的这个呃，排序 或者说一些其他的操作。 那么最直观的方法，其实就是把这样一类对象 中间的共同属性呢抽象出来，形成一个称为叫minion的类， 那么这些千姿百态的minion它其实具有 非常强的、很多共同的特点，以及会有很多共同的行为。 那么这些所谓共同的特点属性和行为呢，就被定义在这样的一个class Minion中间， 那么它包含了一系列的共同属性，比方说，minion的名字啊， 头发的颜色，眼睛的个数，身上穿的衣服的种类等等。 此外呢，它还包含了一系列minion的行为或者是你对minion的一些操作， 比方说你可以获取这个minion的名称， 你可以去数一数这个minion本身眼睛的个数， 以及去设置minion头发的颜色和穿着打扮等等。 那么有了这样的一个class Minion之后， 如果我们想去生成新的minion对象就变得非常容易了。 我们可以去具体实例化， 或者说对minion其中的一个成员属性进行赋值， 之后呢，就会生成一些新的不同样式的minion。 那么这样其实就是一个最最简单的由一类事物抽象成一个类， 再由一个类去生成新的实例化的对象的一个过程。 
- 在有了一个直观的了解之后呢，我们来看一看C++语法 本身对于类的定义。那么关于类的话呢， 首先是利用一个关键字class来定义这个类， 之后呢，根据这个类名，是你定义的这个类本身的名称， 那么关于类的具体内容呢，你可以把它卸载这样的一对 大括号里面，就像结构体一样， 那么要注意呢，就是每一个类的结束，大括号之后呢要有这个分号， 那么在这个具体的类定义当中呢，我们可以定义一系列的成员变量， 以及成员函数，那么对于，每一个成员变量和成员函数呢，又可以定义它相应的访问范围。 那么通过访问范围说明符，就可以声明说这个成员变量或者成员函数具体可以在什么地方被访问到。 那么这就是关于类的一个最基本的一个定义。 那么关于它其中的一些具体的使用方法以及展开的一些说明呢，我们会在后续的课程呢给大家进行介绍。 好，那我们今天的课程呢， 就到这里，很高兴和大家一起共同出发，去学习本学期的程序设计实习课程。 
## 10. 面向对象语言的发展历程
- 大家好，在这一小节中，我们来 共同分享一下，面向对象程序设计语言的发展历程。 
  - 提到程序设计语言的发展历程，我们就要 追溯到1960年，算法描述语言ALGOL 60的诞生。 作为程序设计语言里程碑的ALGOL， 首次在程序设计中间引进了 局部性、递归、巴科斯-诺尔范式等等一系列，新的概念。 它同时呢，也是C语言的原型。 
  - 但是在ALGOL 60 的基础上，1963年， 英国剑桥大学又推出了CPL 语言。 CPL 语言中间的这个C呢，其实还有一个小故事。 它最早呢，是由剑桥大学一家在研制开发的，所以C 呢，就代表了Cambridge 的意思。 后来呢，由于伦敦大学呢也加盟了进来，所以CPL 语言就被命名为叫做 “Combined Programming Language”。 那么相比于ALGOL 60， CPL语言呢，更加接近硬件一些， 但是规模呢，仍然比较大，难以实现。 
  - 于是呢，1967年，剑桥大学的这个 Martin Richards 呢，进一步对CPL语言进行了简化， 产生了BCPL语言，也就是“ Basic Combined Programming Language"。 那么BCPL 语言呢，还是比较繁琐，
  - 于是1970年， 美国贝尔实验室的 Ken Thompson 呢，以BCPL语言为基础，又做了进一步的简化，设计出了更加简单、并且接近于硬件的B语言。 那么B语言呢，正是取之于BCPL语言中的第一个字母来进行命名的。 Thompson 呢, 同时还用B语言写出了第一个Unix操作系统。 但是B语言呢过于简单，功能呢非常有限，
  - 所以 1972 至 1973年呢，Bell实验室的这个Dennis Ritchie, 就在B语言的基础下，设计出了C语言。 那么他选取了BCPL中间的第二个字母来进行命名。 C语言本身呢，它既保持了BCPL语言中，和 B语言中间的一些比较精炼， 接近硬件的优点， 同时呢，又克服了它们过于简单，数据没有类型等等一系列的问题。 就在这一系列结构化程序设计语言如火如荼发展的同时呢， 面向对象的程序设计也在悄然兴起。
  - 1967 年， 挪威科学家达尔和尼加德呢就正式发布了Simula 67， 这样的一种语言。那么Simula 67 呢，它是被认为第一个面向对象的程序设计语言。 它引入了后来面向对象程序设计语言中间所遵循的很多基本概念， 比方说，类、 子类、对象、继承等等。所以呢，Simula被 作为面向对象程序设计中间，一个非常重要的里程碑。 那么，之后的话，
  - 1971年，美国施乐公司的Alan Kay 呢，也发明了一种面向对象的语言， 称为叫做Smalltalk。 那么它是，可以认为是，历史上第二个面向对象的程序设计语言。 同时呢，还研制开发了一整套，第一个真正意义上的集成开发环境，IDE。 那么Smalltalk 呢，对于许多程序设计语言的产生呢，起到了非常重大的推动作用。 像是Objective C呀，JAVA 等等。 那么90年代呢，许多软件开发思想，也得利于Smalltalk。 
  - 那么上世纪70年代末，还是在美国的AT&T， 那么 Bjarne Stroustrup 呢，以C语言为基础，发明了C++语言。 那么C++语言本身呢， 更加适应于面向对象的程序设计需要。 
  - 同时呢，1995年，Sun公司呢为了减少程式移植的工作量， 也发明了JAVA语言，它是一种跨平台的语言。那么使用JAVA进行编写的话呢， 可以经过很少的改动，就可以在不同的计算机系统上来进行运行。 
  - 那么03年呢， 微软呢也效仿JAVA， 开发了一系列的这一个， 开发了一个语言，称为叫做C#。 
- 那么它呢，这样一系列程序设计的语言的不断地发展呢，也推动了我们软件业的不断更新和换代。 那么在这样的一个程序设计中间呢，我们来重点了解一下本学期我们将要进一步接触到的C++程序设计语言。 
  - 那么C++语言本身呢，其实它起源于 Bjarne做博士论文时的一些程序撰写的经验。 那么，Dr. Bjarne Stroustrup呢，他本身呢，现在还就职于德州， 农工大学的计算机系。他呢，已经被评为呢，AT&T的fellow。 那么他同时呢还在致力于C++程序设计的这个不断的更新。那么像是去年的5月份呢，他又， 呃，更新了他自己关于这个，我们程序员称之为叫做C++ Bible 的这个 
《C++ Programming Language》 的第4版。那么这本巨著呢， 中间呢包含了最新的一些C++的特点。 那么在这个Bjarne研C++的过程中间呢，他其实发现说 Simula 本身呢，已经具备了大型软件开发的特点。但是Simula 的运行速度呢，太慢了。 而BCPL呢，快很多。 但它过于底层的特点呢，不适和大型软件的开发。 所以呢，他开始选取C语言。在C语言上面呢，增加一些类似于Simula 的特点。 那么之所以选择C呢，实际上是因为它更适用于各种不同的用途，那么更加快速而具有很好的移植性。 所以呢，一开始这个Bjame研究的这个C++的这个版本呢，被称为叫做C with Classes。 
  - 那么在83年8月，第1个C++正式投入使用了。 使用的时候呢，正式被命名为C Plus Plus。 
  - 1985年的10月呢，Bjarne 完成了经典巨著， The C++ Programming Language 第一版。 那么在这个基础上呢，C++地发展呢并没有停止，它在不断地更新。 
  - 1989年呢，C++的2.0 版本呢发布了。那么这2.0版本中间呢， 加入了多从继承、抽象类、静态成员等等，这些概念。 
  - 90年呢又加入了模版、异常处理、名字空间等机制。 
  - 94年呢，美国国家标准学会ANSI发布了关于C++的标准。 
  - 98年呢，ANSI和ISO联合发布了至今最为广泛使用的C++标准，我们通常把它称为呢，叫做 “C++98”标准。 那么C++98本身呢，最重大的改进就是加入了标准模板库，Standard Template Library。 那么，它使得泛型程序设计呢，成为了C++本身除了面向对象之外的又一个非常重要的特点。 
  - 03年呢，ISO的C++标准委员会发布了“C++03”标准。 在05年的时候呢，又有一份叫做“Library Technical Report 1"的技术报告呢，发布了。 在这一份技术报告中间呢，加入了正则表达式，哈希表等重要的类模版。 
  - 那么在2011年9月，ISO标准委员会呢通过了最新C++标准， 也就是著名的C++11。 那么C++11本身呢，对于C++语言的特点和标准库呢，多做了非常大的扩充。 比方说，它支持了这个lambda 表达式。 lambda表达式呢，它允许在本地呢，定义函数，也就是在必要的地方呢来定义， 从而消除了函数对象产生的许多安全风险。同时呢， C++11呢，又允许对象自动类型推导。 那么它允许声明对象时呢，不再去指定类型。 自动类型推导呢，主要是用于对象类型很长、很繁琐的时候进行使用，或者是对象本身是自动生成的，比方说使用模版的时候。 此外呢,C++11呢还包含了一些像统一初始化语法、代理构造、空指针、 右值引用、智能指针等等这些新的特点。 那么，时下呢，比较流行的C++编译器呢， 就包含了有GCC，以及微软的Visual C++ 10.0， Dev C++，IBM的Eclipse，以及Borland的C++Builder等等。 那么我们课程上的一些后续的例题呢，都会保证在VisualC++ 和Dev上进行编译和通过。所以大家呢，可以在进行编译环境下呢，去，呃，编辑C++代码。 
## 11. 从客观事物抽象出类的例子
- 大家好，在这一小节中，我们通过一个具体的例子 来看一看如何从一个客观事物抽现出一个c++类来。 那么这个例题呢，是要求写一个程序 通过输入矩形的宽和高，来输出面积和相应的周长。 那么我们都知道说，对于一个矩形而言，如果给定了相应的宽和高，那么这个矩形就被定义下来了。 同时呢，又可以去计算这个矩形的面积和周长。 那么对于这样的一个程序设计题目来讲的话呢，这个矩形它拥有两个属性，也就是所谓的宽和高。 那么我们可以通过去设置两个变量来分别代表宽和高， 此外呢，对于矩形还有这样的相应的操作，分别是去设置宽和高， 去计算面积以及去计算周长。 那么这样相应的对应的操作呢，在具体程序设计的时候就可以实现为三个对应的函数， 我们来具体看一看这样的两个属性 三个操作会怎么样能够被抽象为一个类呢？ 我们可以首先呢去对应定义在代码中间的这样的几个变量和函数， 我们可以呢通过去设置int型的w和h 去代表这个矩形的宽和高。 那么有了这样两个变量之后呢，我们可以去构建这样三个函数， 分别呢去计算面积，计算周长和初始化， 那么来去对这个矩形进行一定的操作。 那么有了这样的一个分析之后呢，我们就可以把这样一系列属性和操作封装起来， 形成一个称为叫做矩形类。 那么这个矩形类呢，中间的w和h这样两个 变量呢，我们把它称之为叫做成员变量。 而对应的这样三个函数，去计算周长、面积和设置宽高 那么可以认为说呢叫做类的成员函数。 而成员变量和成员函数呢又通称为叫做类的成员。 那么我们就会发现说，其实这个类挺似曾相识的。不错， 我们可以看到呢，其实类就是一个包含了函数的结构体。 那么有了这样的一个非常直观的和似曾相识的概念之后呢， 我们来看一看在c++代码中间是如何去实现这样的一个矩形类的。 
    ```C++
    class CRectangle {
        public:
            int w,h;
            void Init(int w_,int h_) {
                w = w_;
                h = h_;
            }
            int Area() {
                return w * h;
            }
            int Perimeter() {
                return 2 * (w + h);
            }
    };      //注意分号不能掉
    ```  
  那么对于这个类呢，我们首先使用class 这样的一个关键字去声明说，啊我要进行一个类定义。 那么class之后呢就是我们自己命名的这样的一个类名，我们把它称之为叫做CRectangle。 那么CRectangle之后呢，它定义了一对大的花括号， 在这个花括号内部呢，就是整个类定义。 注意了，每一个类的结束呢都必须有分号来表帧。 那么在这个类定义中间呢，我们看到了它呢首先会定义 两个变量，分别是表帧了矩形的宽和高。 之后呢，又定义了这样三个函数， 这三个函数呢，分别是对矩形的一些操作， 那么有初始化的，init， 有去计算面积的area，有去计算周长的perimeter。 那么有了这样三个函数之后呢，就可以对整个矩形有一个比较充分的行为的一个描述。 那么这样的话呢，其实就是简单定义的这样一个叫做CRectangle的一个class。 那么注意呢，就是我们在这里面还有一个对于访问范围的一个说明符，这个说明符呢我们会在后续的课程呢进一步地去讲解。 有了这样的一个CRectangle类之后，那怎么用呢？
    ```C++
    int main() {
        int w,h;
        CRectangle r;       //r是一个对象
        cin >> w >> h;
        r.Init(w,h);
        cout << r.Area() << endl << r.Perimeter();
        return 0;
    }
    ```    
  我们可以在 main函数里头除了去定义宽高这些 变量去用来呢后续的输入这个对应的参数之外呢，我们还可以使用CRectangle类来去声明一个新的变量称为r。那么这个r呢，实际上就是CRectangle类的一个对象。 这个对象呢，有了之后，我们就可以利用这个对象去访问它的成员函数。 那么可以通过r的init函数去初始化我们从键盘输入的宽和高， w和h。那么有了相应这个r矩形的宽和高之后呢， 我们就可以去计算相应的r的面积和r的周长， 然后把它输出出来，这样呢就满足了整个例题的需要。 我们看到了说，其实呢，CRectangle实际上是一个特殊的类型。这个类型呢，是你自己以类的形式来定义的。 它其实就和我们之前看到的这些int，flout 没有什么太大的区别，只是一个比较复杂的、带有函数的这样的一个类型。 **那么这个类型的变量呢，我们把它称为类的实例， 也称为呢叫做对象。 而这个过程，定义这个类定义的变量的过程呢，我们把它称之为叫做实例化**。 那么这实际上呢就是一个最基本的类定义和类实例化生成对象的一个过程。 当我们看到说对于每一个类对应的对象而言呢，它自身实际上是有内存空间分配的。 每一个对象呢都有各自的空间，比方说我们刚才的这个CRectangle而言， 那么每一个对象的大小等于什么呢？**对象的大小就等于所有成员变量的大小之和， 那么以CRectangle类的对象为例，那么它在内存空间里头开辟一块地方出来，它要有多大呢？ 那么它实际上就是两个int型的大小， 所以如果这时候你sizeof一下CRectangle的话你会发现它等于8，就是两个int**。 那么除此之外呢要注意就是，在内存中间，如果你有两个对象，分别是r1和r2的话，那么这两个 CRectangle的对象呢，它们之间是有各自的空间的， 不会相互影响。如果r1中间的一个变量呢 发生了变化，是不会影响到r2自身的 对象中间的成员的。 此外的话呢，对象之间呢我们是可以使用等号`=`来进行赋值的， 但是呢，注意不能使用这些符号`'==','!=','>','<','>=','<='`来进行比较。 不过其实c++本身语言呢实际上是给大家留了一个空间的， 那就是后面呢我们会给大家介绍说运算符重载之后我们就可以使用这些符号来进行对象之间的比较了。 
- 那么在知道了类和对象之后，我们就来重点看一下说如何去访问类的成员变量和成员函数，对吧？ 我们定义CRectangle在这个类里面，定义了一系列的变量和函数， 但具体怎么在它的实例化对象中间去访问呢？ 访问的第一种方法就是我们使用对象名加一点，加成员名，
    ```C++
    CRectangle r1,r2;
    r1.w = 5;
    r2.Init(3,4);
    ```  
  那么我们利用CRectangle这样的一个类去实例化定义了两个对象分别是r1和r2，那么我们需要去访问r1的某一个成员变量w的时候，我们就可以使用r1.w，就可以直接进行赋值了，对吧？我们把5赋给 r1这个对象里面的这个w，具体w这个成员变量 那么我们也可以同样去对r2这样的一个对象进行操作， 那么这一次呢我们不需要通过成员变量了，我们希望利用成员函数来进行访问，所以呢我们可以利用r2.init 这样的一个函数去把3和4分别设置给r2的这个w和h。 那么注意了，r1和r2我们在刚刚讲过， 它们彼此之间呢在内存中间是相互独立的两块空间。 那么对r1而言呢，我们一开始进行了赋值之后w就变成了5。 而r2.init这样的一个函数调用呢。只会把r2的w 初始化为3，h呢初始化为4，它 不会影响到r1中间的任何一个成员变量的值。 
- 第二种方法呢，我们同样可以使用指针来进行访问。 我们可以利用指针指向其中的一个成员名 来进行具体的这个访问成员变量和成员函数的操作。 
    ```C++
    CRectangle r1,r2;
    CRectangle *p1 = &r1;
    CRectangle *p2 = &r2;
    p1->w =5;
    p2->Init(3,4);      //Init作用在拍p2指向的对象上
    ```  
  同样的，我们用CRectangle呢去定义两个对象，r1和r2， 之后呢，我们可以用CRectangle类型呢去定义一个指针*p1和*p2， 分别指向r1和r2这两个对象的首地址。 之后呢，我们就可以用p1和p2来指向 对应的w和Init函数。 那么同样的利用指针，也是分别作用在自身的对象上。 
- 最后一种呢，就是使用引用。 
    ```C++
    CRectangle r2;
    CRectangle &rr = r2;
    rr.w = 5;
    rr.Init(3,4);       //rr的值变了，r2的值跟随变化
    ```  
  引用呢，我们之前在郭老师的这个小节介绍中间呢已经具体学习了引用这样的一种方法，那么其实说白了呢一句话，引用就是某一个成员变量的一个别名， 那么第三种方法去访问成员变量呢，就可以利用引用名加一点，加成员名来进行访问。 那么还是这样的一个CRectangle的例子。 我们去对应实例化的一个对象r2，那么我们要利用一个引用， rr作为r2的一个别名， 那么我们除了用r2进行一点访问之外呢， 我们也可以使用rr.，来分别访问w和Init， 注意呢， 在这个在内存空间中，r2呢同时也可以认为是rr， 所以呢，我们利用rr的这个w呢，先初始化为5之后， 如果我们再次调用Init这个成员函数的话，那么这块的对应的成员变量呢，就被修改为3， 那么h呢就修改为4，因为我们说呢，r2的值和rtwo的值呢实际上是一回事。 
- 那么最后呢，我们来看一下说 除了刚才main函数里头我们利用直接利用这个 r.Area和r.Perimeter呢，可以进行输出，同样呢， 我们也可以去写一个叫做PrintRectangle这样的函数来表示利用函数来输出这个结果。
    ```C++
    void PrintRectangle(CRecctangle &r) {
        cout << r.Area() << "," << r.Perimeter();
    }
    CRectangle r3;
    r3.Init(3,4);
    PrintRectangle(r3);
    ```  
  那么这个函数的话呢， 就需要利用CRectangle的这样的一个对象来作为参数呢进行传递。 也就是说，我们利用CRectangle呢，定义了一个对象r3，我们对r3呢进行了初始化的设置，调用了它的Init函数3和4， 我们需要打印输出周长和面积的时候呢，我们可以把r3作为参数传进来，那么传进来之后呢， 调用PrintRectangle这样的一个具体的函数，那么这个函数里面呢，它cout是谁呢？ cout实际上是r3的Area这样的一个函数， 以及r3的P这样的一个函数。那么就可以对应输出r3这个对象的面积和周长了。 那么它其实跟我们之前传统意义上的参数呢是一模一样的，只不过这个参数的类型呢是CRectangle。 
- 最后呢，我们来看一下，除了之前我们把类的成员函数的定义写在类的这个定义中间呢，我们还可以把成员函数呢分离出来，只在类定义里面呢去声明我的这个类里面呢包含了这一系列的这个成员函数。那么具体的这个函数的定义呢，可以防止整个类定义的之外， 那么在类定义之外呢，怎么样去区分这个函数本身是成员函数而不是一个普通意义上的函数呢？
    ```C++
    class CRectangle {
        public:
            int w,h;
            int Area();     //成员函数仅在此处声明
            int Perimeter();
            void Init(int w,int h_);
    };
    int CRectangle::Area() {
        return w * h;
    }
    int CRectangle::Perieter() {
        return 2 * (w + h);
    }
    int CRectangle::Init(int w_,int h_) {
        w = w_;
        h = h_;
    }
    ```  
  我们可以利用CRectangle::这样的一个标记去声明说， 哎，我这三个函数它不是 普通意义上的函数，它是属于CRectangle类的。 那么有了这样的三个，有了这样的标记之后呢， 这样三个函数就可以作为类的成员函数 来进行定义了。那么大家注意，同样的，在调用这些类的成员函数的时候， 我们仍然需要使用对象。对象的指针，或者是对象的引用来进行，它也不能作为普通函数来进行访问。 
## 12. 类成员的可访问范围
- 大家好，在这一小节中呢，我们来共同讨论一下类成员的可访问范围。 那么类成员呢，实际上 在类中间是会被定义各自的访问范围的。 那么通过一个关键字呢，就可以定义类成员到底是在什么位置上允许被访问到。 那么这个关键字呢分为三种，
  - 一种呢叫做private， 那么它呢实际上主要是指定了一些私有成员， 这些私有成员呢只能在成员函数的内部被访问。 
  - 第二种呢，是public，那么它呢去指定了一些所谓叫做公有成员 那么这些公有成员呢，可以在任何地方被访问到。 
  - 最后一种呢，是叫做protected， 那么protected呢主要是指定一些叫做保护成员， 那么这些呢，我们会在后续的继承的这一章里面呢，给大家讲述到。 
- 那么有了这样三类关键字之后呢， 我们就可以在类中间去定义不同的成员 对象，成员变量和成员函数的访问范围。 那么这三种关键字出现的次数和先后顺序呢本身是没有限制的， 就是说你可以分别在你需要的时候去指定对应的成员的一些可访问范围。那么我们来看一个具体的例子， 在定义类的时候呢，我们可以看到说对应有 class和className，对应呢就会有这样三种不同的访问范围，那么private, public和 protected呢，就是用来说明类成员的可见性的。 那么会有同学问了，如果没有呢， 像结构体一样就会默认为是公有成员吗？ 恰恰相反，那么**在类里面呢，缺省的如果什么都没有标记， 就默认为呢是私有成员，也就是说不可以随便被访问到**。 
    ```C++
    class Man {
        int nAge;       //私有成员
        char szName[20];//私有成员
        public:
            void SetName(char *Name) {
                strcpy(szName,Name);
            }
    };
    ```  
  我们来看，如果我第一个类称为叫做class Man，一个man这样的一个类 那么它中间呢，有两个成员变量，分别是 nAge和szName的一个差类型的数组， 那么这样两个成员变量呢，它前面是没有类型的， 没有类型的情况下呢，我们说了，它是私有成员。 私有成员呢，只能在成员函数里面进行访问， 比如说我们去写一个函数叫做SetName 那么SetName是用来干什么呢？把我们从外面传进来的这个名称呢赋值给szName，是吧，我们去做strcpy。 那么这时候的szName呢是可以被访问到的， 是允许的。**那么类的成员函数内部可以访问哪些呢？ 可以访问的是当前对象的全部属性和函数以及同类 其他对象的全部属性和函数。这叫做函数的内部**。 那么成员函数以外的地方是什么呢？它只能去访问这个类对象的公有成员，也就是public 标记的那些成员。 我们来看一个具体的例子。 
    ```C++
    class CEmployee {
        private:
            char szName[30];        //名字
        public:
            int salary;             //工资
            void setName(char *name);
            void getName(char *name);
            void averageSalary(CEmployee e1,CEmployee e2);
    };
    void CEmployee::setName(char *name) {
        strcpy(szName,name);        //OK
    }
    void CEmployee::getName(char *name) {
        strcpy(name,szName);        //OK
    }
    void CEmployee::averageSalary(CEmployee e1,CEmployee e2) {
        salary = (e1.salary + e2.salary)/2;
    }

    int main() {
        CEmployee e;
        strcpy(e.szName,"Tom123456");   //编译错，不能访问私有成员
        e.setName("Tom");               //OK
        e.salary = 5000;                //OK
        return 0;
    }
    ```    
  如果我定义了一个name呢，称为叫做CEmployee 那么这个class呢它本身包含了一系列不同这个可访问范围的成员变量。我们看首先呢定义的是private， private包含了哪些成员变量呢？它是这个，对应的这个employee的这个名字，szName，同时呢它还有一系列这个公用的成员变量。比如说salary。 此外呢还有一系列的这个函数，也是public，比如说setName， getName和averageSalary这样三个函数 那么在这三个函数里头， 这是所谓叫做成员函数内部。 在内部里头呢，我们是可以去访问 对应的这个私有成员的。 那么除此之外呢，我这个私有成员都是可以访问的。 除此之外呢，我们如果在成员函数的 外部，比方说我们在main函数里头 我们调用了一个strcpy这样的一个函数，我们需要去访问e.szName，对吧，e是我们用CEmployee去定义的一个对象。那么这个对象的szName呢， 如果你这样写，在程序里头一编译，它就会发现说，编译报错了。 为什么呢？szName呢，人家是private的， 不可以随便被访问到。那有同学就会问了说 那我怎么去把一个名字赋给对应的这个成员变量呢？ ok，我们有其他的函数，比如说叫做setName， 我们会有一些这样的接口函数去帮你把名字赋给对应的私有成员。那么我们利用setName的这个值，把这个值赋给谁呢？ 赋给name，然后再在 这个成员函数的内部去把name strcpy给szName， 这样的过程呢就可以去实现对于私有化成员的访问了。 那么注意，e.salary 等于5000，这个操作呢就是可以的。为什么呢？因为salary是public的。 所以我们说我们去设置私有成员的目的是什么呢？ **我们强制要求对成员变量的访问一定要通过成员函数， 这样的好处呢，就可以有效地把私有成员呢隐藏起来， 它不会暴露在非常公开的地方，所有的函数或者是程序员都可以对它进行访问， 而是需要通过成员函数来进行。 那么有了这样的机制呢，可以保证我们的程序呢，少出错，同时呢，也容易修改**。 
- 我们来具体看一看说，如果我的这个程序现在从PC呢迁移到了手机上， 那么我的szName呢不再是一个20个的一个数组，它只能允许呢包含5个成员。 那么这5个的话的修改呢，如果说szName本身它不是私有的，那么你就需要对所有这样的例子都进行操作。你需要把所有包含szName的这样的变量的语句全部找到之后进行修改。 但是如果我们现在有了这样的一个访问范围的限制，szName变成私有的了， 那么我们只需要去通过setName这样的一个成员函数直接进行一步操作就可以把对应的这个成员的这个name的名称呢对szName呢进行赋值。 这样的话呢就可以有效地避免程序出错，并且呢可以易于程序的修改 