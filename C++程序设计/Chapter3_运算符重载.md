# [运算符重载](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/4)
> 如果不做特殊处理的话，C++的“+”“-”“*”“/”等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。我们希望对象之间也能用这些运算符进行运算，例如，复数之间是可以进行四则运算的，两个复数对象相加如果直接用“+”运算符完成，那不是很直观和简洁吗？本模块将介绍利用C++提供的“运算符重载”机制，赋予运算符新的功能，就能解决对象之间运算的问题。
## 1. 运算符重载的基本概念
- 大家好，在这一小节中呢，我们开始了一个新的概念。 那么就是关于C++语法当中的运算符重载。 我们首先来看一下，相关的一些基本概念。 那么运算符呢，其实大家非常熟悉的。 我们在C++语法当中呢，已经预定义了非常多的一些运算符。 那么它呢，主要是用来对数据进行运算操作的。 我们有非常熟悉到的这些加、减、乘、除、求于， 等等等等一系列这样一些运算符。那么这些运算符呢，就都一个特别基本的特点。那么就是它只能用于非常基本的那些数据类型。 比方说：整型、实型、字符型、逻辑型等等。 但是呢，我们在C++当中呢 提供了一种新的数据抽象的手段，也就是允许用户呢去自己定义一个新的数据类型。我们把它称之为叫做“类”。 那么通常呢我们是去设计、调用类的成员函数 来去操作相应这个新类型类里面去定义的对象。 啊，去操作这些相应的对像。但是有些时候呢，我们会发现说 直接使用成员函数呢，在操作对象的时候会显得的很不方便。 比方说我们在数学上，可以直接把两个复数进行加减等计算。 那么C++当中呢，如果我们直接利用+号或者是-号 去操作一个复数类对应生成的对象的时候，就会变得不可以。 那么这时候呢，如果我们要去自己写一个函数呢，当然也可以去做这些相应的操作。 那么我们希望呢，能够像使用数学上的这种加减符号一样， 依旧可以去操作不同类型的这样的一个数据。那么这时候呢，我们就需要去使用运算符重载。 运算符重载呢，主要就是希望能够对抽象的数据类型也能够使用C++原有提供的那些传统的运算符。这样会有什么样的好处呢？首先呢，它会使得代码看起来呢非常的简洁； 并且呢也容易理解。啊，始终的传统原来大家约定俗称的一些符号。 
- 那比方我们举个例子。 我们有两个复数的对象，complex_a和complex_b这样两个 复数类生成的对像。我们呢希望就直接利用+号， 就把就把这两个复数类产生的对像呢 进行相加。那么得到的效果是什么呢？仍然得到了一个新的复数的对象。那么，它的实部呢， 就是之前两个复数类对象的实部的相加，虚部呢也想相应的虚部的相加。 那么运算符重载呢它实际上说白了，就是对已有的那些运算符赋予更多多重的含义。啊，可能有一个运算符它能够去处理不同类型的数据； 那么它可以支持这种不同类型的行为。 它不再是只能把简单的那些整型相加、实型相加，而是变成可以把一些我们用户自己定义的，不同的类型呢都利用原来传统的运算符连接在一起。 所以呢，我们说运算符重载的目的呢，去扩展了C++中提供的那些运算符的适用范围。 并且呢，能够用于类所表示的抽象的那些数据类型。 
- 那么我们看，如果说呢我们对于同一个运算符但是对于不同类型的操作数，那么它所发生的行为是不同的。 但是呢，它使用的，操作这个符呢，运算符呢是一，同样的。**那么运算符重载这样的一个实现呢 它的实质上呢，实际上就是利用了函数重载这样的一个技术**。 那么我们去重载运算符的时候呢，我们通常呢 规定需要使用这样的一个表达形式的一个函数。 就是我们利用operator这样去标记需要重载的运算符。 那么后面呢可以跟着一个形参表，那么这个形参表呢用来 传递的就是相应这个操作运算符连接的这个操作数。 然后呢，再给出一个相应的返回值来定义我们这个运算符进行重返的一个函数。 我们具体看一下，在程序编译的时候呢，我们实际上 会首先将这个含有运算符的表达式 对应转换成为是什么呢？转换成为一个对运算符函数 的一个调用。啊，我们刚才定义了那个函数，operator对应的那个运算符的那个函数。 完了之后呢，我们会去把这个运算符连接的这个操作数，比方说：a+b 对吧？b就是这个运算符。那么a和b这样两个数呢我们把它称之为叫做 操作数。这两个操作数呢就会作为运算符函数的参数来进行传递。 那么当着运算符多次被重载的时候呢， 我们可以根据实际实参的类型 去决定具体是调用哪一个运算符的函数。啊， 我们可能为了支持很多种不同的运算，所以呢我们会撰写虽然对于同一个运算符，我们可能会写若干个不同的运算符函数， 那么具体要使用哪一个呢？我们就要去看a和b的类型。 如果a 和 b是复数，那么我们就去调用复数的那个运算符加相加的那个复数； 如果他是其他类型的话呢，我们就可以调用其相应的类型来进行计算。 
- 那么运算符自身呢是可以被重载为一个普通的函数的。 同时呢，它也可以被重载为类的一个成员函数。这两种实践方式都可以。 
  - 我们来具体看一下，当这个运算符呢被重载为普通函数的时候， 
    ```C++
    class Complex {
        public:
            Complex(double r = 0.0,double i = 0.0) {
                real = r;
                imaginary = i;
            }
            double real;        //real part
            double imaginary;   //imaginary part
    };

    Complex operator+(const Complex &a,const Complex &b)           //"类名（参数表）"就代表一个对象。重载为普通函数时，参数个数为运算符目数
    {
        return Complex(a.real + b.real,a.imaginary + b.imaginary);
    }       

    Complex a(1,2),b(2,3),c;
    c = a + b;                                                     //相当于  c = operator+(a,b);
    ```  
    那么我们有一个complex的复数类， 这个复数类呢当然它包含了一个 构造函数。在这个构造函数里头呢去初始化实部和虚部。 同时呢，我们还有一个 定义了两个这样的成员变量，分别是定义实部和虚部。 那么我们希望能够实践呢这个运算符重载+号去可以连接两个复数，直接进行相加。 那么我们把它声明为是一个普通的函数的话呢，我们就可以去定义 operator+，啊，重载这个+号。 那么它这个参数对应是什么呢？它对应了分别是这个+号前后的两个操作数： a和b。 那么它们的类型呢是complex的一个引用，啊，最为const的类型传进来。 通过计算呢我们希望输出的仍然是一个复数类型的一个 对象，所以呢，返回值也是complex类型的。 我们在这个重载的函数里面完成的事儿呢，其实就是非常简单的吧！ a和b对应这两个对象的实部进行相加，以及它们的虚部进行相加。 我们看到说呢，我们定义好了这个样的运算符重载的函数之后， 如果我们有相应的两个对象-a和b, 啊。 a的实部是1，虚部是2 。b的实部是2，虚部是3 ； 以及我们定义去放置累加和的这个复数的对象 称之为c 。那么应为有了这样的一个 运算符重载+号的函数，所以我们就可以 直接在程序里面这么写c=a+b。 对吧？那么这个函数实际上呢，对应可以认为相当于是什么呢？ 相当于就是我们去调用了operator {{BLANK}}+号这样的一个函数 那么传进来的这个参数呢，分别就是两个操作数a和b。 那么这两个，这个函数的标用 和c=a+b其中的这个a+b的过程呢 这两个是相互等价的。 那么我们要注意，当你重载成一个普通函数的时候，那么参数的个数就是运算符的目数。啊，所谓运算符的目数就是说 a+b那么它是一个2目的一个运算。啊，有两个操作数。 所以呢，因为它要把这两个操作数全部都传递进来， 所以它是一个操作数和参数相等个数这样的一个表示。 
  - 那么当这个运算符被重载为是成员函数的时候呢 它会略略有一点不同。
    ```C++
    class Complex {
        public:
            Complex(double r = 0.0,double i = 0.0):real(r),imaginary(i) {}      //constructor
            Complex operator+(const Complex &);                                 //addition
            Complex operator-(const Complex &);                                 //subtraction
        private:
            double real;                                                        //real part
            double imaginary;                                                   //imaginary part
    };                                                                           //重载为成员函数时，运算符目数减一

    //Overloaded addition operator
    Complex Complex::operator+(const Complex &operand2)   
    {
        return Complex(real + operand2.real,imaginary + operand2.imaginary);
    }

    //Overloaded subtraction operator
    Complex Complex::operator-(const Complex &operand2)   
    {
        return Complex(real - operand2.real,imaginary - operand2.imaginary);
    }    

    int main()
    {
        Complex x,y(4.3,8.2),z(3.3,1.1);
        x = y + z;                      //相当于 x = y.operator+(z)
        x = y - z;                      //相当于 x = y.operator-(z)
        return 0;
    }
    ```    
    我们刚才看到对于一个普通函数来讲， 它会有两个操作数。那么对一个成员函数来讲的话，因为它前面有一个对像； 也就是说，这个a+b这样的一个双目运算， 我们如果把a认为是一个对象来讲的话，那么， +b作为一个成员函数，那么它实际上调用的是一个成员函数的操作。比如说a,operator+。 所以呢，对于成员函数来讲，它就不再是一个两参数的一个传递；而只传递后面那个具体的操作数。啊，所以呢我们去重载运算符变成成员函数的时候，那么它只需要传进来一个参数就可以完成。 所以我们说，参数的个数呢是运算符数目-1。 那么具体的实践其实也是一样的。啊，我们在实现 这个成员函数的时候，我们只需要把这个当前对象的实部 去累加上我们传入的这个参数的实部。 作为实部。而把当前对象的虚部去累加上传入这个对象的虚部就可以了。 那么相同的，operator-号也是作为跟+号一样的一个操作。只不过呢就是做了一个减法的一个操作。那么我们看到，如果我们定义了一个类的对象，分别是x和y； 以及是z。 那么如果我们希望能够把y和z相加附给x,或者是 把y和z相减附给x。那么我们就因为重载了+/-这两个运算符 我们在这里呢就可以直接利用这样等式来进行表达。那么注意， 这里头的x=y+z和x=y-z又是分别是什么呢？ 其实它就是表示了是 x=y.operator。+这个成员函数，那么参数呢就是z。 相应的-号也是这样，x= y.operator - 传入z的参数。那么注意，它和刚刚那个 普通函数对应的不同呢，区别就在于它只传入 一个参数。这个参数呢就是这个两目运算符后面对应的 
## 2. 赋值运算符的重载
- 大家好，在这一小节中我们来分享一下赋值运算符的重载。 我们在提到赋值运算符的时候，大家可能会可能会想到在第一节的课中我们在介绍类和对象的时候， 有说那么当对象这个新的概念被引入的时候原先一些传统的运算符并不能直接作用在现有的这样的一个我们自己定义类型的对象身上。 我们必须利用后续的关于这个运算符重载的技术来实现将传统的运算符作用在对象中间。 但是呢，唯有这个赋值运算符本身呢他是可以直接来进行使用的。 如果说，我们自己定义一个complex类型，啊。那么这个类对应呢有两个对象，分别是c1和c2的话。 那么我们是可以直接利用赋值运算符来实现将c2这个对象自身的全部内容呢，逐字节赋值给c1这个对象的。 
- 但是很多时候我们会发现呢，赋值运算符两边的类型是经常不匹配的。 也就是说，我们不能直接利用赋值运算符来进行赋值。 我们可能会希望将一个int的类型的变量赋值给一个我们自己定义的complex类型的对象； 也可能希望将一个char* 类型的字符串呢赋值给一个字符串对象。 那么在这种情况下呢，我们就必须要去重载赋值运算符。 **那么在重载赋值运算符的时候呢，要提醒大家，我们只能将其重载为成员函数**。 我们在之前有介绍说，这个运算符重载的时候呢是有两种方式的。 一种呢是将其重在为成员函数， 还有一种呢是可以将其重载为一个普通函数。 那么如果你要去重载赋值运算符的时候， 我们不可以将其重载为普通函数；只能呢重载为一个成员函数。 
- 我们来看一个具体的例子。我们希望呢编写一个长度可变的字符串类string, 
    ```C++
    class String {
        private:
            char *str;
        public:
            String():str(NULL) {}               //构造函数，初始化str为NULL
            const char *c_str
            {
                return str;
            }
            char* operator=(const char *s);
            ~String();
    };
    //重载‘=’使得 obj=“hello”能够成立 
    char* String::operator=(const char *s)
    {
        if(str)
            delete []str;
        if(s) {
            str = new char[strlen(s) + 1];      //+1 放 '\0'
            strcpy(str,s);                      //这里实际上是有漏洞的，str不再指向原先的内存，指向了s。原先的内存成为了垃圾。
        } else 
            str = NULL;                         
        return str;
    }
    String::~String() 
    {
        if(str)
            delete []str;
    }

    int main()
    {
        String s;
        s = "Good Luck";                        //相当于 s.operator=("Good Luck")
        cout << s.c_str() << endl;
        //String s2 = "hello!";                 //这条语句要是不注释就会出错,本身并不是一个赋值语句而是一个初始化的语句
                                                //它需要去调用这个构造函数才能够去实现自身的这样的一个初始化的一个操作，
                                                //但是我们目前的这个程序呢是没有第一节方面的这个操作.
        s = "Shenzhou 8!";                      //相当于 s.operator=("Shenzhou 8!")
        cout << s.c_str() << endl;
        return 0;
    }
    ```
  那么这个string类呢，它包含了一个char* 类型的一个指针作为成员变量。 那么这个指针呢，它就是去指向一块动态分配的存储空间。 这个存储空间就是用来去存放那些以“\0"结尾的字符串的。 我们来看一下具体的代码实现。在这个class string里面呢， 我们去定义了一个private的成员变量char*str。 这个char*类型的指针str呢，它就是用来去指向动态分配的那块存储空间的。 啊，也就是说，如果我去重载一个这个operator=号； 那么它就可以去实现将一个字串赋值给我当前的这个对象。 那么当前这个对象内部的这个指针呢，它所指向的 这块存储空间就可以用来去存放我希望存储的这个字串。 那么除了这个成员变量之外呢，我们还定义了一系列的成员函数。 首先呢就是跟string同名的构造函数，它是一个无参的构造函数。 在这个构造函数里头呢，我们就是利用这个初始化成员列表来初始化str成为NULL。然後，我们用NULL来初始化str。 那么这样的一个构造函数我们就表明呢，就是说，只有当我们去调用operator=这个赋值运算符重载函数的时候 我的str呢才会去指向一个动态分配的存储空间。并且，在此之后呢就不再为NULL了。 否则的话呢我是，str是不指向任何一块空间的。 那么这也引发一个问题。就是我们在设计c构函数的时候， 大家要仔细的考虑一下本身这个string类型的对象，它是否在整个的这个生存期中间调用了operator= 这个函数。啊。如果它没有调用的话，那么这个对应str本身呢就是NULL。我们就不需要去执行任何的比例这个操作。 那么除了这样两个构造和c构函数之外呢，我们还有其它另外两个函数。 一个函数呢，就是这个c_str，啊。这个函数 本身它做的事儿呢就是去return str这个指针，啊。 我们希望呢将这个指针呢return出来，但是我们又不希望呢，在外部能够通过利用这个指针去修改这个指针所指向那块内存空间里面具体的值。 所以呢，我们就把这个指针设计为返回值呢，变成一个cont的类型。 也就是说我们保证不用同，不能够通过这个指针去修改这个指针所指向那块地址。 那块内存空间里面的内容。那么，由于我设计了一个const的char* 类型的 返回值，那么我们就当有这样的一个函数。啊，如果我写char * p =s.c _ str这样的一个语句的时候，那么编译器在编译的时候它就会发现说这个赋值号的右边呢，它是一个const的char* 类型。啊。而左边呢是一个非const的类型。 那么这两个呢类型是不匹配的，编译呢就会报错了。 那么除了这个c_str返回一个 指针之外呢，我们还要重点就去设计这个operator=，也就是说这个赋值号， 赋值运算符的这个 重载函数。那么这个重载函数的实现呢， 它一旦实现了之后，我们就可以去实现一个怎么样的事儿呢？ 我们如果用 string类本身定义了一个对象称为叫obj的话， 那么我们就可以对obj直接呢赋值一个字串。 啊，比如说我们把hello赋值给obj，那么我们就是通过去重载这个赋值运算符来实现。 我们看一看具体这个赋值运算符时重载函数的这个设计。 那么一这个obj=hello字串为例，啊。 我们首先呢就是要去定义这个operator=这个函数，重载函数名。 完了之后我们要做的事儿呢，就是将这个hello字串 这块地址对应的指针 char* sz作为参数呢传递进来。 那么我们不希望呢本身这个字串在 被赋值的时候以一些其它的修改。所以呢，我们就把这个指针定义为是const的类型的。啊，那么我们只能去利用这个指针读取这段空间中间的字串；而不能去修改它。 完了之后我们要去判断一下，当前的这个对象，比如说obj，它所包含的这个str的这个 嗯，指针是否为空？若它已经指向了一块内存空间的话， 那么为了保证我拷贝的时候两块空间内容是完全对应的， 我需要首先呢把它delete掉。完了之后呢， 当这个传进来的这个参数，啊，这个 指针s它不为空的时候，那么我才会去执行这个拷贝的工作。 那么，我首先干的第一件事呢，就是要去为这个str分配一块新的那个内存空间，啊。 我要去new一块新的内存空间，那么这个空间呢 的大小呢就是这个传入的这个参数s所指向的那块， 那个字串的大小。然后还要+1，因为要放”\0"这个字符串儿，这个结束符。 那么完了之后，我就要让这个str这个指针指向 这么大小下的一块，新分配的一个内存空间。 那么有了这样的一个内存，动态分配的一块存储空间之后呢， 我就可以去做这个stringcpy的这个工作了。我需要将这个 s指针指向的那个字串，那比方说在这里，就是hello \0这样的一块字串， 把它完全拷贝到str这个指针，啊。这个对象 包含的这个成员变量str指针指向的这块内存空间里头去。 从而呢，就可以实现将这个字串 hello拷贝给obj这个对象这样一个功能了。 那么除了这个，嗯， operator=函数的这个实现之外呢，我们刚才也讲了我们在设计 c构函数的时候也要注意去判断一下str是否为空。 还有当不为空的时候，我们才需要去delete相应的这个指针。 那么在main函数里头的话呢，那么这个程序呢就变得非常的简洁啦！ 因为我们已经定义好了这个赋值运算符的这个函数重载的 这个重载的函数。所以，当我定义了一个string 类型的 一个对象s之后，那么我当然就可以直接去实现 将一个字串，比方在这里“Good Luck”这个字串赋值给s这个对象。 那么这样的一个赋值号的这个运算呢，表达式呢实际它相当于是什么呢？它就相当于是s. operator= 然后传递的参数就是相应的这个字串的，对应的那个指针。 那么我们在这里看到，实际上就是将这个赋值运算符 的重载函数作用在当前的这个对象S身上。 那么有了这个赋值之后呢，我们可以看到，我们同样可以去set out，打印输出相应的这个 以这个S对象来存储的的这个字串是吧，那么我们只需要去调用s.c_str 这个函数返回s对象里面包含的那个str指针，所指向那一段， 内存空间就自然会把good luck这样的一个string呢，把它输出出来。 那么同理呢，也可以把Shenzhou 8这样的一个字串呢赋值给s，也可以相应地输出出来。 那么要注意一点，就是我们如果直接去写了这样的一个初始化的语句，String s2等于hello。 那么这一条语句本身如果在现在我们这一个程序下呢如果你编译运行的时候呢，是会出错的。 因为呢我们本身， 这本身并不是一个赋值语句而是一个初始化的语句。 那么初始化语句它不会去调用operator等于这样的一个函数， 它需要去调用一个以char* 作为参数的一个构造函数。 那么它需要去调用这个构造函数才能够去实现自身的这样的一个初始化的一个操作，但是我们目前的这个程序呢是没有第一节方面的这个操作的，所以呢如果你写一个这样的语句呢是不可以的。 那么整个程序呢就会相应的输出good luck、Shenzhou8这样的一个两行字串。 
  
- 那么我们刚才已经跟大家展示了一个最简单的将一个字符串赋值给一个string类型的对象这样的一个操作。那么我们就是通过去重载这个赋值运算符来进行实现的。 那么我们才刚也提到了就是说我们实际上可以简单地利用一个赋值运算符来实现两个同类对象的复制的工作。**但是在很多场合下，这种复制呢它都应该是一种叫做逐个字节的复制工作。那么这个复制呢我们把它称之为叫作浅复制或者浅拷贝**。 这种简单的逐字节的复制工作呢可能在程序，整个在设计的过程中间会引发一些问题。 也就是说我把一个对象赋值给另外一个对象的时候，看到这个逐字节的这个复制的实现呢未必是我们希望所看到的。 比方说我们来举一个例子。
    ```C++
    String s1,s2;
    s1 = "this";
    s2 = "that";
    s2 = s1;
    ```
  我定义为一个类称为 叫MyString，那么它包含了两个对象S1和S2。 那么由于我刚才已经重载了那个upgrade等于的这个赋值运算符， 那么它可以实现这样一个字符串呢直接赋值给一个对象这样的一个操作。所以呢S1呢自然就被复制成为了 this，S2呢就复制成了that。那么S1.str那就指向了this这个字串，S2.str指向了that这个字串。 那么我现在如果希望进一步去做我希望将S2直接赋值给S1。 那么如果我去利用这个赋值号直接进行赋值，这以个呢在语法上也是没有任何问题的。我们可以直接去实现这个浅复制，也就是将S2里面的， 对象里面的内容逐字节的赋值给S1。那么这个逐字节赋值的结果是什么呢？实际上就是说S1.str，对吧。这个S1这个对象里面就包含这样一个成员变量。 还有呢，就是S2.str这样两个值呢是完全相等的了。 也就是说这两个指针因为了这一步操作之后，它指向了同一块地址。那它们两个值变得完全相同了。 那么它们指向同一块地址之后又会引发什么样的问题呢？ 我们来具体看一下在内存中间的一个示意图。我们一开始 s1.str它指向的是一块内存空间，里面存放的是this这个字串。 s2.str呢它指向的是一个存放that 字串的这么一块内存空间。由于我们执行了这样s2 赋值给S1，两个对象之间实现了这样的一个拷贝的工作之后， 因为它是一个浅拷贝，所以呢我们实现的就是将 s2.str里面的这个具体的指针值 逐字节的呢复制给了s1.str。 所以导致呢这样两个指针的值呢是完全一致的，所以它们共同指向了 原来s2.str所指向的那个 内存空间，那么它中间存放的呢是that这一快， 这个字串。那么这样通过这一张图呢我们可以非常显而易见地看到，这样呢就引发了两个问题。 第一个呢就是说因为s1.str 不再指向原先的这个存放this字串的这个内存了， 那么这一段内存空间呢变得没有任何指针来对它进行控制。 那么这一段内存空间呢可以认为变成了一块这个垃圾内存。 那么这一个或者称为内存垃圾。但是呢这一个 同时呢这个s1.str和s2.str呢 它同时呢都会指向that这个字串所存放的空间。 那么当S1和S2同时消亡的时候 那么我们这一块内存空间呢就会被先后释放两次。 这样呢就会导致严重的内存错误，甚至呢可能引发程序呢意外的中止。 所以呢我们看到说这样的一个浅拷贝，或者浅复制的工作呢本身并不能实现我们所希望实现的 象S2中间的这个set字串 复制给S1本身指向的那一块空间。 

- 那么我们就讲到说 为了实现我们刚才提到的这个功能我们就需要去实现一个叫做深复制或者深拷贝的一个功能。 **那么所谓深复制或者深拷贝它就是将这一个对象中间的指针变量所指向的那部分内容， 复制到，注意是指针变量指向的内容。 那么复制给谁呢？复制给另外一个对象中间指针成员对象所指向的地方**。也就是说我们希望能够将 s2.str所指向的具体的这个字串that 复制给s1.str所指向的那一段内存空间里。 我们来看，**我们具体实际上就是希望这一个 s1.str和s2.str本身这两个值还是不同的。 它们各自指向了独立的两块，分别两块不同的内存空间**。 但是呢通过这样的一个赋值语句的操作呢我们希望实现的事是将str str里面的这个that的这个具体的这个字串复制给s1 str所指向的这段内存空间。那么完成这样的一个工作我们就把它称之为叫作一个深拷贝。那么我们怎么样去实现这个深复制或者深拷贝呢？ 
    ```C++
    String &String::operator=(const String &s)
    {
        if(str == s.str)
            return *this;
        if(str)                                     //s.str不为NULL才会执行复制
            delete []str;
        if(s.str) {
            str = new char[strlen(s.str) + 1];
            strcpy(str,s.str);
        } else
            str = NULL;                      
        return *this;
    }
    ```
  我们就需要在这个MyString这个类里面去添加一个新的 这个operator=的一个成员函数。那么这一个 赋值运算符的重载函数呢，它的参数就变成了是一个String类对象的一个引用。 那么为了保证我只是做一个拷贝而不去影响自身的这个 等于是赋-带赋值的这个值，那么我们就需要将这个参数呢把它声命为是一个const类型。 那么跟之前的那个复制工作其实是类似的。我们首先呢仍然要去判断一下当前的这个对象，比如说S 在这个例子里面实际上是s1.str是否指向了一块内存空间。 那么如果指向了要把它delete掉。完了之后呢我们就要去new一个新的空间。那么新空间的大小是什么呢？是这个传入的这个参数对象 指针所指向的那一块空间的大小并且加一 存放'\0'。那么有了这样的一块新的内存空间之后， 我让当前的这个对象的str，在这个例子里面是s1. str指向这一块新申请的内存空间。完了之后呢我就可以做String copy的工作， 我让这个传递参数对象s.str 指针指向的那个字串的内容，在这里就是that 纲领完全呢拷贝给 这个str新分配出来的这一段内存空间。 那么完成了这样的拷贝之后实际上呢就实现了两个对象本身自身的这个 成员变量指针本身呢是不一样的，分别指向不同的内存空间， 但是它们具体指向的内容是一致的，都是that这个字串。 那么就可以返回当前这个对象，* this。 那么我们刚才看，我们通过去设计一个新的operator等于这样的一个，呃， 赋值运算符的函数重载之后呢，我们是不是就已经完全实现了String类的一个赋值的工作呢？ 如果你仔细考虑一下，你会发现说，还有一点点小遗漏。 那就是，如果我们的程序中间，出现这样的一个自身s赋值给s 这样的一个操作，也就是说，我当前对象赋值给自身，这样一个操作语句的时候呢， 可能会在刚才的那一个重载函数中，刚才的那一个重载函数中间呢，出现一点小问题。 因为呢，我们首先要去判断，str是否指向一块内存空间。 在这个例子中间，s肯定是指向的。 那么我们就要去delete掉，啊，要delete掉这个str。 那么如果我delete掉这个str之后呢，我又要重新去new一块 内存空间，啊，然后去分配给这个str指向。 那么，完了之后还要去执行这个strcpy的工作。 那么你就会发现说，在这样的一系列语句中间的话，会引发一个问题。 这个问题呢， 就是，我可能呢，已经把原先的这个 对应的内存中间的内容呢，已经彻底地删掉了。 删掉之后呢，又要去复制一个不知道从哪儿new出来的一块内容。 那么这时候，这个str指向的这个 自身的这个复制呢，可能具体复制的这个内容呢，就不知道 变成什么了。所以呢，这个过程呢，是不可以出现的。那么 为了避免这样的问题，我们只需要在原先的这个 重载函数中间呢，添加，一开始，添加这样的一个判断。 也就是说，如果我传递进来的参数对象呢，它本身是， 它的指针是和我当前的的这个对象的指针是一样的话， 那么它就是实现了一个自身的复制的功能。那么我们只需要让它去 return当前对象，*this就可以了，而不需要做其他任何的操作。 那么后续的操作呢，都是跟刚才我们讲到的这个运算符重载是一致的。 那么我们在谈论这么多关于这个operator等于函数 这个设计的时候呢，我们都先规避掉了一个问题，就是它的返回值。 那么这个返回值类型的好坏呢，其实也会影响到 我的一个运算符，在重载之后的一个实现的效果。 那么，如果我们对operator等于这样的一个函数的返回值设计成是void， 可不可以呢？那么，答案是否定的，不可以。 因为我们在做这个赋值的时候可能会面对这样的情况， 我们可能会需要先将c赋值给b， 再将其赋值后的结果赋值给a。 那这样呢，很明显，去调用operator等于的时候就会有两次。 那么如果说它的返回值是void会引起什么样的问题呢？ 我们会看到，在第一部分操作，b等于c的时候， 我们会首先以c这个对象作为参数，啊，传递进来，使得operator等于这个 重载的函数作用在b上。那么使得 这个b实现一个将c赋值给b的这么一个 操作。那么这个操作的返回值如果是void， 那么，下一个这个赋值的操作，operator等于就不再会有这个相应的参数的传入了。 所以呢，我们说传递进来的这个参数必须，或者说， 这个传递进来的这个参数，实际上是前一步的返回值。那么这个返回值呢， 必然不能是void。那么我们就需要利用string 类型的这个引用来作为这个传递的这个值，来进一步做为参数。 完了之后呢，让operator等于作用在a这个对象上，来实现，下一个赋值的操作。 那么同理，我们会考虑说，那，如果我只传递让它的这个 返回值变成是一个string类型，而不是一个string类型的引用，可不可以呢？ 当然，答案是可以的。但是它好不好呢？ 因为我们在运算符重载的时候需要维护一个好的风格， 也就是说，我们会希望尽量的去保留运算符原本的特性。 所谓原本的特性呢，就是我们在程序运行的时候， 不管它是对象也好，还是以往传统的数据类型也好，其运算符的方式呢，都是保持不变的。 那么我们看一看，这个例子，啊，我希望呢，首先实现将b赋值给a， 完了之后呢，再实现将c赋值给a。 也就是说，我实现的，最终的结果是会去修改a的值。 那么在这个例子中间我可以看到，这个表达式，a等于b实际上呢，它就是一个， 相当于是一个a的引用， 对吧？那么它是一个a的引用的话，那么我们在进行这个赋值号重载设计的时候，我们就 会希望，operator等于自身呢，这个函数重载 它的返回值呢，也最好是一个对象的引用。 那么，当它是一个string的引用的时候，那么，它才能够 最大程度上地去沿袭本身这个赋值号所 表达的一个特性。那么，对应在这样的一个例子中间 我们首先呢，传入的，就是一个将b这个对象， 作为参数，来进行这个赋值的一个操作。 将重返的这个output的等于这个函数呢，作用在a这个对象上。 只有当它返回的类型呢，是一个a对象的一个引用的时候， 那么，它实际上呢就可以来继续作为 这个，下一个operator等于，这个函数的一个作用的对象，来进行进一步的 这个赋值的工作。而这个赋值呢，就是将c这个对象，作为参数呢，传递进来。 所以呢，我们看到说，我们在做运算符重载的时候，如果为了保持原有运算符 这个自身的特性的话呢，我们希望在设计重载函数的时候，能够最大限度上的实现原先的这个风格。 

- 那么我们刚才介绍了一系列的关于string类自身的一个赋值运算符的函数重载。 那么，在设计string类的时候，我们还可能会遇到这样的问题。 我们需要去编写一个复制构造函数。 
    ```C++
    String::String(String &s)
    {
        if(s.str) {
            str = new char[strlen(s.str) + 1];
            strcpy(str,s.str);
        } else
            str = NULL;
    }
    ```
  那么在复制构造函数编写的时候，其实在很大程度上，我们也会去面临和这个赋值运算符同样的问题。 因为我们可能会去设计一个比方说，对应的string的一个类，对应的一个对象s1， 那么我们把s1呢，赋值为“Hello”。 那么我们如果在这里，又去定义了一个新的string， 类型的对象称为叫s2的话， 那么，如果我将s1，初始，作为参数，初始化为s2， 那么这个时候你会看到程序呢，会去调用相应的， 复制构造函数，啊。那么它调用复制构造函数的时候呢， 我们会同样面对跟刚才一样的这个赋值运算符的问题。 那么，对应相当于 s1要赋值给s2这样的一个操作， 那么如果是， 最简单的一个前拷贝的方式的话，那么就同样会导致 s1和s2的指针，指向了同一块内存空间， 那么会出现一个重复释放内存等等，系列的问题。 所以呢，我们在设计复制构造函数的时候，也需要同样地去 使用这个刚才我们去设计的这个 赋值运算符所实现的这一系列方式。那么如果你只是简单地 去调用这个默认的复制构造函数的话，那么它就会去引起一个前拷贝的问题。 那么，如果我们自己去编写一个复制构造函数的话，那么 我们首先呢，就是要去传递一个string类型的对象的一个引用， 来作为这个复制构造函数的参数。那么首先呢，就要判断一下， 这个传递进来的参数的这个指针，不为空，啊。那么只有当它不为空 的时候，我们才能去用它来初始化当前的这一个，新定义的对象。 那么我们就要去new一个相应大小的一块内存空间， 让当前这个对象str呢，指向这个内存空间。 完了之后呢，也是同样的，去做一个strcpy的工作，使得s1这个对象， 中间的指针str所指向的内容， 全部拷贝给这个str，s2.str 所指向的那一块内存空间。那么有了这样的复制构造函数呢，就可以完全地避免掉 因为调用默认的复制构造函数所引发的前拷贝造成的问题。 
## 3. 运算符重载为友元函数
- 大家好，在这一小节中，我们来看一看运算符被重载为友元函数的情况。 那么运算符重载呢，在之前的课程中间我们介绍到 可以有两种重载的形式。一种呢是被重载为类的成员函数， 另外一种呢就是被重载为普通函数。 但是呢，其实在具体的实现过程中间呢，我们会发现，有些时候呢， 成员函数呢是不能够满足具体的这个重载的需要的。 而另外一方面呢，普通函数呢又不能去访问类的私有成员。这样就会引起了一些矛盾。一方面呢，要让它是一个普通的函数来完成一些功能。但是另外一方面呢，又希望它能够访问类的某些私有成员。 那么这个时候怎么办呢？我们就需要将运算符重载，重载为一个友元函数。 
- 具体来看一下，我们还是那个复数类，class Complex。 
    ```C++
    class Complex {
        public:
            Complex(double r,double i):real(r),imaginary(i) {}                  //constructor
            Complex operator+(double r);                                        //addition
            friend Complex operator+(double r，const Complex &c);               //友元函数
        private:
            double real;                                                        //real part
            double imaginary;                                                   //imaginary part
    }; 
    //-------------------------------------------------------------------------------------------------------------
    Complex Complex::operator+(double r)                                        //成员函数，能解释 c + 5
    {
        return Complex(real + r,imag);
    }
    //-------------------------------------------------------------------------------------------------------------
    Complex operator+(double r，const Complex &c)                               //普通函数，对应新添加的友元函数，能解释 5 + c 
    {
        return Complex(c.real + r,c.imag);
    }    
    //-------------------------------------------------------------------------------------------------------------
    int main()
    {
        Complex c;
        c += 5;         //相当于 c = c.operator+(5)
        c = 5 + c;      //编译出错
        //为了使上述表达式能成立，需要将 ‘+’ 重载为普通函数 
        return 0;
    }
    ```
  那么这个复数类呢，它包含了两个私有的成员变量，实部和虚部。 那我们要对这个实部和虚部的这个定义下的这个成员对象来进行操作的时候呢，我们就不可以直接利用普通的函数来进行这个访问。所以我们只能去定义运算符重载成为一个类的成员函数，啊。这个时候呢，我们只需要去传入一个参数来定义这个加法这么一个操作。 那么这样的话呢，如果我们去生成 一个c+5这样的一个操作，啊，我们这个问题呢是可以，是没有问题的。 我们可以对应的只需要把5传进来，然后把它的实部呢 进行相加，虚部保持不变，就可以了。 因为我们这里调用的实际上相当于是C.operator +。 啊，这样的实现呢，是没有任何问题的。 但是呢，如果我们利用上面的这种重载的方式， 去实现 下面这个功能，啊，如果我们希望能够去实现c=5+c这样的一个操作， 那么编译器就会出错了，对吧，会error。 它就不能再使用这样的一个对象，去调用相应的成员函数这样的形式去实现了。 那么，刚才这样的一个c=5+c的方式呢， 只能将+重载为一个普通函数 来进行实现。我们需要去传入两个参数。 啊，不能利用对象自身去调用相应的成员函数来实现。 只有利用这种方式呢，把5和c分别传递进来， 才能够实现进行加法的这么一个操作。 但是呢，因为这个 对象里面的相应的这个参数实部和虚部呢是private的，所以呢，我们就必须把这个Complex operator+这样的一个普通函数的重载呢 声明为是一个友元函数，friend。 只有声明为一个友元函数之后呢，我们才可以直接去访问相应类的私有成员。 
## 4. 实例-长度可变的整形数组类
- 这个数组啊是我们大家常用的一种东西对吧 大家在使用这种数组的时候可能会有一种难言之隐 有时候这个数组开大了呢，开大了呢会浪费空间，开小了可能又不够用，最好就是需要多小东西这个数组的用量就是多少 这才是完美的，对吧，可是我们数组是固定的又很难办 当然带家都想听解决办法，所以我们用动态内存分配 来解决这个问题，但是用动态内存分配领略出来的东西呢 又要实实际际的去delete它，这挺麻烦的有没有 最好是有一种什么的动态可变常列的数组 这个数组呢，需要放多少东西，它自动就把空间变得那么大 不需要空间那么多的时候它自动又把空间缩小，这才是最好用的东西 对吧，那你真的有这好东西吗？当然有 我们学了这个印象对象里面这个印象重改的概念 加入语言里面就能够实现这样一个数，现在我们来看一看 我们说的是可变长整型数组，这个例子啊 
    ```c++
    //要编写可变长整形数组类，使之能如下使用：
    int main()
    {
        CArray a;                               //开始数组是空的
        for(int i = 0;i < 5;++i)
            a.push_back(i);                     //输入：0 1 2 3 4
        CArray a2,a3;
        a2 = a;                                 //a2是空的
        for(int i = 0;i < a.length();++i)
            cout << a2[i] <<" ";
        a2 = a3;                                //a2是空的
        for(int i = 0;i < a2.length();++i)      //a2.length()返回0
            cout << a2[i] << " ";
        cout << endl;
        a[3] = 100;
        CArray a4(a);
        for(int i = 0;i < a4.length();++i)
            cout << a4[i] << " ";               //输出：0 1 2 100 4
        return 0;
    }
    ```
  假设我们写了这可变长整型数组类，它的名字叫做这个CArray， 它这个能够把下面这个来使用，比如我们定了一个Carray的对象a, a 就代表一个数组。一开始定义的时候a 是一个空的数组。 什么元素都没有，那接下来呢，要用数组的循环，要用数组的这个 push back 成员函数，把5个整数塞进去了，就0到4都塞进去 再说这数组里面呢，都变成有5个元素了 再接下来呢我们定了两个对象a2,a3 它们分别都代表一个空的数组 然后呢我们让这个a2等于a, 那我们希望这效果 a2是新的数组，它里面的内容跟a 的内容是一模一样的 但是a2和a 呢这两组数组的存组空间是隔开的 互相不影响的，这以后，a2是a的负责品 所以我们接下来的事情是把a2所有的内容给它输出 在这里呢我们变了一个数组呢要用到了a点length 这个a的长度，那a2的长度也就是a的长度，这两个是相等的对吧 那我们就让i, 从0走到a点length减1 然后呢就变了a的整个数组，然后把a2数组的每一个元素都给输出 那么这个循环我们希望它输出的结果是0,1,2,3,4 因为a2里面放的就是1234嘛, 再接下来呢我们让a2等于a3. 这个时候我们希望的结果是什么呢 是a2变成和a3一样，那a3呢是一个空数组，那这个时候a2也变成一个空数组 但是要注意，a2 它原来所占有的存空间应该被释放掉 下面这个循环 我们希望它是没有任何输出的 为什么它能做到没有任何输出呢 因为这个时候a2已经变成一个空数组了 既然是一个空数组里面就没有元素, a2点length当然也是0 所以这个循环里面其实不可以进行任何 因此整个循环没有输出，接下来换了一行，输出这里也换了一行 然后呢我们让a下标为3的这个元素等于100，这a 是一个数组嘛它下标为3的元素被扶正成100。下面我们会看到这个变化 下来我们再来一个对象a4 ，a4是一个新的数组，它是用复制过的函数初始化的 那这样我们看的话，a4是等于a的一个复制品,那a4的内容就应该跟a一模一样 但是a跟a4是分别存储在不同的地方的 a跟a4里面的数组存储在不同空间里面 好那a4跟a既然是一模一样，接下来呢我们就把这个a4的内容全部给它输出 那当然输出结果当然是什么0, 1, 2, 100, 4,为什么是100呢 因为当初a下标为3的那个元素被改了对吧 
- 好下边我们整个CArray，CArray呢就是整个可变长整型数组类 我们希望能在这个程序里面能够使用它达到我们想要的结果 那我们写这个CArray的时候要做哪些工作呢 首先我们第一点想到的是，我们肯定写一个类我们要写 构造函数对吧，还要写析构函数真的，然后像这种什么push_back, length这样的成员函数，也当然肯定要写的对吧 然后除此之外我们还要解决一个问题 就是这样CArray的对象，它代表一个数组，它里面需要存放一个数组 那这个数组到底存在那呢？当然我们会需要有一片动态分配的存组空间来放这个数组，对吧，因此我们就能够得出一个结论，那就是 首先我们要用动态分配的内存来存放数组元素 那这一片动态分配的内存你肯定要有一个指针要指向对吧 那我们这个CArray里面就有一个指针成员变量是吧 然后呢这个动态分配内存要释放，那在这个CArray里面什么地方 释放动态分配的内存最合适啊，当然就是在CArray里面的析构函数里面就释放这个内存最合适 对吧，好了然后，然后我们看到这有一条复制语句，这复制语句复制号 我们是不是需要重载啊 这个我们参考前面这个前靠背生考背这个例子，我们知道这个 这样复制号要重载了 然后呢我们看到，这个a2它实在是个对象，但是我们把它用起来的时候 就跟数组的用法是一样的，对吧，因为以前我们看到这个中标号 能怎么使用啊，中号的外面我们从以前上的知识，只能是一个数组的名字 那a2它实际上不是一个数组的名字，它是一个对象的名字 那我们要让这个对象名字加中号也能够成义的话我们得做什么 我们是不是要重载这个中拔号，对吧，重载这个中号 好所以我们知道要重载这个中号，那还要做些什么事情呢？ 我们看看在这，这里用到了这里的CArray的复制 的函数 这个复制的函数能不能用什么呢，大家想想以前所想的前拷贝生拷贝就知道了 它不能用缺省的，为什么呢，可以再解释一下我们要自己写一个复制构造函数，这是我们要做的一些事情 当然还有些别的。
- 现在我们来看一看这个CArray这个类应该怎么编写，
    ```c++
    class CArray {
        private:
            int size;                               //数组元素的个数
            int *ptr;                               //指向动态分配的数组
        public:
            CArray(int s = 0):size(s);              //s代表数组元素的个数
            CArray(CArray &a);
            ~CArray();
            void push_back(int v);                  //用于在数组尾部添加一个元素v
            CArray &operator=(const CArray &a);     //用于数组元素间的赋值
            int length()                            
            {
                return size;                        //返回数组元素个数
            }
            int &CArray::operator[](int i)          //返回值是什么类型？？？返回值为int不行！不支持a[i] = 4;因为返回值可能要作为左值使用，只能返回引用类型
            {
                //用以支持根据下标访问数组元素，
                //如 n = a[i] 和 a[i] = 4; 这样的语句
                return ptr[i];
            }
    };
    CArray::CArray(int s = 0):size(s)
    {
        if(s == 0)
            ptr = NULL;
        else
            ptr = new int[s];
    }
    CArray::CArray(CArray &a)
    {
        if(!a.ptr) {
            ptr = NULL;
            size = 0;
            return;
        }
        ptr = new int[a.size];
        memcpy(ptr,a.ptr,sizeof(int) * a.size);
        size = a.size;
    }
    CArray::~CArray()
    {
        if(ptr)
            delete []ptr;
    }
    CArray &operator=(const CArray &a)              //赋值号的作用是使 “=” 左边对象里存放的数组，大小和内容都和右边的对象一样
    {
        if(ptr == a.ptr)                            //防止 a = a 这样的赋值导致出错
            return *this;
        if(a.ptr == NULL) {
            if(ptr)
                delete []ptr;
            ptr = NULL;
            size = 0;
            return *this;
        }
        if(size < a.size) {                         //如果原有空间足够大，就不用分配新的空间
            if(ptr)
                delete []ptr;
            ptr = new int [a.size];
        }
        memcpy(ptr,a.ptr,sizeof(int) * a.size);
        size = a.size;
        return *this;
    }
    void CArray::push_back(int v)                   //在数组尾部添加一个元素
    {
        if(ptr) {
            int *tmpPtr = new int[size + 1];        //重新分配空间
            memcpy(ptr,a.ptr,sizeof(int) * size);   //拷贝原数组内容
            delete []ptr;
            ptr = tmpPtr;
        } else                                      //数组本来是空的
            ptr = new int[1];
        ptr[size++] = v;                            //加入新的数组元素
    }
    ```
  首先，前面说了我们需要一个指向动态分配的存储空间 因为我们这个数组不是有一个length存在函数对吧，它能够返回数组的长度 那怎么知道数组的长度啊?我们就要用一个size来编，记住这个元素 的个数，然后还要什么呢，我们需要构造函数 有一个普通的构造函数有一个复制构造函数还需要析构函数 这普通的函数这个s呢参数是代表你，一个数组对象，数组化的时候 它里面已经就包含了元素了，这样意思我们等会再解释 然后等会我们还要这个push back 这个成员函数 它用来干嘛呀，用来在数组的尾部添加一个元素 我们当然还要一个印象呼，它用来做完数组之间的这个复制 实现它需要时间生拷贝的这个操作 然后这个length成员函数返回数组元素个数当然就这么写 接下来还有，一个很重要的这个中号 我们把它改成一个CArray的 成员函数，那中问号是双问双符，大家问的这个双问双辅 它的操作符在那呢？一个操作数在中号外面，一个操作数在中号里面 那现在这个双问双符我们把它存改成这个类的成员函数以后 那它就变成应该只有一个参数了对吧 那这唯一的参数应该是什么呢 当然就相当于数组的下标，那个下标呢就是一个整型数 所以这个时候operator 中号就它只有一个整型数i i 就代表数组元素的下标，那我们这个operator ，这个中号能有什么的目的呢 需要能够实现 这样的例句，能够愿意通过而且呢 达到我们想要的这个效果，那你比方说 说n 等 于a i ， 那你就应该能够取出 a i 的复制给n, 对吧，所以这个a i 这个表达式啊 它应该能够发挥，1里面所存放的数组 里面下标为i 的原数的值对吧 那 a 里面存放的数组， a 放在那呢，当然放在有批价那一片零序的存储空间 对吧，那下标为i 的的那个元素，实际上就是什么啊 实上就是这个ptr i, 那我们n 等于 a i, 那我们最希望产生的结果当然就是 n 等于ptr i, 对吧，因此，我们在这里就应该 return ptr i 就行了，但是这里的返回值是什么类型的呢？ 我们还是要思考一的下，啊，到底是什么类型。 哎，公布答案，哎，返回值的类型应该是int的引用。 首先从这个类型匹配的角度来讲，你这里return的是ptr[i]。ptr[i]是一个 int，对吧？ptr[i]是个int那么你这个地方从类型匹配的角度来讲就要么是int；要么是int的引用。 那，嗯，正确答案是int的引用。那返回值为int为什么不行呢？ **啊，返回值为int的话，要实现n=a[i]这个目的是没有问题的。 但是你想要实现a[i]=4这个目的呢就不行了。为什么啊？ 嗯，我们知道这个一个函数的 调用的返回值如果它不是引用的话，我们是不能够把一个函数调用的返回值写在等号 左边的，对吧？就是非引用的函数返回值不可以作为左值使用**。 所以，只要这个函数它返回值不是引用，那么你写这条语句编译的时候就会出错。 啊，另外， 很重要的一点，就是我们写这一条语句，嗯，a[i]=4我们是不是要希望能够修改a[i]的值，对吧？ 也就是说我们希望达到的目的是，a这个数组里面下标为 i的那个元素，它的值应该被修改。 那，那这个a数组里面下标为i的那个元素是什么啊？是不是就ptr[i]啊？ 啊，那么如果 我们希望这条语句能修改ptr[i]的话，那，那这个 这个赋值号左边应该是什么呀？当然就应该是ptr[i]的引用，对吧？ 嗯，只有左边是ptr[i]的引用，那么我们让这个 a[i]等于ptr[i]的引用，然后再让它赋值4的话那就会导致ptr[i]被修改了。 所以这个时候我们要把返回值定义成引用。 唉。再往下看。 现在我们要说到这个构造函数了。啊。这个构造函数呢他有一个参数s. 代表这个，嗯，数组下面被初始化的时候它里面就已经包含多少个元素了。 前面看到这个s有一个确审值是0。就是说你一个数组 如果，数组对象如果被初始化的时候没有指定，嗯，这个参数的话，那这个数组就是空的，里面没有任何元素。 那好，就是说s=0，这个数组就应该是个空的。拿这个ptr呢我们就让它等于NULL。啊，它不是，不指向任何地方。 那，嗯，这个后面呢这个初始化列表已经用s去初始化size了,就size会等于是s了。 嗯，那，那如果这个s是不等于0的话呢，那我们就要动态分配一个存储空间，对吧？ 因为这是一个整型数组，所以我们new一个整数数组出来。嗯，这个new出来的整型数组呢，它里面有s的元素。 然后我们把这个整型数组的地址赋值给ptr,这就完成了这个构造函数的这个作用。 那下面我们再看，啊，我们还需要写这个赋值构造函数。啊，赋值构造的函数呢要完成 嗯，前几章所说的那个深拷贝的这个这个工作。就是说 它需要使得被初始化的那个的对象的内容，变成跟这个a一模一样。 啊，当然这两个对象它不能指向同样的存储空间，对吧？ 我们举，嗯，形象的来看看。假设这有一个a1，啊，a1它里面的ptr指向一片 存储空间。这存放的是数组a1的内容，啊。如果们来执行的这个，嗯，CArray a2 (a1)； 这时，我们说a2就是a(1)的一个赋值品。那这时我们想要达到的效果是什么呢？ 就是你先想，如果我们不自己去写赋值构造函数。 那么执行完这条语句以后，a2会变成什么样？ 什么样啊？那它就是这个样。啊，就是a2里面的ptr 会和a1里面的ptr指向同一个地方。为什么呀？因为我们 不写赋值构造函数的话，编译器自动生成的那个赋值构造函数啊 它会执行赋值的功能。这里所说的赋值的工作， 只是把a1的成员变量赋值到a2里面去。那a1的成员变量ptr 被赋值到a2里面去，那自然a2.ptr就等于a1.ptr。那也就是说， a2的ptr和a1的ptr都指向了同一片存储空间。 对吧？那这个时候我们前面，嗯，前面学的知识，这个是会有问题的。 啊，这是不对的。那么我们正确的结果应该是什么样呢？ 嗯，就是这样。就是a2的ptr指向新的一片存储空间， 然後呢，这片新的存储空间的内容，嗯，跟a1ptr指向的存储空间是一模一样的，对吧？ 嗯，这个才是我们需要达到的这个效果。那么为了达到这个目的我们应该怎么做呢？ 就要看，啊，这个是赋值构造函数的写法。 嗯，在这里呢我怕们要首先判断一下这个a.ptr是不是空。如果a.ptr 是空，也就是说a本来就是一个空数组的话，那我们得让被初始化的这个对象也变成空数组。对吧，所以我们就简单的 把ptr变成NULL，然後size等于0就返回了。那如果 a它不是一个空数组，那我们就要把，嗯，那我们就要把被初始化对象里面的ptr 把它让它指向一片新分配出来的存储空间。然後，a数组里面的 内容拷贝到新分配出来的这个存储空间里面去，对吧？所以就是ptr=new int这样的，啊。 然後呢把，这个就是把a.ptr所指向的 那部分的内容拷贝到ptr所指向的地方去。那一共用拷贝 多少个字节的内容呢？就是这个sizeof(int)*a.size )，对吧？然後我们 把size的成员变量也给他赋值一下。啊，这个就是赋值构造函数。 嗯，那接下来再看，嗯，还有这个 析构函数。那析构函数做什么呢？答案就是释放动态的存储空间。 那释放之前我们也得判断一下，啊，这个ptr是不是空指针。嗯，不是空指针你才去定义的，对吧？ 好了，接下来还有这个，嗯， 我们前面说的这个赋值号也需要把它在重载一下。嗯， 重载的目的是用来实现两个数组对象之间的赋值。那两个数组对象之间的 赋值呢，我们希望达到那种深拷贝的这个，这个，这个效果。也就是说，你写了a1 等于a2的话，那，嗯，a1 的存储空间里面放置的东西就应该和a2的东西一样； 但是a1和a2呢，它们用来放东西的存储空间又是各自独立的，对吧？ 所以这个跟那个赋值构造函数是挺像的。但这边有个小trick，就是我们首先的判断一下, 这个，这个 a的ptr 和被初始化，和被赋值的这个赋值化左边的这个对象的ptr是不是相等的。啊，因为 搞不好会出现a等于a这样的赋值，对吧？那你如果不做这个特判，那可能就会出错。 所以我们先判断一下，如果ptr=a.ptr那我们就什么都不干，直接return*this就行了。 就是 这个函数她的返回值是CArray的引用。这是为了符合这个 赋值号的这个使用的这个惯例。因为在C++语言里面 嗯，赋值号这样一个赋值表达式它的返回值本来就是那个赋值号 左边的那个，那个变量的引用。啊，我们遵循这样的习惯，所以，这个 赋值号被重载以后的返回值仍然是CArray的引用。 嗯，那我们为了类型匹配，当然就return*this, 对吧？ 好了，接下来我们还要看到，如果a.ptr是NULL的话； 那我们就要把，嗯，被赋值的这个对象也变成一个空数组。 那怎么变成一个空数组啊？当然就要ptr-NULL就行了，对吧？但在此之前呢，如果 被赋值的这个数组本身它已经不是空的，那我们就得要 回收它的存储空间。嗯，所以在，在这个前面我们还得先判断一下如果ptr 不是空，就说明这个被赋值的这个，这个数组啊，它原来，嗯，有东西，那我们就要把它的存储空间给它收回。 那这里面还有一点技巧啊，就是，嗯，就是 如果我们每做一下数组，两个数组对象之间的赋值都需要重新分配存储空间的话， 实际上也是有点浪费。所以我们可以这样，我们判断一下，嗯， 两个size。这个size是赋值号左边的那个数组对象， 它的大小，对吧？a.size是赋值号右边的那个， 嗯，数组对象的这个大小。那如果被赋值的那个 数组的容量已经比赋值号右边的那个 还要大，也就是原有的空间已经足够大的话，那我们就干脆不要分配 新的空间。我们就在原有的空间上把新的内容拷贝过来不就行了，对吧？ 所以说，所以说仅当这个原有的空间不够用的时候； 我们才去释放原有的空间，并且重新分配新的空间。 那如果原有的空间足够用了，那我们就直接把新的内容给考过来就行了。 那，memcpy,拷贝新的内容过来就行了。然后，当然size只需要赋值一下，啊，return*this这就可以了。 那最后呢，还有一个，嗯，这个push_back的成员函数 是我们必须写的。啊，push_back的作用就是在数组的尾部添加一个元素。 啊，那我在这里给的是一个写起来简单，但是 效率比较低的做法。啊，效率高的做法呢，嗯，大家可以自己回去实现一下。 嗯，在数组尾巴添加一个元素，那这个时候呢正数组的空间就要重新分配了。 那我们首先先判断啊，如果这个数组原来还是有东西的，那我们就重新分配 这个，嗯， 存储空间。啊，这重新分配的存储空间呢，要比原来的这个数组元素个数还要多一，对吧？ 这新分配的存贮空间，那我们用一个临时的指针指着。 然后呢，我们要把这个，嗯，原来数组的内容拷贝过来。因为， push_back是在数组的尾巴加一个元素，对吧？所以你要把数组原来的内容给拷贝过来。 拷贝到这个临时指针所指向的地方。然後呢，我们再把原来那片存储空间给释它放掉。 啊，然後在让这个ptr指向刚才那个临时的指针。啊 ，那临时的指针已经指向新的数组空间。 那，新的数组空间比原来那个空间多一个元素，对吧？ 嗯，这是分配空间。 那，这是，ptr原来指向一片存储空间的时候，我们要重新分配空间。那如果ptr原来就是空的呢，那我们就直接分配一个元素的存储空间就行了。 那，这些分配空间的事情全部做完以后，我们就要把这个 嗯，v这个元素放到这个新分配的存储空间里面去了，对吧？ 那这条语句就能够在新分配空间的最后的那个位置把v放进去。啊，那这个push_back呢它显然是 嗯，比较低效的。因为你每一次往这个数组添加一个元素，它都要重新分配存储空间。这个 时间上是有比较大的开销。嗯，那比较好的做法是什么呢？ 嗯，就是说我这个，空，空间嘛可以预先分配多一点。 比如说这个数组哪怕是只有一个元素，我一开始也给他32个元素的存储空间， 那么，这个数组的元素个数1 变到32的过程中，我这个空间都不需要重新分配。 对吧？然後你加第33个元素进去的时候，我一下就让这个数组的空间里面变成有64个。 那从33到64这部分，嗯，元素添加的时候呢，也都不需要再重新分配空间了。啊。 然後，你要添加到6，第65个的时候，我让数组空间一下子变到128个。啊 以此类推。这样我们重新分配存储空间的次数就会大大减少。当然这个效率也就，嗯，提高了。 那实际上这个c++,嗯，嗯，标准模版空间有一个vector就是这个可变长的数组， 它的，它也有push_back的成员函数，然後它push_back的实现方法， 就跟我刚才说的这样，采用一种比较搞笑的实现发方法。 
## 5. 流插入运算符和流提取运算符的重载
- 嗯，接下来我们讲一讲这个流插入运算符和流提取运算符的重载。 那我们先引入一个问题。嗯，这个问题就是，诶，我们很经常写的这种形式的东西它为什么能够成立？ 这不是<<算符吗？它为什么能够用在cout的上面，并且把这后面的东西都给它输出呢？ 啊，於是我们就会想这个cout到底是什么东西？ 还有，为什么这个<<运算符能够作用在cout上面？ 那cout是什么呢？嗯，cout实际上是在iostream这个头文件里面定义的一个 对象，啊，它是哪个类的对象呢？是ostream这个类的对象。 那当然ostream这个类也是在iostream这个头文件里面定义的啦！ 那这个<<运算符他为什么能够用在cout的上面呢？ 那我们学过运算符重载，当然你能想象得出来。 嗯，这个<<运算符能用在cout的上面就是因为，在iostream这个 头文件里对这个<<运算符进行了适当的这个重载。 那么大家就可以想象一下这个重载应该是什么样的， 怎么重载才会是的这两个表达式都能够成立呢？ 嗯，那我们知道<<运算符必须重载成一个函数，对吧？那 我们可以把它重载成ostream类的成员函数，也可以重载成一个全局函数。 当然，这，这实际上是取决于人家那个iostream头文件怎么写的，对吧？ 那我们假设如果我想把这个，嗯，<<运算符重载成ostream这个类的成员函数的话。 大概应该怎么做呢？ 嗯，就是我们有可能按下面这种方式 把这个左运算符重载成ostream类的成员函数，对吧？ 嗯，假设这个返回值我们没考虑好就让它 是viod的吧！反正是void看起来也无伤大雅，对吧？ 也许有更好的做法，但我们先让它是void。 然后呢，这是重载成成员函数了。然后它所接受的参数是什么？ 很明显我们可以让它接受一个整型参数，因为我们前面用到了这个cout<<5,对吧? 那显然这个5就是一个参数。所以说我们为了对付这个表达式的话，我们需要做一次重载， 重载的这个函数它应该是int n。 然后在这个重载的这个，嗯，函数里面呢我们在前面当然要把 n给它输出了，对吧？至于n到底怎么输出，那你肯定不再是不会再用什么cout<<于之类的东西了。 假设，假设这个编写这个ostream类的这个，嗯， c++的库的设计者他，他有一些其它的什么办法能够把n 在屏幕上给它输出。那我们对这个<<运算符进行如下的重载就能够应付 这个表达式，使得这个表达式编译能够通过，而且5能够被输出了，对吧？那怎么对付这个表达式呢？ 那当然就应该再做另外一次重载。啊。 就我们看cout<<5 这个表达式它等价于什么呢？它等价于cout.operator<<5，对吧？ 因为这个时候<<运算符被重载成ostream类的成员函数了。那么实际上 这条语句就是在cout这个对象上面调用operator<<这个成员函数，并且以5作为参数。 那cout<<"this"当然就是cout.operator<<(”this“),对吧？那现在我们的问题就是， 如何，做一些什么样的重载才能够是这个表，这个，这个长串的东西能够成立？ 如果我们是仅仅是想让这个，这个表达式和这个表达式分别都能够成立的话， 嗯，很简单，对吧？我们重载两次，一次参数是整型的；一次参数是，是 是差型的就行了。现在要让一个，嗯，这个四子联着写都能够成立我该怎么办呢？ 这时候你就得考虑 这个表达式的返回值的问题了，对吧？C<<5这个表达式它的返回值如果是void， 那么这个void的还能够接着往下运算吗？ 就不行了，对吧？那么cout<<5我们得让它有一个 返回值。这个返回值是什么东西才能够接着往下运算，并且把"this"也给它输出呢？ 那答案很直观的一个想法就是，如果cout<<5它的返回值还是这个cout, 那么，作为返回值存在的这个cout就能够接着再往下跟”this“进行这个运算，然後就能把"this"输出了，对吧？ 这是一种很直观的想法 。因此，我们就可以 修改一下前面存在左运算符的这个，这个方式。我们在这里呢把这个返回值的类型改成了ostream的引用。 注意啊，我们现在的目的是想要使得这个<<运算符 它能够返回cout。就是cout<<5这个表达式它能够返回cout。那怎么做到这一点啊？ 我们就让它的返回值是ostream的引用，然後我们在这个成员函数里面 return*this。那这个*this指针是指向了这个，嗯，成员函数 做作用的对象，对吧？那我们如果，嗯，执行cout<<5，那这个this指针当然就指向了cout了，对吧？ 那*this就是cout。 那这个成员函数它的返回值是一个ostream类的引用，然後我们return*this *this就是cout的话，那实际上这个函数的返回值 实际上就是 ，就是会是cout的引用，对吧？ 那同理，我们，嗯，对这个， 以const char* 为参数的这一次的重载 也要把它的返回值设置成ostream引用。那么我们就可以看到 这样一条，这样一个表达式 我们把它，嗯，写成函数这样的形式它会是什么样的东西呢？ 它就是cout.operator<<(5).operator<<("this")对吧？ 因为我们看到前面这部分它当然就等价于cout.operator<<(5)，对吧？ 那现在我们让这个部分的返回值还能够接着往下运算，怎么做到这一点呢？ 那大家可以知道了，如果前面这个表达式它的返回值就是cout， 那也就是说cout.operator<<(5)这个表达式它的返回值如果就是cout的话， 那么这个cout还可以在下面， 嗯，那么就接下来还可以在cout的上面执行 operator <<成员函数，并且以"this"作文参数去调用这个成员函数，那this就会被输出了。 所以上面这个表达式它所对应的函数调用的形式就是这样，啊。 前面这部分返回了cout,然後就接着这个cout的下面执行cout.operator<<("this")。 那我们前面解释了这个，嗯，<<运算符的重载。我们下面看看如果要写这样一个程序，
    ```C++
    class CStudent {
        public:
            int nAge;
    };
    int main()
    {
        CStudent s;
        s.nAge = 5;
        cout << s << "hello";
        return 0;
    }
    ```
  啊，这里有一个CStudent的它里面有一个年龄， 然後在main里面定义一个CStudent的对象，然後对年龄进行赋值。然后呢，我们可以把s就是这个CStudent的对象交给cout进行输出。 那么交给cout进行输出的时候呢，会输出s的年龄。 也就是说这个，我们希望这个程序输出5hello，那5当然就是s的年龄了，对吧？ 那我们要做些什么呢？那很明显嘛！你得重载这个<<运算符。 因为，因为，你不重载的话，cout没法跟这个s做这个运算，所以我们要重载这个<<运算符。 那怎么重载呢？嗯， 你，你，嗯， cout是ostream类的对象，ostream类早就在iostream这个头文件里面都写好了。 你不可能在为它添加什么成员函数了。所以在这里我们重载<<运算符的时候肯定只能重载成一个全局函数； 而不是把它重载成什么ostrean的成员函数，你不可能做这一点。那我们怎么做呢？ 啊，把这个<<运算符重载成一个全局的函数。 啊，那重载成全局的函数它肯定就是，嗯， 操作数的这个数目等于这个函数的参数个数，对吧？所以它有两个参数。第二个参数很明显 就应该和这个，嗯, CStuden的对象能够匹配的。那第二个参数可以是CStudent的对象， 也可以是CStudent的，的引用。都能够做到类型匹配。那我们取，取它为CStudent的引用， 能够节省这个，嗯，时间和空间，对吧？因为我们不需要形成寻常对象。寻常对象要能够调用赋值过的函数是有开销的。 然後，嗯，既然是CStudent的引用，然後我们在这个程序里面又不会去修改s的值。 所以我就把这个引用变成const了，这是第二个参数。那第一个参数是什么呢？ 嗯， 要执行cout<<s，对吧？那第一个参数肯定要对于cout。 那cout是ostream的对象，那我们第一个参数的类型就应该是ostream的对象；或者是ostream的引用。 在这里为了这个节省开销，我们让它成为ostream的这个引用。 啊，然後呢，我们在这里面 这是一个ostream的这个引用。那么，这个，程，程序 程序走到这里面的时候，o是谁啊？o实际上就是引用了cout。 那也就是说o就是cout，对吧？所以我们直接在这里把s.nAge 给这个cout，这个s.nAge就能够在屏幕上输出了。 然后就完，这就完成了输出的这个工作。 那，那我们这个函数它的这个返回值我们也是需要考虑一下的。不能随便写一个void。 为什么不能随便写一个void呢？因为这个表达式执行完了以后，它还要接着往下运算。 所以我们希望这个表达式它的返回值应该还是cout，这样才能够接着往下运算，对吧？ 那你怎么让这个表达式它的返回值仍然是cout的呢？ 那就我们就重载这个函数的时候，返回值的类型就有讲究了。啊，我们就让它是ostream的这个引用。 然后我们注意到，进到这个函数里面来的时候，这个o是cout的引用。也就是说 o等价于cout。那我们希望这个函数返回值仍然是这个cout，怎么做呢？ 我们就return o就行了，因为0是cout的引用，对吧？然後，这个函数的返回值也是一个ostream的引用。 那么，return o也就是这个函数的返回值，就是cout的引用，那就等价于cout。那问题就解决了。 我额外再说一点啊，如果你这一块不写引用，写ostream的对象，实际上编译是不过的，那是有一些其他的原因， 这里就不再细说了。 
  
- 那下面再看一个复杂一点的这个，这个例题啊。 就是我们假定c是Complex复数类的对象，啊，然后现在我们希望写这个cout《c， 就能够以a+bi的形式输出c的值。 然后写cin》c 就能够从键盘接受a+bi这种形式的输入， 并且使得c. real=a，c. imag=b。我们希望能做到这一点，该怎么办？ 大家可以想想。这个我们在，我刚刚讲的时候都把这两个东西称为 左移、右移运算符，那我们标题又写的是，是流插入和流提取运算符啊。 那大家注意了，实际上在C++的语法里面，这两个东西就是左移，左移和右移运算符。 只不过，把它重载了以后，它经常用于输入输出，所以它就得了另外一个名字叫做流插入和流，流提取而已，啊。 本质上它还是左移右移运算符被重载了。 那现在我们再看这个题，呃，该怎么做。 肯定我们要重载左移 运算符，也要重载右移运算符，对吧。那我们得搞清楚cin到底是个什么东西。 那cout是ostream类的对象，cin是istream的对象。 就是我们希望，呃，有个Com，复数类，我们写好了，它里面有实部和虚部，然后我们可以，可以 来这个cin、c、n，呃， n是整型的，这c是一个复数的对象，我们希望这个，这条语句能够 编译通过，而且它执行的效果是这样的，就是，呃，当等待输入的时候，我们敲了13.2+133i， 再空格87，结果呢，这个13.2+133i就会被读到c里面去。 也就是说c这个复数它的实部是13.2，虚部是133，当然n的值就是87,，对吧。 然后我们接下来又可以把这个c， 这个复数对象交给cout去输出，输出完以后就是，就是a+bi的一种复数的形式， 就是13.2+133i，然后这个逗号，再87。这是我们希望达到的这个，这个，希望达到的这个效果。 那么我们就要重载左移运算符和这个右移运算符，啊。 这整个完整的程序是这样的。这复数类是有实部和虚部。 然后呢，这个复数类有一个构造函数，构造函数呢用来对这个， 呃，real，就是实部，以r，参数r 赋初值，对虚部以i 赋初值。 然后呢，我们说了这个左移右移运算符，我们要把它重载。 在这里，我们只能重载成全局函数了，对吧，你不可能再把它重载成 Ostream类或者istream类的这个成员函数，因为那两个类都已经写好了。 所以我们必须把这，这个左移运算符和右移运算符重载成一个全局的函数。 那在这个Complex类里面呢，这两个 成员变量又都是私有的，那我们这两个全局函数又要访问Complex类的私有的成员，那怎么办啊？ 那解决办法就是我们 把这个重载出来的这个左移和右移运算符把它声明为Complex类的友元，所以我们在这里声明一下，friend。 啊，这个是左移运算符重载，这个是右移运算符重载，都变成友元。 然后我们来看这个左移运算符怎么重载的。 啊，那它的返回值应该是ostream的引用，理由前面已经说过了。 因为我们输出一个Complex对象以后，还能接着用左移运算符运算。 接着输，输出后面的整数啊，什么字符串之类的。所以它的返回值应该 还是一个引用，最好。然后这个程序，这个函数被执行的时候，返回值依然是这个cout的引用嘛。 它第一个参数是这样的，第二个参数是这个Complex的 对象的引用。然后在这里面呢，我们就，就把这个c， 这个复数啊，以a+bi这种形式输出。那当然就是， 这个，这个os是什么呀？ 这个os当然就会是cout，对吧。所以我们就会把这个c. real给cout，然后再输出一个加号，再把这个c.imag 再，再给这个，前面这个，这个表达式的返回值，就是也是cout。 然后再输出一个i。这样以a+bi的形式就输出了这个复数c的值。然后我们return os，这个os 会是什么东西啊？会是cout的引用，对吧。我们return os使得整个函数的返回值仍然是cout。 那我们再来看看这个右移运算符该怎么重载。那我们得知道cin它是 istream的类对象，对吧。所以这个时候我们重载成全局函数的时候，返回值应该是istream 对象的引用。第一个参数是istream的引用，第二个参数呢是这个复数 对象的引用。然后，在这里面要做的事情就是要把这个a+b形式的输入， 把它里面的实部a和b分离出来，读到这个c里面去。 那a+b形式的输入，我们可以作为字符串string 对象给它读入。 这里面关于string对象的一些细节，大家可以先不用深究，啊，后面还会仔细讲到。在这里， 这个片子的主要目的还是向大家演示这个右移运算符该怎么重载。 总而言之，我们可以通过这个is，is是什么呢？ 执行到这个函数的时候，is当然就是cin了，对吧。我们通过这个cin就能够把一个a+b形式的字符串读到这个 s里面，啊。然后，我们就要在s里面把a和b分离出来。那分离的方法当然就是找到这个+号， 然后呢，取+号前面的a再取+号后面的一个b。这里面是有一些这个过程，这些过程我就 不详细说了，因为不是这，这堂课的重点。总而言之，我们把这个， 呃，s里面+号前面的a和b都，+号前面的a和+号后面的b都分离出来以后， 我们在这个就把这个a分离出来放到实部里面。 然后呢，把这个b分离出来放到这个虚部里面。 那，那么a+b所代表的的复数就被读到c里面去了。 然后我们就可以return is了，这is是什么呢？就是cin，对吧。那这个，这个右移运算符它的返回值 还是cin。然后，然后，也就是说我们，呃， 从这个 键盘读取了c以后，这个表达式的返回值还是cin，那cin还能够 跟着下面的这个n继续做运算，啊，你在后面再输入别的都行也都行。 
## 6. 自增/自减运算符的重载
- 大家好，在这一小节中，我们来看一下自加自减运算符的重载。 那么自加自减运算符呢是C语言当中定义 的非常重要的，并且表达形式是非常简洁的一种运算符。 那么自加自减运算符呢，它本身只有两种形式。我们称这为前置和后置。 所谓前置的运算符呢就是指说， 这个++符号呢，出现在对应的这个变量的前面。 而后置呢，就是说我们先定义这个变量 之后呢，再去写这个++运算符。 那么++i呢和i++呢是两种不同的计算形式。 虽然它都可以实现自加的功能，但是呢计算结果是有一定区别的。 我们来看，当这个自加自减运算符呢 本身也要实现运算符重载的时候， 对于前置运算符，啊，也就是我们刚才提到的这种++i的形式， 那么我们就可以把它实现为一个一元运算符的重载。 那么重载的形式呢，可以有两种。一种呢，就是把它定义为一个成员函数。 那么定义为成为函数的话呢，我们可以看到说，其 函数的这个定义呢，函数名就是operator++，或者operator--。 那么它的这个函数的参数呢是没有的。 而返回值就是相应的这个对象的这个对应的这个类型。 此外呢，我们也可以把这个 ++运算符呢，或者说--运算符这个前置运算符定义为这个全局函数。 嗯，就定义非成员的函数。那如果它是一个全局函数的时候的话呢 那么它就必须包含一个参数。这个参数呢是必须将这个相应对象的类型呢传递 以参数的形式传递进来。那么返回值呢也是相应的这样的一个对，相应类型的一个对象。 那么我们看到说呢，这个++object，objective operator++, 以及operator++括号orj 这样三种形式呢，都是去调用这样的一个前置运算符。 那么同样的，对于后置运算符来讲呢， 我们在运算符重载的时候需要把它设计为一个二元运算符。 所谓二元运算符呢，就是说这运算符前后是应该 包含了两个参数的。 那么由于它要区别于之前置的， 所以呢，定义为二元运算符的时候，就需要去多写一个参数。 但是本身呢，这个参数呢，其实是具体没有意义的。 我们看到说，这个如果我们需要把这个 后置运算符重载为成员函数或全局函数的时候， 像于刚刚讲到的，前置运算符，那么它呢会去传递一个 参数。这个参数本身呢只是用来去标记这个重载的运算符呢是后置的， 而没有更多的其他意义。那么通常来讲的话呢，int是自动去把这个对应的值呢 初始化为一个默认的临值，所以呢对objective++，objective operator++和objective++(obj,0)， 都去调用上面这样的一个后置运算符的一个运算符重载函数。 那么我们来看一个具体的例子。
    ```C++
    //program,重载 ++ 和 --
    #include <iostream>
    using namespace::std;

    class CDemo {
        private:
            int n;
        public:
            CDemo(int i = 0):n(i) {}
            CDemo operator++();                                 //用于前置形式
            CDemo operator++(int);                              //用于后置形式
            operator int()
            {
                return n;
            }
            friend CDemo operator--(CDemo&);
            friend CDemo operator--(CDemo&,int);
    };

    CDemo CDemo::operator++()
    {
        //前置++
        n++;
        return *this;
    }

    CDemo CDemo::operator++(int k)
    {
        //后置++
        CDemo tmp(*this);                                        //记录修改前的对象
        n++;
        return tmp;                                              //返回修改前的对象
    }

    CDemo operator--(CDemo &d)
    {
        //前置--
        d.n--;
        return d;
    }

    CDemo operator--(CDemo &d,int)
    {
        //后置--
        CDemo tmp(d);
        d.n--;
        return tmp;
    }

    int main()
    {
        CDemo d(5);
        cout << (d++) << ",";                                     //等价于 d.operator++(0)
        cout << d << ",";                                     
        cout << (++d) << ",";                                     //等价于 d.operator++()
        cout << d << endl; 
        cout << (d--) << ",";                                     //等价于 d.operator--(d,0)
        cout << d << ",";
        cout << (--d) << ",";                                     //等价于 d.operator--(d)
        cout << d << endl;
        system("pause");
        return 0;
    }
    ```
  如果我们希望能够去设计一个 叫做CDemo的一个main。这个CDemo呢，它具体可以实现怎么样的一个功能呢？ 它可以去实现使得CDemo类型的对象d， 可以呢自动地实现d++，++d，以及d--和--d这样的功能。 并且呢还能够使得CDemo类型的 这样的一个对象d呢，可以直接利用cout 这样打印输出出来。啊，那么这时候我们可以看到说刚才我们已经介绍了， 当这个运算符++和--进行重载的时候呢，我们其实可以把它设计成 一个成员函数。啊，那么这时候的话呢我们就需要去相应的 去变成调用d点operator++。对吧，d是这个 对象以及它的成员函数。那么同样的，这是 后置的，这是前置的。它们两个的差别只是一个参数。 对于--也是一样。它同样都可以去北定义为是一个operator-- 这样的形式。 我们同时呢，也可以把它写成是一个全局函数的形式，就是说 它不是去调用了一个成员函数。那这个时候呢，它就可以写成 是去调用一个对应要传递相应的对象。 以及如果是后置的，那还有一个额外的参数零。 那么这个程序的话呢，我们可以看到它的输出结果呢 如果要保证5，6，7，7和7，6，5，5这样的一个形式的话呢 我们就必须要让它实现相应的自加和自减的功能，对吧。 我们可以看到说呢，我们在这里呢，我们首先去初始化的这个，在勾搭函数里去初始化的对象d。 那么，当它是后置++的这样的功能的时候呢 我们自然会在第一个语句里面cout了出来5， 并且实现了d进行++的这样一个功能。那么之后的话呢， 我们在下一步的cout d里面，它就会输出6。对吧，因为d已经自加过一次了。 之后呢，我们又去进一步实现++d，也就是前置这个自加的功能。 那么这个时候的话呢，在这一步输出的时候呢，d已经被添加为，又加了一个1。 所以输出是7。那么这个时候，++d已经完成了这个自加的 运算之后呢，那么这一步输出d的时候呢值是不变的，依然是7。 那么相应的也是一样。于--来讲，这个--呢，因为是后置的， 所以我们看到说，首先呢，打印输出的还是7的，之前的一个当前值7， 呃，d的一个当前值7。那么在执行了这个语句之后呢，它就完成了--的这样一个操作。 那么，它相应的这个d，在cout的d里面呢，它输出的就是6 如果呢，是--d，啊，刚才是d--，现在是--d，那么我们首先应该去执行--的功能。 所以在这个cout语句里，它就直接打印输出5。而--d已经执行了 自减完了之后呢，它相应了输出原来是保持一致的，所以也是5。 那么我们看到说，在CDemo这个类里面，它需要完成的就是关于 这个自加和自减两种形式的这么的一个重，运算符重载。 此外呢，刚才我提到说，因为呢，我们要去实现CDemo这样的一个类对象 CDemo的这样一个类型的对象的打印输出。 那cout本身，这样的一个流输出符，它不支持 你自身的其他任意类型的输出的。那么我们如何可以实现这样的一个输出， 输出成像一个整数一样的一个形式呢？我们就必须另外去设计一个 强制类型转换符的一个运算符的重载，啊，使得 这个对象可以像整形的数一样，被cout出来。 我们来具体看一下这个CDemo类的设计。 我们看到说呢，对于CDemo来讲， 那么它包含的一个private类型的 成员对象，成员变量int n。 此外的话呢，我们在CDemo里头，首先第一步要设计的就是还有一个相应的构造等数。 那么这个构造函数就是利用这个i参数去初始化n。 之后的话呢，我们还需要去定义这个operator++,是吧。 operator++，我们都以这个相应的 成员形式的函数来设计。那么注意了，包含这个参数标记的呢，是后置的类型。 此外呢，我们刚提到说，为了保证cout可以输出相应的这个对象值，我们还设计了一个 int型这样的一个强制类型转换符的一个运算符 重载。那么写的形式就是operator int。 此外呢，我们还定义了两个这个全局函数。我们要把它声明为 是有元。那么它才能够去访问相应的这样一个int n。 那么，这时候呢，我们把这个--的这两个operator， 都把它这个，重载为相应的这样一个有元的全局函数。 那么在这个里面的话呢，也是一样的。由于后置呢，需要加一个int。 那么这时候我们看到了。具体的定义，每一个重载的函数其实是非常简单的。 对于一个前置的++运算符，对吧，所谓前置就是++i这样的形式。那么我们首先需要做的是， 就是去实现具体将CDemo里头的这个n 去进行++。完了之后呢去return当前的这个 this指针，就可以了。 那么同样的对于后置的这个，呃 ++来讲，因为它是实现了i++的功能。所以呢，首先应该返回的 是这个i值，所以我们在这里面，首先去返回CDemo类型的这个 this指针。完了之后的话呢，我们再让它去做n++的这样的一个操作。 完了呢，之后呢，我们就会去这个，嗯，返回相应的这个。 首先，大家去定义这个temp，对吧，就是我们要首先要让它去标记说我们把当前的这个 对象的这个值呢保存下来。然后呢，去进行n++。 之后呢，再回去返回这个修改前的这个对象temp。 那么同样的，后置的这个‘- -’ 是一样的。只不过呢， 最大的区别就在于我们当时声明这两个函数呢， 分别都是这个，呃，全局函数，所以呢，它前面是没有这样的一个CDemo， 这个双冒号的一个标记的。嗯，它不是成员函数。 那，它完全的功能也是一样的，都是去，去实现这样的一个，啊，‘- -’，然后去 return d。啊，或者是首先保留d的当前的一个状态， 完了之后就做这个d点n--，之后再return temp。 这样的一个操作。 那么另外呢，我们在这里强调一点，就是我们在这边呢， 还是需要去，为了去完成整个CDemo的这样一个类 的实现呢，我们需要去定义这样的一个operator int 的一个类型强制 转换运算符的重载。嗯，这个int呢，不再是第一个 整形，变量的类型了。那么，它实际上我们可以看作是嗯， 当我们去定义了一个Demo s，这样的一个对象的时候， 我们如果这样去写啊，int 括号，然后s， 它本相是什么呢？就是当你如果定义好了这样的一个int， 的这个运算符重载的话呢，那么它现在调用的就是s.int，这样的一个函数。 那么它可以强制的把这样的一个对象转换成为一个int类型的一个值。 那么类型转换运算符重载的时候呢是不能够，注意，不能够写返回值类型的。 那么它实际上呢主要是因为其返回值呢 就是我们在做类型转换运算符时候的那个类型啦。 那么我们在设计运算符重载的时候呢还要注意这几个问题。 一个就是++语法规定呢是不允许你自己新定义 新的运算符的吧。你可以借用一些需要的运算符是扩大它的功能， 去进行运算符重载，但是你不能按照自己的创意去定义新的运算符。 另外呢，我们在进行运算符重载的时候，我们希望重载之后的这个运算符 的含义本身呢，它是能够符合我们日常的一些理解行规的一些数学的一些思路的逻辑的。 啊，我们去定义一个加法，去定义一个大于号，或者去定义这样的一个，这个 等号的一个负值等等，我们希望它能够满足传统的一些 我们在数学上，或者一些像逻辑上的一些判断，啊。 此外呢，运算符重载是不能够改变运算符的优先级的。我们都知道每一个运算符都有相应的一个 优先级。那么在你重载的时候是不能够去改变这些的。 另外呢，有一些运算符呢，是不能够被重载的。比方说这里的这个，啊，点 点星花，双冒号，这个三位运算符， 问号，冒号，以及sizeof等等。 那么此外还要注意就是重载运算符，小括号，方括号，啊 以及这个，呃，指针符的时候呢，我们要注意，还有以及赋值运算符 等号的时候呢，我们要注意说呢，这个运算符重载，必须 声明为是一个类的成员函数，啊，虽然说 我们之前强调说这个运算符重载呢有两种形式。 一种可以把它声明为是一个普通的函数，然后把它可以作为一个有员的形式呢，放到类里面来， 然后还有一种呢，是这个成员函数。那么当你遇到这样几种特殊的运算符 进行重载的时候呢，我们要注意，它只能被生命为是类的成员。 