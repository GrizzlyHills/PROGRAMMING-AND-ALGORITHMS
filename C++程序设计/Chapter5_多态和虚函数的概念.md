# [多态与虚函数](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/6)
> 多态是指同一名字的事物可以完成不同的功能，例如有几个相似而不完全相同的对象，有时人们要求在向它们发出同一个消息时，它们的反应各不相同，分别执行不同的操作。在C++中，所谓多态性是指由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。多态性是面向对象程序设计的一个重要特征，能有效增加程序的灵活性。
## 1. 多态和虚函数的基本概念
- 下面讲讲重要的概念，虚函数和多态。 多态是面向对象程序设计里面非常重要的这个机制。它能很有效的提高程序的可扩充性。 那有些程序设计语言有 被对象继承的概念，但是没有多态的概念，那这样的程序设计语言 只能被称作基于对象的程序设计语言，而不能称为面向对象的语言， 比方说visual basic就是这样。
- 那说iii之前首先我们给提一下这个虚函数， 虚函数的概念挺简单的， 就是一个成员函数在类里面声明它的时候前面加个virtual关键字，那这个成员函数就称为虚函数。 那为什么关键字只用在类定义里，声明函数的时候？ 我们把函数体拿到外面来写的时候呢不要写virtual关键字了， 而且要注意，构造函数和静态成员函数它不能是虚函数。 那虚函数跟普通函数的本质差别实际上就在于虚函数可以参与多态， 而普通的成员函数不能。 那多态呢它有两种表现形式，我们看，第一种表现形式。 
  - 第一种表现形式是这样的。首先我们得知道，一个派生类的指针它可以赋值给基类指针，对吧，这是赋值兼容规则。 **那如果通过基类指针调用基类和派生类中的 同名虚函数的时候，啊，注意，这是虚函数啊，在这种情况下，如果 这个指针指向一个基类的对象，那么被调用的就是基类的虚函数。 如果这个指针指向一个派生类的对象，那么被调用的 就是派生类的虚函数。这样的机制就叫做“多态”**。 那这个好像跟我们前面说的有点不一样。那主要差别在哪呢？差别就在于啊， 这个时候被调用的是虚函数，而我们前面说的类似的 通过基类指针调用基类和派生类里面同名的函数 那被执行的就是基类的那个函数，而前面说这个结论的时候呢 那些被调用的函数并不是虚函数。 好这就是多态的第一种表现形式。通过基类的指针来实现的。 那 具体看这个例子。
    ```C++
    class CBase {
        public:
            virtual void SomeVirtualFunction() {}
    };

    class CDerived:public CBase {
        public:
            virtual void SomeVirtualFunction() {}
    };

    int main()
    {
        CDerived ODerived;
        CBase *p = &ODerived;
        p->SomeVirtualFunction();               //调用哪个虚函数取决于p指向哪种类型的对象
        return 0;
    }
    ```  
    在CBase里面有一个虚函数叫SomeVirtualFunction， CDerived是从CBase派生出来，它也有一个虚函数，同名虚函数，同参数表达， 也叫SomeVirtualFunction，然后我们在main里面看，我们让一个基类的指针p指向了 这个派生类的对象，然后我们通过基类指针去调用这个同名虚函数SomeVirtualFunction， 那这个时候程序执行到这的时候， p指向的是哪一个类型的对象， SomeVirtualFunction就是哪一个类的SomeVirtualFunction 在编译的时候是没有办法确定这条语句调用哪一个类的SomeVirtualFunction的，具体到这个程序里面， 当程序走到这条语句的时候，我们看到，p指向的是派生类的对象，CDerived类的对象， 所以这条语句就会执行CDerived类的 SomeVirtualFunction，如果前面的语句不是这样的， 它使得程序走到这的时候p指向的是一个基类，CBase的对象，那么在此处被调用的就会是基类的SomeVirtualFunction。 这个就是多态的第一种表现形式。
  - 多态还有另外一种表现形式， 啊我们知道派生类的对象可以赋值给基类引用，然后我们通过基类的引用可以调用 基类和派生类中的同名虚函数，在这种情况下，通过这个引用， 引用的是一个基类的对象，那么被调用的就是基类的虚函数。啊如果这个引用引用的是一个派生类的对象， 那么被调用的就是派生类的虚函数。这种机制也叫做多态。看这个例子。 
    ```C++
    class CBase {
        public:
            virtual void SomeVirtualFunction() {}
    };

    class CDerived:public CBase {
        public:
            virtual void SomeVirtualFunction() {}
    };

    int main()
    {
        CDerived ODerived;
        CBase &r = ODerived;
        r.SomeVirtualFunction();               //调用哪个虚函数取决于r引用哪种类型的对象
        return 0;
    }
    ```    
    CBase和CDerived里面都有同名虚函数SomeVirtualFunction，啊，然后在main里面呢 我们让一个CBase基类的引用了一个派生类的对象， 那么当程序走到这条语句的时候 由于这个r引用的是一个派生类的对象， 所以此时被调用的就是派生类的SomeVirtualFunction。但实际上这条语句是多态， 如果前面的代码不是这样的，当程序走到这的时候如果r引用了 基类的对象，那么此时被调用的就会是基类的SomeVirtualFunction了。
- 再看一个多态的简单例子。
    ```C++
    class A {
        public:
            virtual void Print()
            {
                cout << "A::Print" << endl;
            }
    };
    class B:public A {
        public:
            virtual void Print()
            {
                cout << "B::Print" << endl;
            }
    };
    class D:public A {
        public:
            virtual void Print()
            {
                cout << "D::Print" << endl;
            }
    };
    class E:public B {
        public:
            virtual void Print()
            {
                cout << "E::Print" << endl;
            }
    };

    int main()
    {
        A a;
        B b;
        E e;
        D d;
        A *pa = &a;
        B *pb = &b;
        D *pd = &d;
        E *pe = &e;

        pa->Print();                //a.Print()被调用，输出：A::Print
        pa = pb;
        pa->Print();                //b.Print()被调用，输出：B::Print
        pa = pd;
        pa->Print();                //d.Print()被调用，输出：D::Print
        pa = pe;
        pa->Print();                //e.Print()被调用，输出：E::Print
        return 0;
    }
    ```  
  这里有class A, 它有虚函数Print，它输出A::Print，那class B,从A派生而来， 它也有虚函数Print，输出B::Print，下面这个class D，它也从A派生而来， 它的Print当然就输出D::Print，然后class E呢又是从B派生而来，它的Print输出E::Print， 呃，这四个类的关系是这样的。其中这个E呢是A的一个间接派生类。 那我们看在main里面，一开始我们定义的若干个对象， 初始化了若干个指针，从这些对象的名字和指针的名字上就能看出他们的这个类型， 然后我们来让pa->Print()， 这条语句执行的是哪一个类的Print呢？啊我们要注意到这条语句实际上它是多态， 为什么啊，因为pa是基类的指针，啊，Print是基类和各个派生类里面都有的 同名虚函数，所以这条语句就是多态。那就要看pa这个时候指向的到底是哪一个类的对象了。 那我们看到，程序走到这的时候pa指向的是什么，是class A的对象， 因此说这条语句的输出结果就是调用了class A的Print输出这个 A::Print，然后我们让pa=pb 那这时候pa呢就指向了这个class B的对象， 所以接下来的这条语句根据多态的原则，就应该执行class B的Print, B::Print，接下来我们让这个pa=pd，那这时候pa呢就指向了一个class D的对象， 那么下面再输出，呃，再调用main的时候当然就调用class D的Print, 然后呢再让pa=pe，这时候pa指向一个class E的对象， 那class E呢它是class A的间接派生类，那么这个 多态的原则在这条语句仍然适用，所以就可以输出class E的这个 Print，
- **那多态到底有什么用呢？多态前面已经说了它能够很有效的提高程序的这个可扩充性， 什么叫可扩充性呢？就是当一个程序需要 修改或者增加新的功能的时候，你这个程序 所做的改动或者所做的增加量比较少，那你这个程序的可扩充性就是好的**。 
## 2. 使用多态的游戏程序实例
- 下面来看一个在游戏程序中使用多态的例子。啊，用于说明多态是如何起到程序的可扩充性的。 我们以我十几年前玩的一个游戏叫做魔法门之英雄无敌为例，游戏里面有 各种各样的怪物，双方都可以指挥几个怪物跟别人去打， 那很显然在这样一个游戏里面呢每种怪物都应该是 有一个类来代表，而每一个具体的怪物就会是一个对象， 比方说用这个CSoldier代表士兵，CPhonex代表凤凰，CDragon代表龙等等， 那么每一种怪物呢，它们都要和敌人作战， 怪物之间互相攻击，攻击的是就会做出动作，啊，这些动作当然都是用成员函数来实现啦。 比如挥舞一把宝剑，啊，放出一个气功炮等等，那怪物呢它还会被别人攻击的时候也会受伤，受伤也会做出各种各样的动作， 会流血，会抖一下，如果血没了就会倒地死去。啊， 这些当然都是通过成员函数来做啦。 那这些怪物它有基本的成员变量，就是它的攻击力和生命值， 那这样的游戏通常会需要升级，啊，添加新的怪物， 比方说我们要加一个新的怪物叫做雷鸟，就这个东西啊， 那怎么样编程？我们这游戏原来怎么写 才会使得升级的时候要增加一个新怪物，然后我这个代码量会增加的比较少呢？ 这就是我们需要解决的这个问题。 
- 那下面我们通过多态的实现方式和非多态实现方式的对比 就能够看出多态的实现方式在添加新的怪物的时候，原来的程序锁需要做的改动会比非多态的实验程式要少很多。 那不管用不用多态，我们这个程序的基本思路都是这样的，就是我们要为每一个怪物 编写Attack,FightBack或者Hurted的成员函数。 这个Attack成员函数用来表现攻击的动作，啊，它会攻击某个怪物， 然后Attack还要调用被攻击怪物的Hurted成员函数， 这个被攻击怪物的Hurted成员函数就会减少 被攻击怪物的生命值，然后这个 Attack成员函数呢还需要被攻击怪物的FightBack成员函数， 这样就能够接受被攻击怪物的反击， 那Hurted函数就减少自身的生命值并且表现出受伤的动作， FightBack成员函数表现反击这样的一个动作， 然后调用被反击对象的Hurted成员函数使这个被反击对象受伤， 那我知道了， 各类的怪物都有一些共同的特点，比方说它有生命值，还有这个攻击力，还有上述的 Attack，FightBack，Hurted成员函数，因此我们就应该设置一个基类CCreature， 这个CCreature概括了所有怪物的共同特点， 然后我们具体的某一种怪物比如说龙啊，狼啊什么的，我们这些类呢都从CCreature类 派生而来。CCreature是个基类它派生出CDragon代表龙，CWolf代表狼，CSoldier代表士兵， 这是基本的思路。
- 那接下来我们先看，如果我不使用多态这个程序改怎么写。 
    ```C++
    //非多态的实现方法
    class CCreature {
        protect:
            int nPower;         //代表攻击力
            int nLifeValue;     //代表生命值
    };
    class CDragon:public CCreature {
        public:
            void Attack(Cwoldf *pWolf)
            {
                //表现攻击动作的代码
                //................
                pWolf->Hurted(nPower);
                pWolf->FightBack(this);
            }
            void Attack(CGhost *pGhost)
            {
                //表现攻击动作的代码
                //................
                pGhost->Hurted(nPower);
                pGhost->FightBack(this);
            }
            void Hurted(int nPower)
            {
                //表现受伤动作的代码
                //................
                nLifeValue -= nPower;
            }
            void FightBack(CWolf *pWolf)
            {
                //表现反击动作的代码
                //................
                pWolf->Hurted(nPower/2);
            }
            void FightBack(CWolf *pGhost)
            {
                //表现反击动作的代码
                //................
                pGhost->Hurted(nPower/2);
            }       
    //有n种怪物，CDragon类中就会有n个Attack成员函数，以及n个FightBack成员函数，对于其他类也如此。                 
    };
    ```
  当然我们需要有一个CCreature类，对吧，它概括了所有类的共同特点。 还有Power攻击力LifeValue生命值两个成员变量，然后呢 CCreature类就是这样了，但是其他的类都是从CCreature类 派生而来，比如CDragon这个类它是从CCreature类派生而来的， 那CDragon这个类里面有Attack这个成员函数，但是呢一个Attack成员函数 不够用，为什么啊，因为一个CDragon类的对象它要攻击各种各样的其他种类的这个怪物， 比方说要攻击狼这个怪物，那它就需要一个Attack成员函数， 这个Attack成员函数呢接收一个CWolf新的指针作为参数， 这个指针就会指向被攻击的那一只狼，那在这个Attack里面， 先写一些代码，表现出那个很炫的攻击的动作， 接下来，就要调用 被攻击对象的Hurted成员函数。我们看到被攻击对象是由pWolf 这个指针所指向的，我们在这里调用被攻击对象的Hurted成员函数。 并且以Power，nPower就是攻击力作为参数传进去，这样就能够使得被攻击对象受伤， 那你传进去的这个nPower越大呢，那个被攻击的对象受到的伤害可能就越大。 然后如果被攻击对象如果没有被打死的话我们还要用 被攻击对象的FightBack成员函数使被攻击对象对自己进行反击， 那怎么样对自己进行反击呢？就是我们以this指针作为参数 去调用这个FightBack，this指针就是指向Attack这个成员函数 所作用的那个对象，也就是攻击的发起者，对吧，那我们现在以this指针作为参数去调用FightBack， 那在被攻击对象的FightBack里面，就反击，就有了目标，就是这个this指针所指向的对象。 那这个FightBack成员函数是需要写很多个的。 攻击狼的Attack就是这样的。那要攻击鬼的呢？那Attack就是这样的。它里面的结构差不多，但是表现攻击动作的代码 它有可能会针对被攻击对象而有所不同。 当然最关键的还是这个参数的类型，就不一样。它这个是Attack. 然后我们再看这个Hurted。Hurted就是如果一个怪物被 别人攻击了，或者被别人反击了，那它的Hurted成员函数就被调用， 参数就是攻击力，那在Hurted成员函数里面呢首先要 写一些代码来表现受伤的动作，受伤啊，流血啊，惨叫一声等等， 甚至倒地死去，然后在这里面呢，要减掉 这个生命值， 假设我们的规则就是把生命力减去这个攻击力， 那如果生命力减低为0以下了，那下面可能还会有一些 动作表现出来，表现它倒地死去。啊，这是Hurted,需要一个就够了。那FightBack 就用来在一个对象被别人攻击的时候对攻击者表示以反击的， 那攻击者有各种各样的，那我们要反击的 对象当然也是各种各样不同类型的，所以跟Attack原理类似。FightBack我们也要写多个 FightBack,iii的成员函数，用来反击不同类型的攻击者， 比如说我们要反击狼这种攻击者，那么FightBack的参数就是 CWolf* ，那在FightBack里面首先我们要表现这个反击的这个动作， 然后呢我们再调用被反击对象的Hurted成员函数使得被反击对象 受伤，那这个时候由于反击 它的攻击力就不像主动攻击那么大，所以我们可以把这个 攻击力这个参数，把它设为主动攻击的参数的力量的一半，啊，这个参数，决定对被反击者的伤害有多大。 那总而言之啦，你要是有n种怪物的话 这个CDragon类就会有n个Attack成员函数，啊，因为龙和龙之间也会互相打的啊， 然后还会有n个FightBack成员函数，对于其他的类来说也是这样的， 那 如果这个游戏版本升级， 添加了新的这个怪物雷鸟，CThunderBird这个类，这个程序改动就会比较大。 到底有多大呢？那显然我们是需要再写一个CThunderBird的类的，这个是少不了的， 但问题是所有已经存在的类我们都要往里头添加两个新的成员函数， Attack和FightBack， 这两个成员函数的参数是这种新的类型的CThunderBird* ， 这样我们已有的类才能去攻击这个雷鸟， 也才能被雷鸟反击。 那我们每一个类都需要改动，当然这个程序的改动就是比较大的。 那怪物种类很多的时候这工作量实在就让人抓狂啊， 
- 那接下来我们来看看这个神奇的多态的实现方法。
    ```C++
    //基类CCreature：
    //基类只有一个Attack成员函数；也只有一个FightBack成员函数；所有CCreature的派生类也是这样。
    class CCreature {
        protected:
            int m_nLifeValue,m_nPower;
        public:
            virtual void Attack(CCreature *pCreature) {}
            virtual void Hurted(int nPower) {}
            virtual void FightBack(CCreature *pCreature) {}
    };
    //派生类 CDragon：
    class CDragon:public CCreature {
        public:
            virtual void Attack(CCreature *pCreature) {}
            virtual void Hurted(int nPower) {}
            virtual void FightBack(CCreature *pCreature) {}
    };    
    void CDragon::Attack(CCreature *p)
    {
        //表现攻击动作的代码
        //................
        p->Hurted(m_nPower);                //多态
        p->FightBack(this);                 //多态
    }
    void CDragon::Hurted(int nPower)
    {
        //表现受伤动作的代码
        //................
        m_nLifeValue -= nPower;
    }    
    void CDragon::FightBack(CCreature *p)   //传入的是基类的指针
    {
        //表现反击动作的代码
        //................
        p->Hurted(m_nPower/2);              //多态
    }      
    ```
  那当然也是需要一个基类， CCreature，这个CCreature概括了所有各种类的 共同特点，比方说这个LifeValue生命值，Power攻击力。 然后还有Attack,FightBack，Hurted这三个成员函数， 但是我们要注意到这个时候Attack只需要一个就够了，这三个成员函数呢全都是虚函数 这点很重要啊，那Attack只需要一个就够了，Attack成员函数里面的参数呢是基类的指针CCreature* 这种类型的， 然后FightBack它的参数也是基类的指针 CCreature* ，实际上，不但基类只有一个Attack和FightBack，实际上 所有的从CCreature派生出来的那些类也都只有一个Attack和FightBack，我们以CDragon类为例来看。 它有一个Attack成员函数， 参数是CCreature* ，然后有Hurted和Fightback 所以他们都是虚函数。那这个CDragon呢具体的函数怎么写呢？ Attack接收一个CCreature*参数， 首先在这里面要表现攻击别人的这个代码，那我们知道 龙攻击别人的这个那个形式它可能是喷火，狼攻击别人可能就撞上去咬，这些动作都是不一样的， 所以在基类里面写一个Attack是不够用的， 必须在每一个派生类里面都要写Attack才可以。 那对于CDragon这个类来说，Attack里面先表现攻击动作， 然后再调用被攻击对象的Hurted成员函数，被攻击对象就是p这个指针所指向的对象。然后呢来调用被攻击对象的FightBack成员函数， 接收被攻击对象的反击，以this指针作为参数。 那CDragon的Hurted成员函数呢就先表现受伤动作 然后再减掉这个LiveValue，如果LiveValue等于0了，就要表现挂掉的这个动作， 那么FightBack久表现反击动作，然后使得被反击对象受伤。那在多态的写法里面 如果有版本升级， 增加了新的怪物雷鸟，这时候我们肯定要编写CThunderBird这个类， 但是我们不需要往已有的类里面为新的怪物去增加新的Attack和FightBack成员函数了， 不需要增加，也就是说 在这种情况下，原有的类可以原封不动没有压力啊， 很舒服发啊。那么到底是怎么做到这一点的呢？ 那我们就来看。 
    ```C++
    CDragon Dragon;
    CWolf Wolf;
    CGhost Ghost;
    CThunderBird Bird;
    Dragon.Attack(&Wolf);           //1
    Dragon.Attack(&Ghost);          //2
    Dragon.Attack(&Bird);           //3     
    //根据多态的规则，上面的 1，2，3 进入到CDragon::Attack函数后，能分别调用：
    CWolf::Hurted
    CGhost::Hurted
    CBird::Hurted
    -----------------------------------------------------------------
    void CDragon::Attack(CCreature *p)      //传入的是基类的指针
    {
        //表现攻击动作的代码
        //................
        p->Hurted(m_nPower);                //多态
        p->FightBack(this);                 //多态
    }    
    -----------------------------------------------------------------
    ```  
  假设我们现在，前面有一堆的这个各种怪物的对象，然后假设我们执行了一条语句Dragon.Attack( &Wolf)，这就是干嘛啊，是让一只龙去攻击一只狼，对不对？那我们还可以执行Dragon.Attack( &Ghost)这个也没有问题， Dragon里面带个Bird也没有问题，为什么这些类型都能匹配呢？ 那我们看因为CDragon.Attack里面那个参数是一个基类的指针， 那我们调用了Attack的时候呢给进去的是 派生类的地址，当然也就是派生类的指针，那我们说过派生类的指针可以赋值给基类的对象 所以在这个地方，参数是基类的指针，但我们调用的时候实参是派生类的对象这个是类型匹配的，没有问题。那现在就是说我们要做到的就是Dragon.Attack( &Wolf)我们要做到的就是 这条龙所攻击的对象却是得是一只狼， 而这只狼被攻击了它就应该要做出受伤的动作，反击的动作，等等 那怎么做到这一点的呢？我们看到，啊，进到这个Attack成员函数里面 首先要执行p->Hurted,对吧？ 那我们注意这个p是基类的指针，这个Hurted是基类和派生类里面都有的 同名虚函数，所以这条语句就是多态，那既然是多态， 也就意味着这个p它要是指向了哪个类的对象，这个Hurted就是哪一个类的Hurted， 那我们执行Dragon.Attack( &Wolf)的时候， 进到了Attack里面来，p就是一个指向Wolf对象的指针， 那这个p->Hurted当然就会调用Wolf对象的Hurted iii一只狼的受伤动作。p->FightBack也是多态， 就会调用狼这个类的FightBack成员函数。 展现狼的反击动作。那如果我们执行Dragon.Attack( &Bird) 进到Attack里面来，由于这时候p指向的是一个CThunderBird类 的对象，所以这里调用的Hurted和FightBack当然就是那个CThunderBird类的 Hurted和FightBack，所以我们就看到， 一有了这些类，我们都不需要动，我们只要新写一个CThunderBird类就可以了。 那新的这个CThunderBird类，就能够和 已有的其他类的那些怪物互相的打来打去 那当然我们这样就节省了很多新增的代码。 
## 3. 更多多态程序实例
- 下面我们来看更多的这个多态程序实例。
- 一个典型的例子，几何形体 几何形体处理程序。啊，这个程序它要输入若干个几何形体的形状的参数。 然後你要按照面积从小到大顺序，把这些几何形体给它输出出来。 它的输入数据，第一行就是几何形体的数目n,不超过100。 然後小面就有n行，每一行是一个几何形体。每一行都有一个字母c开头。 如果c是大写的R，就代表这是一个矩形，然后本行后面跟着两个整数，分别是矩形的宽和高。 如果c是大写的这种C，就代表着一行是一个圆，那这行的后面就是一个整数代表其半径。 如果c是大写的这种T，就说明这一行是一个三角形，那这一行的后面就跟着3个整数，代表三条边的长度。 嗯，输出的要求就是按面积从小到大输出 输出每个几何形体的种类及其面积，每行一个几何形体 形式就是几何形体的名称，然后是面积。举例： 如果说输入数据是这样的，也就是说，嗯，有，有，有三个几何形体。嗯，它们分别是，嗯 矩形，宽和高3 5、圆，半径9、三角形，三条边3 4 5 。那么你输出的时候， 要按面积从小到大的顺序来进行输出。面积最小的是个三角形，所以输出三角形：6。 嗯，然后矩形：15，然後是圆，254，34. 啊，这个题目就这样。 那我们怎么实现它呢？嗯，显然我们要概括 所有几何形体的共同特点，形成一个基类叫做CShape。 嗯，这里不同的几何形体它的属性不一样，因为有的是半径有的边长什么的， 所以没有共同点。**但是它们的方法也就是操作，他们的操作是有共同特点的。 比方说，它们都能够求面积，都能够输出自己信息**。 
    ```C++
    #include <iostream>
    #include <cstdlib>
    #include <cmath>
    using namespace::std;
    class CShape {
        public:
            virtual double Area() = 0;      // "=0" 代表纯虚函数
            virtual void PrintInfo() = 0;
    };
    class CRectangle:public CShape {
        public:
            int w,h;
            virtual double Area();
            virtual void PrintInfo();
    };
    class CCircle:public CShape {
        public:
            int r;
            virtual double Area();
            virtual void PrintInfo();
    };
    class CTriangle:public CShape {
        public:
            int a,b,c;
            virtual double Area();
            virtual void PrintInfo();
    };
    double CRectangle::Area() {
        return w * h;
    }
    void CRectangle::PrintInfo() {
        cout << "Rectangle:" << Area() << endl;
    }
    double CCircle::Area() {
        return 3.14 * r * r;
    }
    void CCircle::PrintInfo() {
        cout << "Circle:" << Area() << endl;
    }
    double CTriangle::Area() {
        double p = (a + b + c)/2.0;
        return sqrt(p * (p - a) * (p - b) * (p - c));
    }
    void CTriangle::PrintInfo() {
        cout << "Triangle:" << Area() << endl;
    }
    CShape *pShapes[100];                               //基类指针，指向所有形体
    int MyCompare(const void *s1,const void *s2);

    int main()
    {
        int i;
        int n;
        CRectangle *pr;
        CCircle *pc;
        CTriangle *pt;
        cout << "请输入测试图形数量： ";
        cin >> n;
        for(i = 0;i < n;i++) {
            char c;
            cin >> c;
            switch(c) {
                case 'R':
                    pr = new CRectangle();
                    cin >> pr->w >> pr->h;
                    pShapes[i] = pr;
                    break;
                case 'C':
                    pc = new CCircle();
                    cin >> pc->r;
                    pShapes[i] = pc;
                    break;
                case 'T':
                    pt = new CTriangle();
                    cin >> pt->a >> pt->b >> pt->c;
                    pShapes[i] = pt;
                    break;    
            }
        }
        qsort(pShapes,n,sizeof(CShape*),MyCompare);
        for(i = 0;i < n;i++)
            pShapes[i]->PrintInfo();                    //多态
        system("pause");
        return 0;
    }

    int MyCompare(const void *s1,const void *s2)
    {
        double a1,a2;
        CShape **p1;                //s1,s2是void*,不可以写“*s1”来取得s1指向的内容
        CShape **p2;
        p1 = (CShape**)s1;          //s1,s2指向pShape数组中的元素，数组元素的类型是CShape*
        p2 = (CShape**)s2;
        a1 = (*p1)->Area();         //*p1的类型是CShape*，是基类指针，故此句为多态
        a2 = (*p2)->Area();     
        if(a1 < a2)                 //如果这个*s1所指向的几何形体面积小的话，那也就是说*s1这个元素应该排在前面，那我们就让这个MyCompare返回-1
            return -1;
        else if(a2 < a1)
            return 1;
        else 
            return 0;          
    }
    ```
  嗯，所以呢，我们就在这个基类里面编写了两个成员函数。啊，它反映了，嗯，不同几何形体对象的共同特点。 一个就是求面积按，啊，一个就是打印信息。这两个成员函数我们都把它变成虚函数。 然后呢，我们看到在这里我们后面写了=0，这意味着什么呢？意味着这个虚函数是个纯虚函数。 纯虚函数就是连函数体都没有的那个虚函数，具体它的这个运用等会儿还会讲。 那我们可以回忆一下，在前面那个，嗯，游戏程序里面CCreature里面的一些虚函数， 它实际上是有函数体的。只不过函数体里面什么语句都没有。但这块呢，是纯虚函数，连函数体都没有的。 为什么我们不需要对CShape去编写求面积和打印信息的这些函数呢？ 那是因为在这个程序里面任何一个几何形体， 嗯，它要么是矩形，要么是圆，要么是三角形。它不会是一个光秃秃的、 抽象的CShape，对吧？不存在一个叫做CShape的这种类型的具体的几何形体。 所以我们就不需要为CShape和这样的类去编写具体的如何求面积的、 如何打印信息的这样的函数了，因此我们就干脆让它=0，变成纯虚函数。 好，接下来再看，CRegtangle从 CShape派生下来是怎么写的，还有成员变量宽和高。 然后还有虚函数、求面积和打印信息。 那同理我们看到CCircle它也从CShape派生而来，它有半径，然後它也有求面积， 有打印信息。然後这个CTriangle 是三角形，它也从CShape派生而来。 它有3条边a、b、c，然后它也有求面积、有打印信息这些虚函数。 好，接下来我们看看各个类的成员函数是怎么实现的。 这个CRectangle类的Area成员函数，嗯，就返回宽乘以高作为面积。 那它的PrintInfo就输出Rectangle，然後再输出它的面积。啊。 对圆来说呢，求面积就是π r平方，嗯，它的PrintInfo就是输出圆，然後面积。对于三角形来说 求面积就是海伦公式，然後就是PrintInfo就是输出一个Triangle，然後再输出面积。 那这个程序我们用什么东西来存放各种不同类型的几何形体呢？ 一共有三种几何形体，如果你就开三个数组去存放它就是比较啰嗦。加上有四个几何形体，你就还得再加一个数组。 显然是不和算的。嗯，包括你用三个数组去存的话，它整个的所有的几何形体都要按面积排序，这时候你怎么处理呢？ 你把三个数组分别排序也不行，对不对？因为不同数组， 不同类型的几何形体之间的面积还要进行比较，嗯，您可能还要另外开一个索引数组。总而言之就很麻烦。 哪有了多态这种概念呢，我们就可以采取简单的做法，啊。这里我们可以用一个 基类的指针数组，嗯，PShapes用来存放各个几何形体。 纯粹的说就是，嗯，这个数组里的每一个元素都是一个基类指针。 但是由于是基类指针，它可以指向派生类的对象，所以我们可以让这个数组里面呢，每一个元素都去指向 各自不同的这个几何形体。啊，所有几何形体都是new出来的对象。 然后它们的地址都被放到这个基类数组里面去。 然後我们排序的时候呢，就是对这个基类指针数组进行排序，啊。 排序的时候用iii进行排序，所以会用到一个比较函数，比较函数我们等后再说。 我们来看看main里面是怎么做。Main里面呢，嗯， 定义了三个不同几何形体类型的指针，然後cin>>几何形体的数目n， 接下来处理每一个几何形体。首先cin>>c;n就是几何形体的种类。然後看看这个c是什么。 如果这个c是R就代表是一个Rectangle ，那我们就new出来一个 Rectangle对象，啊。New 一个新的Regtangle 的对象然後cin>>它的宽和高。然後呢， 我们在tShapes里面找一个元素，让这个元素指向刚刚New出来的这个 CRectangle 的对象。啊。 这也是，间接的可以说我们是把这个对象存到这个数组里面了。 实际上就是让这个数组里面的一个指针指向new出来的对象。 那如果这个几何形体的种类是圆形， 那我们就New一个圆形对象。cin>>它的半径，然後在pShapes里面找一个元素 让它指向New出来的这个，这个圆形的对象。嗯， 如果这个几何形体是一个三角形， 那我们就New一个三角形的对象，Cin>>它的三条边， 然後在pShapes里面找一个元素让它指向 这个New出来的三角形。也还是不断递增的，所以说，pShapes里面 不会，嗯，人都会指向读取进来的几何形体，不会漏掉。 嗯， 那上面这个循环执行完以后，我们就把所有的几何形体都读进来了。 好，接下来我们我们要做的事情，就是对这个pShape的数组新型排序。 啊，我们排序的是这个基类指针数组pShapes，啊。它里面一共有n个元素，n个几何形体吧。 每个元素的大小都是，嗯， pShape * 这个指针的大小。 然後排序的时候用比较函数my compare进行排序。 啊。 嗯，那实际上这个比较函数会按照这些指针所指向的 几何形体的面积，对这些指针进行从小到大的这个排序。 排完续以后呢，我们就应该遍历这个pShapes的数组。然后把每一个 几何形体的信息都输出出来，所以在这里就是一个循环。在这个循环里面，嗯，我们要 调用pShapes[i]->PrintInfo打印 PShapes[i]所指向的那个几何形体的面积。那大家注意了，这个pShapes[i]它是 基类指针，对吧？然後这个PrintInfo呢，它是基类和派生类里面都有的 同名虚函数。因此说整条语句呢，就是一个多态这个语句了。 那么也就是说，如果pShapes[i]指向的是一个 圆的对象。 那这里就会调用圆的PrintInfo 。如果pShapes[i]指向的是一个三角形的对象，这里就会调用三角形的PrintInfo。 这里会输出什么？三角形然後乘以面积，对吧？如果这一块，嗯，pShape指向的是一个矩形的对象，这里就会调用 矩形的PrintInfo，就会输出Triangle，嗯，嗯， Rectangle然後跟那个面积。 所以我们遍历这个数组，就能把所有几何形体的面积都打出来。 嗯，再来看看这个很关键的mycompare比较函数的这个写法。 嗯，这个mycompare函数，它的两个参数 都会指向那个pShape子数组里面待比较的元素。 那我们当然希望通过* s1就能拿到s1所指向的那个元素。 那实际上是不行，你这么写* s1的话编译的时候会出错，为什么呢？因为这个s1它是void的新类型的指针。 那么* s1到底是多少个字节呢？不知道，所以编译器没有办法处理* s1。 那我们心里知道是s1指向的那个元素它是一个，嗯，CShape的新类型的指针。 那我们要拿出s1之下的东西那应该怎么办呢？我们就应该 把s1强制转换成一个CShape的**，然後赋值给这个p1。啊。 p1在这儿定义的。嗯，那，那为什么 要强制转换成CShape**呢？嗯，因为我们知道，嗯，s1 所指向的东西是什么？是pShapes数组里面的元素。 那数组里面的元素是什么类型的呢？是CShape* 。那现在我们要让p1这个指针 指向Cshape* 这种类型的指针。那也就是说， p1它实际上是指向指针的指针， 对吧？那指向指针的指针所以我们就要用两个* 。 啊，所以第一个类型是CShape** ，因为p1指向了一个类型为CShape* 的指针。 好了，那通过上面这个强制类型转化，我们就让p1和p2分别指向了待比较的两个数组元素。 也就是* p1是待比较的一个数组元素。 注意，* p1的类型是是CShape* ，它是一个指针，而且它是一个基类指针。 那它指向某一个具体的几何形体。那现在这条语句就是通过 基类指针去调用基类和快径类里面都有的同名虚函数Area 因此这条语句就是iii, 那 如果* p1指向的是一矩形 在这里被调用的就是矩形的Area，也算是一个矩形的面积。 如果* p1指向的是一个三角形，啊，这里被调用的就三角形的Area。就算出一个三角形的面积。 那a2是另外一个几何形体的面积。 然后我们就比较这两个几何形体的面积，啊。 嗯，**如果这个* s1所指向的几何形体 面积小的话，那也就是说* s1这个 元素应该排在前面，那我们就让这个MyCompare返回-1**。 那如果，嗯，* s1的面积也就是这个，嗯， a1， 它的面积比这个，嗯， a2还要大的话，这个时候大家这个*s1就应该排在后面； 所以MyCompare就返回1。嗯，如果两个面积都一样大就返回0。 通过这个比较函数就能够把pShape里面的数组指针 让它们所指向的几何形体的面积 从小到达进行排序。
- **那这种动态的写法到底能带来什么好处呢？嗯，当然也就是提高了程序的可扩充性。 让我们来看，嗯，就如果你要添加新的几何形体，比如说，五边形pentagon。 就是说，我们的程序只要做很小的改动就行了，怎么做呢？我们只需要从CShape这个类派生出CPentagon。 然后我们还需要做什么？ 我们需要在这SWITCH语句里面加一个case，用来处理五边形Pentagon。 除此之外，其他地方需要动吗？嗯，这，这个循环 这个循环和这个排序的语句都不用动。其他已有的类就更加不用动了。所以我们所做的修改就是特别少的。 这个就体现了多态在提高程序的扩充性方面，确实有很好的这个作用。 那实际上啊，我们用一个基类指针数组存放指向各种派生类对象的指针， 然後我们遍历这个数组，然后就能对各个派生类对象做各种操作。啊，这种做法 在实际演变成中是非常常见的。** 
- 再看另外一个例子。 
    ```C++
    //在非构造函数，非析构函数的成员函数中调用虚函数，是多态！
    class Base {
        public:
            void fun1()
            {
                fun2();     //相当于 this->fun2(),this是基类指针，fun2是虚函数，所以是多态
            }
            virtual void fun2()
            {
                cout << "Base::fun2()" << endl;
            }
    };
    class Derived:public Base {
        public:
            virtual void fun2()
            {
                cout <<"Derived:fun2()" << endl;
            }
    };

    int main()
    {
        Derived d;
        Base *pBase = &d;
        pBase->fun1();                      //输出： Derived:fun2()
        return 0;
    }
    ```  
  在这个例子里面class Base基类，基类里面有一个fun1函数 ，调用了fun2； 我怕们要注意啊，这个fun2是一个虚函数，啊，fun1不是。 然后呢fun2里面也输出base::fun2。接下来再看这个派生类。 这个派生类呢他是从基类base派生而来。 嗯，然后它有一个虚函数fun2，这个fun2呢就是 Derieved::fun2。 然后，我们看这个main 程序定义的一个派生类的对象。 然後，嗯，让基类指针指向派生类的对象。然後， 通过基类指针调，调用fun1，这种不是多态，对吧？因为fun1并不是虚函数。 嗯，所以大家想想看，这个程序的数据结果是什么呢？ 看上去应该是Basefun2，对吧？ Base的fun2，对吧？因为进来fun1里面了，就要用fun2，是个fun2, 当然就是Base的fun2，就输出，所以就输出Base::fun2。 但实际上不对，啊， 输出的结果是Derieved:fun2。非常的意外，是不是啊？ 到底是怎么回事儿呢？ 我们来看，在fun1里面调用fun2，你看是不是等价于 this ->fun2这种写法，是一样的对吧？在这里你把这个this指针 放在这儿和去掉效果是相同的。嗯，我们学this指针的时候已经说过了。 那大家分析这条语句，this是不是一个基类指针啊？ 答案是是，对吧？出现在 嗯， base 的这个成员函数里边的this指针，当然它的类型就是base*的，它是基类指针。 在这里fun2又是虚函数，那么通过基类指针调用 虚函数，这条语句就是多态。 也就是说，当程序执行到这条语句的时候，执行的是哪一个类的fun2取决于 指至This指针到底指向的是哪一种类型的对象。那我们分析，在main里面 pBase fun1指至pbase是指向一个派生类的对象d的。 那进到fun1里面，this指针指向的东西自然也就是这个d。 所以，此时this指针指向的是一个派生类的对象， 那么根据多态的原则这条语句就会调用派生类的fun2, 就是Derieved类的fun2。 所以会输出Derieved 的fun2。好，那通过这个程序的例子，我们就能够得出一个结论，什么结论呢？ 就是说在非构造函数、非析构函数的成员函数中 啊，我们调用虚函数，就是多态。 就像这个，fun1它不是构造函数，也不是析构函数。啊，然后在这里面 调用了fun2。那，你这块写this->还是不写this->是没有差别的，对吧？ 那我们就说了，诶，这样的语句它就是多态。 
- 但是呢，如果我在构造函数和析构函数中调用虚函数，就不是多态了。 在这种情况下，编译的时候就能确定到底调用的函数是什么？那当然应该是这个类自己的那个虚函数。那么自己没有的话，就是它的直接基类中定义的那个虚函数。 啊，它不会等到运行的时候才决定调用的是自己的还是派生类的函数。 我们看具体的例子，
    ```C++
    //派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数
    class myclass {
        public:
            virtual void hello()
            {
                cout << "hello from myclass" << endl;
            }
            virtual void bye()
            {
                cout << "bye from myclass" << endl;
            }            
    };
    class son:public myclass {
        public:
            void hello()
            {
                cout << "hello from son" << endl;
            }   
            son()
            {
                hello();
            }   
            ~son()
            {
                bye();
            }      
    };
    class grandson:public son {
        public:
            void hello()
            {
                cout << "hello from grandson" << endl;
            }   
            void bye()
            {
                cout << "bye from grandson" << endl;
            } 
            grandson()
            {
                cout << "constructing grandson" << endl;
            }   
            ~grandson()
            {
                cout << "destructing grandson" << endl;
            }      
    };
    int main()
    {
        grandson gson;
        son *pson;
        pson = &gson;
        pson->hello();          //多态
        return 0;
    }
    结果：
    hello from son
    constructing grandson
    hello from grandson
    destructing grandson
    bye from myclass 
    ```  
  嗯， 我们看在这里，这里有一个基类myclass，啊，它有一个虚函数。 Hello输出hello from myclass。然后这里 还有一个bye给它输出bye from myclass。 然后呢，这个son它从myclass派生而来， 还有虚函数hello, hello from son。请注意这块hello前面并没有加Virtual关键字。 但是C++的语法规定，在派生类中和基类 的虚函数同名参数表的那个函数，嗯， 不加Virtual关键字他也自动成为虚函数。啊。 所以这块这个hello前面虽然没有写virtual,它也是虚函数。 嗯，然後在上个构造函数里面调用了hello。 啊，在上个析构函数里面调用了bye。 然后再看下一层的这个派生类grandson。 嗯, grandson它有hello。这hello前面没写virtual关键字，但是由于 同名同参数表的hello在基类里面已经是虚函数了。所以在派生类里面它自动也是虚函数。 它会输出hello from grandson，然後它的bye呢，输出bye from grandson。 嗯，然後它还有构造函数construction grandson"这个输出。还有析构函数输出 destructing grandson。好了我们来看main这样的， 嗯，main里面呢就定义了一个grandson的对象，然后呢，让一个son这样的指针指向grand的 son对象。然後通过这个基，基类son基类型的指针gson去调用hello。 然後这条语句当然就是多态，然后就会产生输出。那我们要分析这个程序的输出结果。 我们先从这个构造函数开始分析。 嗯，在这里面有一个派生类的对象生成，所以会从 顶至下执行一个个基类的构造函数。那么，首先执行的就是 myclass的构造函数，但是myclass的构造函数没有输出，所以我们不管它。 然后在这里，接下来执行的是son的这个构造函数。Son的构造函数里面调用了hello。 那这个hello它是一个虚函数，那到底是不是多态呢？ 啊，注意我们前面说了，在构造函数和析构函数里面调用 虚函数不是多态。所以这个hello就是son这个类它自己的hello。嗯，因此我们看到， 第一条输出就是hello from son。啊, 然后接下来就会进行grandson自己的 这个构造函数了。然後输出constructing grandson，这边的constructing grandson。 嗯，然后我们看在这儿，嗯，这是 son-这里的指针指向了这个grandson的对象，然後 这条语句还是多态，为什么啊？因为这样，因为这个pson 是son性类型的。Son这个类相对上来说它是基类。因此说 因此说这条，这样就是通过基类指针调用一个虚函数，所以它是多态。 拿这个时候pson，嗯，指向的是一个grandson的对象，那当然执行的hello就是grandson的hello。 嗯，Grandson的hello。这就会输出一个 嗯，hello from grandson。嗯，再接下来，嗯，这个main就结束了，main结束了 那这个gson这个对象就消亡，就会引发析构函数的调用。 那就先执行grandson自己的析构函数，啊，输出一个destructing grandson. 然后呢，在执行 son的，嗯，析构函数。啊,执行son的析构函数。Son的析构函数里面调用了bye， 那这个bye呢，嗯，它是虚函数，在基类里面是虚函数，对吧？这条语句是不是多态呢？前面说了， 构造函数、析构函数里面调用虚函数都是多态。所以这个bye呢，按理说就应该是son自己的这个bye。 可是son自己没有bye啊？那这个bye上哪儿去找呢？嗯，son 从myclass 继承了一个bye。所以这个bye就是myclass 的bye 。因此， 结果的输出也是bye from myclass。 
- **嗯，那为什么在构造函数和析构函数中调用虚函数，它就不应该是多态呢？ 那当让编译器就是这么设计的。那至于为什么要这种设计，那大家想想看啊，它在初始化的时候会先执行 这个 嗯，里面的基类对象的构造函数。那也就是说在基类对象的构造函数执行期间 派生类对象它自己内部分成员对象实际上是还没有被初始化的。 那如果在基类的构造函数执行期间调用的虚函数 而你就允许这虚函数是多态的话，那么在基类构造函数执行期间就会 调用了派生类的虚函数。因为多态嘛！ 当这个派生类对象它自己的成员变量还没有初始化好 你在这个派生类对象上面就执行了成员函数， 那这个成员函数的执行的结果就是有可能不正确的。 因此我们不能够在，嗯，基类的构造函数里面就去执行派生类的这个虚函数。 所以在基类的构造函数里面调用虚函数，就不是多态。 若在析构函数里面调用虚函数也不是多态。它的道理跟构造函数的情况是差不多的。**你们自己去想一想。 
## 4. 多态实现原理
- 下面我们说多态的实现原理。 
- **这个多态嘛，它的关键在于，啊，通过基类指针或者引用调用一个虚函数的时候， 编译的时候你没有办法一口咬定说这个，嗯， 虚函数到底是哪一个类的。 只有在运行到那条语句的时候才能确定，嗯，这个虚函数到底是属于哪一个类的。那这种情况叫做 动态联编。**啊，它跟多态说得上是一回事儿了。拿这个很神奇的动态联编，到底是怎么实现的呢？ 嗯，我们先看一个程序。 引发大家一点思考，啊。
    ```C++
    //为什么都多出来4个字节？
    class Base {
        public:
            int i;
            virtual void Print()
            {
                cout << "Base:Print";
            }
    };
    class Derived:public Base {
        public:
            int n;
            virtual void Print()
            {
                cout << "Derived:Print" << endl;
            }
    };

    int main()
    {
        Derived d;
        cout << sizeof(Base) << "," << sizeof(Derived);         //输出：8，12
        return 0;
    }
    ```
  嗯，在这个程序里面有个基类base，嗯， 它有一个，嗯 他有一个成员变量 i。然後它有一个虚函数输出BasePrint。 然後在Derieved的类里面呢， 也有一个成员变量n。这个Derieved 类是从base派生而来的，它的Print输出 Derieved的Print。然后在main里面我们定义了一个派生类的对象d， 嗯， 然後就没什么用了。然後，输出了size of base 和size of derieved，啊。 当你说嘛，这size of base 它应该是四个字节，对吧？它只有一个整型成员变量。那size of derieved应该是八个字节，啊。 这是我们前面所学的知识。那实际上这个程序输出了的结果是8和12。 也就是说吧，为什么 这些对象都多了四个字节出来了？看上去是很奇怪吧？ 啊，那多出来的4个字节它肯定是有用的。 具体做什么用呢？这就牵涉到多态实现的关键-虚函数表。 就是说，嗯，**在C++里面每一个有虚函数的类， 那一个类如果没有虚函数但它的基类有虚函数，那它也算是有虚函数的类啊。 总之吧，每一个有虚函数的类都有一张虚函数表跟它对应。 这个虚函数表，是编译器自动生成的 自动生成的，加到你这个可执行文件里面去的。当你的可执行程序被装入内存的时候 和一个类所对应的虚函数表，也就被装到内存里面去了。 然後有虚函数的类的任何对象中都会，都会存放着这个类所对应的虚函数表的地址。 然後虚函数表里面放着什么东西呢？ 啊，虚函数表里面放着这张表所对应的类的所有虚函数的内存里面的地址。 那实际上我们前面看到，诶，那些包含虚函数的类，它的事实上 结果比我们想象的要多了四个字节。那多出来的字节是什么东西呢？ 多出来的四个字节，实际上就是用来存放这个类所对应的虚函数表的地址了。 那我们看，一个base的对象b 它的前四个字节存放的就是base类所对应的 虚函数表的指针。那接下来才开始存放自己的成员变量i。 那这个虚函，通过虚函数表指针就能够找到base类所对应的虚函数 虚函数表，这个虚函数表是是在内存里面的。这base类的虚函数表里面放的些什么东西呢？ 放了的就是base类的所有虚函数在内存里面的地址。 那通过这张表 有了虚函数的名字就能够查到这个虚函数在内存里的地址了。 有了虚函数在内存里面的地址，当然就能够调用这个虚函数了**。 
- 调用一个函数本来就是跳到那个函数的地址上去执行嘛！ 当然你还是得再跳回来。 那融延制虚函数表是可以通过 虚函数的名字，或者说虚函数的代号，或者是什么东西来进行查找的。 总之，有了这张表，你就能够查到一个虚函数在内存里面的地址。 注意，每一个类 只要是包含虚函数的类它都有一张虚函数表跟它对应。 那假设这里有一个Derieved类的对象，那它这个对象前面的四个字节放着的也是 Derieved的类的虚函数表的指针。接下来才存放 Derieved类的成员变量。 前面是从基类继承下来的i，后面是它自己的n。 好， 那通过前面的四个字节就能够找到Derived类所对应的这个虚函数表。 这个虚函数表里面放的什么东西呢？当然就放着的Derived类的 全部虚函数的内存地址。啊，它存放了 Derieved里面的Print的这个虚函数的内存地址。 那我们查这张表就能够得到Derieved类的所有虚函数的内存地址。 那有了内存地址之就能调用虚函数。嗯，那现在 多态是怎么实现的呢？假设我们用一个pBase的指针指向 指向某个对象。这个对象它有可能是，是，是，是基类的对象，也有可能是这个派生类的对象。 那这样一条多态语句 那么基类指针调用虚函数，这台，这条多态行状的语句 被编辑处理了以后它会生成一大堆的指令。这些指令并不是简简单单的 就跳转到某个函数的地址去执行那个函数。啊，这个一系列指令 首先 它做的事情就是根据基类指针所指向的，嗯，或者说基类引用 所引用的那个对象中存在的虚函，对象中存放的虚函数表的地址。 啊，这对象里面的全四个字节就是虚函数表的地址。 然后有一个指着指着它，指着一个对象，或者引用在引用那个对象。 那总而言之我们通过这个对象的前四个字节，就能够找到这个对象 所属的类对应的那张虚函数表。 然後，我们再在这个虚函数表中去查找虚函数的地址。 找到虚函数的地址以后，就去调用哪个虚函数。 啊，就是对于一条多态语句，编译器编译出来的指令 执行过程会比较复杂的这么一大套。那当然了， 在这个，这一切指令执行的过程中， 这些对象里面放着的是哪一个类的虚函数表的指针？ 最后终究会跑到哪一个类的虚函数表里面去查找虚函数的地址？ 那最终被调用的又是哪一个类的虚函数？嗯，这也是多态实现的这个 原理。 那，知道这个原理，你对这个 面向对象对多态什么的理解就会更加深入了一层，啊。 多态好难讲啊！ 
- 诶，嗯， 不好意思，本来扔完瓶子嘛，就算该讲完了。我突然想起来还要多补充一句。 就是这个多态啊，我们知道它能够有效的提高程序的可扩充性。 也就是它能够很好的节省程序员的时间。 但是这么做到这点，它有没有代价呢？嗯，当让是有的。啊，天上不会掉馅饼。 嗯，这个代价就是多态的程序在 运行期间会有额外的时间和空间上的开销。 那这个额外的时间上和空间上的开销是什么呢？就是每一个有虚函数的类的对象里面都会多出来四个字节，用来存放虚函数表的地址。 每个对象都会多四个字节哦！那当然就是空间上的额外开销啦。那时间上的额外开销表现在哪儿呢？ 就表现在对多态的函数调用语句，我们说了， 把它编译出来的一系列指令，需要执行查询函数表这样一个过程， 那查询函数表就是时间上的开销啦。 要知道现在是一个硬件便宜，人力贵的时代。 我们让，嗯，这个硬件多花点功夫节省下来是人的时间，那是非常合算的。所以多态当然是一个非常好的机制（特性）。 
## 5. 虚析构函数
- 大家好，在这一小节中，我们来介绍虚析构函数。 所谓虚析构函数的引入呢，是我们在程序设计的时候遇到一些实际的问题。 
    ```C++
    class CSon {
        public:
            ~CSon() {}
    };
    class CGrandson:public CSon {
        public:
            ~CGrandson() {}
    };

    int main()
    {
        CSon *p = new CGrandson;                //会引发问题
        delete p;                               //通过基类的指针去删除派生类对象时，会引发问题
        return 0;
    }
    ```
  那么如果我们说我们有一个基类，成为叫做CSon的话， 那么它有一个派生类，叫做CGrandson。 那么这两个类呢，它对应的都有自己相应的析构函数。 如果我们在程序设计的时候呢，有时候会让一个基类的指针，比方这里， CSon星花P去指向一个派生类的对象 我们new一个，用new这个运算符呢，去new出一个CGrandson的对象。 那么这个时候呢，如果我们在程序执行了一系列操作 之后，希望去delete掉new出来的这个派生类的对象， 我们通常呢是会delete掉这个指针的，delete掉p。 那么这个语句就会引起一些问题。 我们直观上看呢，它因为delete掉的是一个基类的指针，所以理所当然会去调用 基类的机构函数，但是逻辑上讲呢，这个指针本身又指向的是一块 是一个派生类的对象，那么分配的也是一个派生类对应的这样的一个内存空间， 那么这个时候，它应该调用的 还有派生类的析构函数。 但是目前的程序设计角度上来看呢，便应器是不会知道它需要调用派生类的析构函数的。 那这样呢就会引起一些问题。比方说我们在delete掉这个 p的时候，可能会导致程序出错。 如果我们在这个CGrandson这个程序里面要去对这个CGrandson的对象来定基数， 由于你没有去调用析构函数，那么可能这个基数呢就会产生一定的误差。 另外种情况呢，是我们由于 使用了这个CGrandson这个对象 那么它在整个这个声明设计当中呢都进行了动态的内存分配。 那么由于你没有去调用delete函数，delete函数没有去调用析构函数 所以呢，那么我们可能会导致这部分内存空间呢就没有机会去被回收回来。 那么就是考虑了这样的一个问题， 我们呢，就需要去针对这种基类的指针去删除派生类的对象。 
- 只调用基类析构函数的问题， 希望能够设计实现什么呢？实现去 删除一个派生类对象的时候呢，可以先调用 派生类自身的析构函数，啊，去把这个对象去真正地析构掉。 接着呢，再去调用基类的析构函数。 那么这个功能具体怎样实现呢？我们的解决方法是 我们会把基类的析构函数声明为是virtual。 啊，它是一个虚的。 那么如果基类的析构函数被声明为virtual之后呢， 相应的，派生类的析构函数也会被声明为virtual的。 它可以不进行直接的声明啦。 那么这时候就能够实现我们刚才希望的那个功能，也就是派生类 的析构函数呢，首先被调用，接着呢是基类的析构函数准备调用到。 那么大家要注意。**如果一个类本身已经定义了虚函数， 那么我们建议说，最好是直接将析构函数定义为虚函数，就是虚析构函数。 当然大家要注意，我们是不允许虚函数作为构造函数的。** 我们来看一个具体的例子。
    ```C++
    //只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用“virtual”关键字声明，都自动成为虚析构函数
    //一般来讲，一个类如果定义了虚函数，则最好将析构函数也定义为虚函数
    class CSon {
        public:
            ~CSon()                             //修改为 virtual ~CSon() 即可解决下面的问题
            {
                cout << "bye from son" << endl;
            }
    };
    class CGrandson:public CSon {
        public:
            ~CGrandson() 
            {
                cout << "bye from grandson" << endl;
            }
    };

    int main()
    {
        CSon *p = new CGrandson;                //会引发问题
        delete p;                               //输出结果：bye from son. 没有执行 ~CGrandson()
        return 0;
    }
    ```
  那么我们有一个基类的类，成为叫做class son。 那么在这个son里面呢，我们析构函数呢会去打印输出bye from son。 那么它的这个派生类grandson呢同样的也有一个机构函数。 打印输出bye from grandson。这两个机构函数分别来标记什么时候会被调用到。 那么我们看到，安造我们刚才分析的可能会引起的错误， 如果我们去定义了一个son类型的一个 基类的一个指针，pson， 那么它指向的是grandson的这个对象的话，我们在delete的时候， 你看看程序运行的是什么呢？程序运行的是bye from son。 它并没有去调用grandson这样的一个类的一个派生类的析构函数。 那么这样呢，它就会影响很多相关我们刚提到的问题。 那么如果我们现在呢相应的去把这个函数变成是virtual的， 也就是我们定义了虚析构函数son， 那么相应的grandson也是变成虚析构函数了。那么这个时候我们同样去执行 刚才这一系列的语句，我们会发现说呢， 我们打印输出呢会有两个语句，分别是bye from grandson和bye from son。 也就是在delete的这个语句执行的时候，它首先调用的 第一步就是虚析构函数，啊，派生类的析构函数。 然后呢，第二步调用的是基类的析构函数。 也就是我们在执行grandson的时候，同时又引起执行son的析构函数。 那么这样呢，就能够实现程序的这个顺利执行。 
## 6. 纯虚函数和抽象类
- 大家好，在这一小节中我们来介绍一下纯虚函数和抽象类。 **所谓纯虚函数呢，就是指 有这样一类特殊的虚函数，它自身呢，是没有函数体的**。 所谓没有函数体呢我们来具体看一下。 
    ```C++
    //纯虚函数：没有函数体的虚函数
    class A {
        private:
            int a;
        public:
            virtual void Print() = 0;               //纯虚函数
            void fun()
            {
                cout << "fun";
            }
    };
    ```
  有一个类呢称之为叫class A, 那么它呢除了有定义一个private的成员变量int a之外呢 还定义了有两个函数，我们看到，第一个virtual的虚函数呢它会非常的特殊， 这个Print函数呢它不像我们通常意义上看到的 会包含一对花括号，对吧，函数体，或者是呢包含某一个语句的 执行的一个语句，那么它所做的事呢就是直接标记等于0，这样的一个标示符而已。 那么这个函数呢实际上什么事情都做不了，啊在这个类里面， 那么这样的一个函数我们就把它称之为叫做纯虚函数。 那么有了这样的一个纯虚函数的概念之后呢 我们来看**如果包含这样的一个纯虚函数的类 我们就把它称之为叫做抽象类**。 对吧？所谓纯虚，那么就是说一点都不务实，全是虚的。 那么既然都已经全虚了，那么它所涉及到的类呢 也变成了一个抽象的概念，所以称之为叫做抽象类。 
- 那么这个抽象类呢，它呢有一些自身的特点。 
  - 首先呢，就是这个抽象类呢它只能是作为基类， 它只能作为基类来派生一些新的类来进行使用。 
  - 其次呢，这个抽象类呢它自身是不能够去创建相应的对象的， 也就是说一个抽象类它只能作为一个基类，比方说这个class A,它自身呢是没有对象的， 它只能去派生出来一些新的不同的类， 那么利用这些新的类来生成一些相应的对象以及进行一些相应的操作。 所以呢我们看这个抽象类的概念的引入呢实际上它会非常有利于使用多态这样的一个方式去创建相应的不同的新的对象， 啊，它可以认为说是一种多态使用的创造的一个条件。 那么独立的抽象类的对象呢是不存在的，但是呢 你可以被包含在派生类对象中间来进行这个实现。 那么抽象类这个概念本身呢它是非常符合逻辑的，对吧，因为我可以首先定义一个抽象类 然后由这个抽象类呢具体去实现了一些不同的 这个派生类来进行实际的进一步的开发和使用。 
  - 那么具体呢抽象类的指针和引用呢又是可以定义的， 我们可以利用这个指针和引用呢具体指向这个抽象类派生出来的那个新类的对象， 来看一下，
    ```C++
    //只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用“virtual”关键字声明，都自动成为虚析构函数
    //一般来讲，一个类如果定义了虚函数，则最好将析构函数也定义为虚函数
    int main()
    {
        A a;                    //错，A是抽象类，不能创建对象
        A *pa;                  //ok，可以定义抽象类的指针和引用
        pa = new A;             //错误，A是抽象类，不能创建对象
        return 0;
    }
    ```  
  刚才这个抽象类大A，那么如果直接用它去定义一个 对象，小a的话，那么这个是错误的。因为抽象类不能够创建对象。 但是呢我们可以用 大A这个抽象类呢去定义一个*pa这样的一个指针， 那么这个指针呢它是可以定义的， 同时引用也可以。另外呢我们如果说我们用pa去指向一个 抽象类对应的New出来的一个对象呢是错误的。 因为抽象类不能生成对象。 但是如果我们定义了一个派生类，且这个派生类自身也不是抽象类， 那么我们就可以用pa呢去指向这个相应的对象。 那么在抽象类当中呢 我们要注意它的成员函数是 可以去调用纯虚函数的，也就是说， 我们在抽象类里面出来纯虚函数，还有一些其他的函数， 那么这些其他的成员函数呢是可以去调用纯虚函数的， 但是注意在构造和析构函数里面是不能够调用纯虚函数的。 
- 那么如果一个类呢它是从抽象类里面派生出来的， **我们希望这个类呢变成是不再是抽象类那怎么办呢， 它就必须要去实现这个基类当中所有的纯虚函数啊，只有把所有的纯虚函数都实现了才能够将抽象类的身份替换掉，变成是一个非抽象类。 那么也可能有一些类呢它并没有实现所有的纯虚函数那么它仍然是一个抽象类。 那么在实现这个所谓纯虚函数的时候呢 其实你即便就是添加一对空的大括号，也是一个认为是一个具体的实现化。**我们来看一个例子，
    ```C++
    //纯虚函数：没有函数体的虚函数
    class A {
        public:
            virtual void f() = 0;               //纯虚函数
            void g()
            {
                this->f();                      //ok
            }
            void A()                            
            {
                f();                            //f();错误,构造函数和析构函数中不允许调用纯虚函数
            }                              
    };
    class B:public  A {
        public:
            void f()
            {
                cout << "B:f()" << endl;
            }
    };

    int main()
    {
        B b;
        b.g();                                  //输出：B:f()
        return 0;
    }
    ```
  我们有一个抽象类class A, 那么对于这个class A来讲的话呢它有一个纯虚函数 virtual void f()这样的一个函数，我们看到这个函数自身呢是没有函数体的。 那么同时呢我们还有一个成员函数，函数g 在这个成员函数里头呢我们是允许调用纯虚函数f的， 那么它执行的操作呢就是用当前这个this指针指向f， 那么要注意，在这个a的构造函数里头是不可以去调用 f函数的，如果调用的话呢是错误的，构造函数里头不可以使用纯虚函数。那么从这个抽象类派生出来的新类class B呢 ，它在实现的时候就具体实现了这个纯虚函数f， 那么它的实现呢就是去输出B:f 打印输出这样的语句。**那么由于B呢对这个纯虚函数进行了实现， 所以呢它不再是一个抽象的类了。那么由于不再是一个抽象类呢它就可以去定义一个相应的对象**，大B区定义了一个对象小b，那么小b呢就调用了基类的一个函数g，那么这个g呢它是g类的一个成员函数，我们刚提到，成员函数是可以去调用纯虚函数的。 那么这个纯虚函数呢已经在这个非抽象类啊， 这个派生类B里面具体做了实现， 那么这个时候呢我们小b调用g这个函数实际上调用的就是在b这个派生类里面f函数的一个具体的实现。那么就是去执行了cout B:f() 那么我们看最后，这个程序执行的结果就是打印输出 B:f()，所以呢我们看到说由一个抽象类具体派生出来了一个新的类， 那么 在这个新的类就可以产生了一些相应的对象，啊， 这个对象呢就可以具体去执行相应以及实例化了的这个纯虚函数。 