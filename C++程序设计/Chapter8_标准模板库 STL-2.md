# [标准模板库](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/9)
> 本模块将继续介绍C++的标准模板库（Standard Template Library，STL），这是泛型程序设计最成功的应用实例。STL是一些常用数据结构（如链表、可变长数组、排序二叉树）和算法（如排序、查找）的模板的集合。有了STL，你就不必编写大多的、常用的数据结构和算法。即便不想用面向对象的程序设计方法编程，学习STL也是大有裨益的。
## 1. Set 和 Multiset
- 呃，同学们好呃，这节课我们说说标准模板库 STL 里面的这个 set 和 multiset 呃，这个这个东西特别的好用，那我们知道前面讲的这个顺序容器，现在该讲这个关联容器了。 关联容器呢有这个四种，set， multiset， map 和 和 multimap， 它们的特点呢就是内部元素是从小到大排好序的，当然什么叫小什么叫大你可以自己定义。 呃，那这些关联容器除了各种容器都共有的那些成员函数以外，它还有以下这些成员函数。 呃，最常用的一个就是 find。 find 呢它能够查找等于某个值的元素啊，这里所说的等于不是用那个恒等号去判断等于，什么叫等于呢，如果 x 小于 y 和 y 小于 x 同时不成立， 那这个就认为 x 和 y 是相等的啦呃，至于这个什么叫小于呢，以后这个可以自己定义了。 呃，这个 lower_bound 是查找某个下界，哦还有 还有这个 up_bound 是找上界，equal_rang 呢就是同时查找上界和下界，count 是计算等于某个值的元素的个数。 然后 insert 是用来插入一个元素或者一个区间到这个关联容器里面呃，
- 进一步学习这个关联容器之前， 之前我们首先要学一个预备知识就是这个 pair 模版，这个 pair 模版呢是这，这个 STL 里面预先定义好的一个类模版啊，我们前面学模版的这个知识的时候实际上自己也写了一遍。 跟那个有点像，
    ```C++
    //pair模板
    template<class _T1, class _T2>
    struct pair {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        pair():first(),second() {}
        pair(const _T1 &__a, const _T2 &__b):first(__a),second(__b) {}
        template<class _U1,class _U2>
        pair(const pair<_U1, _U2> &__p):first(__p.first),second(__p.second) {}
    };
    // map/multimap容器里放着的都是pair模板类的对象，且按first从小到大排序
    //第三个构造函数用法示例：
    pair<int,int> p(pair<double,double>(5.5, 6.6));              //p.first = 5, p.second = 4
    ```
  这个 pair 模版它有两个类型参数 T1 和 T2 啊，这个 pair 模版被写成了 struct 的这个形式，这样它里面所有的成员呢不需要声明就都是公有的，然后把这个，在这里面把 T1 它的 define 成 first_type, 那我们以后用 first_type 就能够 代表 T1 类型啦，然后把 T2 定义成 second_type 这种类型的，那重要的是我们要知道 pair 模版有两个成员变量 一个叫做 first 一个叫做 second， first 是 T1 类型的 second 是 T2 类型 的，接下来我们要看的就是 pair 模版的几个构造函数，第一个构造函数无参构造函数嗯，我们看这里有一个初始化列表， first 和 second 是对象的话是成员对象的话，那么 first 和 second 都是用无参构造函数来初始化的。 那如果 first 和 second 是基本类型的变量的话呢，那后面加个圆括号从语法上来讲也没有问题，那等于也就 不初始化它啦呃，再看第二个构造函数呃，第二个构造函数呢它有两个参数 a 和 b， a 呢是 T1 类型的，b 是 T2 类型的嗯，然后在这个初始化里面呢用 a 去初始化 first 用 b 去初始化 second 呃，这个非常的符合逻辑呃，那我们看第三个构造函数呃，第三个构造函数它不是一个普通的构造函数。 构造函数，它实际上是一个模版啊，它是一个函数模版呃，那这个函数 函数模版呢仅在我们真的用到了这种形式的构造函数的时候它才会被实例化出来，等会会讲到它如何被实例化。 这个函数模版它有两个参数 U1 和 U2，类型参数啊，然后这个 pair 构造函数它的参数呢是另外一个 一个呃，pair 模版类的对象，在这个 pair 模版类的对象 p 里面呢呃，这个 first 成员变量呢， 是 U1 类型的，然后 second 成员变量呢是 U2 类型的。然后我们在这个构造函数里面啊呃，用 p.first 去初始化 去初始化呃，first ，用这个 p.second 去初始化呃，这个 second 呃，这也呃，看上去也没有任何问题吧。 pair 模版这么重要呢，那是因为啊，这个 map 和 multimap 这种容器里面放着的东西全都是从 pair 模版实例化出来的类的对象，而且它们是按 first 这个成员变量从小到大排序的呃，按大小 按大小，什么叫小什么叫大你可以自己定义呃，除此之外呢 set 里面和 multiset 里面也有一些成员函数。 那个 equal_rang 它的返回值就是一个 pair 模版类的对象，所以我们要先说 pair 模版呃，那 那，那接下来我们先看一下第三个构造函数模版在什么时候会起作用，比方说我们定义的一个 pair 模版类，pair<int, int> 啊，它是一个 pair 模版类，然后我们定义了这样一个类的对象叫做 P ，那 P 后面跟的这个括号就给出了构造函数的参数，然后看这个构造函数的参数呢只有一个，那肯定是呃，调用了 那边这个构造函数的对吧，这个唯一的函数呢是另外一个 pair 模版类的对象，那个 pair 模版类是 pair<double, double> 好，那这个 pair 模板类的对象呢是一个没有名字的零时对象它的类型是 pair<double, double>， 那么这个零时对象它的 它的 first 成员变量当然就是 double 类型的而且它的值是 5.5 对吧，然后这个零时对象它的 second 成员变量也是 double 类型 类型的，它的值是 4.6， 那，那总而言之我们就会用 5.5 去初始化 P 的 first，用这个 呃，4.6用 p.second 是在这块就对应4.6呃，去 p.second 那当然初始化的结果就是呃，把这个浮点数去尾取整啊，因为我们这个 P 里面的 first 和 second second 它都是 int 类型的对吧，所以我们就去尾取整结果 p.first 呢变成了5，p.second 变成了4.6 
- 好我们学过了 pair 的预备知识啊，接下来我们就要近距离的看看这些关联容器都长什么样。 啊我们先看这个 multiset 它在 STL 里面的定义是这样的啊，
    ```C++
    //multiset
    template<class Key, class Pred = less<Key>, class A = allocator<Key>>
    class multiset {
        ....
    };
    //Pred类型的变量决定了multiset中的元素，“一个比另一个小”是怎么定义的。
    //multiset运行的过程中，比较两个元素x，y大小的做法，就是生成一个Pred类型的变量，假定为op，若表达式op(x,y)返回值为true，则x比y小。
    //Pred的缺省值是less<Key>

    //less模板的定义：
    template<class T>
    struct less:public binary_function<T,T,bool> {
        bool operator()(const T &x, const T &y) 
        {
            return x < y;                 //less模板是靠 < 来比较大小的
        }
        const;
    };

    //multiset的成员函数：
    iterator find(const T &val);          //在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()
    iterator insert(const T &val);        //将val插入到容器中并返回其迭代器
    void insert(iterator first, iterator last); //将区间[first,last)插入容器
    int count(const T &val);              //统计有多少元素的值和val相等
    iterator lower_bound(const T &val);   //查找一个最大的位置it，使得[begin(),it)中所有的元素都比val小
    iterator upper_bound(const T &val);   //查找一个最小的位置it，使得[begin(),it)中所有的元素都比val大
    pair<iterator,iterator> equal_range(const T &val);      //同时求得lower_bound和upper_bound
    iterator erase(iterator it);          //删除it指向的元素，返回其后面的元素的迭代器
    ```
  我们首先看到 它有三个类型参数，一个叫 Key ，那 Key 呢就代表这个 multiset 里面放着的元素的 这个类型呃，第二个类型参数 Pred 呃，这里看上去比较奇怪，它还有一个等于什么 less<Key>，这是 类型参数也可以有缺省值的这个意思，等会再解释， 解释。那总而言之 Pred 它是用来规定 呃，multiset 里面的元素比大小是按什么规则来进行的。 呃，也就是说 Pred 类，类型的变量， 它决定了比大小的这个规则，这个 multiset 在运行的过程中在需要比较两个元素 x y 的时候。 multiset 会生成一个 Pr 类型，Pred 类型的变量，假设这个 Pred 类型的变量叫做 op。 那么怎么比较元素 x y 的大小呢，multiset 就会去计算 op(x,y) 这个表达式的值。 如果这个表达式的值返回为 true 的话那么就认为 x 比 y 小也就是说 x 要排在 y 的前面。 那我们看到这样一个表达式要有定义，那 op 得是一个什么东西才行呢？ 那我们知道 op 它可以是一个函数指针或者函数名字或者是函数对象啊那 那真正 multiset 在运行的过程中这一块的话实际上是有可能是函数指针也有可能是一个函数对象。 很多的情况都是函数对象，那如果 op 是一个函数对象的话，op(x,y) 怎么解释呢，这当然就是调用 op 这个对象的 operator 圆括号成员函数。 对吧，那我们说了这个呃，这个 Pr 呃，Pred 它的缺省值是 less<key>，那这意味着 什么呢？那我们就要看这个 less 到底是个什么东西。 less 呢它是一个函数对象类模版，在 STL 里面就有的 呃，把它定义成一个 struct，它从什么东西派生过来这个不重要我们不管它。 我关心的是 less 这个类模版里面它重载了圆括号 那这个圆括号呢一般就是被用来比大小的，对吧，比较 x y 的大小。 那这个，这个圆括号成员函数返回 true 的时候就意味着 x 是小于 y 的。 那我们看这个圆括号里面怎么比大小呢啊，我们看到啊，如果 x 小于号 y 这个表达式返回值为 true 的话。 那么呃，整个函数的返回值就为 true，那归根到底我们就 知道了，这个 less 模版它是靠小于号来比较大小的。 那也就是说你在使用 multiset 的时候你从这个 multiset 实例化出来一个类的时候，第二个类型参数和第三个类型参数你都可以不给的。 其中这个第三个类型参数根本就不重要，我们就当作没看见不理它了啊，第二个类型参数如果不给的话呢。 第二个类型参数的类型就会用 less<key> 来替代呃，那也就是说如果你 嗯 不给第二个类型参数的话呃，那 multiset 在执行的过程 过程中比大小的时候用到的这个变量 op 就是 less<key> 这种类型的。 那这个时候要用 op(x,y) 这个表达式进行 进行比大小的时候呢就会调用这里定义的这个圆括号。 那在此情况下我们看到比大小的规则是什么？就是用小于号来比大小。 那也就是说，你使用了 multiset 的时候，如果你没有自己定义比大小的规则。 那在这个缺省的情况下，multiset 就是用小于号去比大小，去比较 元素的大小了。那接下来呢我们来看看 multiset 都有哪些成员函数啊。 呃，第一个是 find 啊，它是在容器中 查找值为 val 的元素，就是说值等于 val 的元素。 如果查到了呢就返回其这个元素的迭代器，如果查不到呢，返回值就是 end() 这个迭代器。 那这里所说的等于它的意思不是用那个恒等号去判断啊，而是 x 小于 y 和 y 小于 x 同时不成立，那就算 x 等于 y。 至于什么叫小于呃，你可以自己定义也可以用缺省的这种小于号。 然后这个 insert 就是把一个元素。 把一个值插到这个容器里面 那就能够新添加一个元素了嘛，然后就返回这个新增元素的这个迭代器。下面这个 insert 呢是把一整个区间插入到这个容器里面去，它的返回值是 void。 Count就是统计有多少元素的值和这个val相等。相等的意思是X小于Y和Y小于X同时不成立。呃，然后这个lowerbound它是查找一个迭代器， 它实际上是相当于查找一个下界啊，下界的意思是就是说它找一个迭代器， 这个迭代器it， 使得从begin到it中的所有元素都比val要小。当然it所指向的那个元素它， 不比这个val要小。呃，然后这个upperbound，它是查找一个上界。 呃。 它呢是查找一个最小的位置it，嗯，所谓最小就是，最靠左边吧， 那这边的这个最大就最靠右边吧。呃，那upperbound是找一个最小的位置it，使得这个左闭右开的区间，就是从it到end这个区间里面的所有元素， 都比val要大，也就说val，小于这个区间里的，呃，所有元素 那么我们要知道，这个，find, insert, 呃，插入一个元素，以及，以及这个，呃，lowerbound, upperbound， 他们的时间复杂度呢，就都是这个，呃，logN的。 那insert的时间，insert一个区间的时间复杂度是多少呢？ 那跟这个区间有多少个元素有关系，对吧？ 区间有n个元素那就，那就再，再，再乘以logN。 然后，呃，multiset还有一个成员函数叫做equal range。 equal range它是同时求得lowerbound和upperbound。 那lowerbound和upperbound两个值啊，怎么同时返回两个值呢？所以这个时候equal range它， 呃，它的返回值就是一个pair类模板的对象。啊，这个pair类模板， 实际上画出来的类型是pair, iterator, iterator。 也就是说，在这个pair对象里面，它的first成员变量和second成员变量， 类型全都是，呃，这个容器上的迭代器。然后实际上呢，在这个返回值里面， 反而是对象里的first实际上就是存放着lowerbound的结果，second就会存放着upperbound的这个结果。 呃，还有一个重要的成员函数erase，就是删除，呃。 某一个迭代器所指向的元素。它的返回值呢也是一个iterator，就是C++的标准， 它并没有说erase的返回值是iterator。但是在好多现在的编译器里面， 这个erase它删掉了it所指向的元素以后， 它的返回值就是被删除元素后面那个元素的，这个迭代器。 那这样用起来会很方便呐。**那我们使用erase的时候要注意就是，如果一个迭代器指向的元素被删掉了，那这个迭代器就会失效。 那你就不能，再去使用这个迭代器了。呃，你不能说，it所指向的元素被删掉了， 你还用it，让it++，它还能自动指向被删除元素的后面的元素，或者再后面一个元素。 这是不行的，总之吧，一个迭代器所指向的元素一旦被删掉，这个迭代器你最好就不要再用它了。**
- 那我们下面看一下这个multiset具体的这个用法。 这是一个完整的程序啊，但是它是会出错的。
    ```C++
    //multiset的用法
    #include <set>
    using namespace::std;
    class A {};

    int main()
    {
        multiset<A> a;
        a.insert(A());          //error
        return 0;
    }

    /*
    multiset<A> a;
    就等价于
    multiset<A, less<A>> a;
    插入元素时，multiset会将被插入元素和已有元素进行比较。由于less模板是用 < 进行
    比较的，所以，这都要求A的对象能用 < 比较，即适当重载了 <
    */
    ```
  在这里面有个class a，我们使用multiset要include set这个头文件。 呃，然后我们定义了一个multiset的模板类。 就是multiset尖括号a， 然后定义了一个这个模板类的对象。那我们知道multiset它有三个 那个类型参数a，我们只给了一个类型参数a， 表明这个multiset里面呢，每一个元素都是class a这种类型的对象。 不打也可以，对吧，因为我们后面两个类型参数是可以有缺省值的。 呃，这条语句没有什么问题。但是呢，我们在写这个a点insert，啊这条语句，就会编译出错了。 为什么会编译出错呢？那我们就分析一下 这个multisetA到底是一个什么样的东西。啊，我们写multiset a这么一个简单的写法， 它是等价于下面这种写法的。 当然下面这种写法它也少掉了一个类型参数，那个第三个类型参数我们不管它。 所以我们就关心这里，第二个类型参数它的缺省值是，less a。 那么这个multiset在插入元素，就是执行erase，执行insert。 在执行插入元素的时候，multiset会将被插入的元素和已有的元素进行比较。 这时候比大小的规则是什么啊？就是这个less a。 那less a 这个类里面它的圆号有重载，它重载的圆号的这个成员函数，然后那个成员函数里面呢，用了小于号去对两个class a的对象进行比较。 然后我们整个程序里面都没有重载这个小于号，那也就是说，两个class a的对象是不能比大小的。 所以，呃，程序在这就会编译出错。归根到底就是因为程序编译器会从， 会实地化出来一个less a这个类，这个类里面圆号用到了小于号， 然后这个类里面呢圆号成员函数用到了小于号，然后你这个小于号呢又没有定义， 所以就编译错了。呃，
- 那下面我们看一个能编译过的这个例子啊。 呃，在这个例子里面我们看啊，
    ```C++
    //multiset的用法
    #include <iostream>
    #include <set>              //使用multiset需包含此文件
    using namespace::std;

    template<class T>
    void Print(T first, T last)
    {
        for( ;first != last; ++first)
            cout << *first << " ";
        cout << endl;
    }

    class A {
        private:
            int n;
        pbulic:
            A(int n_):n(n_) {}
            friend bool operator<(const A &a1, const A &a2)
            {
                return a1.n < a2.n;
                friend ostream &operator<<(ostream &o, const A &a2)
            }
            friend ostream &operator<<(ostream &o, const A &a2)
            {
                o << a2.n;
                return o;
            }
            friend class MyLess;
    };

    struct MyLess {
        bool operator()(const A &a1, const A &a2)
        {
            //按个位数比较大小
            return (a1.n % 10) < (a2.n % 10);
        }
    };

    typedef multiset<A> MSET1;              //MSET1用"<"比较大小
    typedef multiset<A, MyLess> MSET2;      //MSET2用 MyLess::operator()比较大小

    int main()
    {
        const int SIZE = 6;
        A a[SIZE] = {4,22,19,8,33,40};
        MSET1 m1;
        m1.insert(a, a+SIZE);
        m1.insert(22);
        cout << "1)" << m1.count(22) << endl;       //输出：1)2
        cout << "2)" << Print(m1.begin(), m1.end()) << endl;       //输出：2)4 8 19 22 22 33 40
        MSET1::iterator pp = m1.find(19);
        if(pp ！= m1.end())                          //条件为真说明找到
            cout << "found" << endl;                //本行会被执行，输出：found
        cout << "3)" << *m1.lower_bound(22) << "," << *m1.upper_bound(22) << endl;       //输出：3)22,33 
        pp = m1.erase(m1.lower_bound(22), m1.upper_blund(22));  //pp指向被删除元素的下一个元素
        cout << "4)" << Print(m1.begin(), m1.end()) << endl;       //输出：4)4 8 19 33 40
        cout << "5)" << *pp << endl;       //输出：5)33
        MSET2 m2;                          //m2里的元素按n的个位数从小到大排
        m2.insert(a, a + SIZE);
        cout << "6)" << Print(m2.begin(), m2.end()) << endl;       //输出：6)40 22 33 4 8 19
        return 0;
    }
    ```
  先写了一个print这个模板。 呃，它是能够把一个区间，first和last里面内容都给它用celt输出出来。 呃，然后这个class a，还有个成员变量n。然后class a 呢定义了一些友元， 其中有一个是小于号，被重载的小于号。这个小于号所规定的比较大小的规则是什么啊？ 就是谁的n成员变量数学上小， 那谁就算小。啊，然后还有这个，有运算符用来输出，这个对象n的值。 嗯，还有另外一个类，叫做myless，啊，这个myless是干什么的呢？ 啊，我们看到这个myless，它是一个函数对象类。 它里面重载了圆号，这个圆号所规定的比大小的规则是什么呢？ 我们看看，就是说，谁的个位数数学上小，谁就算小，啊。 好了，那现在，我们接下来看， 去用这个multiset。这里我们用到了一个multiset a。 呃，这种类型。那这个类型写起来可能比较长吧，这我就把它typedefine一下，啊， 让它变成了这个mset1。那这个mset1， 我们定义的时候并没有去制定比大小的规则。 那也就是说mset1这种容器吧，它是用小于号来比大小的。 那我们再来typedefine另外一个类型，multiset a, myless。 呃，给它一个新的名字，啊，mset2。 那就是说mset2 这种容器，它是用什么东西去比大小的呢？ 呃，我们看到它用到myless这种类型。 呃，实际上归根到底就是用myless里面的这个operator的这个圆号，这个成员函数去， 呃，比大小的。那也就是说，myless所定义的这个比大小的规则就是， 呃，谁的个位数数学上小，谁就算小。 好那我们再看main里面啊， 首先定义了一个size, 呃，它有6个元素吧，宿主有6个元素。 然后呢，我们定义了一个mset1类的容器，叫m1。 然后在m1里面调用insert1成员函数，啊，才能够把一整个区间插入进去。 那插入进去以后这些元素就自动排好序了，在这个过程中肯定会去调用比大小的小于号了。 啊，然后我们在m1 里面再插入一个22，呃， 那multiset它是排好序的一种容器，而且它里面的元素是可以重复的， 所以我们接下来看，我们调用count成员函数算一下有多少个元素它等于22，那输出的结果当然都是2，对吧因为 原来有一个22，你又插入一个22，那它有两个22。 呃，接下来我们调用print这个模板把m1的内容全部输出了， 那我们看到，是按照从小到大 的顺序输出的。因为m1里面的元素是排好序的，而且那个排序的规则就是用小于号， 而且是， 这个小于号所定义的这个排序规则，就是谁的成员变量n数学上小，谁就算小。所以这里面我们看到，这些是，数学上从小到大排序输出了。 接下来呢，我们调用这个find去查找这个元素19，好那我们看这个m1里面 不是18，19什么之类的对吧？那这个时候呢，肯定是能找到的。那判断能否找到的办法就是看一下返回值这个迭代器是不是 等于and，如果等于and就说明找不到。那这个程序它肯定能找到啊，所以这一行会被执行出一个found。 呃，那再接下来呢我们看，哎，在m1上面调用lowerbound，lowerbound它的返回值是一个迭代器。 然后我们通过星号再把这个迭代器指向的内容给它输出，那这个lowerbound它是做些什么呢？ 嗯，这个lowerbound啊，它， 我们看它的定义啊，lowerbound，嗯，它是，在这个容器里面查找一个最大的位置it，使得从begin到it里所有元素都比这个val要小。 那这个最大的位置，就是说最靠右的这个位置，或者说是最接近and的这个位置， 注意这个区间是一个左闭右开的这个区间，那么我们这个m1点lowerbound22， 呃，就是要在这里面查找一个迭代器，嗯，这个这个it，然后使得从4，啊，这第一个元素begin，4到这个it 这个区间里面的所有元素都比22小，那这个lowerbound找到的迭代器应该指向哪儿呢？它当然应该指向这个22，对吧？那这样的话我们从begin 所有元素，当然它都比22要小了，对吧？注意这是左闭右开的这个区间，所以这个22本身是并不算在内的。嗯，那总而言之吧， 我们这个m1点lower bound找到的迭代器就指向了这个22，是吧？所以，我们给它输出的时候，输出的值当然就是 22了。那接下来我们再看upper bound。Upper bound是干什么的呢？Upper bound是要求一个左闭右开的这个区间。 它的这个左边的那个迭代器，左边这个迭代器要尽可能靠begin 尽可能向左。那求出这个左闭右开的区间里面呢，每一个元素呢，都要比这个22 要大。 那这个左闭右开的区间就是这样。 那么这时候我们这个upper bound所求出来的那个迭代器，等于就是指向这个33。就是指向33 这个迭代器。所以我们这里输出的结果，你要输出，新m1点upper bound输出的结果当然就是33了。 好，接下来我们呢，再调用erase，就把这整个区间都给它删掉， 就是lower bound 和upper bound之间的元素给它删掉。那我们看到这个区间是什么呢？这个区间它是 一个左闭右开的区间，就是22， 然后，这个，33。由于这是一个 左闭右开的区间，所以呢，这两个22就被删掉了，但是33呢，还留着。然后我们这个PP就等于 erase的返回值，它是迭代器指向了被删除那个区间的后面的一个元素。那当然就指向了这个33。 所以我们这个，一开始输出这个m1里面的内容，它有两个22 被删了。然后再输出新pp，就是pp指向的元素，那当然就是33了。接下来我们再看有一个m2， 这个是MSET2。MSET2这个容器里面比大小的规则是什么呢？就是个位数小的， 就算是小。嗯，于是我们在这条INSERT语句中一下把一个区间插到m2中间去，这个区间就是 数组A，那就是说数组A里面的元素都被拷贝到m2里边去了，而且是按个位数从小到大排序了， 我们把它输出，果然，按个位从小到大排序，就是这个样子。OK，这个输出 是这样的。好，这个multi-set呢，总算说完了。
- 接下来就讲讲这个set。Set也特别常用。 **它跟multi-set的差别就在于啊，这个set里面是不能够有重复元素的。嗯，什么叫 重复元素啊？并不是说A等于B，A就叫重复了啊。实际上，如果有A小于B不成立，而且B小于A也不成立，那么 A和B就算是重复了。**
    ```C++
    //set
    template<class Key, class Pred = less<Key>, class A = allocator<Key>>
    class set {
        ....
    };
    //插入set中已有的元素时，忽略插入
    //Pred类型的变量决定了set中的元素，“一个比另一个小”是怎么定义的。
    //multiset运行的过程中，比较两个元素x，y大小的做法，就是生成一个Pred类型的变量，假定为op，若表达式op(x,y)返回值为true，则x比y小。
    //Pred的缺省值是less<Key>

    //less模板的定义：
    template<class T>
    struct less:public binary_function<T,T,bool> {
        bool operator()(const T &x, const T &y) 
        {
            return x < y;                 //less模板是靠 < 来比较大小的
        }
        const;
    };

    //set的成员函数：
    iterator find(const T &val);          //在容器中查找值为val的元素，返回其迭代器。如果找不到，返回end()
    iterator insert(const T &val);        //将val插入到容器中并返回其迭代器
    void insert(iterator first, iterator last); //将区间[first,last)插入容器
    int count(const T &val);              //统计有多少元素的值和val相等
    iterator lower_bound(const T &val);   //查找一个最大的位置it，使得[begin(),it)中所有的元素都比val小
    iterator upper_bound(const T &val);   //查找一个最小的位置it，使得[begin(),it)中所有的元素都比val大
    pair<iterator,iterator> equal_range(const T &val);      //同时求得lower_bound和upper_bound
    iterator erase(iterator it);          //删除it指向的元素，返回其后面的元素的迭代器
    ```
  好，那，如果你插入的一个元素 如果你想往set里面插入一个值的时候，这个值跟set里头已有的元素重复了，那就是说会怎么样呢？ 这个插入当然就不成功了。我们来看看set的这个用法。
    ```C++
    //set用法示例
    #include <iostream>
    #include <set>
    using namespace::std;

    int main()
    {
        typedef set<int>::iterator IT;
        int a[5] = { 3,4,6,1,2 };
        set<int> st(a, a+5);                                        //st里是 1 2 3 4 6
        pair< IT, bool > result;
        result = st.insert(5);                                      //st变成 1 2 3 4 5 6
        if(result.second)                                           //插入成功则输出被插入元素
            cout << *result.first << "inserted" << endl;            //输出： 5 inserted
        if(st.insert(5).second)                                     //插入成功则输出被插入元素
            cout << *result.first << endl;  
        else
            cout << *result.first << "already exists" << endl;      //输出： 5 already exists       
        pair< IT, IT > bounds = st.equal_range(4);
        cout << *bounds.first << "," << *bounds.second << endl;     //输出： 4,5 
        return 0;
    }
    ```  
  嗯 在这里我们定义一个，当然include头文件set ，然后我们定义了一个类型，就是set<int>这种容器上面的 迭代器。这种类型我们称之为大写的这个IT。Inter rate，这里有一个数组。 3、4、6、12，然后我们定义了一个，set容器，里面都是整形的 变量。把这个数组的全部内容都拷过去，那我们在这里定义set的时候，我们并没有指明这个 排序的方式，对吧？那当然这个set<int>就是用小于号去排序的。 所以在这里面ST里面的元素当然就是按照数学上的小从小到大排序的，就是1、2、3、4、6。 嗯，接下来我们定义一个pair，内模板，pair模板类的对象对照，那这个result它有两个层面，一个叫 first，一个叫second。那First的成员变量呢，它的类型IT，就是set<int>上面的迭代器，second的成员变量类型呢，就是booi类型， 定义这个result类型干什么用呢？有用。下面我们调用st一点insert，要往里插一个5， 那我们知道这个set里边它是不能有重复元素的，所以你要往里头插一个元素的时候，是有可能不成功的。 如果你要插的东西在这个set里边本来就有了，那你就不能成功了。可是，你怎么判断插进去的那个元素 你想要插的那个元素在set里边是不是存在呢？就是这个插入到底是不是成功，如何判断呢？那答案就是我们要拿到insert成员函数的 返回值。具体到这条语句，当然是能够插入成功的，对吧？因为它要插入5。 5在原来并没有。那我们怎么判断插入是否成功呢？我们就看这个返回值，它是？对象，看这个返回对象second的 成员变量，这个second的成员变量是booi类型的，其值是true或者false。如果这个second的值为 true，就是说插入成功了。那这个时候result点first就是一个迭代器，它 指向刚刚被插入的这个元素。然后我们就输出新result first，那就是刚刚被插入的那个5，对吧？ 所以这一行就输出了5，inserted。好，那我们下回再来插入一个5， 然后判断是不是成功。最后当然就不成功，是吧？因为你刚刚已经把5放进去了，就是你再插入5就重复了，于是就不成功。 既然插入不成功，那程序肯定就会走这条语句，插入不成功是因为set里面已经有一个元素它的值 跟你要插入的东西重复了，在这种情况下，insert成员元素它的返回值的first成员变量会是 一个迭代器，就会指向那个重复的元素。那在这里，重复的元素就是5。所以在这里输出新的result first当然就会输出5。 那就是输出5，already exists。接下来我么再看调用了这个set的equal range的函数，求4这个值的 equal range。Equal range就是同时求lower bound和upper bound。那这个equal range它的返回值也是一个pair对象。 这个pair对象的first和second成员变量全部都是迭代器。那实际上，这个lower bound求出来的东西就是一个迭代器嘛。 就会放到first的成员变量里面。Upper bound这个迭代器就会放在second的成员变量里面。那这个st是1、2、3、4、5。 那求lower bound。Lower bound是什么呢？Lower bound是求一个最靠右边的迭代器。 啊，这个，这个迭代器，再往左的那些元素，都比这个值要小。那最靠右边的，这样一个迭代器求出来就是 指向4这个位置。它的右边的元素，嗯，它的左边的元素都比4要小，而且这个迭代器，你就 没法儿再往右移了。再往右移，4就不比4小，那就错了，对吧？所以我们输出的这个 bounds点first就是，lower bound就指向4嘛。然后upper bound是什么呢？ 就是求做靠左边的一个迭代器。然后从这个迭代器开始，一直再往右，直到元素都要比4都要大。那当然这个迭代器就指向5这个位置。 对吧？它是最靠左边的，而且从它开始往右的元素都比4要大。所以，所以输出新的bounds点second当然就是5了。 因为这个upper bound被放到bound点second里面去了。 那总算讲完了，费了好大劲。 
## 2. Map 和 Multimap
- 说完了set 和multiset，现在我们要说另外两种重要的关联容器，就是map和multimap。 嗯，这时我们先回顾一下pair模板。这个map和multimap里面放着的东西 它不能是基本类型的变量，它必须是pair模板类的对象。 嗯，那也就是说，map和multimap里面放着的东西一定是个对象，而且对象一定是只有first和second的 这两个成员变量。而且,multimap和map都是按照first的成员变量 来把这些元素进行从小到大排序的。当然，什么叫大小，你可以自己定义啊。 我们来看看map的这个multimap 它的定义，啊，是这样。 嗯，第一个类型参数key ，实际上就是代表了multimap里面元素的first的成员变量的类型。 第二而类型参数T，就是元素的second的成员变量的类型。第三个 类型参数Pred确审值是lesskey, 就规定了 比大小的规则。那第四个类型参数，那个我们不管它，就用确审值就行了。然后再multimap的里面呢 嗯，typedef了一个value type的这样一个类型。嗯，它是一个pair类型，pair<const key.T> 嗯，那就是一个value type呢它有两个成员变量。嗯，first的成员变量呢是T类型的。 而且是const的了。那second的成员变量呢，是T类型的。那在map和multimap里面 我们往往把元素的first 的成员变量，呃，称为这个关键字。 那这样的话multimap和map之中的元素啊，都是由关键字和词组成，啊。 First的成员变量叫关键字，Second的成员变来那个叫值。它每个元素都是一个pair对象。 关键字的类型是key ，那multimap的中他是允许有多个元素的关键字， 也就是与first的成员变量相同的，然后元素按照first的成员变量从小到大排序。 那确审的情况下呢，当然是用less Key定义什么叫小。 
- 我们下面看一个具体程序的例子。
    ```C++
    //Multimap用法示例
    #include <iostream>
    #include <map>
    using namespace::std;

    int main()
    {
        typedef multimap< int, double, less<int> > mmid;
        mmid pairs;
        cout << "1)" << pairs.count(15) << endl;                //输出：1）0
        pairs.insert(mmid::value_type(15, 2.7));                //typedef pair< const Key, T > value_type;此处生成了 pair< const Key, T >(15, 2.7) 临时对象                                                              //然后插入到pairs中去
        pairs.insert(mmid::value_type(15, 99.3));
        cout << "2)" << pairs.count(15) << endl;                //求关键字等于某值的元素个数；输出：2）
        pairs.insert(mmid::value_type(30, 111.11));             //typedef pair< const Key, T > value_type;
        pairs.insert(mmid::value_type(10, 22.22));        
        pairs.insert(mmid::value_type(25, 33.333));             //typedef pair< const Key, T > value_type;
        pairs.insert(mmid::value_type(20, 9.3));   
        for( mmid::const_iterator i = pairs.begin(); i != pairs.end(); ++i)
            cout << "(" << i->first << "," << i->second << ")" << ",";     //输出:(10,22.22),(15,2.7),(15,99.3),(20,9.3),(25,33.333),(30,111.11),
        return 0;
    }
    ```  
  呃，我们使用multimap #include <map>的这个头文件。然后这里面 typedef了一个类型，叫mmid，这个类型是一个muiltimap的 容器。type的first的成员变量，整型的。 然後，second的成员变量呢，是double型的。然后，这个关键字也就是first的成员变量，比大小的规则是了less int，那归根到底就是用小1号去比大小啦。 呃，这就是我们定义出来的一种Multimap的容器类的这种类型mmid。 然后，这里定义了一个这个pairs这样一个容器。然后，在这里呢调用pairs.count成员函数算里面有多少个，元素的关键字的值等于15 。啊，这里说的等于也不使用等等号。 而是说x小于y，y小于x同时不成立，就算等于。 这里面算有多少个元素的关键字是等于15，那当然没有，对吧？因为一开始pairs就是空的。所以说， 呃，这第一行的输出呢，就应该是，嗯，0。对，第一行输出是0。然後接下来呢，我们调用 这个multimap 的insert成员函数。就往里头去插入一个元素，那我们知道 要插入的元素必定是一个pair模板类的对象。所以我们在这个参数这块要生成一个 pair模板类的对象。怎么生成呢？呃，看这种写法，这个东西是什么呀？是在 mmid这个类里面定义的valuetype这种类型。那在这个multimap的这个定义里面有这样一条语句， typedef pair <const key.T> value_type。那，呃， **那么也就是说这个 mmid value_ type是个什么样的东西呢？那当然就是把这个key替换成这个int的这个T替换成double以后，得到的这样的一个pair模板类这种类型。 呃，那这个是一个类型的名字，而后面呢()里面有给出了参数。这个参数当然就是 构造函数的参数，于是这里面的整个表达式就是一个临时的这个对象。这个对象所属的类型是，呃，mmid value type. 归根到底就是这个pair、呃，int、double。好，现在在这里就生成了一个 这样的一个pair对象。这个pair对象的first的成员对象是int型的，嗯，它的值是15 。然後， second的成员变量呢，是double型的，它的值是27。 然后就把这个对象插到这pairs里面去了，那实际上就是这个对象的副本被插进去了。** 呃，接下来再插入另外一个对象，是15 ,99.3。呃，multimap只允许有两个元素。 它们的first的成员变量相同的，所以我们接下来算。这时候有多少个元素first的成员变量值是15啦！ 呃，这个时候当然算起来就两个，所以就会输出2，2，第二行的是2。 呃，然后在接下去又插入了这个30，101.1、10，22.2。嗯，然後，嗯，就不停的全部 进行几次插入。然后我们在这里呢，呃，用一个 迭代器i来遍历整个的这个，呃， 这个multiset的容器pairs。然后呢，对每一个迭代器i我们输出它指向的的那个 元素的first的成员变量，和second的成员变量。然后我们发现，呃，这个循环，啊 这个循环输出的结果在这儿，啊。嗯，那这个结果有什么规律呢？啊，我们看到他们的first 的成员变量， 就是一个整型的关键字它是从小到大排序的。这个小的定义就是用小号来确定的。实际上也就是数学上的这个整数的大小的意思。
- 那接下来我们来看一个有点复杂，但却是你学得会就很有收获的一个例题。啊，这个例题呢，是一个学生成绩录入和查询系统。我得把这个题目念一遍，啊。虽然很长，呃，这个系统呢，它接收以下两种输入： 就是 Add name id score或者query score。而这个内容呢，它是一个 字符串 ，这个字符串中间是不会有空格的。呃，它代表学生的姓名。 那么id 呢是个整数，代表学生的学号。Score是个整数，表示学生的这个分数。然後，学号是不会重复的，那分数和姓名都有可能重复。那总之add的 这条语句就是添加一个学生的信息到这个系统里面去。那query呢，呃，就是进行查询了。就是你碰到add的这样的，呃，输入的时候， 你就把一个学生的信息给存起来。嗯，碰到query score的时候呢，就表示要查询。那看到这种输入，你输出已有记录中，啊，就前面已经出现过的学生里面，分数比这个score低的最高分获得者的姓名、学号和分数。那如果有多个学生都满足条件呢，我们就输出学号最大的那个学生的信息。 那找不到满足条件的学生就输出这个nobody 。好，我们看一下例子。呃，比方说，呃 你输入了add Jack 12 78，好，那你这个程序得记住啊，前面有一个学生叫Jack的他的学号是12 ，他的分数是 78。接下来输入一个query 78，这就是要找分数低于78的 某一个学生。如果有不只，嗯，这个学生呢它是低于78分里面的最高分。如果有多个学生都满足这个条件 的话我们就输出学号最大的那个学生的信息。那到目前为止有，前面只有一个学生Jack， 那当然就，呃， 找不到符合条件的人，对吧？所以说对应query 78 这一行 会产生一个输出结果是nobody。接着query 81，啊，那当然啦，低于81的最高分就是这个jack嘛！所以就会输出一个 Jack，然后他的学号，他的成绩。然后Add Percy 9 81，把学号为9的 Percy同学加进去了，她的分数是81。然後把Mary同学加进去了。然后，query 82 就找分数低于82的的那个最高分的同学，有两个，嗯，但是呢Percy的学号大，所以说我们就可以输出 Percy 9 81。再加query 82 ，那么这已经讲过了。再加 Tom 11 79，有一个Tom同学进来了，分数是79分，呃，学号是7。 然后，query 80就找低于80分的那个最高分，当然就是这个Tom了，呃，对吧？然後query81 找低于81的这个最高分，还是 Tom，所以最后这两行都输出的是Tom的信息。 啊，就是这种东西。那这个程序呢，呃，我们看到它 一边要更新原有的信息，一边还要进行这个查询，当然你最蠢的的办法你可以说，我就是 用一个数组把这个，呃，所有的学生信息全部记下来。当你要查找一个学生的信息 的时候呢，我就从头到尾把这个数组说一遍不就得了吗？当然，你可以这么做。这么做也很简单， 但是，这样做的效率是很低的。呃，这样做的话，呃，你如果，那么添加学生信息 你可以采取用一个vector，然後在尾部进行添加的方式。那添加学生 信息的复杂度基本上可以认为是常数吧！可是， 查询一个学生信息的时候呢，你得从到到尾搜整个数组。那复杂度就是ON的了。 那我们现在是要求，呃，大家用一种办法来做，应该要使得，啊， 添加和查询都很快，比方说，添加的时间复杂度是log n的，查询的时间复杂度也是log n的。 啊，关键是要查得快。这才符合我们的要求。我可以出一大堆的数据，比如说，有一、两百万条的记录， 那你每次进行查询都要搜一、两百万条的记录的话，这肯定就，就很慢了。 那我出个有一两百，一两百万个学生的信息的这个题目放到这个poj上面， 嗯，然后规定一个时限，比如说一秒什么的，那你用顺序查找的办法，用一个vector来存这些东西的话，你十有八九就要超时。 好了，那这个时候，我们该用什么办法来提高这个程序运行的速度？使得不停地更新学生的信息， 不停地进行查询，那它也能保持很高的效率。 就是，经常的状态就是，就是我们添加一个学生，时间复杂度是log n了，查询一个，一个分数，时间复杂度仍然是log n呢？那这样的， 呃，一个题目，我们该用什么，呃什么样的数，什么样的办法去存这些学生的信息呢？ 啊，大家刚才看到了，这个map和multimap应该能很容易想到啊，我们应该要用关联容器，然后呢，我们，关联容器里面呢，这个元素嘛，它都有关键字和值部分对吧，然后是按照关键字，也就是first成员变量从小到大排序的。 然后根据first成员变量去进行查找的话，呃，这个速度也会很快。那在这个例子里面，我们 把一个学生的信息，哪一部分算作这个关键字呢？那当然是分数对吗？我们要根据这个分数查询。 那当然是分数对吗？我们要根据这个分数查询。我们要查询，嗯，低于某个分数的这个，呃，低于某个分数的那个学生， 这个学生是在所有低于这个分数的里面，他的分数最高的。啊，这种查询是按分数查的，我们当然就把分数当做first成员变量。那剩下的部分呢， 那剩下的部分呢，有好几个有姓名，又有，有ID，它是两部分的内容啊？怎么对应到另外一个second成员变量上呢？ 让我们来看看。
    ```C++
    //set用法示例
    #include <iostream>
    #include <string>
    #include <map>
    using namespace::std;

    class CStudent {
        public:
            struct CInfo {                      //类的内部还可以定义类
                int id;
                string name;
            };
            int score;
            CInfo info;                         //学生的其他信息            
    };

    typedef multimap< int, CStudent::CInfo > MAP_STD;

    int main()
    {
        MAP_STD mp;
        CStudent st;
        string cmd;
        while( cin >> cmd ) {
            if( cmd == "Add" ) {
                cin >> st.info.name >> st.info.id >> st.score;
                mp.insert( MAP_STD::value_type( st.score, st.info ) );          //插入pair类模板的对象；mp.insert(make_pair(st.score, st.info));也可以
            } else if( cmd == "Query" ) {
                int score;
                cin >> score;
                MAP_STD::iterator p = mp.lower_bound(score);
                if( p != mp.begin() ) {
                    --p;
                    score = p->first;                                           //比要查询分数的最高分
                    MAP_STD::iterator maxp = p;
                    int maxId = p->second.id;
                    for( ; p != mp.begin() && p->first == score; --p ) {        //遍历所有成绩和score相等的学生
                        if( p->second.id > maxId ) {
                            maxp = p;
                            maxId = p->second.id;
                        }
                    }
                    if( p->first == score ) {                                   //如果上面的循环是因为 p==mp.begin() 而终止，则p指向的元素还要处理
                        if( p->second.id > maxId ) {
                            maxp = p;
                            maxId = p->second.id;
                        }
                    }
                    cout << maxp->second.name << " " << maxp->second.id << " " << maxp->first << endl;
                } else                                                          //lower_bound的结果就是begin，说明没人分数比查询分数低
                    cout << "Nobody" << endl;
            }
        }
        return 0;
    }
    ```  
  好，我们首先确定要使用，这个， 要使用这个关联容器，但到底是要用map还是multimap呢？ 因为这里面分数是关键字，刚才说了，这学生的分数是有可能重复的， 所以说我们必然要用允许关键字重复的那个关联容器，就是multimap。 好，现在我们要往这个multimap里面放着的东西，一定是一个pair模板类的对象。但实际上我们要往里头放的东西， 又是一个学生这样的记录，学生记录刚才有三部分，有姓名、id和分数。而一个pair模板类它只有first和second 这两个成员变量，那怎么把一个学生的记录对应到一个这个，呃，pair模板类的对象上面去呢？ 这要求我们好好地设计学生这个类，啊，我们写了一个cstudent这个类。啊，在cstudent这个类里面呢， 再定义了一个内部的类。在C++里面，类内部还可以再定义一个新的类的，好。 那现在我们在这个定义的内部类里面呢，它的名字叫cinfo。 啊，这个内部类里面包含了两个成员变量，一个是id，就是学生的学号。一个是name，就是学生的姓名。 然后cstudent里面呢， cstudent里面它有两个成员变量，一个是整形的，分数，另外一个成员变量就是， cinfo类型的一个对象。 啊，那么这个对象里面就存放了这个学生的其他信息，就是，就是这个id和姓名。 呃，然后呢我们typedef了一个类型叫做mapstd， 就是学生的map容器，这个mapstd是什么样呢？是multimap，映着cstudent，cinfo。 那也就是说，在这个，呃，map容器里面，关键字是整形的，就是first成员变量是整形的，然后second成员变量呢，是什么类型的呢？ 是cstudent里面定义的cinfo，这种类型的。好，内部类的使用方法就这样。 你在使用内部类的时候，前面要加上这个包含它的那个外部类的名字。 好了，**那现在我们定义出来的mapstd是一个multimap容器，这个容器里的每个元素， 都是一个pair类模板的对象**，然后它的first成员变量是整形的，实际上，可以用来代表，呃，学生的成绩， 然后它的second成员变量呢，是cstudent，cinfo类型的。那这，那second成员变量里面存放的， 当然就是一个学生的id和他的姓名了，对吧？呃，那我们在实际 画出来mapstd这个类型的时候啊，我们，我们并没有指定这个，呃，关键字比大小的规则。那也就是说， 那也就是说，呃，这是一种缺省的情况。 我们当然就是用这个less int去比较关键字的大小，也就是说，归根到底，使用小于号 去比较关键字，也就是这个学生的分数的大小的。那当然，在这个mapstd里面， 又是按照学生的分数从小到大排序的。然后我们在main里面呢， 又定义了mapstd的对象nt，啊，有个cstudent的对象st， 然后有个string用来存放读取的命令，然后我们就读取这个，一个，一条条的命令了。 如果读取来，进来的命令是add，就代表我要添加一个学生的信息， 那么我们就把学生的信息都读到这个st这个对象里面来，啊，读了他们的姓名、id和分数。 接下来我们要做的事情就是要把这个，呃，学生的信息给它插入到这个mp里面，所以我们要调用mp.insert。 但问题是呃，这个mp里放的东西必须是pair 模板类的对象。而我们现在，呃， 学生的信息是放在一个cstudent对象里面的， 我们不能直接把这个st往这个mp里面插，对吧？那我们就必须用一个， 嗯，pair模板类的对象，来存放，这个 学生的信息才可以。那怎么做呢？那我们 就在这里生成了一个pair模板类的对象，这个pair模板类就是mapstd value type，啊。 因为这个value type就等于就是指明了， 一种类型，value type的类型是什么呢？就是mapstd， 这种，呃，multimap的里面的元素的类型，就是这个value type。 那现在这个mapstd value type是一个类型的名字，然后后面又跟了一个圆括号。 然后圆括号里面呢，又给出了，呃，具体的参数。 当然就是构造函数的参数，那也就是说，这个insert这个函数里面的整个参数呢，就是一个临时的对象，这个对象是 ，这个对象是一个pair模板类的对象。它的first 成员变量呢会等于st点score，啊，就是学生的分数。 它的second成员变量呢，会等于st点info，啊,就是学生的其他信息，包括id和姓名。 好了，现在我们现在就把这样一个pair模板类的对象给它插入到mp里面去了， 这当然就是把一个学生的完整信息都给它插入到这个mp里面去了。好了，那如果我们,嗯，收到的指令是query，也就是要进行查询。 那怎么办呢？那我们先把要查的那个分数给，补进来。 好，接下来，我们要查的就是比这个score分数低的， 那个最高分，它的学生。 那怎么来做这件事情呢？那我们知道，在这个mp里面，所有学生都已经按照分数从小到大排序了， 现在我们要找一个，比某个分数低的， 一个最大的那个分数。这时候用什么办法来做啊？当然我们就用这个 lowerbound来做这件事情。那我们要回忆一个这个lowerbound是做什么的。 啊，这个multimap的lowerbound，呃，它返回一个迭代器，呃，它的参数是一个待查找的值va, val， 呃，它返回的一个迭代器叫做it，这个it有什么特点呢？ 这个迭代器，它使得一个左闭右开的区间begin到it中所有 的元素的first成员变量，也就是关键字都比待查找的值val要小。 然后我们看，呃，在这儿，我们是要查找一个比score小的那个最高分对吧，所以我们用这个lowerbound 来进行查找，然后我们会，把查找的结果放到这个迭代器p里面。 那p就相当于是这边的这个it。那我们查找出来的一个区间， begin到这边it，它里面所有的，呃，元素，它的first成员变量，也就是分数， 都会比这个score要小。但是呢，这个it， 呃，本身所指向的那个学生，他的分数呢，并不会比score要小。 好，现在我们就查找这样一个，一个p，迭代器出来了。 呃，那当我们要继续下一步的时候，还要去判断一下p是不是等于mp点begin。 如果p等于mp点begin就意味着什么呢？就意味着这一块啊，这一块这个东西，这个it就是begin了。 那么这个左闭右开的区间，起点是begin，终点是begin， 那等于这个区间就是空的， 那也就是说，如果，如果这个p啊，它是等于mp点begin的话， 就说嘛我们根本就没有查找到任何一个能符合分数，呃， 分数低于score的这样的一个学生的记录。 那所以当p不等于mp点begin的时候才说明，我们能找到符合条件的这个，这个学生。 那，那这时候p所指向的学生是不是符合条件呢？不是符合条件。 啊，p所指向的学生，在前一个学生才是符合条件的。 他的分数才是低于score的最高分，所以我们就--p， 让p值往前指向一个学生，--p之后，p所指向的那个学生， 他的分数就是低于score的最高分了。所以这个时候，我们就把p->first，也就是这个 低于score的最高分，我们给它记下来，记到score里面。 然后呢，由于分数=score的学生可能有多个，如果有多个的话， 我们就得把这多个学生全部都看一遍，然后找出id最大的那个学生。 那这样的话，我们就先假设，一个迭代器maxp，它指向 当前已经找到的id最大的那个学生，那当前找到的 就是p，对吧，然后我们用一个maxid变量， 记录当前已经找到的那个符合条件的学生里面 id最大的那个id， 然后接着我们，我们接下来就要通过一个循环，让 p倒着往前走。 一直走到什么时候才停止呢？如果p已经走到了begin， 都走到头了那当然就停下来。或者说发现p所指向的那个分数， 呃， 已经不等于score了，那我们也会停下来，对吧。那也就是说 只要p还没有到begin，以及p所指向的分数一直都是score，就是这个 這個符合条件的最高分，那我们就 要进行循环，对这个p所指向的学生进行 查看。好，现在我们对p所指向的学生进行查看，就是看，按他的 second成员变量。second成员变量是什么啊？就是一个学生除了 分数以外的其它信息。然后second成员变量里面就有一个id，就记录了这个 呃，学生的这个 记录了这个学生的id，对吧，然后我们就看p所指向的那个学生 的id，看它跟我们当前记下来的那个最大id比怎么样，如果比 maxid还要大的话，那我们呢，当然就要更新这个maxid，对吧。然后我们还要更新这个maxp。 maxp是我们当前找到的最优学生的那个 迭代器。对吧，那我们就更新这个maxp，好了，那这个循环结束以后，它有可能 由于两种原因结束，一种原因就是p=mp.begin；另一种原因就是p->first已经不等于这个score了。 那在这两种情况下，是要分别处理的。如果这个循环终止是因为 p=mp,begin才终止的， 那我们总而言之吧，这个循环终止以后，我们就要看看，终止的条件是不是，呃，这个 我们就要看下循环终止的时候，这个p->first是不是还跟score相等？如果还跟 这个最高分score相等的话呢，那我们还是要去判断一下p所指向的这个学生， 他的id是不是更大，如果是的话，还要更新这个当前找到的最优学生的迭代器，以及最优学生的这个id。 那整个循环执行完以后，我们就找到了这个最优这个学生了。 所以找到最优学生以后呢，我们就把这最优学生的信息给他输出，就行啦。输出姓名， 这个id，还有他的这个分数。那我们再看这块的这个 else，else实际上是对应于前面这个 if的，对应于前面的这个if的，那也就是说，如果走到else这里，就意味着 这个lower_bound刚才查的结果就是begin，说明没有人分数比那个待查询的分数低，那么我们当然就输出这个Nobody。 那这个程序稍微有一点复杂，但是它确实很典型地指明了这个multimap的用途。 里面这个lower_bound是非常好用的，从这里我们能看出来。 总之吧，就是这个关联容器，它特别适合用于， 呃，不断地要更新数据，以及要不断地在数据里面查询的这种情况。 因为你不管是添加一项数据，还是删除一项数据，实际上复杂度都是 log n的，然后你进行查询的时候，实际上复度的也是log n的，都很快。 另外我们再补充一点，就是我们前面看，往这个mp里面插入一个 这个学生的信息的时候，是这么写的，这个写法看上去还不那么舒服。实际上你也可以写mp.insert(make_pair (st.score.st.info))。那这个make_pair呢，就是STL里面一个 函数模板。它的返回值就是一个pair 模板类的对象。然后这个对象，它的first成员变量跟st.score 是一样的，类型也相同啊。second成员变量就跟st.info是相同的， 那multimap说完了，
- 接下来我们再说一下map， 
    ```C++
    //map
    template< class Key, class T, class Pred = less<Key>, class A = allocator<Key> >
    class map {
        ....
        typedef pair< const Key, T > value_type;
        ....
    };
    //map中的元素都是pir模板类对象。关键字（first成员变量）各不相同。元素按照关键字从小到大排列，缺省情况下用 less<Key>,即 "<" 定义 "小于"。
    ----------------------------------------------------------------------------------------
    //map的[]成员函数
    //若pairs为map模板类的对象
    pairs[key]
    //返回对关键字等于key的元素的值（second成员变量）的引用。若没有关键字为key的元素，则会往pairs里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用

    //如：
    map<int, double> pairs;
    //则
    pairs[50] = 5;      //会修改pairs中关键字为50的元素，使其值变成5。若不存在关键字等于50的元素，则插入此元素，并使其值变为5。

    ```
  map跟multimap是很像的，它的最重要的差别就在于map里面不能够有两个元素，它的first成员变量是相同的,即不能有重复的关键字。 那map的定义跟multimap很像，Key是代表关键字的类型，T是值的类型，然后这是比较大小的这个规则。 那么map缺省的情况下，也是用less<key>，就是用"＜"来 比大小的。那map的用法上跟multimap还有一个 重要的不同就是，map它有[ ]这个成员函数。那[ ]成员函数已经很好用了。 就是如果一个pairs，它是map的模板类的对象， 那么pairs[key]这个表达式是有定义的，在这里面呢，key实际上应该是一个， 类型和关键字相同的 那种变量或者是常量。 等于说这个表达式，它能够返回 对于关键字等于key的那个元素的值， 什么叫值啊？值就是second成员变量，它返回的是这个second成员变量的引用。 那如果没有关键字为key的元素， 这个时候呢，就会往pairs里面插入一个关键字为 key的元素。然后这个元素，它的值，也就是second成员变量， 是用无参构造函数初始化的，然后这个表达式一样会返回刚才那个 新插入元素的值，也就是second成员变量的引用。 那我们举个例子，比如说有一个map<int, double>这样的 map的容器类的对象pairs。那么我们写表达式pairs[50 ]=5， 这个表达式呢，就会修改pairs中关键字，也就是first成员变量为50的元素， 把它的值，也就是second成员变量变成5。 那如果pairs里面，没有关键字等于50的元素，那这个时候 一个新的元素就会被插到pairs里面，而且新元素的 关键字，也就是first成员变量值就是50，然后second成员变量，也就是值的值，就是5。 下面我们来看一个具体的这个例子啊， 
    ```C++
    //map用法示例
    #include <iostream>
    #include <map>
    using namespace::std;

    template<class Key, class Value>
    ostream &operator<<( ostream &o, const pair<Key, Value> &p)
    {
        o << "(" << p.first << "," << p.second << ")";
        return o;
    }

    int main()
    {
        typedef map< int, double, less<int> > mmid;
        mmid pairs;
        cout << "1)" << pairs.count(15) << endl;                //输出：1）0
        pairs.insert(mmid::value_type(15, 2.7));                //typedef pair< const Key, T > value_type;此处生成了 pair< const Key, T >(15, 2.7) 临时对象                                                              //然后插入到pairs中去
        pairs.insert(make_pair(15, 99.3));                      //make_pair生成一个pair对象
        cout << "2)" << pairs.count(15) << endl;                //求关键字等于某值的元素个数；输出：2）1
        pairs.insert(mmid::value_type(20, 9.3));   
        cout << "3)";
        for( mmid::const_iterator i = pairs.begin(); i != pairs.end(); ++i)
            cout << *i << ",";                                  //输出:(15,2.7),(20,9.3)
        cout << "4)";
        int n = pairs[40];                                      //如果没有关键字为40的元素，则插入一个
        for( mmid::const_iterator i = pairs.begin(); i != pairs.end(); ++i)
            cout << *i << ",";                                  //输出：4）(15,2.7),(20,9.3),(40,0)
        cout << endl;
        cout << "5)";    
        pairs[15] = 6.28;                                       //把关键字为15的元素改为6.26
        for( mmid::const_iterator i = pairs.begin(); i != pairs.end(); ++i)
            cout << *i << ",";                                  //输出：5）(15,6.28),(20,9.3),(40,0)           
        return 0;
    }
    ```    
  我们使用map，#include <map>这个图文件，然后呢，我们在这里有一个， 对于＜运算符的重载，目的是为了把 一个pair对象的那个内容，在屏幕上给它输出。 输出的方式是先输出左括号，然后是输出first前面，然后再加个逗号，再输出右 p.second，然后再输出右括号。 然后在main里面呢，我们定义了一个类型，叫做mmid。这个mmid是个什么类型呢？ 是map<int, double,less<int> >。当然这个less<int>你不写也是一样的，如果你要写的话呢，这两个 大于号之间要加一个空格，否则有的编译器就会把它看做是又一运算符，那编译就会出错了啊。这是很怪异的一个地方。 好了，现在，我们这个，总之这个mmid它的类型是这样的， 那么也就是说，它是一个map，然后这个map里面的元素。 它的first成员变量是int类型的，然后second成员变量是double类型的。然后它们 关键字，也就是first成员变量排序的，比大小的方式就是用less来 比大小。归根到底就是用小于号来比大小、好，现在我们定义了一个mmid的 对象pairs，然后我们就 一开始就输出，这个pairs里面有多少个事物，那当然是没有事物，对吧，所以就输出0。 然后呢，我们就插入一个 元素进去，这个元素呢，是一个pair 模板类的对象，然后它的first成员变量是15，second成员变量是2.7， 然后我们插入，在下面再插入另外一个元素，这时候我们用到make_pair。 第二个元素它的first是15，second是99.3。 那我们要知道，map里面，它的 元素first关键字是不能重复的，那前面已经有一个元素，它的 first成员变量是15了，那么这个插入肯定就不能成功。 对吧。所以我们接下来再计算有多少个15。算出来，有两个。那这里我们有讲如果判断这个 insert它的操作是不是成功的，这一点跟set的情况是很类似的，大家去参 考set的那个例子，就是在调用insert的时候，如果里面原来有元素，它的first等于你 要插入的这个first的话，插入就会失败。好了，那接下来我们可以插入另外一个元素，就是这个20，9.3。 然后我们便利整个pairs，把所有的元素都输出，输出的结果就是这个，（15，2.7），（20，9.3）。 一共有两个元素，是按first成员变量从小到大排序的。接下来我们再看，我们看n=pairs[40]， 那pairs[40]这个表达式吧，它的返回值是关键字为40的那个元素，它的second成员 变量的引用。如果不存在关键字为40的元素，会怎么样呢？就有一个新的元素会被 插入到pairs里面去。这个新的元素，关键字上就是40，它的second呢，在这个例子里面是被初始成为0，实际上second 应该是用无参构造函数初始化哦。然后我们就便利整个 pairs，会发现，在这个标号为4的这个输出，它多了一个元素出来就是（40，0） 再接着往下走，我们呢，pairs[15]=6.28，因为pairs[15]，它的 返回值是，关键字为15的那个元素，它的second成员变量引用。所以这条语句就会把关键字为15的元素 它的second成员变量改成6.28，于是我们把pairs内容全部输出的时候，就发现这个（15,2.7）变成了 （15,6.28）。啊，总算把multiset也和set都讲完了。 
## 3. 容器适配器
- 大家好，在这一小节中，我们来具体了解一下，除了第一类容器之外， 另外一种特殊的容器，被称为叫作容器适配器。 那么容器适配器呢，我们可以以为认为说，它就是去使用某种之前了解到的顺序容器来进行实现的。 那么这个顺序容器呢，它实际上就是以栈或者队列的形式来进行数据结构方面的组织，从而呢，进行工作的。 
- 那么第一类的这个容器适配器呢，被称为叫作 stack，也就是所谓的栈。 那么在使用它的时候呢，需要 include stack 这样的一个头文件。 那么堆栈这样的一个数据结构本身呢，它实际上就是具有这样的一个后进先出的这样的一个工作方式。 
- 那么第二种容器适配器呢称为叫作 queue，也就是说所谓的队列。 我们在使用的时候呢，也是仍然需要去 include queue 这样的一个头文件。 那么 queue 呢，队列相比于栈而言的话呢，它实际上是一个先进先出，这样的一个工作方式。 
- 除了传统的队列之外呢，还有一个叫作 priority queue，啊，也就是优先级队列，或者称为叫作优先队列。 那么它本身呢，认为是一种特殊的队列。 那么对于 priority queue 来讲的话呢，我们通常是会对最高优先级的元素呢，首先来进行第一个处理，啊。本来对于队列而，来讲的话呢， 我们每回都是去这个，输出队头的元素。那么对于 priority queue 来讲的话呢，它就会去输出或者说出列第一个，具有最高优先级元素的这样的一个元素。 那么对于 priority queue 来讲的话，它也需要去 include queue 这样的一个头文件。 
- 那么对于容器适配器来讲的话呢，它通常呢就包含了这样三个成员函数， 分别是 push，啊，添加一个元素，以及 top， 也就是说，返回，如果是一个堆栈的话，stack 的话，它会返回栈顶元素的引用。 那么如果对于一个队列 queue 来讲的话呢，它返回的是队头元素的这样的一个引用。 此外呢，除了 push 添加元素之外，你来可以做删除，可以 pop，我们可以删除掉相应的一个元素。那么要注意的就是，在容器适配器上面，它本身是没有迭代器这样的一个概念的。 所以呢，我们之前在STL当中介绍的各种排序啊、查找，以及 变序等等这些算法呢，它都不适用于容器适配器。 我们来具体看一下。 
- 首先第一个，stack，这样的一个栈来讲的话呢，我们说堆栈这个结构，
    ```C++
    //stack
    //stack是先进后出的数据结构
    //只能插入，删除，访问栈顶的元素
    //可用 vector， list， deque 来实现
    //缺省情况下用 deque 实现
    //用 vector 和 deque 实现，比用 list 实现性能好
    template<class T, class Cont = deque<T> >
    class stack {
        ...
    };
    ```
  是一个后进先出的数据结构，啊。我们呢，有这个栈呢，它实际上是一端封闭的。 所有的操作呢，都是在这个栈顶这样的一个元素的位置上来进行。 也就是所谓的 top，啊 。虽然呢，我最先进入的元素， 是坐落在这个所谓的栈顶，bottom的， 那么，但是，凡是后进来的元素会被先处理，因为它是一个单向的一个， 这样的一个操作。所以呢我们说这进行的一系列的插入、删除以及这个访问， 访问元素这样的一个函数呢，都是作用在这个栈顶元素上的。 那么，对于这个 stack 这样的一个容器适配器来讲 的话呢，我们通常可以用 vector、list 、和 deque 这样 几个顺序容器来实现。那么在 STL 当中呢，默认的情况缺省呢就是用 deque 来进行实现。 那么使用 vector 和 deque 这样动态这种数组呢，会比使用 list 这样的一个链表的实现呢，要更，性能更好一些。 那么对于这个 stack 来讲的话呢，我们就会去定义一个 这样的一个类型参数，啊。那么可以看到它对应 存放的是这个 class T 这样的一个类型。那么对于这个 使用的这个顺序容器来讲的话呢，我们会看到缺省的这个 类型呢就是 deque。 那么对于 stack 这样的一个栈来讲 的话，虽然它是通过顺序容器来进行实现的， 但是作用在这个顺序容器上的那些成员函数呢，本身是不可以用在这个栈上面的。 那么对于这个容器适配器，这个 stack 来讲的话呢， 那么 除了这个 science 和 empty 两个函数之外，我们要看到它会有三个最主要的成员函数。 
    ```C++
    //stack中主要的三个成员函数
    void push(const T &x);      //将x压入栈顶
    void pop();                 //弹出（即删除）栈顶元素
    T &top();                   //返回栈顶元素。通过该函数，可以读取栈顶元素的值，也可以修改栈顶元素
    ```  
  那么分别就是第一个，叫作 push，啊，也就是说，我会把需要 push 的这个参数值X 那么把它呢，压入到栈顶，啊。我们刚看到我们画了一个堆栈。 那么所有的操作呢，都是在这个栈顶元素上来进行操作的。 那么如果你要新 push 进来一个新的这个元素也会放在这个栈顶上面。 那么除此之外呢，你可以 pop，可以删除掉，啊，也就是说我压进来元素，我压栈之后还可以 弹出去相应的栈顶元素，也就是删除这个元素。我也可以把这个栈顶的元素呢，把它 pop 掉。 除此之外呢，我对于这个栈顶的元素 还可以呢，来进行这个返回及相应的引用，啊。我们通过 pop 这样的一个成员函数，可以返回相应的这个栈顶元素的引用。 当然我们利用这个函数本身呢，也可以去读取相应的值，也可以去修改相应的元素。 
- 那么除了 stack 这样的一个堆栈的这个形式之外呢，我们还有一个常用的叫作队列，queue。 
    ```C++
    //queue
    //和stack基本类似，可以用list和deque实现
    //缺省情况下用 deque 实现
    //用 vector 和 deque 实现，比用 list 实现性能好
    template<class T, class Cont = deque<T> >
    class queue {
        ...
    };
    //同样也有push， pop， top函数
    //push发生在队尾
    //pop，top发生在队头，先进先出
    ```
  那么它和 stack 的基本情况呢是相类似的，我们可以用 list 或者 deque 呢来进行实现。 那么缺省的情况下呢，使用的是 deque 这样的一个顺序容器，啊。那么要注意的就是，我们对于 queue 这样的一个容器适配器来进行 操作的时候呢，它同样也包含了这样三个成员函数。 但是区别于刚才的堆栈，我们的这个队列呢，因为它是两边都开口的， 所以呢，我们，当我们去放进一个新的元素 进来 push 的时候，那么它总是发生在队尾， 啊， 它总是发生在队尾。也就是 说我们把新的元素加进来的时候呢，是把它 push 在队尾的。 但是如果你需要去处理， 删掉某一个元素的时候，那么处理在队头，啊。 对于队头这个元素来进行处理，我们可以 pop 掉队头。所以我们说 在对于队列 queue 来讲的话呢，它是先进先出的，啊，也就是说先进来的元素先进行处理。 那么这时候，top 所返回的引用值呢也是这个 队头所指向的这个元素值。 
- 那么除了 queue 之外呢，还有一个特殊的队列，称为叫作 priority queue ，啊，优先队列。
    ```C++
    //priority_queue
    //和stack基本类似，可以用vector和deque实现
    //缺省情况下用 vector 实现
    //priority_queue通常用堆技术实现，保证最大的元素总是在最前面
    //执行pop操作时，删除的是最大的元素
    //执行top操作时，返回的是最大元素的引用

    template<class T, class Cont = deque<T> >
    class queue {
        ...
    };
    //同样也有push， pop， top函数
    //push发生在队尾
    //pop，top发生在队头，先进先出
    ```
  那么优先队列呢，其实它跟 queue 是类似的。 那么它可以通过 vector 和 deque 来进行实现。那么默认情况呢，我们通常使用 vector。那么 那么对于这个 priority queue 来讲的话呢，我们通常呢，是使用堆排序来进行实现的。 因为它要保，始终保证这个最大的元素总在这个最前面，啊。 也就是说，队列中间的这个 最前面的元素不一定就是我最先进入的那个元素了，而是我所定义的 通过堆排序之后实现的这个最大元素。 那么对于 priority queue 来讲的话呢，因为它内部是堆排序，所以呢它 本身的这个内部，中间的元素呢，并不能完全保证是有序的。 它只能够保证最大的这个元素呢，在队头。 也就是说，我每一次只是去将队头的元素来进行一些操作，啊。 那么对于这个 priority queue 来讲的话呢，它特别适用于这种 不停地在一堆中间去取这个最大值的这种情况，啊。 那么对于 priority 的这个 queue 来讲的话呢，它是不允许，注意它是不允许去修改队头元素的。 那么 priority queue 呢，它还包含了这个 有一个第三个参数，啊。它主要是用来去进行这个大小比较的。 那么默认的情况呢，它是使用这个 less<T> ，啊，这个比较器来进行完成的。 那么我们因为使用 less，less 这样的一个比较的话呢，我们会看到，我们在priority queue 中间存放的元素呢，至少你要保证它是那个利用< 这个运算符来进行比较的。 那么，如果对于 priority queue 来讲的话呢，我们的队头元素 X， 那么如果它和队内的任何一个非队头的元素 Y 进行比较的话， 我们要使得保证说，这个Y<X 这样的一个表达式始终是 false。 那么我们对于 priority queue 来讲的话呢，它是可以去执行这个 pop 操作的。 那么它始终删除的都是我们 通过堆排序出来得到的这个最大的元素。而在返回这个 top 操作的时候，它返回的就是这个最大元素的引用，啊。 我们来看一个具体的例子。
    ```C++
    //priority_queue用法示例
    #include <iostream>
    #include <queue>
    using namespace::std;

    int main()
    {
        priority_queue<duble> priorities;
        priorities.push(3.2);
        priorities.push(9.8);
        priorities.push(5.6);
        while(!priorities.empty()) {
            cout << priorities.top() << " ";        //输出结果：9.8 5.6 3.2
            priorities.pop();
        }
                
        return 0;
    }
    ```      
  我们对于这个 priority queue 来讲的话呢，它在使用的时候，也需要去include queue 这样的一个头文件。 那么我们定义好了一个 priority queue 这样的一个容器适配器， 具体这个对象的话呢，它实际上是，存放的元素是这个 double 类型的。 我们称为叫作 priorities，啊。我们对于这样的一个优先队列的话呢， 让它 push 进来一系列的值，啊，这个值呢分别是 3.2 ，9.8 和 5.4。虽然我 push 进来的值本身是无序的，啊，也就是说，先进入的这个元素 3.2 显然不是最大的， 但是通过使用这个 priority queue 呢，那么实际上在这个 容器适配器的内部，它会始终把这个最大的元素放在队头。 那么当我的 while 循环在进行处理的时候，它只要这个队列 不为空的时候，那么我都让它去 cout ， ptiorities，top。 .top，啊。我让它这个最大元素呢，的引用呢，被输 出出来，所以呢我就会看到我第一次输出的就是9.8这个值。 那么接着呢，我会让它的 priorities pop 啊，去使用这个 pop 这个成员函数。我把队头的元 素呢，pop 出去。9.8 被 pop 出去之后呢，剩下的这两个元素分别是 3.2 和5.4。 那么它们两个呢，位于队头的元素就是相对较大的那一个，显然，这时候 在去 top 的时候巨出现的是 5.4，啊，接着最后是 3.2。 所以对于这个 priority queue 来讲的话呢，那么可以看到它本身输出的这个结果 呢，实际上呢，就是对应始终把这个最大值依次地输出出来。 
## 4. 算法
- 大家好，在这一小节中呢，我们来介绍一下STL算法，那么这次课呢，会比较不一样，是由我和郭老师一起来讲。 因为这个STL算法，它比较杂，又比较多，讲起来特别枯燥， 那我们要一个人讲的话，就我们讲得也累，同学们可能听得也累。所以我们就变化一下形式，两个人一块讲。 这样挺好。那么STL本身的分类呢，郭老师，这七类应该是您分的吧？ 对，我也参考一些其它书吧，然后也有一些自己的观点吧，这就分了七类，其实你爱怎么分，我觉得也都无所谓了。 **那这个算法的话呢，可以有这种不变序列算法和变值算法。 还有删除算法，变序算法，排序算法。以及这种有序区间算法和数值算法。 嗯，大概就这七类把。那么算法本身呢，我们在这个实现的时候呢，这种一般来说都是重载了两个版本。 那么通常可以用这个 “==”等等来判断元素是否相同，当然也可以用“<"，主要来用“<"来判断这个大小。 对，那还有一个版本呢，它就会多出一个类型参数，这个”Pred“。 然后这个模板的函数形参部分就会多出一个”Pred“类型的参数op， 那么这样的算法啊在 执行的过程中，它需要比较两个元素x，y大小的时候，它就会去计算表达式"op(x,y)"，看这个表达式的返回值。 如果为true的话，那么这个算法就会认为x是小于y的**， 
- 那么如果我们举个例子的话呢，对于这个min_element的这个算法的话，它实际上就会对应有这样的两个版本， 那么就会有，除了有这个 first和last作为，两个迭代器作为这个参数之外呢， 还会有，存在第二种，就是会多出这样的一个，刚才郭老师提到的， 一个表达式来进行判断。对，这个第一个版本嘛，它就是用这个“<"来比较大小的。 因为它没有让你自定义比较大小的方式，而第二个版本呢，就用这个op 去定义比较大小的办法。那你真正调用min_element的时候呢，这个实参，这个op，你可以给一个函数的名字， 也可以给一个函数对象，都是可以的。也就是说这个函数如果是你自己定义的话，那这个大小就可以变得更为丰富多样化了。对对，就不见得是我们传统意义上的数学上的大或者小了。 好，那么后面可以继续看， 
- **那么对于第一类这种不变序列算法的话呢， 它主要就是不会去修改算法本身所作用的容器或者对象**， 那么它通常呢，适用于这种顺序容器，或者我们讲到的那种关联容器，就是所谓第一类容器。 那么它的时间复杂度呢，通常都是O(n)量级的。对，因为它们做的时候，一般都会从头到尾，遍历一下整个容器，所以它一般就是O(n)级的。那么对于这个不变序列算法的话呢，它主要包含了以下这个表格中间的一系列算法， 

    算法名称 | 功能 
    ---------|----------
    min | 求两个对象中较小的(可自定义比较器) 
    max | 求两个对象中较大的(可自定义比较器)  
    min_element | 求区间中的最小值(可自定义比较器)
    max_element | 求区间中的最大值(可自定义比较器)
    for_each | 对区间中的每个元素都做某种操作
    cout | 计算区间中等于某值的元素个数 
    count_if | 计算区间中符合某种条件的元素个数 
    find | 在区间中查找等于某值的元素
    find_if | 在区间中查找符合某条件的元素
    find_end | 在区间中查找另一个区间最后一次出现的位置(可自定义比较器) 
    find_first_of | 在区间中查找第一个出现在另一个区间中的元素(可自定义比较器)
    adjacent_find | 在区间中寻找第一次出现连续两个相等元素的位置(可自定义比较器) 
    search | 在区间中查找另一个区间第一次出现的位置(可自定义比较器) 
    search_n | 在区间中查找第一次出现等于某值的连续n个元素(可自定义比较器)  
    equal | 判断两区间是否相等(可自定义比较器) 
    mismatch | 诸葛比较两个区间的元素， 返回第一次发生不相等的两个元素的位置(可自定义比较器) 
    lexicographical_compare | 按字典顺序比较两个区间的大小(可自定义比较器)  

    ```C++
    //find：
    template<class InIt, class T>
    InIt find(InIt first, InIt last, const T &val);     //返回区间[first, last)中的迭代器i， 使得*i == val

    //find_if:
    template<class InIt, class Pred>
    InIt find_if(InIt first, InIt last, Pred pr);       //返回区间[first, last)中的迭代器i， 使得pr(*i) == true
    
    //for_each:
    template<class InIt, class Fun>
    Fun for_each(InIt first, InIt last, Fun f);         //返回区间[first, last)中的每个元素e， 执行元素f(e)， 要求f(e)不能改变e        

    //count:
    template<class InIt, class T>
    size_t count(InIt first, InIt last, const T &val);  //计算[first, last)中等于val的元素个数（x==y为true算等于）
    
    //count_if:
    template<class InIt, class Pred>
    size_t count_if(InIt first, InIt last, Prd pr);     //计算[first, last)中符合pr(e) == true 的元素的个数    
    
    //min_element:
    template<class FwdIt>
    FwdIt min_element(FwdIt first, FwdIt last);         //返回[first, last)中最小元素的迭代器，以"<"作比较器；最小指没有元素比它小，而不是它比别的不同元素都小；
                                                        //因为即使 a != b, a < b 和 b < a 有可能都不成立

    //max_element:
    template<class FwdIt>
    FwdIt max_element(FwdIt first, FwdIt last);         //返回[first, last)中最大元素（不削于任何其他元素）的迭代器，以"<"作比较器；以"<"作比较器
      
    ```       
  难道我们都要念一遍吗？念一遍，念一遍，来，来，请。那么第一个的话呢，就是那个min， min的话，它主要用来去求这两个对象中间较小的一个算法。那么对应的话呢，还有一类呢，叫做min_element, 那么这个算法本身的话，注意是第三个哦，那么它呢，是用来去求某个区间中间最小的值。 对，这里标注出可定义，自定义比较器的， 一般就是有两个版本，一个是用“<"或者“==”判断相等 或者是小于，另外一个就自己去定义一个什么规则去 比较相等或者大小。这个min和max这两个 东西是特别常用的。 像这种min_element，max_element嘛，你自己要写的话，也就是两行的事，就是一个循环，对吧，那你要能记得住的话， 也总比写两行要稍微好点吧。 还有这个for_each嘛，就是对区间中的每一个元素都做某种操作，这个for_each它实际上有两个版本。 一个是不变序列了，它不会改变 容器里面的对象。另外一个是变化序列了，它或者是变值的，它会改变容器里面的 容器的内容。对，那个我们在后面再说。 那么下面的话呢，在不变序列算法中间呢，还有这个count，那么它主要就是用来去 计算区间中间等于某个具体，就是你count的那个元素的 个数，然后同时的话，你还可以按照某种条件去count这个个数。 某种条件是count_if，这个count就是用 “==”。find，find特别常用了。 find其实您之前不都讲过了吗？它就是顺序查找。因为它太重要了，所以再讲一遍也不嫌累。哎，这个find我们标红了哦，说明很重要哦。 它在区间中查找等于某值的元素，这个等于呢，就是"=="。 所以呢，那你也可以find_if根据某些条件来去查找具体某一个元素。对，那就更灵活一些。 然后，这个，这个find_end查找最后一个位置，这个好像不太常用啊。 find_first_of也不是那么常用。这个我们在string里面有提到过。它有一个成员函数，叫find_first_of，对，嗯。 然后就是这个adjacent_find，这个就更，我好像从来没用过。 对，我也没有用过，虽然我写的程序也不少了啊。 反正STL里面有很多东西吧，你要是不嫌记着累，你都能记住，那用起来也还是蛮方便的。 这些，有些很简单的函数，你自己写两行就能写得出来的，你要懒得去记，也无所谓。 对，adjacent_find就是用来去发现第一次出现的这种连续两个相等的元素的位置。对。 好，下面。好，那接着。 那么对于不变序列算法呢，还有这种search，它主要就是说 在一个区间中间，去查找另外一个区间当中第一次出现的这个位置。 嗯，这就有点像那个string里面的什么 find_first_of去找 就是在一个字符串里面找另外一个子串里面的任何一个字母第一次出现的地方。对，这两个 会比较类似，看起来。然后同时的话，还可以search_n，也就是说你可以去在这个区间当中查找出现某个值连续n个元素。equal就是判断两个区间是不是一模一样啊， 那么这个mismatch的话呢，就是逐个去比较 两个区间中间的这个元素，那么返回的是第一次不相等的那个元素的位置。 返回一个迭代器，是吧？，对对，是，啊，这个 lexcographical_compare，就是按字典序比较两个区间的大小。这两个大小什么，你都可以 自己去定义了。就是lexcographical。呵，这是最复杂的一个STL算法的名字了。 那么我们具体来看的话，就是说，对于find这样的一个算法的话，它实际上就是说 是在我们定义好这个区间当中，去寻找这个相应 对应我们去查找这个value的这样一个值，然后返回的是一个相应的这个迭代器。 然后如果没有找到的话呢，就返回的是这个last。 find_if呢，它是查找符合某种条件的这个元素。 条件就用这个pr来表示了，pr(*i)==true。那这个(*i)这个元素就是符合要求的。 那就返回这个i。第二遍录果然比第一遍录，感觉机器差了很多啊。对啊， 是啊，好，那我们再。再打打鸡血，是吧。这个那么对于for_each这样的一个操作的话呢， 它实际上主要就是说，在这个区间当中的每个元素e，都去执行这个f(e)这样的一个你定义好的一个操作。 但注意就是说f(e)本身，它是不会去改变这个e的，也就是说，对于这种 不变序列算法，是吧，第一类是，它本身是不会去修改任何容器当中的这个元素值的。 它只会去计算，按照你定义好这个某一个操作，这个f来去相应计算一个值。是吧？是的。 对，算出一个新的值来。反正做某种操作吧，但是这个操作不会改变e。 count就是用来计算这个区间里面有多少个元素等于这个值value。然后这个 等于是用"=="号来判断的，那count_if呢，就是判断 这个first,last区间里面有多少个元素，满足某种条件，这个 条件，就是pr(e)==true。这个e指的就是那个元素 然后那么，刚才提到就是说，有讲了max，min是比较常用的两类这个 两个算法啊。除此之外的话，还有min_element和max_element也是非常常用的。也是比较好用的。 那么对于这个min_element的话呢，它主要就是说在这个区间当中去 返回这个最小元素的这个迭代器。注意它这是返回的是一个区间当中的最小元素。 min是返回两个对象比较的这个元素。对，这个 min_element呢，这个版本是用"<" 做比较器的。然后什么叫最小呢？ 最小指的是没有元素比它小。 但注意，不是说它比任何元素都小。对对对对 对。这个东西很绕口。是，所以我把它变红了啊，下面的程序能够看到这个例子。 因为就是说，即便a不等于b的话，a<b，和b<a也有可能 同时都不成立。就取决于你这个"<"是怎么编写的嘛。因为"<"有可能被重载， 那max_element也类似啊，它找最大的元素。 最大，什么叫最大啊？就是它不比任何其它元素都小，那它就叫最大。 那么它也是可以用这个"<"来进行作比较器的。它确实，这个版本就是用"<"作比较器的。 那我们来具体看一个例子。（怪异的例子啊），
     ```C++
    //priority_queue用法示例
    #include <iostream>
    #include <algorithm>
    using namespace::std;

    class A {
        public:
            int n;
            A(int i):n(i) {}
    };

    bool operator<(const A &a1, const A &a2)
    {
        cout << "<called" << endl;
        if( a1.n == 3 && a2.n == 7)
            return true;
        return false;
    }
    int main()
    {
        A aa[] = {3,5,7,2,1};
        cout << min_element(aa, aa+5)->n << endl;
        cout << max_element(aa, aa+5)->n << endl; 
        return 0;
    }
    /*
    输出：
        <called
        <called
        <called
        <called
        3
        <called
        <called
        <called
        <called
        7
    */
    ```   
  那么在这个例子当中的话呢，这个 我定义好了一个类A，然后呢，它中间包含了一个 这个int型的成员变量，然后我们还定义了一个构造函数，让它来初始化，用这个参数i来去初始化这个n。 然后大家来具体看看郭老师这个很怪异的operator<。 对，这个"<"嘛， 它确实比较独特，精神病，它每次被 调用都会输出一个called，但是它规定只有3<7， 这是true的，所有其它情况， a1都不会小于a2。只有a1.n==3.a2.n==7的时候，这个小于号才成立。也就是说 在这个"<"的定义下面，任何两个class A的对象比大小， 返回都是false，除非，第一个是3，第二个是7。 7,啊只有3＜7是成立的。那现在我们在这个数组a[ ]里面， 去求最小 元素，求这个最大元素，那我们先看看，这个求最小元素。这个 函数被调用被执行的时候会有哪些输出啊， 它输出的结果是啊，4个＜called，然后输出一个3. 这是为什么呢？是不是很奇怪？对呀，因为明明这个 最小的这个数组里面明明有1和2的存在，为什么输出的居然是3呢？ 就是我每次讲到这个，呵呵，在课堂里讲到这段，这段代码的时候都感觉就在台上很囧， 嗯，好啦，这个问题是这样的，就是你想一下，如果你写这个min_element, 你怎么写呢？你只能顺序遍历整个数组对吧，那你肯定要有一个，一开始要假设一个最小值， 那那很自然的你会假设，第一个3是最小值，就是一开始我们假设3最小，对吧。 接下来我们就会拿3跟其他的去比较了，比如说，3跟5比较 这个时候呢，min_element是怎么比较的呢？它是去看5＜3的值是不是为真， 如果5＜3为真的话，那么5就是这个 比3更小了。那这个时候最小值就要被更新成5了。当然在这个例子里面 显然不是，对呀，所以3现在依然还是最小的。然后又比较7＜3， 啊还是假，所以3还是最小。然后2＜3，1＜3，全都是假， 啊所以经过四次比较以后，这个3依然是最小的。 就被记下来了，3是最小值。那刘老师你来说说max的情况。 那么在max这种情况下的话呢，我们是去比较这个 呃首先是应该是去比较 3和5是吧。对，先假设3是最大值，对，然后假设3是最大值， 然后去比较3和5.然后这时候你会发现说呢这个确实是满足这个 3＜5不成立，然后这时候就会被 3依然最大，替换成7和3进行比较。然后因为我们在刚刚的这个operate小于号里面 定义说当满足一个是3一个是7的时候，它就自动会变成是TRUE了。 所以那么这个时候的话呢，我们就会认为说这个 呃更大的这个值是7，然后这个7的话呢会进一步去跟这个2比较， 然后它也是false，那么这个时候就会7会去跟1比较，然后所以呢最后返回的最大值就是7了。 啊，对。那就是min 和max它工作的这个过程， 呃就是这样的。有点怪是吧。但是我觉得可能知道这个还是有必要吧，所以就讲啦，就这样了啊。 
- OK,那我们先进一步， **再看变值算法**，那么第二类呢就是这个所谓的变值算法，那么这个变值算法的话呢，它实际上刚刚对应第一类呢我们刚刚说到它不会去修改就是这个算法作用在这个容器上的话呢它不会去修改任何容器中间的元素， 但是**变值算法的话呢它就会去修改这个原区间或者是目标区间中间元素的值**。 **然后注意这个有一个区间的值如果被修改的话，这个区间它不能是属于关联容器的**。 那为什么呢？ 啊考我吧。啊你知道吧，那你说吧。对呀，这个因为本身关联容器大家也应该知道 说它实际上是一个具有排序好的这样的一个容器，那如果你直接就通过这种变值算法去进行修改的话，那么这个容器当中的这个所有的这个排序好的内容就被彻底打破了，如何你在做其他的操作的话，有序性破坏了啊，如果你去做其他操作的话呢，实际上就是都是，可能就会出现不一样跟预期的结果不一样的值。你要查找可能就找不到了。 嗯，所以变值算法不能够使得关联容器上面的元素被改变。 那变值算法有这个几个啊，

    变值算法名称 | 功能 
    ---------|----------
    for_each | 对区间中的每个元素都做某种操作 
    copy | 复制一个区间到别处  
    copy_backward | 复制一个区间到别处，但目标区间是从后往前被修改的
    transform | 将一个区间的元素变形后拷贝到另一个区间
    swap_ranges | 交换两个区间内容 
    fill | 用某个值填充区间  
    fill_n | 用某个值替换区间中的n个元素
    generate | 用某个操作的结果填充区间
    generate_n | 用某个操作的结果替换区间中的n个元素 
    replace | 将区间中的某个值替换为另一个值  
    replace_if | 将区间中符合某种条件的值替换为另一个值
    replace_copy | 将一个区间拷贝到另一个区间，拷贝时某个值要换成新值拷过去
    replace_copy_if | 将一个区间拷贝到另一个区间，拷贝时符合某条件的值要换成新值拷过去

    ```C++
    //transform：
    template<class InIt, class OutIt, class Unop>
    OutIt transform(InIt first, InIt last, OutIt x, Unop uop);      //对区间[first, last)中的每个迭代器i，
                                                                    //执行uop(*i);并将结果依次放入从x开始的地方，要求uop(*i)不得改变*i的值
                                                                    //本模板返回值是个迭代器，即 x + (last - first); x可以和first相等
    -------------------------------------------------------------------
    #include<vector>
    #include<iostream>
    #include<numeric>
    #include<list>
    #include<algorithm>
    #include<iterator>
    using namespace::std;

    class CLessThen9 {
        public:
            bool operator()(int n) { return n < 9; }
    };
    
    void outputSquare(int value) { cout<< value * value << " "; }

    int calculateCube(int value) { return value * value * value; }

    int main()
    {
        const int SIZE = 10;
        int a1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int a2[] = {100, 2, 8, 1, 50, 3, 8, 9, 10, 2};
        vector<int> v(a1, a1 + SIZE);
        ostream_iterator<int> output(cout, " ");
        random_shuffle(v.begin(), b.end());                         //变序算法。主要是用来随机打乱对应的这个v中间的值
        cout << endl << "1)";                                       
        copy(v.begin, v.end(), output);                             //1)5 4 1 3 7 8 9 10 6 2   (结果是随机的)
        copy(a2, a2 + SIZE, v.begin());
        cout << endl << "2)";                                       
        cout << count(v.begin(), b.end(), 8);                       //2)2
        cout << endl << "3)";
        cout << count_if(v.begin(), b.end(), CLessThen9());         //3)6
        cout << endl << "4)";
        cout << *(min_element(v.begin(), b.end()));                 //4)1
        cout << endl << "5)";
        cout << *(max_element(v.begin(), b.end()));                 //5)100
        cout << endl << "6)";
        cout << accumulate(v.begin(), b.end(), 0);                  //6)193
        cout << endl << "7)";
        cout << for_each(v.begin(), b.end(), outputSquare);         //7)10000 4 64 1 2500 9 64 81 100 4    
        vector<int> cubes(SIZE);
        transform(a1, a1 + SIZZE, cubes.begin(), calculateCube);    
        cout << endl << "8)";
        cout << for_each(cubes.begin(), cubes.end(), output);       //8)1 8 27 64 125 216 343 512 729 1000          
        return 0;

    }
    -----------------------------------------------------------------------------
    ostream_iterator<int> output(cout, " ");                        //定义了一个ostream_iterator<int> 对象，可以通过cout输出以" "分隔的一个个整数。
    copy(v.begin(), v.end(), output);                               //导致v的内容在cout上输出
    ```   
  有这个for_each, 它用来对区间中的每一个元素都做某种操作，那这个操作它是 可以改变这个元素的值的。那这个版本跟上一个版本就在于参数 呃， 那个参数是一个，可以是一个函数或者函数对象，然后那个函数对象或者函数的那个参数它一个是const,一个不是const。 说起来挺罗嗦的，大家自己去查查吧。呵呵，然后呢，第二个这个算法的话就是copy， copy的话呢我们通常直观上根据这个词也能想到，它就是去完成一个复制其中 一段区间到另外一块儿的这样的一个操作，那其实copy本身呢它还有一些 呃我们会在后续的例子当中看到它有一些独特之处，我们还可以通过一些其他的方式，通过COPY来实现一些 其他的这个功能，对，就是X+里面的算法吧，你看名字好像觉得它应该只能干这个事情，你说COPY你就觉得它 只能是干copy的事情，其实不是的，它里面只不过是一个代码的形式，你用 这个模板能做什么是取决于你的想象力的。 我们后面会看到COPY的习惯用法。 还有这个copy_backward,它也是复制一个区间到别处。但是它跟COPY的差别在于 它的 在目标区间是从后往前被修改的，就是拷贝的时候是从后面到前面拷贝的。 copy呢是从前面到后面拷贝的。 那郭老师你要不给大家介绍一下说为什么会考虑从后往前这种操作呢？ 我不刚刚教你了吗，你说一下。 呵呵呵呵。挖坑，我想给郭老师挖坑没挖住是吧？ 那么郭老师刚才在我们在第一遍录的时候， 郭老师就提到这个本身这个函数这个算法呢 它呢实际上主要是当你它主要考虑说两个这个区间本身有重叠的时候， 那么如果你都是从前往后去来进行这个拷贝的话呢， 那么可能就会出现后面的这个内容在没有拷贝之前就已经被这个覆盖掉了。 对，就重叠部分的内容还没有被拷贝到目标区间就已经被覆盖掉了。 所以呢，那么有了这个copy_backward之后的话它就是它实现的实际上是从后往前拷贝。对，就能解决这个问题。 嗯，好。然后还有这个transform它是把一个区间的元素变形以后拷贝到另外一个区间，那也就是说 你用一个区间的元素作为函数的参数算出一个什么新的值然后 把它新的值弄到另外一个区间去，基本上就是这个意思。 那么除此之外的话呢还有一系列变值算法， 其中就包括这种swap_ranges，那么它主要是用来去直接交换两个区间之间的内容的。 啊那念swap啊，我一直念swap. 到底是什么呀？swap,呵呵，好啦，那就swap吧。 还有，还有这个fill,fill是用某个值填充某个区间。然后你也可以fill_n， 就是刚开始用某个值去填充区间，那么这时候的话可以直接去替换区间中的n个元素。 generate就用某个操作的结果填充区间，它就填充的办法可以更复杂一些啦。对，它是一个操作啊。 然后完了之后的话呢，就replace的话，就是将这个区间中的某个值替换为另外一个值。 replace_if 就是把符合某种条件的值换成另外一个值。 然后还有这个replace_copy，也就是说我们把一个区间拷贝到另外一个区间的时候， 那么拷贝时候的这个值要替换成一个新值拷贝过去。就是不是原模原样的拷贝啦， 那这个跟replace_if 感觉好像蛮类似的啊。 呃replace_if 是替换一个区间里面的元素， replace_copy是把一个区间的元素拷贝到另外一个区间，考过去的时候 还要做一些操作。replace_copy它不会改变原区间的内容。哦。 然后这个replace_copy_if 就是把一个区间里面 符合某种条件的那个值拷贝到另外一个区间。那拷贝过去 的又不是原有的东西，而是把原有的东西经过某个计算变形以后， 变成新的值。我觉得后面这几个做法实在都， 确实很少用啦，还不如自己写呢，你自己写也就是两三行的事嘛，去记它还累的半死。 OK。那这个transform的话呢，本身这个操作呢， 这个算法呢它实际上就是说，对这个我们定义好这个区间当中的每一个迭代器，都会相应的去执行这个 我们定义好的uop这样的一个操作。然后并且把这个结果呢就依次放在这个从x开始的这个地方。 嗯，对啊。然后还要求这个原区间是不会发生变化的啊， 它返回值也是一个迭代器，就是目标区间被考过去的最后一个元素的那个，后面的那个 那个位置，然后x和first可以相等。就是它的原区间和目标区间嘛，它可以重叠， 就是这个意思。嗯。 那我们来具体看这个关于这个变值算法本身的一系列的这个，啊对对对，例子。还有包括clactstorm. 这里面有一个ClessThen9,它存在了一个这个圆括号，这个函数对象类。 它实际上就规定了一种条件，这个条件就是 返回＜9的值，对，看这个n是不是＜9.如果是的话就返回true。 那完了之后呢还定义了几个这个，呃全局函数。 对对，呃。一个是outputSquare，主要就是用来去计算对应这个value去求这个 平方的这个值。把平方值给它输出出来。然后还有这个calculateCube, cube还是cube?cube吧。哦，OK。然后呢它主要就是去计算这个立方的这个值。然后它就返回立方，立方的值。 然后在main里面，这个好长啊，对啊。呃。 接着读，这个这个a1里面有1,2,3,4，5,6,7,8,9,10啊，a2看上去没有什么顺序可言。 然后这个呢就把a1的内容全部搞到v里面去了。定义好了一个vector， 对，然后下面这个东西好古怪啊，太古怪了，你来说。这是什么东西啊？ 这个我也没有看懂耶。呵呵，不会吧你装的。 这主要是郭老师挖坑后面具体讲这个copy这个具有想象力的这个算法。这个东西吧，ostream_iterator是X1里面自己定义的一个内模板啦。 然后，你就知道它叫ostream_iterator就行了啊。然后把这个内模板实际化，啊 整型常数把它实际化，它的意思就是说以后你要通过这个ostream_iterator<int>去输出的东西都是 都是这个int类型的。好，这个，这个我们现在就定义了一个ostream_iterator<int>这种类型 的对象，它的名字叫做output。然后我们初始化这个对象的时候呢，给了两个参数，一个是cout， 一个是这个空格字符串。那就意味着以后我们把什么东西交给output的时候， 都会出现在 都会等价于交给cout，输出到屏幕上。而且被输出的东西， 都是一个个的整数。而且每输出完一个整数，后面都要加一个空格。 这句话就是这个意思。具体怎么实现呢？我们等会再看。 啊，下面这个东西。然后就是对应这个random_shuffle，这个算法实际上应该不算是在这个变值算法。它叫变序算法。对。然后它主要是用来这个 随机的这个，打乱一下这个，我们刚看到对应的这个vector v中间的值。 对，这个，这个东西特别好使。因为有时候你经常会需要随机打乱一个数组，比如你写一个打牌的程序什么的。 你要随机给大家发牌，你就会把所有的牌先random_shuffle一下，对吧，这个真的特别好使。这个是伪随机吧？ 当然是伪随机了，计算机不能实现真正的随机啊。然后呢， 完了之后呢，我们就让它这个cout一下，我们就可以看到说这个 我们先去看输出的结果吗？对，对对，就是这个编号为1的这个 这个输出啊。它是5 4 1 3。啊，那这块，当然你每次 （因为它是随机的嘛），每次都不一样，接下来就是问题的重点，就是这个copy copy我们前面说到它是用来把一个区间的内容拷贝到另外一个区间里面的。 现在我们执行的这个东西，这个output它好像不是一个容器啊。它确实不是一个容 器，它也不会是一个什么区间的开始位置，但是我们确实就可以这样用copy。 然后copy以后，输出的结果，这是会导致输出的哦。输出的结果，是什么东西呢？ 啊，这个输出结果实际上就是这个，刚才这个随机的结果被输出了，就是在这条copy语句里面导致它输出了。 对，你会发现，1和2之间没有任何其它的这个直接输出的语句。 通过copy来实现的。对，就是通过copy来实现这个输出的。然后我们看到输出的每一项都是整数，然后 输出的每一项后面都被加了一个空格，当然这个2后面也是有空格的啊。这也就是copy所做的事情。它为什么能做这个事情呢？ 这个我们一会再讲，卖个关子。好。 接下来这个干嘛了？接下来这个copy实际上就是执行了一个copy的工作。 啊，对。它是把a2的内容拷贝到v里面去。啊，但这时候要提醒大家 一下啊，这个copy操作，它要求这个目标区间的这个位置，它本身有足够的空间。 就是比如说，你在这里copy了SIZE这个元素过去，那么在目标区间里面v.begin开始往后的地方，它应该有 至少有SIZE这么多个元素的空间。要不然就会怎么样啊？要不然就会相当于数组越界，就会出错了。 就是事先你要为目标区间已经准备好了空间，你才能拷，没有空间你是不能拷的。就是说这个事情，主要是要程序员 本身来保证的。对，是的啊。好了。然后接着我们应该把这个a2整个copy给了这个v之后的话呢， 那么我们就可以相应地在这个v上进一步做操作。对。我们就 进一步去cout这个，第二行输出的什么呢？输出的实际上是这个 count。我们在这个v之间去count 8。 出现了这个8这个元素。有几个？对，然后呢，这时候的话，我们会看到，因为现在这个 v变成了是a2这个数组。然后这时候你会发现说对于a2这个数组呢，出现了两次8。 对啊。所以这时候我们count一下的话，就可以对应输出就是2。然后同时的话， 你也可以count_if，也就是说我们按照某一个条件限制下去count这个相应的值。 那么我们对应的话呢，就是我们刚才定义好的这个CLess Then9这样的一个类。 这是个函数还是个类？嗯， 这个是个对象，（哦，这是个对象）它是个函数对象。CLess Then9是一个 我比较喜欢中英结合啊，你就会CLess Then Nine，哎哟，高大上。我是CLess Then9。 好吧，这个CLess Then9吧，是一个类的名字，对吧。那 它后面加了一个圆括号，就成了一个对象的名字了。这个对象呢，它没有名称。 那这个CLess Then9这个对象是怎么起作用的呢？ 就是说count_if，假设我们把这个对象名字叫做op吧，那么 count_if在计算是不是有某个元素符合条件的时候， 它所谓的条件是什么呢？就是op(e)=true。 就是e就是它要考察的一个个的这个v里面的元素。如果发现op(e)=true的话， 那count_if就认为哎，我找到一个元素了。那算一下，有多少个？ 多少个元素满足op(e)=true这个条件呢？那op(e)是什么呢？就是op. operator(e)。对吧。那么这个op.operator(e)是什么呢？就是前面看到的CLess Then9。 这块的这个，n<9了，对吧？所以在这里就统计出来了小于9的元素的个数。是什么呢？ 小于9的元素个数有几个啊？有6个，对吧？算一下，就是6个吧。 肯定不会错啊。所以就是第三行数据就是这样了。然后你继续。 然后接着话呢，我们就要去，实际上去找这个min_element，我们去对应这个在这个v这个 数组中间的话呢，去寻找这个最小的这个值。当然我们在这个例子当中，并没有自己去定义，额外定义一个 operator<，所以我们就满足直接找了一个最小的值。那么现在这个v的话呢，就是刚才看到的这个 a2数组。是a2数组吧？对啊。这时候，a2最小值就是（最小就是数学上最小的意思）这个1。 就是1，嗯。然后呢，相应的，如果是max_element的时候的话呢？ 我们找的就是最大值。我们对这个a2这个最大的话呢，就是刚才看到的这个100。 然后此外呢，还有这个accumulate，这应该是一个， （累加）算是计算的这个，算是是数值计算的，（数值算法）数值计算的一个算法，你就把刚才这个a2当中数组中间所有的这个值累加起来的话呢， 那么一算，计算机就得到是193。那这个accumulate的源代码是什么样的？得放到前面去了。 就比较啰嗦了。这个就先这样吧。为什么要放到前面去啊？accumulate的源代码在哪里啊？ accumulate就是累加，是吧。（这不是就是用的现成的）对对，没错，我的意思是 你要理解accumulate是怎么工作的。就得看accumulate的源代码。前面有没有出现过啊？我已经忘了。 好像没有哎。是吧，呵呵。反正它做一个累加的工作，从v.begin到v.end， 累加到初始值0上面。如果你这个初始值是0，所以就是求这个的和了。 好吧，那我们再看这个for_each。 for_each是干什么的呢？就是对于v.begin，v.end里面的每一个元素e 它都会去执行output square(e)。它就干这个事情。 嗯，就是去计算相应的这个平方，然后输出出来。是啊，那个output square 是什么呢？我们得回忆一下，是吧？要不都忘掉了。output square在这干什么啊？ 它把参数的平方给它输出了，再提醒一下啊，这里有 calculateCube是返回这个参数的立方哦。 好吧，那我们就看这个 呵呵 在哪里啊？再往前，很前很前。这个咱们助教怎么处理呢？这种情况。他会剪掉，（剪掉，OK）没关系，接着讲，我们接着往下讲 就完了。好，嗯 那我们再看这个for_each啊，这个for_each对每个元素都执行这个操作。 那也就是说，这条语句会导致输出。什么样的输出呢？ 就是输出了这个 这个东西。因为对v里面的每一个元素都输出了它的平方。对吧。 相应地，transform也是去做了，但它实际上是去做了这个calculateCube这样一个操作。 对，而且把操作的结果，要放到了这个cubes.begin 开始的地方。（嗯，对）反正cubes已经有空间了。对吧。 那现在实际上就是把a1里面的每一个元素，它的立方， 放到了这个cubes.begin开始的往后的地方去， 所以我们在输出cubes，结果就会是 这个1 2 3 4 5 6 7 8 9 10的这个立方。对，然后我们输出 cubes的时候也是利用了copy这样的一个，看起来稍显怪异的 算法来输出的。对，并不是说用copy来进行输出多么有必要。只不过 我是举这个例子，是为了说明一下copy它可以被如何来使用。就是嘚瑟贴呗。呵呵，就是提醒大家 写程序要具有想象力哦。接下来咱们要讲讲这个copy的奇怪用法了啊。对，然后会看见这个copy它本身并不是去实现 这个复制，拷贝的工作。我觉得这么讲很久，好像很累啊，咱们放点什么背景音乐好不好？郭老师，有什么推荐吗？ 你喜欢听什么样的音乐啊？ 我其实都随便听的。最近在听这个什么儿童歌曲，陪我们家妹子 整天听“什么门前大桥下，什么游过一群鸭”之类这样的。好吧，好吧，不适合用来做背景。 我喜欢听一些电影的音乐。我们现在来放一个熟悉的这个东西。大家一定能听得出来是什么东西的。 好，我们就着这个音乐讲，会很兴奋的。好，现在这个 我们要说copy的妙用，对吧。 我们注意到这条语句，我们在前面定义了一个这个ostream_iterator这个 这种类型的对象， 然后把cout和这个空格字符串作为参数传进去。 结果我们来一条copy， 结果这东西就能够在cout上输出，这到底是怎么回事呢？ 我们接着往下看啊，那我们对这里，首先，知道这个，首先要对copy算法有一些了解。 你来说说copy是个什么样的啊？ 这个copy的话呢，那我们刚才其实已经在前面那个例子里面，就是例题中间就可以看到，对吧。 我们copy如果正儿八经地实现的话，
    ```C++
    //copy函数模板（算法）
    template<class InIt, class OutIt>
    OutIt copy(InIt first, InIt last, OutIt x);     //本函数对每个在区间[0, last - first)中的N执行一次*(x + N) = *(first + N)

    //对于
    copy(v.begin(), v.end(), output);               //first和last的类型是vector<int>::const_iterator; output的类型是ostream_iterator<int>

    //copy的源码
    template<class _II, class _OI>
    inline _OI copy(_II _F, _II _L, _OI _X)
    {
        for(; _F != _L; ++_X, ++_F)
            *_X = *_F;
        return (_X);
    }
    ```     
  它实际上做的事呢，就是对应在这个 定义好的这个区间范围内，那么它实际上执行的是说，从这个 0到这个last减去first中间，那么去执行，就是 去执行N次，每一次它实际上执行的事呢，都是把这个对 first加上N之后，拷贝给这个x+N,也就是对应把这个区间中间的内容拷贝给我这个 输出处，等于说定义目标口的把这个 希望拷贝给谁，具体的这个位置上，来执行这个 呃，呃，相应这个拷贝的工作。>>我们来看它的源代码吧，就能够更清楚地说出来这件事了，啊。 这是copy的源代码，不见得所有C++的编译器， 都是这么实现的，但它的核心，实际上就是这里的这个循环。 那我们就来看看这个参数啊，这个copy它有两个类型参数，一个叫II，一个叫 OI。实际上这是暗示你，这个是输入叠在一起，这个是输出叠在一起的意思。那我们来看看这边的 还有copy的前两个函数的参数是F到L，它可以是一个区间的起点和终点。 然后这个X呢，它可以是一个区间的，呃，这个所谓的目标的位置，然后我们看下copy做了一些什么呢？看到 F一直走到L，对吧，在走的过程中呢，++F，也++X， 然后呢，在这个循环里面做的事情就是把新F的值复制给新X，那也就是说，把F所指向的那个内容， 拷贝到X的所指向的那个位置上去。对，这就是最传统copy的实现。对啊，它成为一个循环，就把 区间FL里面的内容拷贝到从X开始的 地方。就是从这个源代码看，我们觉得它应该是干这样的事情的。但是。对啊，就 直观上看，感觉跟那个output什么就完全不搭界嘛。没有什么关系，对吧。但实际上它可以做到输出的这个功能。它为什么能够实现呢？那我们来看啊。 呃，我们看这个程序，
    ```C++
    //关于 ostream_iterator, istream_iterator 的例子
    #include<iostream>
    #include<fstream>
    #include<string>
    #include<algorithm>
    #include<iterator>
    using namespace::std;

    int main()
    {
        int a[4] = { 1, 2, 3, 4 };
        My_ostream_iterator<int> oit(cout, "*");
        copy(a, a + 4, oit);                        //输出： 1*2*3*4
        ofstream oFile("test.txt", ios::out);
        My_ostream_iterator<int> oitf(oFile, "*");
        copy(a, a + 4, oitf);                       //向 test.txt 文件中写入 1*2*3*4
        oFile.close();
        return 0;
    }
    ```    
  就是说，如果假设让你自己写一个， My_ostream_iterator，然后它的功能嘛，是跟前面那个ostream_iterator 接近，你会怎么写？这里假设我们自己定义了一个模板，叫做My_ostream_iterator， 然后，然後呢，在这里，它能够把整形的东西输出。 然后，实际上它能够把整形的东西交给cout输出，然后输出一个整形的东西，后面就跟一个*号。 这个My_ostream_iterator的对象的名字叫oit，然后我们copy （a， a+4，oit）呢，就会在屏幕上输出一星，二星，三星，四星。 那如果我们定义的一个文件，test.txt， 把这个文件对象关联到test.txt上面，然后这个文件是用来输出的， 然后呢，我们下面定义一个新的这个My_ostream_iterator对象的时候，是用文件 对象oFile作为参数，而且这个型号不变，那么下面这条copy语句呢，就会导致 一星，二星，三星，四星被写到这个文件里面去了。 >> 好神奇啊！也就是说，本身这个copy既可以实现在屏幕中间的输出，也可以实现在 >> 文件里面的输出。对。 然后文件用完了，你当然得关掉了，对吧？ 那好了，现在就假设我出的题目就是让你去写一个类模板My_ostream_iterator， 你该怎么去写？>>对，所以我们的问题就是如何去编写 这个My_ostream_iterator？
    ```C++
    //My_ostream_iterator类应该重载 "++" 和 "*" 运算符， "="也应该被重载
    template<class T>
    class My_ostream_iterator: public iterator<ouput_iterator_tag, T> {
        private:
            string sep;     //分隔符
            ostream &os;                //没看懂
        public:
            My_ostream_iterator(ostream &o, string s): sep(s), os(o) {}
            void operator++() {}                                    //++ 只需要有定义即可， 不需要做什么
            My_ostream_iterator &operator*() { return *this; }
            My_ostream_iterator &operator=(const T &val)
            {
                os << val << sep;
                return *this;
            }
    };
    ```    
  啊，这个如果作为作业就是很难的一个作业了。 很需要想象力，那你要会写这个东西呢，你首先要对copy的源代码，要了解地清楚。 那我们copy的源代码，就写在这儿了。对吧。那好了，现在我们，如果有一条语句copy(a,a+4,oit)， 它就会把a里面的内容， 弄到屏幕上给它输出，对吧，那么当我们 编译器编译到这条语句的时候，就会从这个 copy模板实例化出来一个copy函数。那copy函数， 就是这样的，这里面的部分肯定是原样照抄，但是呢，这些参数，它需要把具体的类型给实例化出来。 这个a是int型类型的， 对吧，所以说，这里的II就变成了这个int*。 那这边的，这个这块嘛，这当然也是int*， 然后我们看到这个oit，它是什么类型的啊？ oit它不是My_ostream _iterator<int>类型的，对吧。所以说在我们实例化出来的这个copy函数里面， 最后一个参数就是My_ostream_iterator<int>型类型的，然后它的名字叫做X。 这里面，当然就都不变了。对吧。好了，现在的问题就是，编译器， 从这个copy模板，实例化出来的一个具体的copy函数， 它长这个样子的，那现在我们要让这样一个copy函数能够编译通过， 你需要解决哪些问题呢？ >> 那显然是要这个，我们看到说要对应乘法这个++这个运算符。>>对啊，你要不++的 ，不重载++的话，这个X是一个对象，你对它++，怎么能够说得通呢？说不过去，对吧。>>然后我们还需要去考虑这个， 星花这个运算符也需要去重载。>>对啊，也不然星X不也没有定义，是吧。>>对，然后另外呢，这个 等于号，因为我们等于号两边呢，可能类型也是不一致的。>>对啊。>>所以我们需要要等于号上也要进行处理。 >> 啊，对，我们等于还要重载一个等于号这个运算符，对吧，否则这些++，*，和=都会不过。 >> 等等，那本身输出这个语句还是没有体现出来啊，感觉。>>对啊， 就是我们，我们会把F到L里面的所有内容都输出了，对吧。 那到底在哪里进行这个输出呢？ 当然要输出的东西就是这个*F，是吧，那这个*F， 到底是通过什么办法去输出的呢？在什么地方被输出的呢？ 那我们首先来考虑一下，就是这有三个运算符被重载，这三个运算符 我们重载它一方面是要解决编译过不了的问题，对吧，另一方面，我们重载它，也需要让这些运算符具体干一些事情。 比方说，想办法把这个*F给它输出， 好了，那我们表面，我们分析一下，我们觉得这个++X， 是否没有什么事情可以干？你把它重载一下，让它 能够编译过就行了，不需要在++里面做一些事情。 那由于这边要输出的内容就是个*F， 然后等号要能够执行的话，这个*X得是一个什么东西？ 才能在上面执行这个等号呢？ 那首先啊，我们认为，这个*经过重载以后，它就是一个函数了，那*X 就是一个函数调用的这个表达式了。一个函数调用的表达式，它能出现在 等号的左边，它的返回值应该是个什么啊？>>引用啊。>>应该是引用，对吧。那它引用了谁呢？ 引用了谁合适呢？ 当然就是引用了这个X合适了，对吧。也就是说， 这个*X这个表达式，它的返回值是一个引用，它就引用了这个X， 那然后这个X=*F怎么解释呢？就变成X .operator= （*F）了。 好，那么接下来我们在，这是个等号啊，接下来我们在这个operator=这个函数里 面，就可以把这个*F给它输出了。对吧。嗯。所以说我们重组了++,但是++不用干事情， 我们重载了*X，这个*X只要返回X的引用就行了。然后我们重载了=，在这个=里面， 把这个参数*F给它输出了。这就是我们要做的事情。>>好，接着下面继续看。 对，我们这时候就得出一个结论，就是我们 对于My_ostream_iterator这个类来说，我们应该重载++和 *运算符，还应该重载=运算符，那现在我们就可以写出My_ostream_iterator这个类模板了。 实际上，我们在比如说这个dev C++或者其它一些编译器里面，我们还要写一个public这个东西， 才能过，那是因为那些编译器里面的copy，它不像我写的那么简单。虽然那些copy，它的核心部分是一样的。但是 它可能会有一些额外的其它东西，这我们不管它，我们要为了使这个程序编译过的话，可能 要加这一条。这个不是问题的重点，重点的是我们看看下面的这些内容。 怎么写？就是我们看到这个 使用这个My_ostream_iterator的时候，它不是有构造函数，对吧？构造函数里面有个cout，有个*。这个东西是有用的，这就意味着，以后 通过copy进行输出的时候，你要输出的内容会出现在cout里面，然后 输出内容后面的每一项都要加*，但是显然，我们得用一个什么东西，把这个cout和这个 字符串*给它记下来，对吧。那应该用什么东西来记呢？那只能是用成员变量来记了，就要用My_ostream _iterator的成员变量来记了，那我们可以用一个string来记录那个分隔符，就是就是每输出一项，就是那个*啊。 然后我们还得用一个东西把cout给记下来了啊、**那cout我们知道它是ostream_ iterator的对象，对吧，包括前面这个oitf，它是 ofstream的对象，ofstream是从ostream派生而来的，所以这个ofstream，它也是ostream的对象。 因此说，我们呢，可以用一个ostream对象来记录它，但是要注意了， 由于ofstream它的成员函数，它的那个无参构造函数是私有的，所以我们在里面，没有办法定义一个ostream 的对象，所以我们只好用一个ostream的引用， 来记录这件事情。**好，现在所以在它的构造函数里面，它不是接受两个参数吗？一个是ostream的 呃，引用，一个是字符串，那我们就用这o和s把这两个成员变量给它初始化了。这就 记下了你要把东西输出到cout，还是输出到一个什么文件对象里面， 以及分隔符是什么。我们都记下来了。然后我们就重载这个++，这个++什么事情都不用干， 那++的返回值，按理说，符合习惯的写法应该是引用，对吧， 在我们这里反正没用了，无所谓，你写一个简单的void也没有什么关系。 好了，然后我们再看到，这里要重载的又是一个*，我们要重载*， 那*我们说了，让它返回值是一个引用，在这，那引用谁呢？ 就是*X返回值就应该引用X，那所以我们就return*this。 是吧，*就解决了。最后一个要重载的就是这个=。 这个=号，=号我们按照惯例的话，它应该返回那个引用，对吧，那我们就这么写吧。 然后这个=号要把这个val给它输出，那我们怎么输出呢？ 那不就是交给这个os输出，对吧？ 就是这个东西，然后输出val，然后再输出后面的一个分隔符，然后再return*this。 那就行了。所以这个My_ostream_iterator就是这么写， 那写了这个东西以后呢，我们看看copy它的作用就变了，对吧，就不再是执行什么拷贝了。这里面你看不到执行什么拷贝的操作。 实际上就变成copy用来往文件或者往屏幕上进行输出了。 所以这就说明了我前面要讲的这个重点就是，一个STL里面东西，具体能干什么，并不是由它的名字所决定的，它能完成什么样的功能，是取决于你的想象力的。 
## 5. 算法（续）
- 刚才看完这个具有想象力的copy之后呢，我们就进入了第三类算法。 
- 那么第三类算法呢，它实际上是叫删除算法，它主要就是去删除容器中的某些元素。 当然要注意就是说，本身这个删除它不会减少容器里的元素的个数。嗯，对呀。比较怪异吧！嗯， 通常这个做法是怎么样得呢？ 这个空位子。郭老师您 》嗯 》写得这个PPT让我觉得 感觉像是在讲故事一样。》这是我发明的巧啊，空位子。 》看到空位子是怎么处理呢？》嗯。 嗯，怎么处理啊？就是把元素，没有 删掉的元素就往前填。填的时候……》不是，是首先先把删掉 的元素相应地就看成是就产生了一个位子。》对对对，然后从后面所有没有被删掉的元素 都往前移，去填那个空位子。然后一个元素被移到空位子的时候，它本身又变成了一个空位子。然后后面的接着往》可是它原来 的那个位子就变成了空位子》原来的那个位子，没错。》然后这个空位子又怎么办呢？尤其是它填充了以前的这个元素。 容器中间的元素。》形成了以前的元素。》还是放到那，就不变了。 》最后有一些空位子它的内容就不变了。 嗯。》哎，我讲得是后面有一些具体的算法它本身就是一些操作了，实际上。 》你看后面的例子你就会搞明白了。 这个删除算法它是不应作用于关联容器的，这个是要注意的地方。 》对，它跟刚才讲得那个原因是一致的。》嗯》关联容器它本来是已经排序好了的。》对。》这样一个有序的一个容器。 》那下面看这个例子。等会儿会有例子啊。》那我们先看本身这个删除算法它包含这个remove，是吧？ 最常用的就是remove了。》remove是什么？》remove它就是删除区间当中等于remove的那个值的元素。》嗯，对。 》然后呢，你也可以remove-i，f就是去删除这个区间中满足某种条件的元素。》嗯，是。》郭老师，因为又断了。 那我接着讲吧。》下一个音乐。》那这个remove-copy它主要做的事就是去拷贝这个区间到另外一个区间》嗯。 》等于具体每一个值的时候，就不会去做这个拷贝的工作。》嗯，对啊。 嗯。》讲到remove-copy-if了。 》就是拷贝的时候，某种符合某种条件的元素它就不拷贝了呗。这些都用得很少。Unique还用得挺多的。 Unique用得特别多。》对，unique是挺常用的。》对，就是它能删除区间里连续的相等的元素。 然后它只留下，那些连续相等的元素吧，它只留下一个，这所谓什么相等也可以指定地比较细的。 那现在这个unique呢它是经常被使用的场合就是有时候我们需要把一个数组里面排序 然后还要把重复的元素都去掉。那你就可以先sought，然后再unique一下，就行了。 然后，它unique它可以返回一个迭代器，也就是 被删完以后，最后一个有效元素后面的那个位置所指代的迭代器。那你 把这个unique返回的迭代器跟整个区间的begin的开头一减，你说它还，你就会知道还剩下多少个元素了。 它特别常用。那我们下面 看看，就这个unique，扯了半天，还没有翻到这儿啊。好， 它，unique它有两个版本吧。有一个版本是用这个 用这个等等，还要一个版本是多了一个比较器， 啊。是pr，pr为true，就说明x和y相等。 》注意它就是返回的这个是这个迭代器指向的是这个删除后的》对，删除后的这个区间里面 原来有效的最后一个元素的那个后面，元素删除后的区间呢，最后元素的后面 》那我们来看这个具体的例子啊。》嗯，对。 这不是有1、2、3、4、5。然后这是，这儿有两个2啊。 然后这个，这个东西我们前面讲过了啊。现在我们所做的事情就是remove，从a里面把2给它删掉。 从a里面把2给它删掉，我们把它输出以后发现，是1、3、5、2、5. 》可能大家觉得有疑问了。2不是都删掉了吗，为什么还要2存在呢？》那我们先要看看它的这个过程。 这个，不是1、2、3、2、5，对吧？那么，先把2删掉，把2 删掉呢， 就是把2的位置标记为空位子。然后就拿后面的这个元素来填这个空位子。 那把3填过来，就变成这个样子。它本身就变成了一个空位子。 然后还有这个2 又是一个空位子，对吧？ 然后5在这。然后就拿5填到这个3的空位子，就变成了1、3、5，然后后面有两个空位子。 它的内容维持是2和5不变。所以就是1、3、5、2、5。 那，然后它返回，这个remove它会返回一个迭代器的。这个p也是 这个新p在整个数组上面它就是一个迭代器。它实际上返回的迭代器会指向2这个地方。 那现在我们要说，那为什么它删除元素并不是真的把这个容器里面的元素给删掉，而是往前移呢？ 为什么是用这种空位置的办法处理。 大家可以想象如果，啊，你可能会觉得如果 这个remove操作的是一个容器的话，应该把 容器里面的某一个值真的删掉而使得容器中的元素个数减少，是吧？但是我们知道remove它也可以用来操作这样的数组的。 用来操作这样的数组的时候，你怎么把数组里面的元素给它真的删掉呢？》这样是不可能的。 》不可能，不可能是吧？所以说，remove是没有办法去减少它所操作的区间 里面的元素个数，它只会在这个区间里面进行一些元素的移动，然后告诉你 剩下的那个元素，它最后在什么位置。 然后你把这个返回的迭代器减去开头，你就知道剩下的元素一共有几个。这就够好用了，就可以了。》嗯。 那么刚才看到的是这个数组，来进行一些相关的remove的操作，是吧？》对啊。》那么下面我们会对 B这个数组，把它放到vector这个，v这个里面来。》嗯嗯。 》这个时候我们也同样可以去remove这样一个vector中间的某一个元素。 》嗯。》还就是remove这个2。》嗯。》那么这个实际上实行的过程跟刚才 的例子是一样的。》对对对。》我们一开始是有1、2、3 2、5、6这样的 6个元素。》对。》那么这个时候我们第一步的操作呢，remove掉这个2的话，那么实际上我们就把这两个2的位置变成了所谓的空位子。》空位子。 》是啊。》然后呢，我们就把其他的值呢，依次地向前填充。》嗯。嗯。》那就变成了1、3、5、6 》是啊。》那么这个时候就额外多出来了两个空位子。》嗯。》然后这个空位子的话，相应还是填充原来的值，就是5和6. 》嗯，对。》所以这个时候，如果要是你用这个cout，第三行的这样一个输出的话呢， 》嗯》实际上就是 1、3、5、6、5、6。》嗯，对。》那么这个时候如果我们去test一下vector里面的元素有没有少呢？ 我们就cout了一下v点size。》嗯。》这样一个获取vector大小这样一个 这样一个操作的话，我们会发现它输出的仍然是6，就是说，实际上这个元素的个数并没有减少。》嗯。》所以说删除这个操作的实质并没有去减少 真正减少掉这个元素，这个中间包含的元素的个数。》嗯，对， 我补充一下，就像是刚才这个remove不是把返回值放到p里面去，对吧？然后我们通过p减a， a是这个开始的位置。通过p减a输出3，就意味着元素被删掉以后，有效的东西还剩下3个。 嗯，就是这意思。 嗯，下面。》那么第四类算法的话就叫做变序算法，是吧。 》嗯。》它主要是用来改变这个容器中的元素的顺序的。 它本身也是不会去改变元素的值的，就像我们刚才看到的那个random shuffle的那个变序的算法。》嗯，变序的算法。 那么这个变序的算法同样是不能适用于关联容器的，是吧？因为我们知道关联容器实质上是一个排序好的一个容器。》对，你不能再改变它……》换个歌吧。噢，噢。 》啊。》终于，终于可以比较平复了。 那您既然讲了，我们再平复一下。》好吧，那变序算法它的复杂度都是O（n）的啊。 它， 它，比如说random shuffle，random shuffle执行的还不太好说，反正大部分都是O（n）的吧。 然后这个reverse就是，其中有一个reverse，它把 区间前后次序颠倒。 由1、2、3、4变成4、3、2、1。这当然是O（n），是吧。 reverse copy就是把一个区间颠倒后的结果拷贝到另一个区间，然后源区间不变。 rotate把区间进行循环左移。这个，这个 有点变态了，这个不知道干什么用，反正没有用过。rotate copy 不用扯它了吧。 嗯， next permutation，这是，这个东西好哎， 啊。 nest permutation是把区间改为下一个排列。 那排列它是有大小关系的。比方说，你三个数，1、2、3它的排列一共有6个，对吧？ 1、2、3这是最小的，然后是1、3、2，然后 是什么？》2、1、3。》是， 2、1、3，它是。最大的是什么？》是3、2、1.》哎， 对，它是从大到小顺序的。这个大小也可以 制定地比较符合规定。》然后这个》嗯。》prever什么？ permutation就可以去，找寻上一个的排列。》上一个排列， 是吧？》这个是比较方便的一个方式。》对。random shuffle就是前面看到的，就是 打乱顺序。partition是把区间满足某个条件的元素移到前面，不满足的移到后面。 这个用得也不太多。但是permutation这个东西特别好使。等会儿我们还会看到例子。 stable partition是把区间内满足某个条件的元素移到前面，不满足的移到后面。 然后，对于这两部分的元素，就是对满足条件的这些元素吧， 有若干个。那么这些元素它们的原来的先后次序是不变的。》不改变的。》嗯。》所以示stable的。 》对啊，是啊。然后下面就不说了。嗯 random shuffle它要求上面是随机访问 迭代器。容器上面试随机访问的迭代器。这些东西都是啊。 然后，reverse就是颠倒区间。next permutation就是 嗯， 那我们就来看next permutation的例子。 嗯，你来说。》那我们这个例子当中的话呢，这个，那 有定义了一个string，一个对象str，那么它的这个已经定义好的顺序就是23 1。那么如果我们这个时候去求这个next_permutation的话呢， 那么当然这个输出的这两个 参数的话，是区间的起点和终点啊。对，然后那么这时候的话，我们实际上就应该 对应输出的是这个下一个231后续的这个排列的这个 值。那我们会看到，这时候如果我们count str的话呢，我们输出的就是这两个值，也就是说23 1后面就只有312和321，它会依次这样去输出。这是一个循环嘛，就是next_permutation 返回值会true就意味着我找到了下一个排列，返回值为false就意味我找不到下一个排列了。那现在我们通过这个循环就会把 231后面的所有排列都找出来。一共就两个，一个是312，一个是321。 所以这个循环输出了这两行，然后再输出了一个这个呗。 那就是这个*，对吧。那，那下面我们看这边 还定义了一个char类型的数组，对，char类型的数组，这个数组里面有324三个字符。现在我们要做的是， 求这三个字符的什么下一个排列，对吧，就是324下面的这个排列。那分别是，有三个342，423，432。 通过next_permutation这个循环，就一次把这个三个排列给算出来了。 那这个排列它，next_permutation并不是说只能用来求 一些字符的排列的。就是如果你一个，哪怕一个 容器里面放的是整数，或者是别的一些什么对象，都可以用next_permutation来求它的这个排列的。 好现在我们再看这个例子，就是我们可以把string拿来sort，这个当初说string的时候，并没有提到。但实际上它是可以的。 我们把这个str拿来sort以后，str里面原来放着的字符，经过next_permutation以后，已经变成了 321。对吧。这个next_permutation它会修改它所作用的这个区间的。 所以我们这个循环执行完了以后。str里面的东西实际上已经变成这个321。 然后我们在这里可以把它sort一下，它又重新变成了123。不是，那是你画的是132。 嗯，对，123还没有输出，对对对。然后呢，我们再来next_permutation。 一次一次地做，就把123后面的所有排列都给它输出出来了。 就是这个东西。对。next_permutation，prev_permutation都是特别好使的。 嗯，怎么又来一个？对啊，这是作用在整型的数组或者容器上面的这个例子 啊。因为它太好使了，所以我就多举几个例子啊。你知道我们。OK，就是说适用范围可以有很多，是吧。 对啊，对啊，我们有研究生入学考试的什么复试，考了一个全排列，好多人 有好些人还是不会做的。其实会这个函数就好写了啊。 啊这个东西，就是这是一个整型的数组，这是一个整型的这个list，它里面的元素 也都可以看做是一个排列。然后我们用next_permutation都可以把下一个排列给求出来。也就是说这个ls 它里面的内容不就是8，7，10，对吧？因为它是把a里面的给拷贝过来的。 那现在我们，8，7，10的下一个next_permutation就是下一个排列就是8，10，7.然后再下一个就是 这些东西啊，就通过next_permutation就能够 把这个ls的内容给改变了，改变了它的排列。而这边无非就是把ls的内容给它输出呗，所以就输出了这三行。 嗯，所以这个next_permutation这个算法呢，我们就详尽得解释了一下。大家肯定应该会用了 啊。其实您应该写一个，至少可以秀一个这个什么prev_permutation。 没法忘了吧，反正有了next，previous怎么回事，也知道了啊。OK。 那我们从这个排序，刚才这个是叫做变序，变序算法就变成了排序算法。 对，变序算法就是它变出来的序。可能是乱的，不一定是这个 有按照某一个大小来排。第五种算法就是这个排序算法。 那么它实际上比刚才这个变序算法的复杂度肯定要更高一些的，通常来说的话是nlog(n)的。 嗯，是。那么这个排序算法的话，它需要支持这个随机访问迭代器。其实刚才那个也需要支持吧？ 也是。就是那些算法，我们说了，它如果不能作用在关联容器上，它们就都需要随机访问 迭代器。对。然后呢，这个，同样的这个排序算法是不是不适用于 关联容器，同时它还要注意，它也不适用于list。因为list本身它是这个双向迭代器。 对。它上面的迭代器不是随机访问的，所以不能用这个排序算法来处理。 那这个排序算法中间呢，响当当的代表就是这个sort啊。啊补充一点就是， list上面的迭代器是双向的，但是我们前面还是有不少算法能够作用于list的。 就是有的算法，我们强调了它需要随机访问迭代器，那它就不能作用list，是这样的啊。 好了，那刚才你说响当当的？响当当？sort。sort响当当？为什么啊？ 经常用到，我觉得这是我最早接触到的STL的一句。 终于可以不用自己也写sort了，我已经用了一个效率不错的sort的source啦。对。 就是我们说到排序的时候，说的都是会把一个什么区间从小到大排序啊。我们都说是从小到大排序。 只不过什么叫小，是可以自己定义的啊。 注意了啊，这个小并不见得就是<所代表的小，啊。 嗯，缺省的情况下，那可能就是<所代表的小。 那然后除了这个sort之外还有这个叫做stable_sort。 嗯，对。这个sort我们知道，它的平均时间复杂度是nlog(n)的。 当然它的最坏情况下复杂度是n平方的。 就是大多数情况下，我们都认为它是nlog(n)，你不会那么点背的啊。 那如果你特别在乎这个最坏情况下的这个时间复杂度。 那你就可以去使用这个stable_sort了。这个我们等会再接着讲，先把这个先念一遍啊。stable_sort它把区间 从小到大排序，它保持相等的元素间的相对次序，所以它是稳定的嘛。 partial_sort是对区间部分排序，直到最小的n个元素就位。就是它可以只排 最小的n个元素排好，就拉倒了。嗯，然后还有一个叫做 你刚才说叫什么？part-tion？part-tial，是吧？我念错了啊。这不是叫partial？ par-tial？这到底是什么？partial。对，哎，我怎么历来都念做part-tial啊。 partial然后，（一部分的sort）partial_sort_copy也就是说你可以将区间的前n个元素排序后拷贝到另外一个地方。 但是本身注意就是元区间的这个值是不变的。 对对对，你是我的一词之师（郭老师的表情好凝重啊），呵呵，啊，知道它叫partial 了哦。好，这个nth_element就是把，对区间部分排序，使得第n小的元素就位。 然后而且比它小的都在前面，比它大的都在后面。这就 OK了。这个东西我还真没有用过哦。看上去好像很厉害。 然后此外还有一系列的关于这种非排序的，一系列的这个。这个我们就不介绍了 吧。然后详细关于“堆”的话，欢迎这个关注张铭老师的"数据结构与算法"。呵呵，嗯，对啊。 sort确实特别常用。 它有两个版本，一个版本是没有自定义比较器的，那这个时候， 就是用<去比大小，我们sort，我们说它都是从小到大把一个东西给排好序的，至于什么叫小， 这个版本的sort，就是用<来定义什么叫小的。所以这个版本，应该是比较，通常是比较（最常用的啊）。 常用和正常的情况啊。量得掉光了也没有什么不正常啊。是不是啊？好，OK。 所以这个第二个版本实际上就是通过你自己定义好的这样的一个（更灵活） pr这样的一个 比较器，然后来去判断一下说这个pr(x,y)中间等于是计算出来的 这个值是否是true。对，就是sort，你在调用sort的时候，就要给出第三个参数，那你这个第三个参数， 叫做pr。然后在sort运行的过程中，它要比较两个元素x,y的时候，就会去计算pr(x,y)这个表达式。 为true的话，就认为x应该排在y的前面，觉得x更小。 那么这个表达式要有定义的话，pr得是个什么东西才行呢？ 它要么得是个函数对象，要么得是个 函数指针。对吧？这个东西才能有定义。对。 那，这是个具体的例子。就是我们定义好了一个类，叫做MyLess。 然后它中间包含了一个重载的这个operator圆括号， 它实际上做的事就应该是去比较这两个参数n1，n2的这个个位的这个值。对。 也就是说重新定义了这个，比较大小的规则，对。谁的个位数小，谁就 算小，谁的个位数学上小，它就算小。那，那下面这个 sort(a, a+5, MyLess())，就是把a按从小到大的 顺序来排序，只不过这个小的含义，是我们自己定义好的这个MyLess。就是按照这里来定义的，那就 谁的个位数数学上小，谁就算小，那么排出来的结果当然就是 这个，哦，我们给他输出，就是这个 这个数字，对吧 。这是按照个位数从小到大来排的。 嗯，那下面这个呢？这是greater<int>， greater<int>我们前面接触过了，应该记得它是用大于号去 比大小的。等于说greater<int>的，它的意思是，谁在数学上， 大，谁反而算小。那么这个sort的话，当然就是 降序了，对吧，数学上的降序，来把整个 a给它排好序了。也就是说，只要这个sort本身有第三个这个参数的话，我们实际上是应该按照这个 你的第三个参数来进行，这个规则来进行这个排序的（比大小的）。对，嗯，是的。 那这个sort呢？我们说它是这个 快速排序，复杂度，平均复杂度是n*log(n)，实际上绝大多数情况下都是n*log(n)。它的平均性是最优的。 最坏的情况下，性能是差的，是n平方的，但是 这种情况下很少见。如果我们要保证最坏情况下的性能，那么我们就可以使用stable_sort。stable_sort是归并排序，那归并排序它能够保持相等元素之间的先后顺序。 除此之外，它还有稳定的这个性能。就是说，它“最坏 情况下"，时间复杂度也是n*log(n)。这里面有个前提就是说，它有 足够的重组空间可以用。一般都不成问题的。最坏的情况下，它复杂度也是n*log(n)。最好的情况， 没什么最好的情况。平均也是n*log(n)。最坏也是也是n*log(n)。最好的情况下不要排了。对。那 复杂度，如果空间不够的话，复杂度就是 这个n*log(n)*log(n)啊。 它用法跟sort是一样的，然后它都要求随机访问迭代器的支持。 所以，list上面也不能用它。 对，list自己本身有那个sort。对，自己本身就有sort。然后我们来 看这个第六种算法，就是这个有序区间算法。 那有序区间算法的话呢，它实际上就是说，本身要求所操作的区间是已经从小到大排序好的。 对，嗯。然后呢，那么同时它也会需要支持这个随机访问迭代器。所以 因为它是随机访问，要求随机访问迭代器，那么它依旧不能作用在这个关联容器和list上面。 也就是说，它实际上是对这个有序区间来进行一系列的这个其它的操作。 对，最典型的就是这个binary_search了，就是折半查找，查找 区间中是否包含某个元素， 然后，所谓包含某个元素嘛，表面上的理解就是看看是否 有某个元素跟你查找的那个值相等。 可这里的相等呢，又不是==的意思，而是x＜y， 和y＜x同时不成立，这就叫相等。前面已经有过例子了啊。 然后，这个includes就是判断是否一个区间中的每一个元素，都在另外一个区间中。 等于说相当于判断一个集合是不是另外一个集合的子集吧，差不多是这个意思。嗯，对，然后呢， 这个还可以去求取这个lower_bound和upper_bound。那么lower_bound的话，实际上它就是查找 最后一个不小于某个值元素的位置，注意是不小于某个值。 嗯，对。这个。然后这个upper_bound也就是去找这个第一个大于某个值元素的位置。 类似于那个关联容器里面的lower_bound和upper_bound的成员函数。equal_range就是同时 或者lower_bound和upper_bound。我们知道关联容器里面有这三个成员函数的。 它们是类似的，就不再细说。然后呢，也可以把这个两个本身的这个 有序这个区间呢merge在一起，形成这个第三，把它要 放到这个第三个区间当中去。对，那比如说到时间复杂度，我们知道binary-search它肯定是 log(n)的。lower_bound和upper_bound，equal_range也都是log(n)的。至于这个这个includes，它是多少呢？ 那它取决于你要 找的那个，某一个区间，它里面有多少个元素，然后再乘以一个log(n)。 merge合并两个有序区间到第三个区间，这个是 on的，两个区间都得扫一遍嘛。对。 那么有序区间算法本身呢，它还包含了一系列这样类似于集合操作的一些算法。 嗯，比方说有这个set_union，它能够把两个有序区间合并起来，然后拷贝到第三个区间。 对，它实际上求的就是这个并。集合的并。但是这些有序区间算法跟集合又有点不一样，因为集合是不允许有重复元素的。 但是在有序区间算法里面，不管源区间和目标区间（还是不考虑的），都可以有重复的元素。 然后还有这个什么set_interaction，它实际上它取的是这个交的这 部分。对。然后，set_difference是求集合的差，就是说 a-b，就是说a-b的差，那当然就是，在a里面 不在b里面的元素。嗯，对。 然后还有这个叫做。对称墙。对。symmetric _difference，symmetric_difference是什么呢？这个，这个是a 这个是b，symmetric_difference就是两个的并减去两个的交。 就是就是非阴影的部分了啊。symmetric_difference 然后还有这个叫做inplace_merge，是说将两个连续的 有序区间呢，原地合并为一个有序区间。 就合并在某一个区间上面了。这些区间算法说实在的，它也不怎么太常用。 它的规则有时候还比较奇怪。 还是来看看这个最常用的这个binary_search。对，就是折半查找嘛，复杂度 是log(n)的啊。 这个很常用。它的返回值就是 一个bool类型，告诉你有没有找到，这个前面已经有充分的例子啊。 我们知道会用就行了，这跳过去吧。看这边有一个具体的实例啊， 这个Greater10，这就是判断一个东西是不是大于10喽。 然后在这里面，我们有一些这个有序区间的算法。 对应就是我们有一个a1的数组，是吧，包含了这样一系列的 数字。然后完了之后呢，我们让这个 定义好的一个v，这样一个vector，那么用这个a1来进行 初始化。然后之后的话呢，我们现在第一件做的事呢，这个就是去find 在这个v这个数组中间呢，去find10这个 元素。然后返回的是一个迭代器。马上让它给到这个location，我们定义好的这个 location这样的一个位置上。那么这个时候的话呢，就可以去 当然你要首先去判断一下说，它是不是等于v.end的？相当于是说。找不到的话就等于v.end 了。对。然后那么如果它没有等于v.end呢，我们就去输出相应的这个位置，说明它找到了。是吧。然后它实际上呢， 对应就可以看到是，我们求取的是location-v,begin。两个随机访问迭代器是可以相减的。 对，对应找到这个10的话呢，因为我们去，如果你去数一下的话，它对应就应该是下标应该是这个 8。那么这时候它就会输出是这个8。 那么完了之后的话呢，我可以，刚才用的是find这个函数啊。那么除此之外的 话呢，我还可以find_if，也就是说我可以按照某个条件去查找。 这也是一种有序区间算法啊。反正这是前面的。哈哈。 没关系，你讲吧。郭老师，您那笔记本快没电了，音乐要 戛然而止了。那么这个时候呢，我们就可以去使用这个Greater10,。 嗯。我也被您带坏了，变成中英文夹杂的这样的情况了，是吧。这个条件就是说去找大于10的嘛。对，然后就可以传递的这个 用这个函数本身来去判断。这个时候相应地也会去得到一个。第一个大于10的。 这样的一个位置。然后我们也可以得到相应的这个计算， 用这两个迭代器进行计算，就可以看到说是这个50， 50的下面就输出3了。 然后我们再看，终于看到这个有趣的binary_search了。哈哈。 我们现在是把v给它排序了，然后在这上面去找9。 注意就是binary_search前提就是一定是要在这个排序好的，这个。不排序，它没办法进行二分查找，结果就完全不对。 好，那现在我们就在这里面找9，当然就能找到了，所以就是输出一个9 found。这个例子好无聊啊。我想跟你说的一模一样的。哈哈。 然后那么我们刚看到的就是这个binary_search的一个例子，对吧。实际上 并没有讲什么更多的内容。完了之后呢，我们会看，就是我们才提到说有这一系列 这个lower_bound，upper_bound,和这个，uper是不是，是掉了个p吗？ 应该是少了一个p。对，upper_bound。然后就是equal_range 这样的这个三 个相应的这个算法。它实际上对于这个lower_bound的话呢，它实际上就是说 首先前提就是你的这个区间内，首先所有的元素都是有序的。 然后它在这个有序的这个范围内呢，去查找相应的这个 最大的位置。然后它呢，会比这个整个这个中间所有的元素呢，都会去要这个 小于相应的这个我们定义好的这个value的这个值。对，就是，对于这个版本 来说，就是说对于这个区间里面任何一个x，x<val， 它都得要成立。所以这个区间是左闭右开的这个区间。 这个Fwdit指向的元素，并不包含在内。对。 然后那么相应的upper_bound其实也是类似的。嗯。 就是在这个区间里面的所有元素，它说都比val大，都比val大是什么意思呢？不是用大于号的意思啊。 就是说val<x，这个x对于任何一个x属于这个区间，那 val都小于 x，就是这个意思。嗯。然后equal_range实际上就是同时去返回这个lower_bound和upper_bound。同时求得lower_bound和upper_bound。 反正这个lower_bound和upper_bound，equal_range，它们的时间复杂度都是，都是log(n)的啊。 嗯，它们都要求这个区间是有序的。那这个equal_range它的返回值就是一个pair。 那pair就是一个pair类模板生成的， 类的对象。假设这个，这个这个返回值是pair，变量名字叫p的话， 那就是说从这个first到p.first中间的元素都比val要小，因为p.first就是 lower_bound求得的那个值嘛。然后这个p.second就是upper_bound求得的那个值嘛。 就这样，好，下一页。 那这个merge的话，实际上它做的事就是把两个这个有序区间合并起来。 而且合并完了，还是有序的。 然后放在这个第三个这个，形成了第三个这个序列。放在从x开头的地方。 那你这个x开头的地方，后面必须事先已经有了足够的空间。不能说空间不够，它临时会 分配出来，不会的，你必须从x开始的地方，已经有足够的空间。 这个函数才能正确执行。 第三个序列也是有序的。对，所以这个merge这个本身这个算法，它也包含了两个版本， 一个就是用小于号来做比较器的，一个也可以自己去定义这个pr。对。pr。对。 那么此外的话，还有这个includes，就是判断某一个区间里面的 是否所有元素都在另外一个区间里面。那什么叫做都在这个区间里面呢？ 比如说你要算一个x first和last里面都有一个元素x。x在first1last1中到死是什么意思呢 是不是存在一个y属于first1last1然后y等于x 是不是这样呢？也不是的。不是这个意思。他的意思是 存在一个y它属于这个first1last1 对于这个版本来说就是x属于y，y属于x都不成立。 这个就叫找到了。那么对于第二个版本这个就用pr来 set_difference就是 求两个集合的差。在一个区间里面 求出不在另一个区间中的元素，放到s开始的地方 在何不在的概念中刚才说的是一样的。 >> 刚刚说这个set_difference实际上就是去做这个a减b的>>对两个集合的差 那他如果有多个相等的元素，这个first1last1有多个相等的元素在first2last2里面 那么这个多的的元素最终也会放到这个目标区间里面去。>>所以他跟这个集合会不太一样。 可能会有重复的元素出现。>>set_intersection就是求集合的交 排序也是有两种决定大小的方式。 一种是用小于号一种是用自定义的。他们都是有序区间上的 他们所操作的区间，原区间都是要有序的。最后生成的东西也是有序的。 然后他会求出两个区间里面共有的元素放到从x开始的一个地方。 这里面有一个特殊的设定。就是如果有一个元素e 在first1last1里面出现了n1次，然后再first2last2里面出现了n2次 那么这个元素在结果的区间里面出现的次数是两者n1和n2里面比较小的。 那个次数。>>因为他是求交嘛>>对 也符合逻辑啊。 这个叫什么>>symmetric_difference>>对称他就是取交 把两个区间里面互相不在另一区间里的元素x 放到开始的地方。那么它的优点就是求并集。 求并集它特殊的地方就是如果有个元素e在first1last1 里面出现n1次，在first2last2里面出现n2次 那在目标区间里面就出现n1n2里面多的那个次数。 并嘛。这也是有道理的。 这个bitset>>这个是 跟算法其实是>>这个不叫算法>>对 就是没有什么太多关系>>对他也不叫容性因为它里面没有什么可变的类型。 >> 那为什么要放在这集里头呢>>那你说放在哪呢，只能放在这咯 反正他就是一个很好用的东西。我们不用管他属于什么分类。 >> 烦着呢就是一个类模板>>对，就是一个类模板 它实际上就是用来实现很多bit的标志位。因为我们已经有时候选择的时候我们会比方说需要 100个标志位。100个bit的标志位。 那你怎么来做这个事情呢 你可以说我排一个数组。我要用10000个标志位。每一个标志位只要一个bit就够了。我怎么办 排一个字符型的数组来放这个标志位是吧 虽然可以这么做但是比较麻烦。因为你要找到比如说第1000个标志位到底在哪的时候 你首先要算出这第1000个标志位是位于第几个 字节里面。然后你还要算出它是这个字节里面的第几个位。 反正你要做一个除法出一下三然后再要比一下模之类的 比较啰嗦。那就这个bitset呢很容易就定义出一个东西。这个东西就是1000个标志位。 那你还可以是任意把这1000个标志位里面的任一位置1还是置0.或者是反问他的值。 随便怎么样都可以。很方便。 >> 跟他配套还有很多成员函数可以用。>>对啊，比方说，那我们在使用 这个bitset的时候这里面也没有类型常熟。只有一个整形的一个东西。 那我们使用它的时候N是一个整形常熟。这是bitset一个事实。 这个bst就是由40个bit组成的对象。然后 bitset提供了很多的成员函数可以随便的访问这个bst里面的这个 40个bit。可以修改任何一个bit 所以取任何一个bit的值都很方便。表现出来他就是有一大堆的 成员函数。包括bitset可以拿来做位运算的。 一个bitset他可以&等于一个bitset。 那这两个bitset就一样长。然后 就是说做&。这个是&=这个是&^=.还可以有左移右移操作。 这跟位运算道理是一样的。那这边这个set函数就是把bitset里面全部的为都变成一样。 这个是设置某一位。你可以设置某一位为零或者为一。 这个1的常熟就代表你要设置第几位。第二个常数就是必要把它变成一。 那这个reset呢就是把全部为都变成零 这个reset呢就是可以把某一位设成零。这个就是设定的位数。 flit就是把bitset全部给他翻转。flip这个版本就是把某一位给它翻转。 >> 主要是bitset我从来没有用过。 这个bitset它本身还可以去返回某一个位的引用。它实际上就是operator这个方括号 那么相应具体这个位上就是这个参数去指定的。 那么同时的话也可以去判断说 本身这个某一位是否为一。那么他把他主要是一个bool的变量。 它实际上也是用这个operator方括号。 但是它是对应的一个const的函数。 因为它只是判断一下。他不是说>>她不会提出改换>>对 那么同时的你也可以相应的去取这个具体的一个位。 bool at中括号就是说他会进行下标某一位的判断。>>跟之前我们讲的是一样的。 那么这个也是可以具体对某一位进行相对应的访问和判断。 那么完了之后的话呢还有这个这边有一个叫做 to ulong这样一个把某一个具体的 是把一个bitset转换为一个>>完整形>>对>>就是unsigned long >> 这就是一个ulong>>比如说你bitset里面有三个标志位他们都是111要转换成ulong就是7 那么还可以的话呢就是说我们可以把具体的这个 除了转换成ulong之外呢还可以转换成string这养一个字符串。 >> 就是零幺串位>>然后此外的话呢还可以去直接用这个count 相应的这个1的个数。然后呢也可以去求取这个 tsize的这个大小。他一共有几个标志位。 然后呢这个 operator等等的话呢实际上他就是取>>判断两个bitset>>是否相等以及判断他们是否不等。 >> 还有啊>>那么这个test就是去测试某一位是否为1.any就是判断某一位是 否有某一位为一。ncne是不是全部为零。 然后这个东西就是左移右移。这个 语法之类的。这里面有个静态成员变量>>与返回相应 