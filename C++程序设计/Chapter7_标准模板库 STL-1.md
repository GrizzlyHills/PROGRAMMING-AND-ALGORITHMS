# [标准模板库STL-1](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/8)
> 本模块将介绍C++的标准模板库（Standard Template Library，STL），这是泛型程序设计最成功的应用实例。STL是一些常用数据结构（如链表、可变长数组、排序二叉树）和算法（如排序、查找）的模板的集合。有了STL，你就不必编写大多的、常用的数据结构和算法。即便不想用面向对象的程序设计方法编程，学习STL也是大有裨益的。
## 1. STL-概述
- 现在我们来讲讲C++里面的重要内容，标准模板库 先来看看标准模板库大概是什么样。 标准模板库呢简称为STL，是standard template library的这个缩写。 里面主要是一大堆的函数模板， 类模板。因为C++语言的核心优势之一就是便于软件的重用。 那它有两方面能够体现软件的重用，一方面就是面向对象的思想，比如说继承啊， 多态啊，标准类库等等啊。另外一方面体现软件重用的地方 就是C++支持泛型程序设计。 什么叫泛型程序设计啊？就是使用模板的程序设计 那C++里面你可以自己编写模板，也可以使用标准模板库里面带的各种类模板和函数模板 那在C++里面 标准模板库里面呢它是将一些常用的数据结构，比方说这个链表啦，数组啦，二叉树啦等等 实现为一些类模板。 然后它把一些常用的算法，比方说排序、查找等等写成函数模板。 那么有了这些模板以后啊，以后不论数据 结构里面存放的是什么对象，然后你这个算法针对是什么样的这个对象 那我们都不必重新自己去写这个数据结构， 也不必自己去编写算法。直接使用这些类模板和函数模板就能够处理各种各样的 数据啦。那标准模板库呢就是 常用的数据结构和算法的模板的集合。 那有了这个STL以后呢，我们就不必要编写大多数的标准数据结构和算法 而且STL里面的这些模板它的性能也是相当高的， 它对于一个算法实现水平一般的程序员来说，你自己实现的那些算法和数据结构可能效率还没有STL的里面的那些东西高。 
- 那STL里面有一些基本的概念，有三个，就是容器，迭代器和算法 
  - 那我们先看什么叫容器，容器实际上就是数据结构。这个容器里面可以容纳各种类型的数据， 是通用的数据结构。那容器实现为类模板 那迭代器。
  - 迭代器实际上就是，本质上就是指针。 它可以用于依次存取容器中的元素，就是你要访问容器中的元素，你就得必须通过迭代器来进行。 这迭代器用起来像是一个指针，它的内部归根到底也是通过指针来实现的。
  - 那算法是什么概念呢？算法实际上就是一个个的函数模板，这些函数模板往往都是用来操作容器中的元素的。比方说用来对这个容器进行排序，把整个容器排序或者说在整个容器查找一些、一个值，这些都是算法所完成的功能。 那比方说我们常见的sort算法，就是对用来对一个vector这样的容器里面的数据进行排序。把整个vector变成有序的， 然后我们可以用find这个算法来搜索一个list这种容器里面的对象这个list呢就是链表，而且双向链表。 那算法本身与他们操作的数据类型无关，因为它是函数模板嘛， 所以这个算法它可以用在从简单数组到高度复杂的容器上面的任何数据结构上面使用。 
- 在C++里面，就简单的数组我们也认为是一种容器。 举一个例子，这一个简单的数组，`int array[100]`,整型数组，我们就可以说它是一个容器。 那这个容器上面的迭代器是什么呢？就是int* 类型的指针， 就可以作为这个容器上的迭代器使用。 比方说你让一个Int* 类型的指针指向这个数组的开头，然后你通过对这个指针不断地进行++操作，就能够让这个指针指向这个容器里面的不同的元素。然后你就通过这些指针就可以访问这些元素，所以int* 类型的指针就可以作为迭代器。那这个sort算法 它就可以作用于这个数组，这个容器上面，对它进行排序。比方说我们可以写 `sort(array, array+70)` 那这条语句就对这个array数组里面的前70个元素进行排序。那在这里， 这个array是个int型的指针，array+70也是一个int型的指针。这两个东西都是迭代器,那STL里面的容器呢，就是用来存放各种类型的数据的。**你可以把基本类型的变量、对象等等都往里头放，那容器就都是类模板，STL里面的容器可以说有三种**，
  - 第一种叫做**顺序容器**，容器都是有类模板，类模板嘛，所以这些类模板当然都是有名字啦,那STL里面的顺序容器一共有三个，它们的名字是`vector`，`deque` 和`list`。这个vector就是动态数组， 一维数组，`deque`是双向队列，`list`是双向链表。 
  - 第二种容器叫**关联容器**，关联容器有set,multiset,map和multimap这四个。 它们都是排序的，而且查找速度会很快 
  - 第三类呢叫做**容器适配器**。容器适配器有`stack`,`queue`,`priority_queue` stack就是栈，queue是队列，priority_queue是优先级队列 
- STL的容器是用来放各种数据的，就可以把基本类型的变量放进去也可以把对象放进去。**当一个对象被插入容器中的时候啊，实际上这个对象并没有被放进去，被放到容器里面的是这个对象的一个复制品**。然后许多这个算法，比如说排序、查找，它要求对容器中的元素进行比较，比较是否相等或者比较大小。然后有的容器呢本身它就是排序的，那这个这种排序的容器在工作的过程中肯定也要对这个容器里面的元素进行 比较大小，交换位置等等操作。那因此说呢，经常的，我们放入容器里面的对象，它所属的类我们往往会需要重载==和<运算符，以便这些算法对这个容器里面的元素进行判断相等或者判断比大小，会用得到这两个运算符。
- **那下面我们就说说这个顺序容器**。顺序容器的特点就是说这个容器里面的元素并没有排序，那元素的插入位置同元素的值无关。不管这个元素的值是不是大还是小，你想让它插入到哪个位置你就能让它插入在哪个位置, 顺序容器有三种，它们是vector,deque和list。
  - 我们先来看看vector。vector它在头文件<vector>里面来声明的。我们要使用它就得包含这个头文件。**vector呢它称为向量，实际上它就是动态数组， 那既然是个数组，它的元素在内存中就是连续存放的。**它是动态数组的意思就是说它的数组的元素的个数可以动态地变化。我们知道数组呢，它随机存取任何元素肯定都是在常数时间完成，为什么呢？因为你只要给一个元素的下标，那在我们已经知道了数组首地址的情况下，根据下标要取出那个元素是很容易的。我们只需要在首地址上面再加一个下标的这种偏移量，就能够算出比如下标位为i的那个元素的地址。然后我们马上就能访问到下标为i的这个元素，所以随机存取任何元素是在常数时间完成。这个vector呢 在尾部增删元素会具有较佳的性能，这里所说的较佳性能它的意思是大多数情况下在常数时间 就能够完成在尾部增删元素，但是在某些特殊的情况下这个增删的操作就无法在常数时间完成，就需要 O(n)这么多的时间。为什么呢？因为这个vector我们知道它是动态数组，所以它里面肯定有动态分配的存储空间用来存放数组的元素。那vector内部在实现的时候这个存储空间往往会预先多分配一些，比方说你这个vector元素里面只有10个元素的情况下，vector也会实现分配比如说30个元素的， 32个元素的那么多的空间。这样做的好处就是你要往里头加第11个元素，加第12个元素一直加到第32个元素的时候 在尾部添加元素都只需就直接把元素加进去就行了。存储空间不需要重新分配。那你要加到第33个元素的时候，这个时候存储空间不够了，那此时就必须重新分配存储空间，把那个原来的32个元素拷贝过来然后再在尾巴加新的这个元素。那么我们就知道，在不需要重新分配存储空间的情况下往尾部添加元素就直接加进去，所以时间是常数的。那要重新分配存储空间了，那你要把老的内容还要拷过来，这个时候时间就不是常数的。 那时间是什么呢？就是O（n）了，因为它跟你原来有多少个元素是有关系的。由于vector总是提前多分配一些存储空间，因此说在大部分情况下我们往尾部添加这个元素或者删除元素的时候 那是不需要重新分配存储空间。因此是时间复杂度就是常数，只有在少数情况下，要分配存储空间了， 这个时间才会变成O（n）的。那这个vector你在中间或者说在头部插入或者删除一个元素，时间复杂度是怎么样的呢？这个很容易想出来，假设你在这个位置要删除掉它， 那你就会必须要把后面这些元素全部都往前移对不对？那就是时间复杂度肯定不是常数的， 而是跟你后面有多少个元素有关系。所以这个复杂度是O(n)的。包括你在前面的位置你要插入一个元素，那你肯定要把这些 已有的元素全部都要往后移，然后空出一个位置再插入新的元素。这个复杂度当然也不是常数，也是O（n）的。所以vector在中间或者说头部插入或删除元素，复杂度都是O-N的，在尾端增删元大部分情况下常-时间是常数的。那说到这我就要提醒同学们，那就我们学习STL里面的容器和算法不但要知道这些容器和算法完成什么样的功能以及如何去使用它，我们还必须要了解在这些容器和算法进行的各种操作它的时间复杂度是怎样的。一个算法运行起来它的时间是怎样的。 一个容器上面的某一种操作时间复杂度是怎样的。这我们都需要了解，否则我们写出来的成绩就会显得效率很低。因为你滥用了某一种时间复杂度比较高的这个操作。
  - 下面我们再来看这个deque。 Deque呢它也是顺序容器。那**deque它事实上是双向队列**。 元素在内存应该也是连续存放的。这一点跟动态数组有点相似。它跟vector的差别在什么地方呢？ 这共同点是它和vector一样随机存取任何元素都能在常数时间完成，但这个常数要比较大一些，也就是说 随机存取元素虽然能在常数时间完成，但这个速度要比vector要慢。但vector比但这个deque比vector明显的优点在于在deque的两端增删元素都会具有较佳的性能。所谓较佳的性能 就是前面讲的大部分情况下这个时间是常数的。那deque是如何做到这一点的呢？那我们看假设这是一个deque。 这在内存里面连续的这个9个单元。那对于deque来说它是双向队列，它会有一个队头的指针和一个队尾的指针。那-那这个deque里面的元素就位于队头队尾指针之间。那假设队头指向的元素是有效的。队尾指向的那个单元呢是空的，队尾指向的那个单元的前一个是最后一个队列的有效元素。 那它是双端队列，在两边增删元素，时间复杂度大多数情况下都是常数的。那只有需要重新分配存储空间的时候才-才会变成O-N的。因为要把老的那种拷贝过来。那为什么大多数情况下复杂度 是这个常数的呢？我们想象假设我们要在头部加一个人数，那我实际上就把元素放在这，然后我把这个头部的指针移动到这就行了，这个时候我们就添加了一个元素了。那我要在头部删除一个元素很简单。 我就把这个元素去掉，然后呢我把头指针移到这，实际上把头指针移到这就意味着把这个头部的元素已经删掉了。这其他存储空间并没有发生变化，只是移动一下头指针的时间呢就是常数的。那在尾部增删元素也是一样的。比如说你要把这个尾数元素删掉。 那你实际上就直接把尾指针移到这，就意味着刚才删掉了一个元素。那增加也是相同的。所以呢在 大多数情况下deque里面增删元素在双端增删元素都是具有 常数时间就能够完成的，除非这个deque里面的存储空间都已经占满了，这个时候你要往里头添加元素就得重新分配存储空间。 那当然时间复杂度就是O-N的了。但是为什么deque随机存取任何元素 它的这个常数时间会慢于这个vector呢？那我们来看看这个道理。就是这个deque添加元素有可能是这样一种情况。就原来队头指向的这个元素是a0。然后我们加了a1，a2，a3，a4，a5，a6。 加完a6以后呢就到达了这一片连续存储空间的末尾了。这个时候还可以往里头加，怎么加呀？ 就是我倒过来把a7放在这个存储空间开头的位置，但是我可以把这个-这个队尾指针放在这。这并没有矛盾对吧。 这个是队头在这，顺着队头一直走到队尾，顺着这个队头一直走到存储空间的末尾，然后再倒回来往前走一个。 这是下一个元素的位置。这是符合逻辑的。不会有任何矛盾。那-那么在这种情况下，我们要随机访-存取 任何元素，也就是说我给一个下标，你就得算出这个元素的地址，那怎么算啊？当然我们用这个下标去加这个head 的对吧？但是加head的-光加在head上不够，那么有可能发生加-你这个下标加上head了以后 就超过了这个存储空间的末尾的情况。那如果在发生了超过存储空间的末尾的情况的时候，你又得把这个位置倒到这个 头部来了。就等于说你要减去一个整个存储空间的这个长度，这样看才能把位置倒回到这个头上来。 那这样一个判断是否越-越过了尾巴？并且要回到来前面的这个操作是需要时间的。那vector是没有这种时-这种操作的。 因此说deque在进行随机存取元素的时候它会比vector慢一些。 
  - 下面再来看第三种顺序容器list。list呢它是一个双向链表。 **既然是链表嘛，它们的元素在内存里面当然就是不连续存放的**。 那而且在任何位置增删元素都能够在常数时间内完成。 这里面有一个前提就是你已经找到了那个需要增删元素的位置，在这个情况下增删元素是在常数时间内完成的。 那你不能把寻找要增删位置的这部分时间也算进去。 那-那比方说我在这个双向链表里面要把这个元素删掉，那我要做的操作是什么？ 无谓就是摆一下前面那个元素的指针和后面这个元素的指针，要修改两个指针，然后中间呢要把它delete掉。 那这一部分时间当然就是在常数时间内进行完成对吧。 然后这个list呢它不支持随机存取。 也就是说list里面它并没有一个成员函数。 这个成员函数使得你给一个下标i，说我要访问第i个元素，这个成员函数就返回给你第i个元素的地址。 或者它的内容。list里面不提供这样的成员函数。那你如果是自己就是要访问第i个元素呢，你怎么办啊？ 你只能从这个链表的头部开始一个一个的往后走，一直走到第i个元素为止。 所以我们说list它不支持随机存取。 
- **那下面呢再简单的介绍一下关联容器**。 关联容器它的特点是元素是排序的。 那既然是排序的，那你插入一个元素的时候，插入完了这个关联容器一样要维持有序。所以你插入的那个元素放在什么位置 是由这个元素的值决定的。不是说你想把它插在哪它就能插在哪。那关联容器把里面的元素都排了序它的目的是什么呢？ 目的当然是为了查找。就是说关联容器在查找的时候具有非常好的性能。我们知道如果你在一个没有排序的序列上面进行查找的话 那你只能顺序查找，从头查-找到尾对吧。就是说时间的话都是O-N的。 但是如果你在一个排好序的序列或者说容器上面进行查找的话呢，你可以用这个类似于折半查找的方法，每次缩小查找范围一半，所以就是说查找的时间复杂度是变成O(log(N))的。 那关联容器呢 它通常以平衡二叉树的方式实现。那什么叫平衡二叉树数据的内容呢我们就不提了。 我们在这个关联容器上面以进行插入一个元素 跟查找一个元素它的时间复杂度都是O(log(N))的。 就都是很快的。那关联容器有四种。 
  - 前两种呢是set和multiset。这两种关联容器 都在头文件set里面。这个set就是集合。在set中呢它不允许有相同的元素。有set和multiset的里面的元素都是按照这个都是排好序的，按照元素本身的值来进行排序。 set里面不允许有相同-相同的元素。但是multiset中呢它允许存在相同的元素。 
  - 那我们再看这个map和multimap它们都在头文件map里面。它这个map和set-set不同之处在于什么呢？ set的里面可以用来放各种各样类型的对象，什么基本类型的变量都可以。但是map里面呢它里面只能放对象，而且这个对象必须有且仅有两个成员变量。这两个成员变量名字还是确定的。一个叫做first，一个叫做second。然后map它是根据first的值对元素进行从小到大的排序，当然这里所说的小和大并不一定就是我们通常认为的比如说一是小这个意思。这个小和大它的含义可以 有多种方式可以自己定义的，这是后话。 那map根据first的值的元素进行排序 并且可以根据first来快速的进行检索。 那等于first就相当于是关键字，那个second呢就相当于是一个关键的值。然后整个map和multimap都用 根据关键值来排序。那这个map和multimap它唯一的不同之处就在于 这个map里面不允许有两个元素。它们的first的成员变量是相等的。 Multimap呢它允许有多个元素。它们的first的成员变量相同。 也就是说在map里面关键值是不能重复的。但是在multimap里面呢关键值是可以重复的。 
- **接下来我们说这个容器适配器**。容-容器适配器有三种。 
  - 第一种是stack。stack呢就是栈。什么叫栈啊？栈是项的有限序列，然后满足序列中被删除、检索和修改的项最近插入的那个序列的项。 也就是说是个栈顶的项。那栈就是后进先出的一种数据结构。 这里就是一个栈。这一块top指向的就是一个的栈井。 那对于一个stack来说你要访问的元素必须是位于top的。你不能访问这里面的元素。你要访问的只能是top的元素。 而且你要进行这个插入操作的时候你也只能把这个元素加在这个栈顶。 这个就是stack，你要删除的元素也只能是位于栈顶的元素。 它是后进先出的。
  - 第二种容器适配器叫做queue， 它是队列，那队列是先进先出的，这个跟前面的双向队列不一样哦，这里是一个单向的队列，也就是说呢， 对于queue来说，插入操作只能在尾部进行，就只能在尾部添加元素。但是删除和检索以及修改都只能在头部进行，就是在队列里面，你能访问的元素一定是位于这个队头的，你可以取它的内容，修改它的内容，把它删掉。 当时你要往这个队列里面添加元素的时候呢，你只能加在队尾。 队尾的元素你也没法访问， 你可能往队尾加入元素，反正队列里面，除了队头元素以外的其它元素你都是没有办法访问的。 你要访问它们，你只能把队头元素弹出去，删掉，让下面的元素变成队头元素以后，你才能访问它。 这个就是queue。
  - 那还有一种容器适配器呢， 叫做priority_queue，它也是一个队列， 但是呢，它是优先级队列，就是说，它内部是维持某种有序的， 然后呢，这个priority_queue能够确保优先级最高的那个元素 总是位于这个队列的头部。也就是说，你访问到的元素，你删除的元素，都一定是优先级最高的那个元素。那至于什么叫优先级最高，这个可以自己定义。 
- 那接下来我们就要看看这个，顺序容器和关联容器中它们都有哪些成员函数可以使用。 这里列出来只是一部分，并不是说全部的啊，这一部分只是顺序容器和关联容器中都有的成员函数。
  - 比如它有一个begin这个成员的函数呢，它返回一个迭代器 这个迭代器指向元素中的第一个元素，就是头一个元素。 
  - 那end呢，它返回自己也是一个迭代器。 这个迭代器指向容器中最后一个元素后面的位置。注意，它不是指向容器中的最后一个元素，它是指向容器中最后一个元素后面的那个位置。 那那个位置实际上是没有东西的，对吧？你想要访问end所指向的这个东西会导致出错的， 
  - 这个rbegin，它返回指向容器中最后一个元素的迭代器。 它指向了最后一个元素。 
  - rend它就返回一个迭代器，这个迭代器呢，指向容器中第一个元素最前面的那个元素的前面的那个位置，实际上rend它也没有指向任何东西。
  - 还有这个erase，可以用它从容器中删除一个或者几个元素。
  - clear就是把容器清空，所有的元素都删除。 
- 前面那页的那些函数是顺序容器和关联容器里边都有的，现在我们再来看看顺序容器里面有哪些常用的成员函数。
  - front，它能够返回容器中第一个元素的引用，注意它返回的引用，而不是迭代器。back，它返回容器中最后一个元素的引用。
  - push_back，这个特别常用，它用来在容器的末尾添加新的元素。pop_back呢，它用来删除容器末尾的元素。
  - erase，是用来删除迭代器某一个迭代器所指向的元素，然后或者用来删除一整个区间。不过在删除以后呢，erase能够返回被删除元素后面的那个元素的迭代器。 
- 那说了半天迭代器，我们就要说说到底迭代器是个什么东西。它是用于访问容器中元素的一种，相当于中介。它用起来像指针一样，归根到底，也是通过指针来实现的。总之，它用于指向顺序容器和关联容器中的元素。它的用法呢，跟指针类似。它也有const和非const两种，就跟指针有const和非const一样。然后通过迭代器就可以读取它指向的元素，这跟指针是一致的，对吧？然后通过非const的迭代器还能修改其指向的元素。那迭代器到底长什么样子呢？那我们可以自己定义一个，定义一个容器类上面的迭代器，它的方法可以是容器类名iterator，然后再变量名。这个迭代器嘛，它一定是具体针对于某一个容器类的。 在一个容器类上面，就会，你可以定义一个迭代器出来。什么是容器类啊？从容器模板实例化出来的类就叫做容器类。这就是定义一个迭代器的方法。有了这个迭代器以后呢，我们就可以访问这个容器类的对象的里面的那个元素了。或者我们也可以写容器类名const_iterator变量名，那这个变量名也是一个迭代器。只不过这个迭代器是常量的迭代器了。那如果我们要访问一个迭代器所指向的元素，怎么办呢？我们写*迭代器 变量名，这就访问它所指向的元素了。这看上去，就跟指针的用法是一样的。那迭代器上面可以执行这个++操作，迭代器一旦执行了++操作，它就会指向容器中的下一个元素。那如果迭代器到达了容器中最后一个元素的后面，那你这个时候再使用它就会出错，因为它已经不指向任何有效的东西了。这种错误就类似于使用NULL或未初始化的指针一样。下面我们看一个迭代器的例子。
  ```C++
  #include <iostream>
  #include <vector>
  using namespace::std;

  int main()
  {
      vector<int> v;    //一个存放int元素的数组，一开始为空
      v.push_back(1);
      v.push_back(2);
      v.push_back(3);
      v.push_back(4);
      vector<int>::const_iterator i;    //常量迭代器
      for(i = v.begin(); i != v.end(); ++i)
          cout << *i << ",";
      cout << endl;
      vector<int>::reverse_iterator r;    //反向迭代器
      for(r = v.begin(); r != v.end(); ++r)
          cout << *r << ",";
      cout << endl;    
      vector<int>::iterator j;    //反向迭代器
      for(j = v.begin(); j != v.end(); ++j)
          *j = 100;
      for(i = v.begin(); i != v.end(); ++i)    
      cout << *i << ",";
      cout << endl;          
      return 0;
  }
  ```
  这个例子里面用到了vector，所以我们include了文件Vector。 vector<int> v这个时候我们就定义了一个vector容器类的对象v，这个v是一个动态的数组。 然后我们这边写的是int，所以这个数组里面的每一个元素都是整形的，那么这个v的类型是什么呢？就是vector<int>。 用这种方法初始化的v呢，它里面什么元素都没有，是一个空的这个数组。 接下来我们往v里面放入一些元素，都是在尾部进行添加。push_back在尾部添加1，然后push_back 2添加 了2，一直push back，最后放进去1,2,3,4四个元素。然后我们在定义这个数组v。怎么做呢？我们可以定义一个迭代器。vector<int> 是容器类名，const_iterator然后i，这个i就是一个迭代器，它是一个常量迭代器，你通过i只能访问它所指向的内容，不能修改它指向的内容。 下面我们通过这个i去便利整个v。怎么便利呢？让i从v.begin开始，v.begin 回忆一下，返回值是什么啊？就是v里面第一个元素的迭代器。那i就一开始让它指向 v里面的第一个元素。然后这个v.end是什么啊？是v里面最后一个元素后面的那个位置。v.end 返回值是一个迭代器，它指向v里面最后一个元素的后面。那我们让这个 迭代器i从v.begin开始，就是从第一个元素的位置开始，不停地通过++，指向下一个元素，一直走到 v.end为止。那只要i还没有到达这个v.end，那i的指向的内容就是有意义的。对吧？它就真实地指向一个 元素。那我们就输出*i。i是迭代器，*i就是这个迭代器所指向的元素。 然后呢再输出一个换行，这个程序还有下面一部分。就是这一部分，这个循环所输出的结果 是什么呢？就是1，2，3,4。它便利了整个数组，输出每一个元素的值。那接着往下走， 然后我们还可以定义一个所谓的反向迭代器。叫做reverse_iterator，它是反向迭代器，它跟那个iterator类型是不兼容的啊。它名字都不一样，所以类型就不兼容。类型的名字不一样，所以当然也不兼容。那对于反向迭代器 来说呢，我们可以让这个r=v.rbegin，那rbegin是什么东西呢？就是v里面 的最后一个元素的迭代器。然后呢只要 r还没有等于v.rend，就让这个r++。对于一个反向迭代器来说，你让它执行++操作， 实际上它就会指向容器里面的前一个元素。反向迭代器跟所谓的正向迭代器不一样的地方。 上一节片子里面看到的是正向迭代器，反向迭代器，你对它进行++操作，它是从后往前走的。那这个rend是指向 的v里面的第一个元素前面的位置，然后这边的r呢，一开始指向的是最后一个元素，那我们现在让这个r 不停地往前走，然后把每一个r都指向的元素都输出，那这个循环输出的结果当然就是4，3，2，1。就是 从这个v后面倒着往前，把所有的元素都打出来。刚才又输出了一个换行。那下面在定义一个这个非常量的迭代器， 我们反正通过j就可以修改它所指向的元素，通过这个j便利整个v，把j指向 每个元素都修改成100，然后再来通过前面的那个i，输出了v里面每一个元素的值，那它 输出的值就是四个100了，因为全部已经被改成100了。 
- STL里面我们常用的迭代器有两种，一种叫双向迭代器，一种叫随机访问迭代器。 那这两种迭代器上面所能进行的操作是不一样的。
  容器 | 容器上的迭代器类型 
  ---------|----------
  vector | 随机访问 
  deque | 随机访问 
  list | 双向 
  set/multiset | 双向 
  map | 双向
  stack | 不支持迭代器 
  queue | 不支持迭代器 
  priority | 不支持迭代器  
  - 对于双向迭代器，我们可以进行哪些操作呢？列在这了，也就是说，如果p和p1都是双向迭代器， 那下面这些表达式都是有定义的，而且有其功能。比如说++p和p++，它都能够使得p指向容器中的下一个元素。而--p和p--呢，它都能够使得p指向容器中的上一个元素，就是往这个容器的头部，开始的位置走。这个*p呢？它能够取p指向的元素，实际上这个表达式，它的返回值是p所指向的那个元素的引用。然后p=p1，当然就是赋值操作了，然后p==p1就是用来判断两个迭代器是不是相等。两个迭代器相等就意味着 它们指向相同的元素，然后两个迭代器可以来用不等号来判断是否不相等。这些都是双向迭代器能够进行地操作。
  - 那随机访问迭代器，它的功能更强。首先所有双向迭代器能做的操作，随机访问迭代器都可以做。此外， 它还能够做一些双向迭代器不能做的操作。比方说我们可以来一个P+=i， 那这个表达式它的效果就是，把p向后移动了i个元素，它修改了p的值。那p -= i呢，它就是把p向前移动了i个元素，就是往容器的头部移动。那这个表达式它是有定义的，这个p+i这个表达式的值也是一个迭代器，这个迭代器呢，它指向p后面的 第i个元素。那p-i呢，这个表达式的值自然就指向了p前面的第i个元素。 还有，p[i]，也是有定义的，显然这个中括号是经过重载的。p[i]这个表达式的值是什么呢？ 它的值是p后面第i元素的引用。注意这个表达式的值不再是迭在一起了，而是以p后面第i元素的引用。 然后我们看，对于两个随机访问迭代器来说，我们可以用<，≤，≥ 进行 比较。那这个两个随机访问迭代器，p<p1，到底代表什么意思呢？ 那就是说p所指向的这个元素，它在p1所指向 的这个元素的前面。这就是p<p1的含义了。 
## 2. STL-概述（续）
- 那个STL上面不同容器里面的那个迭代器，它的种类是不一样的。嗯，对于这个vector和deque来说 它上面的迭代器都是随机访问迭代器，也就是说vector 和deque支持你给一个下标 它马上就能取到这个下标的人数，这种操作. list，还有这个关联容器，它们上面的迭代器都是双向迭代器，而不是随机访问迭代器 而不是随机访问迭代器，所以，嗯，这5种东西上面都不支持随机访问，你没法 调用一个成员函数，说我要访问第二个元素，马上就拿到第二个元素，不行 你要访问第二个元素呢，在这5种容器上面，你都得自己写一段代码 嗯，从这个容器的头一个元素一直往后走，走到第二个元素。那至于容器适配器， 它上面根本就没有迭代器，因为容器适配器嘛，并不是说能访问中间的元素，能访问的都是位于什么站顶啊，队头的元素 它不能便利整个容器，除非把所有元素都删掉了 每个元素才能被访问到，所以这里根本不需要迭代器，因为能被访问的元素都是位于站顶、队头这样的位置的 那要注意了，有的算法，比方说sort，还有binary search 它需要通过随机访问迭代器，来访问容器中的元素，注意，这个排序和折半查找，我们知道 它需要在容器里面的各个元素之间作比较大范围跳跃， 所以它需要随机访问迭代器的支持 那对于这样的算法来说，list和关联容器就不支持这些算法了 就是说，你不能用一个sort去对一个list进行排序 。当然，你更不能用它来对关联容器进行排序，因为关联容器已经排好序了 还有，你不能，嗯，用binary search去在关联容器和list上面进行查找 因为，这两个算法它都要求随机访问迭代器的支持，而我们这些list，set/multiset, map/multimap 上面的迭代器都是双向迭代器，而不是随机访问迭代器 所以这些容器，list以及关联容器就不支持sort和binary search。
- 那这个vector上面的迭代器它是随机访问迭代器 那我们遍历vector就可以用下面几种方法来做，对于deque也是这样的 
  ```C++
  //下面程序中，每个循环演示了一种做法
  #include <iostream>
  #include <vector>
  using namespace::std;

  int main()
  {
      vector<int> v(100);                   //v被初始化为有100个元素
      for(int i = 0; i < v.size(); ++i)     //size返回元素个数
        cout<< v[i];                        //像普通数组一样使用vector容器
      vector<int>::iterator i;  
      for(i = v.begin(); i != v.end(); ++i) //用！=比较两个迭代器
        cout << *i;
      for(i = v.begin(); i < v.end(); ++i)  //用<比较两个迭代器
        cout << *i;        
      i = v.begin();
      while(i < v.end()) {
        cout << *i;
        i += 2;                             //随机访问迭代器支持"+=整数"的操作
      }
      return 0;
  }
  ```
  这条语句定义了一个vector V 这个V呢是个整型数组，一开始它里面有100个元素，这是它构造函数参数的含义 然后我们就可以 遍历这个V，怎么遍历呢，第一中方式，我们可以通过下标随机访问 就是我们可以通过中括号，这个被重载的运算符，来访问V里面的第i个元素 这个v.size 代表v里面的元素个数 v[i]直接就是V里面下标为i的那个元素了 那我们还可以定义一个常量迭代器，ii，让这个ii从v.begin一直走到v.end 然后把这个ii所指向的元素突出 注意这里我们可以用不等号比较两个迭代器，那由于在vector 上面的迭代器 是随机访问迭代器，那两个随机访问迭代器是可以用小于号进行比较的 所以这个循环我们也可以这样写，在这里用小于号也是没有我问题的 而且由于随机访问迭代器，你可以给它加一个整数 所以我们在遍历vector的时候也可以 隔一个输出，那就是这样ii等于ii加2 或者你写ii加等于2都可以 嗯，让它 这样这个循环就可以间隔一个的把v里面的元素给它输出出来了 加一个整数的操作是随机访问迭代器可以做的，
- 但是双向迭代器就不能做这种操作 
  ```C++
  
  #include <iostream>
  #include <vector>
  using namespace::std;

  int main()
  {
      list<int> v(100);
      list<int>::const_iterator ii;
      //正确的做法
      for(ii = v.begin(); ii != v.end(); ++ii)
        cout << *ii;
      //错误的做法，双向迭代器不支持<,list没有[]成员函数
      for(ii = v.begin(); ii < v.end(); ++ii)
        cout << *ii;
      for(int i = 0; i < v.size(); i++)
        cout << v[i];
      return 0;
  }
  ```
  那对于list 来说，它上面的迭代器是双向迭代器，不是随机访问迭代器 那我们要遍历list，可以怎么做呢。 list<int>v 这是一个list，刚开始它是空的 那我们要遍历这个list，我们可以定义一个list上面的迭代器，它叫ii ii从begin开始，往后走，一直走到end 但这时候你要判断它有没有到达end呢，你就用不等于 你不能在这里用小于号，这是不行的 为什么，因为list上面的迭代器是双向迭代器 双向迭代器是不能用小于号去比较的，这中写法就是错误的 这个位置你这能写不等于，而且这个双向迭代器 不但不支持小于，而且这个list 它也没有中括号成员函数，我们知道 这个list还有关联容器，它不支持随机访问，它没有中括号这种成员函数 所以对于一个list来说，你想要用这种办法去访问它下标为i的那个元素 也是不行的，编译会出错的，你要访问下第i个的元素 你只能自己写一段代码，让一个迭代器从begin开始一直往后走i步，才可以 
- 下面我们来介绍下什么叫算法 前面说了算法就是一个个函数模板，大部分是在algorithm中定义的STL中提供能在各种容器中通用的算法，比如查找，排序等等算法是通过迭代器来操作或者访问容器中的元素的许多算法对容器进行操作，并不见得对整个容器进行操作 它可以只对容器中的某一段，就是中间一个局部区间来进行操作 所以这些算法往往需要两个参数，这两个参数用来指明它所要操作的容器中间的一段 那这两个参数一个就是那一段的起始元素的迭代器 另外一个就是终止元素的，后面一个位置的迭代器 排序查找都是这样，这个后面我们还会细说 然后有的算法会返回一个迭代器 比如说find这个算法，在容器中查找一个元素 并返回一个指向该元素的迭代器 补充一点，像排序和查找算法，作用与某个容器，它并不一定要把整容器排序 或者说一定要在整个容器里进行查找，它可以只把容器中的一小段进行排序 也可以只在容器中的一小段进行查找 然后这个算法可以处理容器 也可以处理普通数组，算法能工作在容器上，也能工作在普通数组上 
- 让我们来看一个算法，find() 以此为例，让大家有一个基本了解，算法是什么样的 find 是顺序查找 它是一个函数模板，它的模板的定义就是这样的 
  ```C++
  template<class InIt, class T>
  InIt find(InIt first, InIt last, const T &val);
  ```
  那不同的编译器的头文件所列出来的find 模板写法会略有不同 这里，我找出来find的模板的声明 注意，它是一个模板，它有两个类型参数，init和t，这个init实际暗示你这个类型参数是一个迭代器 it代表迭代器嘛 然后这里有first 和last，实际上就指明了你要查找的区间 因为find是用来做顺序查找的 那这个val呢，就代表你要查找的值 然后注意一点，就是说算法是有一定功能的 比如说find，通常来说，它就是实现顺序查找的功能 但它只是一个模板，find并不意味着只能实现顺序查找的功能 你用find这个模板能做什么事情，实际上是取决于你的想象力的 并不局限与顺序查找，这个我们后面还会看到类似的例子 总而言之，对于find这个模板来说 它要查找的区间是first 和last 那注意，这区间是左闭右开的区间 就是这个区间里的第一个元素是由first所指向的，这个区间里的最后一个元素是由last所指向的 但是last 所指向的那个元素，并不在查找范围内，左闭右开的区间嘛 然后find是在fist和last区间查找等于val的这个元素 什么叫等于，是用等等号来判断是否相等 然后，这个函数的返回值是一个迭代器，那如果找到了，返回值实际就是一个迭代器 这个迭代器指向被找到的元素 那如果找不到呢，返回值当然也是一个迭代器，而且这个迭代器就等于last 所以我们在调用find的时候，通过返回值 可以判断是不是找到了 具体的办法就是看看返回值是不是等于last，如果等于last就说明找不到，不等于last 就说明找到了。那这顺序查找的时间复杂度是什么样的呢，是ON的 因为它并不要求查找的区间first和last是有序的，那它查找的过程就是从头一直走到尾，所以复杂度就是ON 我们看一个find例子，
  ```C++
  #include <iostream>
  #include <algorithm>
  #include <vector>
  using namespace::std;

  int main()
  {
      int a[10] = {10,20,30,40};
      vector<int> v;
      v.push_back(1);
      v.push_back(2);
      v.push_back(3);
      v.push_back(4);
      vector<int>::iterator p;
      p = find(v.begin(),v.end(),3);        //在v中查找3
      if(p != v.end())
        cout << "1)" << *p << endl;         //输出：3
      p = find(v.begin(),v.end(),9); 
      if(p == v.end())  
        cout << "not found" <<>> endl;      //没有找到
      p = find(v.begin() + 1,v.end() - 1,4);//在2，3这两个元素中查找4
      cout << "2)" << *p << endl;           //输出：4
      int *pp = find(a, a + 4， 20)；
      if(pp == a + 4)
        cout << "not found" <<>> endl;
      else
        cout << "3)" << *pp << endl;        //输出：20
      return 0;
  }
  ```  
  include algorithm 这有一个array，是一个数组，普通数组也可以算容器 这里有个vector<int>，动态数组V，然后我们往V里面放了1，2，3，4，然后在V上面定义了迭代器，vector<int>迭代器p，然后调用find(v.begin(),v.end(),3) 这个是干嘛？就是在整个容器，整个V容器上面去查找3这个元素 呃，然后下面这条语句就判断是不是找到了。 那在1,2,3,4里面找3呢当然是能够 找得到的，对吧？所以说这个时候，呃，P就会指向被找到的那个元素，也就是3 那你输出* p的话，当然输出的结果就是3。 啊，那我们再来看看find这边用到的这个，这个区间 它查找的区间v.begin，v.end，它是左闭右开的，也就是说v.begin 是位于查找区间之内，但是这个呢，v.end不位于查找区间 之内，这是很合理的对吧？因为v.end本来就v里面最后一个元素的后面的那个位子。 也就是说v.end实际上没指向任何有效的元素，那在 find在进行查找的时候，v.end并不位于查找范围之内也就是很合理的。 **那实际在STL的各种算法里面 只要是提到了这个区间，啊这个区间都是左闭右开的。** 再看下面，呃 p等于find v.begin v.end 9，啊，就在V里面去查找9这个元素，v里面有什么啊？是1,2,3,4，那当然就找不到对吧 所以我们看，看到，如果v等于，啊，如果P等于v.end那就说明找不到，这个输出not found，那当然确实会输出not found 找不到9,。然后p等于find v.begin加1 然后v.end减2，啊，就是在v.begin加1到v.end减2这个区间里面去查找 元素1，但是要注意的v.end减2这个，元素实际上并不在查找范围之内。 那我们看到整个容器是1,2,3,4，那v. ，v.begin加1是什么啊？就是2对吧？那v.end减2是什么呢 呃，这个4是v.end减1，3是v.end减2，啊所以v.end减2是3 但是由于v.end减2实际上并不位于查找区间范围之内 也就是说查找区间2,3是个左闭右开的，但真正有效的元素实际上就只有一个2 所以，你在这里面去，嗯，进行查找1的话，啊，实际上是找不到的。 那找不到的话，这个时候P的值会是什么呢？我们说 p的值它会等于这个查找区间的终点，也就是说p的值是 等于一个迭代器它指向什么？指向这个3 那p当然就不等于end了，所以你输出* p的时候呢就会输出3 呃因为这个时候查找区间的终点实际上就是这个，这个3了。 现在再看int* pp等于find array array加4, 20 啊，这个时候我们在一个普通数组里面也能进行，用find进行查找 这个时候数组的名字就是迭代器，因为数组的名字就是int *array这个指针 呃，在这个容器里面进行查找，嗯然后 查找区间好像是从array到array加4，array加4并不位于 查找范围内，在这里面查找20，呃，然后呢，我们就 根据查找的结果输出这个*pp，啊输出的结果呢就是这个 20，因为在这个array里面能找到20，啊，那么array定义的它里面是有20的 
- 那我们知道在这个STL里面啊，这个关联容器内部的元素是从小到大排序的。 然后呢有些算法吧它要求它操作的区间是从小到大排序的，这类算法我们称之为“有序区间算法”。 比如说binary_search折半查找，它就要求查找的那个区间 必须是从小到大排好序的，然后才能进行二分查找 然后呢有些算法它会对区间进行从小到大排序，这称为“排序算法” 比如sort,它就能够把处理的那个区间变成从小到大排好序。 还有一些其它算法也会用到这个什么大小的这个这个概念 但要注意了我这里所说的从小到大可不见得就是什么1一定是小于2这么简单 这个大和小的定义程序员可以自己去设定的 比方说程序员可以规定，哎我在这个呃，呃，容器里面 从小到，这容器里虽然放的都是整数，但我这个从小到大的意思是 按照个位数从小到大排序，也就是说这两个整数谁的个位数小谁就算小 这就叫做自定义大小的这个概念 呃也就是说前面这里说的所有的从小到大，从小到大啊，它的具体的含义都是可以发生变化的 对于两个整数你也可以说绝对值大的就算是小，绝对值小的就算是大，你也可以这么定义，没有问题的。 但是呢在缺省的情况下，就是你没有对这个大小给出任何 自己定义的情况下，在缺省的情况下，那么下面三个说法是等价的 呃，如果我们说x比y小，这个说法就等价于表达式x小于y为真 这也等价于y比x大。哦，这三个说法是等价的。 在缺省的你没有自己定义大小的概念的这个情况下 以下三个表达，以下三个说法等价，然后在STL里面x和y相等也不见得就是我们那么简单理解的相等的概念。 啊，就有的时候x和y相等，它等价于表达式x等等y为真 在什么情况下，嗯，是这样子的呢？ 比如说我们在没有经过排序的区间上进行的算法，比如顺序查找find，我们说在一个区间里面 查找某一个元素，那你要查找的那个，呃查找某一个值，那你要查找那个元素肯定要等于这个值，对吧 那这个时候这个等于就是用等等这个运算符来进行判断的 但有的时候呢x和y相等 它就不再等价与上面的这个，呃，x等等y为真了，它跟这个等等 这个，呃，运算没有关系 有的时候x和y相等，它等价于下面这个描述 就是x小于y和y小于x同时为假，啊 注意这里的小于呢，它还未必就是小于号的那个意义，在这里的小于 也是可以自定义的，反正你在自定义的，就是说有些情况下你自定义了 小于的含义，然后在然后呢x和y相等，它就变成x .如果 小于y，和y小于y x同时都不成立，那我们就认为x和y是相等的 哪怕x等等y这个表达式实际上它的访问值是false，我们也认为 x和y是相等的，在什么情况下会是这样呢？啊就是 对有序区间上，比如说birary_search来说 x和y相等，就是上述的这个含义。 还有对于关联容器自身的成员函数find来说，x和y相等，也是这里所说的含义。 呃，那关联容器就是用来查找的，查找速度快，但是你不能用find算法 或者是什么其他的birary_search算法去查找关联容器，关联容器它自身带有成员函数find 可以用来进行查找。 那下面我们就看一个这个关于这个“相等”的概念 的这个这个演示，啊，
  ```C++
  #include <iostream>
  #include <algorithm>
  using namespace::std;

  class A {
    private:
      int v;
    public:
      A(int n):v(n) {}
      bool operator<(const A &a2) const
      {
        cout << v << "<" << a2.v << "?" << endl;
        return false;                             //返回false意味着任何两个classA的对象，一个都不会小于另外一个 
                                                  //任意两个classA的对象x,y，x小于y总是不成立的，y小于x也总是不成立的
      }
      bool operator==(const A &a2) const
      {
        cout << v << "==" << a2.v << "?" << endl;
        return v == a2.v;
      }      
  };

  int main()
  {
      A a[] = {A(1),A(2),A(3),A(4),A(5)};
      cout << binary_search(a,a+4,A(9));          //折半查找
      return 0;
  }
  ```  
  我们这里有个classA 呃，它里面有成员变量v,然后呢在这里我们 呃，重载了小于运算符，规定了，呃，两个classA 对象比大小的规则，在这运算符里面呢我们先输出了待比较的两个元素的这个 呃，这v的值，然后返回false,返回false意味着什么啊 意味着任何两个classA的对象，一个都不会小于另外一个 任意两个classA的对象x,y，x小于y总是不成立的，y小于x也总是不成立的。 然后我们也定义了一个，一个等等号，呃，它它用来判断两个classA的对象是否相等 呃，呃那是否相等的这个规则比较传统，啊，就是两个的V相等，它就是相等了。 好了，我们在定义了这种小于和等于这种规则的前提下，我们看看用birary_search会发生什么事情 注意，再强调一遍，这里的小于被定义成任何两个classA的对象 一个都不会小于另外一个，好我们在main里面，啊 定义了这样一个classA的数组，呃它们是A1，A2，A3，A4，A5 然后我们用birary_search在这个数组里面去查找A9这个元素 是二分查找 那你想是不是应该能找得到呢？这是，数组里面是1,2,3,4,5,你要查找的是A9，当然应该找不到，对吧 也就是说，birary_search这个函数调用它的返回值应该是0，是false才对。 但实际上的结果呢却是毁三观的，呃它的返回值是1 它告诉你在A1到A5这里面找到了A9 为什么会是这样的结果呢？我们看到输出结果前面还有，前面这四行 也就是说，我们看到在这个程序运行的过程中 呃，程序运行的过程中呢这个，呃，等等号并没有 被调用，这个小于号被多次调用 那也就是说，呃，**这个birary_search在执行的过程中，它判断呃这个数组里面有没有哪一个元素的值跟A9相等，它用的不是等等号 用的是小于号 这就是我们前面所说的那个相等的概念了，就是说如果x小于y不成立，y小于x也不成立 那就认为x和y相等 根据x等等y没有关系，这就是birary_search工作的这个原理**。 所以我们看到，呃，birary_search，birary_search首先 看看3小于9是不是成立？结果是不成立，不成立的话 birary_search就应该，就认为我应该在，呃3前面那一半去找，所以它又去找 2小于9是不是成立？又不成立，那它认为应该再到前面一半去找，于是就 判断1小于9是不是成立，还是不成立，那这时候已经不能再向前啦，已经没有啦 所以，birary_search就判断9小于1是不是成立？也不成立，好了，那1小于9不成立，9小于1也不成立 那birary_search就认为1和9是相等的，所以它就认为，呃找到了A9，于此输出一个它的返回值就是1 看上去是不是很奇怪，但它就是这么工作的。 
## 3. 顺序容器Vector
- 大家好，在这一小节中我们来看一下STL的第一个容器Vector。 可能有同学会注意到今天我们这个课程的背景呢有一点点不一样 这是因为学校呢新给我们大家添置了一个叫做，嗯，多重背景的这样一个背景幕 那么一共有蓝绿黑白四种颜色 那么我们这次课呢，就选择这种青葱模式。 其实很多同学在了解了Vector的使用之后呢 都会感慨说：哎呀，这才是我想要的那个数组 那么具体它是一个怎么样的数组呢？我们说Vector它本身提供的是一种叫做可编程的动态数组。 什么叫做动态可编程的数组呢？ 这就是针对我们之前自己去写的一些静态的数组，比方说我们定义了一个int a[100] ，我们定义了一个数组a它包含了100个元素，你可以从a[0[一直访问到a[99] 但是有些时候，往往程序就偏偏需要呢第100个 101个，也就说额外超出我们自己定义的数组范围大小的那些元素 那么在这个时候，我们就不可以轻易对静态定义的这些数组呢 直接进行删改或者说直接来进行扩充 那么这时候我们就迫切地需要说:哎呀，最好能有一个所谓可以自动来调节长短的动态数组，就可以解决大问题 那么Vector就是你所需要的那个数组。 当然呢，我们去使用Vector的时候，必须要去引入这样的一个头文件。 之前呢郭老师已经给大家介绍了关于迭代器的概念 那么作用在Vector这个容器上呢，这个迭代器呢，我们说它是一个叫做随机访问的迭代器 因为它是随机访问的，所以呢我们可以根据下标随机地访问某一个元素 那么由于是随机访问迭代器，所以这种按下标随机 访问某个元素的时间呢，通常都是为常数级别的。 而且呢我们在Vector这个容器的尾部 如果去添加一些额外的一些元素进来的话呢，那么它的速度也通常是比较快的 因为我们针对Vector这个容器呢，一般来说即便去存放一个元素 也会需要去开辟一个比方说32个元素大小这样的一块空间 因此呢，你如果需要在这个基础上来进行扩充的话，那么只需要直接去添加相应的元素就可以了 当然如果你增加的内容非常的多，超出了我预先预留的这样的一些额外的空间的话 那么通常我们需要去分配一个新的空间出来，然后把已有的数据呢直接拷贝到新的数据上 新的空间上来进行扩充，那么这样的过程呢，可能就会速度会慢一些 所以我们说呢，通常在尾部添加这个元素的速度呢是比较快的。 但是要注意我们对于Vector来讲，因为它本身就是一个数组 如果我在这个数组的中间去插入某一个元素的话，那么这个的插入速度呢实际上还是非常慢的，因为这个过程呢他并不是 一个固定的时间，而是跟你本身数组的大小是有关系的 因为你需要去插入相应的元素并且把其后续的所有元素呢进行一下移动。 另外呢，我们在这个Vector这个容器上呢 可以使用后续要介绍的所有的STL的算法 所以我们说整个这个Vector的容器呢提供了非常强大的功能 那么对于Vector来讲呢，它包含了一系列的成员函数 那么首先呢大家会想到说我们实际上会要去利用构造函数 来对这个Vector容器呢进行初始化 那么初始，它这个初始化的构造函数呢，主要是包含了这样的几种 首先呢，你可以去使用这样的一个无参的构造函数 那么无参的构造函数呢，就是将这个容器呢直接初始化为空 此外呢，也可以去传递一个 整形的这个参数来作为这个 定义初始化的这样的一个，N个元素的一个个数，啊也就是说 我把这个容器呢初始化为包含n个元素的这样的一个数组 那么同时呢，你也可以去传递两个参数，第一个参数还是int n，那么第二个参数呢，是一个const T类型的一个val的一个值 那么这实际上呢还是说假定呢我的这个 数组中间的元素的类型是T 那么通过这样的一个构造函数之后呢，我们会将整个容器初始化为包含了n个元素，并且每个元素值都是相应的这个val这个值所对应的值，那么这样的一个容器呢就被初始化为 n个元素且每个元素都是val的这样的一个数组。 最后呢,我们还可以利用传递两个迭代器的值 那么这个迭代器本身呢它实际上应该对应的是 另外一个容器的一个起始的迭代器和中止的迭代器 也就是说我们将这个容器初始化为另外一个容器上的 从迭代器first到迭代器last所指向的那一段区间上的内容。 注意这个区间呢，它是一个前闭后开的一个区间 所以呢我们可以利用这样的一个构造函数呢，直接把其他的 容器中间的内容啊初始化到我自身这个容器中间来。 那么除了这个相应的一系列构造函数之外呢，我们还有一些常用的函数 比方说我们刚才提到说对于Vector这个容器，你在尾部来进行一系列的操作呢 实际上速度是会非常快的而且非常的便捷，所以相应地我们就有了一个 在尾部去删除相应元素的函数叫做pop_back，啊，pop把它pop出去 那么同时呢我们还有一个去把相应的值添加进来的，这样的一个函数叫做push_back 我们把相应希望能够添加到容器末尾的这个元素呢，把它push进来 另外呢我们可以直接去调用size这样一个函数，去获取这个容器 当中包含元素的个数，另外呢我们还可以去利用font back这两个函数去获取元素这个容器当中 第一个元素以及最后一个元素相应的引用 
- 那么说了这么多，我们来具体看看这个Vector的这个容器呢是怎么样使用的。 这里给出了一个小的程序 
  ```C++
  #include <iostream>
  #include <vector>
  using namespace::std;

  int main()
  {
      int i;
      int a[5] = {1,2,3,4,5};
      vector<int> v(5);
      cout << v.end() - v.begin() << endl;          //输出：5
      for(i = 0; i < v.size(); i++)
        v[i] = i;
      v.at(4) = 100;
      for(i = 0; i < v.size(); i++)
        cout << v[i] << ",";                        //输出：0，1，2，3，100
      cout << endl;
      vector<int> v2(a,a+5);                        //构造函数
      v2.insert(v2.begin() + 2, 13);                //在 begin() + 2 位置插入13
      for(i = 0; i < v2.size(); i++)
        cout << v2.at(i) << ",";                    //输出：1，2，13，3，4，5     
      return 0;
  }
  ```  
  我们可以看到说我们在这个小程序当中呢，因为要使用Vector，所以我们要引入 Vector这样的一个头文件。 那我们接着呢，就来具体看一下如何去使用Vector这样的一个动态数组。 我们在这个例1这个例子当中呢，简单地 解释了一下如何使用Vector来进行一些动态数组的操作 我们看到呢我们在程序当中首先定义了一个静态数组a 这个数组它包含了5个元素，这5个元素呢分别被初始化为了1、2、3、4、5 此外呢，我们利用Vector这样的一个容器去定义了一个动态数组v 这个元这个v呢，它中间的每一个元素都是int型的 此外呢，我们通过刚才介绍的第二种构造函数 来对这个v呢进行初始化，我们通过传递 一个int型的量 参数5来初始化说，我的这个v容器当中呢包含了5个元素 那么有了这个定义好的v之后呢，我们实际上就可以对这个数组 呃，本身或者说对于这个容器来讲呢进行一系列的操作了 我们可以让其返回相应首元素的迭代器v.begin 以及v这个数组 最后那个元素之后元素相应对应的这个迭代器。 我们看到说我们强调end这个函数呢，它返回的是我的这个 v当中最后这个元素之后 那个位置的迭代器，啊，所以呢我们可以 去返回相应这样两个迭代器之后，因为本身作用在 Vector上面呢这个迭代器呢，它是随机访问迭代器 所以呢,这两个迭代器是可以进行相减的，啊，有了相减这个操作我们就可以把它对应的值呢size出来 实际上就会包含整个这个 容器的大小，也就是相应的5，在这个例子当中。 那么除此之外呢我们也可以for循环 去让它对整个容器中间的每一个元素来进行赋值 那么要注意就是我们可以利用 这个方括号所对应的这个下标访问来访问容器当中的每一个元素。 当然我们也可以 去判断说i呢始终是要小于v.size 也就是说要不能超过我们定义的这个容器的这个元素个数。 除此之外呢我们还可以利用v.at这个函数 来访问相应的一个元素，就这个容器当中的某个元素 在这个例子当中呢我们访问的就是第5个元素 我们把v当中的这个第5个元素呢赋值为了100 那么有了上述的这样的一系列赋值之后呢 我们就可以相应的把v中间的每个元素呢size出来 除此之外呢我们还可以利用其它的构造函数来初始化相应的这个 我们用vector定义的这个动态数组。比方说我们利用 刚才介绍的第四种构造函数 通过去定义一个容器的起始的位置以及它末尾的位置 来初始化相应我们新定义出来的这样的一个 vector v2。我们这里就利用了a这个数组 把a这个数组当中的这样的一段内容直接初始化给v2。 那么，有定义好这样的一个v2这样的一个动态数组之后呢， 我们可以做的事儿是什么呢？我们可以去调用insert这个函数 我们可以直接把相应希望插入的这个值呢，插入到我们指定的位置上。 也就说，我们现在呢希望能够在begin()+2的位置上插入13这个值 那么我们就首先在insert第一个参数当中呢，去传递我们希望插入的位置。 之后的第二个参数呢，去传递希望插入的具体的这个值。 通过这样的一个方式，调用这一个insert函数就可以实现我们之前在静态数组 当中所需要去进行一系列这个插入拷贝这样的一个过程的 繁琐的过程。只需要去调用这一个函数就可以完成了 那么我们就把13这个值相应地插到了v2这个数组当中。 那么有了这样的一个插入之后呢，我们来看一下最后这个 v2的形式。是吧？我们刚看到说我们首先做了这个v.end()- begin()，我们得到一个5这样的一个值。那么我们通过一系列的这个赋值之后呢，就得到了这样0,1,2,3 100.我们最后把这个 at(4)这样的一个值，元素呢赋值为了100。最后呢，我们需要做的事儿呢就是 我们把原先的这个 a呢初始化给了v2，所以呢v2一开始呢是1,2 3,4,5这样的五个值。之后呢，我们希望把13 值呢插入到从begin()+2的位置上。比如说，我们希望把13呢插入到了这里 所以呢我们如果在这时候 所以呢如果我们在这时候cout v2的话， 我们会看到呢相应的这个输出就是1,2,13,3,4,5 
- 那么除了去利用vector去构建一个一维的动态数组之外呢，实际上vector也可以去形成一个二维的动态数组。 那么其实思路会非常的简单，就说我们在vector<int>这个类型的参数设置的时候呢，把它再次去使用一个vector<int>这样的一个容器来定义就可以。比如说我们这里只要嵌套地使用两个vector就可以实现一个二维动态数组的一个实现。那么对于这里头举得这个例子，vector v来讲的话呢，那么它当中包含了3个元素。那么每一个元素对应的呢又是一个vector<int>这样的一个容器 我们具体来看一下。 
  ```C++
  //实现一个二维动态数组
  #include <iostream>
  #include <vector>
  using namespace::std;

  int main()
  {
      vector<vector<int>> v(3);
      for(int i = 0; i < v.size; ++1)
        for(int j = 0; j < 4; ++j)
          v[i].push_back(j);
      for(int i = 0; i < v.size; ++1){
        for(int j = 0; j < v[i].size(); ++j)
          cout << v[i][j] << "  "; 
        cout << endl; 
      }      
      return 0;
  }
  ```  
  我们利用这样的一个二维动态数组的一个定义，比如说利用vector<int>这样的一个容器 作为类型来初始化每一个 v中间相应的元素的类型。那么有了这样的一个定义之后呢，我们需要做的事儿， 如果我们希望能够去把相应的这个值都放到我们对应的这个二维数组当中呢，我们就可以写 这么一个二重的一个for循环。然后在 循环体当中呢，去把相应我们希望放在这个vi中间的内容呢把它push back进去 那么有了这样的一个过程之后呢，我们把每一个对应的值都把它放进去 之后我们要做的事儿呢，我们把这个j都放进去之后，我们要做的事儿呢 就是相应地把它输出出来，然后我们会看到呢，我们这个程序呢实际上 就可以完成把这个0,1,2,3,4对应每一个值 相应地赋给这个v(3)，其中每一个元素中间的值也可以把它相应地输出出来就可以了。 所以这就是一个最简单的一个二维动态数组的一个实现 
## 4. List和Deque
- 大家好，在这一小节中，我们来进一步了解一下STL当中顺序容器中间的list和deque。 那么对于 list这样的一个容器呢，它实际上就是我们在数据结构当中非常熟悉的双向链表。 所谓双向链表呢，就是说这个链表当中的每一个元素它都会包含一个指针，指向其后续的元，元素 此外呢，它还包含一个指针去指向其前一个元素。 那么有了这样一个list之后呢，我们会看到我们在list 当中的任何位置插入和删除呢，都是常数时间的。 比方说，我们希望在a[i] 这个元素和a[i+1]这个元素之间呢插入一个新的元素s 那么我们要做的事呢就是去使得ai和ai+1这两个指针呢发生一下改变 使得它们的指向呢都变成指向s就可以了，所以我们说这个插入和删除的过程呢 是非常便捷的。 那么要注意就是我们在list这个容器当中呢 是不可以根据下标来进行随机存储元素的。 那么作用在list这个容器上的迭代器呢，它不是随机访问的。 最后呢我们说，实际上所有的顺序容器 所具有的那些函数呢，在list当中呢都是可以使用的。 对于list来讲呢，它还有几个比较重要的成员函数，比方说我们之前有提到的这个push，它push的是谁呢？它push的是front也就是说我在链表的最前面插入一个元素 同时呢，我也可以去删除链表的，也就是说去删除这个表头，啊去删除最前面的这个元素。 此外呢，它还有单独的一个sort函数来进行排序，那么注意因为本身list呢它 不支持这个随机访问迭代器，因此呢它不能用 STL算法本身的那个sort函数，它是自身自带的。 此外呢，我们还有这个remove 这个函数，那么它主要是用来删除和指定值相同的元素。 那么unique呢是删除所有和前一个元素相同的元素，也就是删除那些 具有一样值的元素。 那么此外呢，你可以去merge，也就是说我们把两个链表merge在一起 那么注意就是我们要清空其中被合并的那个链表。 此外呢我们也可以去颠倒链表，啊我们经常会需要说我们把这个链表呢要逆序一下，那么自己写的程序呢就会非常的复杂。那么在list这个容器上呢 我们只需要去调用reverse这样一个成员函数，就可以简单地实现这个操作了。 最后呢，我还可以去splice,也就是说我们在指定的位置上呢 去插入另外一个链表当中的一个或者多个元素。 那么注意就是我们需要在插入之后呢把，把它相应在另外一个链表当中的元素呢那就删除掉。 我们来看一下对于list这个容器来讲呢，因为本身的迭代器是不支持这个完全地这个随机访问的 所以我们说呢，在标准库中间的sort函数呢对它呢是不能使用的。 那么我们list自己本身呢是有一个成员函数的，我们可以呢对于 相应的这个list对应的这个 容器这个链表来讲呢，我们可以用自己定义的这个 compare的函数，也可以去利用我们自带的这个无参的版本，这个sort函数。 注意，这个版本，这个无参的这个sort函数呢，它是由小到大来进行排序的。 那么list本身这个容器呢，它本身只能使用这个叫做双向迭代器，啊，因为它既要去执行这个当前元素指向下一个元素，或者是当前的元素指向上一个元素，所以这个迭代器本身呢是双向的。 那么它呢因为是双向迭代器，而不是随机的这种迭代器呢，所以它不能支持这个比大小 这个比较运算符，或者是这个利用方括号来进行下标访问的运算符 以及随机的移动。啊也就是说所谓随机移动就是说我们不能利用list迭代器来加2 做这样的一个操作来进行相应的访问。 - 那么list这样的一个容器呢，它具体是怎么样使用的呢？我们来看一个例子，啊 
  ```C++
  //实现一个二维动态数组
  #include <iostream>
  #include <vector>
  #include <list>
  #include<algorithm>
  using namespace::std;

  class A {
    private:
      int n;
    public:
      A(int n_):n(n_) {}
      friend bool operator<(const A &a1, const A &a2);
      friend bool operator==(const A &a1, const A &a2);
      friend ostream &operator<<(ostream &a1, const A &a);
  };

  bool operator<(const A &a1, const A &a2)
  {
    return a1.n < a2.n;
  }

  bool operator==(const A &a1, const A &a2)
  {
    return a1.n == a2.n;
  }

  ostream &operator<<(ostream &o, const A &a)
  {
    o << a.n;
    return o;
  }

  //定义函数模板PrintList,打印列表中的对象
  template<class T>
  void PrintList(const list<T> &lst)
  {
    int tmp = lst.size();
    if(tmp > 0) {
      typename list<T>::const_iterator i;           //typename用来说明list<T>::const_iterator是个类型，在VS中不写也可以
      i = lst.begin();
      for(i = lst.begin(); i  != lst.end(); i++)    //与其他顺序容器不同，list容器只能使用双向迭代器，因此不支持大于或小于比较运算符，[]运算符和随机移动
        cout << *i << ",";
    }
  }

  int main()
  {
    list<A> lst1,lst2;

    lst1.push_back(1);
    lst1.push_back(3);
    lst1.push_back(2);
    lst1.push_back(4);
    lst1.push_back(2);  
    
    lst2.push_back(10); 
    lst2.push_front(20);
    lst2.push_back(30);
    lst2.push_back(30);
    lst2.push_back(30);
    lst2.push_front(40);    
    lst2.push_back(40);

    cout << "1)";PrintList(lst1);cout<< endl;       //1，3，2，4，2，
    cout << "2)";PrintList(lst2);cout<< endl;       //40，20，10，30，30，30，40， 
    lst2.sort();                                    //list容器的sort函数，从小到大排序
    cout << "3)";PrintList(lst2);cout<< endl;       //10，20，30，30，30，40，40  
    lst2.pop_front();
    cout << "4)";PrintList(lst2);cout<< endl;       //20，30，30，30，40，40
    lst1.remove(2);                                 //删除所有和A(2)相等的元素
    cout << "5)";PrintList(lst1);cout<< endl;       //1，3，4，
    lst2.unique();                                  //删除所有和前一个元素相等的元素
    cout << "6)";PrintList(lst2);cout<< endl;       //20,30,40,
    lst1.merge(lst2);                               //合并lst2到lst1并清空lst2
    cout << "7)";PrintList(lst1);cout<< endl;       //1,3,4,20,30,40,
    cout << "8)";PrintList(lst2);cout<< endl;       //空
    lst1.reverse();
    cout << "9)";PrintList(lst1);cout<< endl;       //40,30,20,4,3,1,
    lst2.push_back(100);
    lst2.push_back(200);
    lst2.push_back(300);
    lst2.push_back(400);
    cout << "10)";PrintList(lst2);cout<< endl;      //100,200,300,400,    
    list<A>::iterator p1,p2,p3;
    p1 = find(lst1.begin(),lst1.end(),3);           //4
    p2 = find(lst2.begin(),lst2.end(),200);         //1
    p3 = find(lst2.begin(),lst2.end(),400);         //3
    lst1.splice(p1,lst2,p2,p3);                     //将[p2,p3)插入p1之前，并从lst2中删除[p2,p3)
    cout << "11)";PrintList(lst1);cout<< endl;      //40,30,20,4,200,300,3,1,
    cout << "12)";PrintList(lst2);cout<< endl;      //100,400,

    return 0;
  }
  ```  
  我们在这个类A里头呢，重载了这个相应的这个operator这个小于号以及这个 呃 判断是否相等以及这个，呃，左移的符号，是吧 我们把这三个相应的这个运算符呢都重载为 呃，有源。那么此外呢这个A还包含了一个构造函数，啊 那么这是相应我们刚才对应的3个 呃，运算符重载的函数，那么这3个函数呢都被定义为 是类A的这个有源，我们看到像小于号呢就是去 呃，返回对应的这个 相应这个具体A这个类对象中间包含的这个n成员变量的 这个比大小的结果，以及去判断相应它们这两个n值是否相等。 啊，或者是去输出相应的这个a.n 那么此外的话呢，我们还定义自己定义的 一个叫做print list这样的一个函数模板，啊 我们去相应打印这个链表中间的这个对象。 那么可以看到说呢，这个函数模板呢，它呢实际上呢就是 去定义了一个传递进来的这个，啊，lst这样的一个对应的列表。 那么，我们会看到说我们在这里呢实际上呢，呃 可以用这个typename去定义这个list T双冒号，const,iterator这样的一个，呃 本身的这个迭代器的类型，啊用来去声明说我们定义的一个迭代器i 那么去，用这个长长的一串呢去标记出它是一个类型，然后这一串呢实际上在VS里面 可以，可以不去写。啊，我们让这个本身的这个定义好的这个迭代器呢，i 呢 让它赋值从list的这个begin开始，啊，依次从这个链表的这个首元素开始 然后去相应地输出其每一个值，啊，一直到这个list的末尾。 那么有了这样的一个print list 的这样的一个函数模板之后呢，我们就可以相应输出 我们希望能够打印的链表中间的对象。 我们来具体看一下，啊，在定义好了这个类A以及相应的打印输出 嗯，链表当中每一个对象的这样的一个print list的一个函数模板之后呢 我们来具体看一看怎么样对这样一系列的list来进行一些操作。 我们在main函数里头呢，首先定义的就是一个A类型的 两个链表，分别是list1和list2 我们接着做的事呢就是对这个list1和list2呢分别其中的每个元素呢来进行赋值，啊进行插入 这个相应元素这样的一个工作。我们首先呢就是对list1呢进行了这样5次push back的工作 也就是说我们把相应的这个list1当中的元素呢插入进了 1，3，2，4，2这样5个元素，接着呢我们会去 构建这个list2，那么我们首先push back进来一个10 接着呢，我们要push front, 也就是说我们需要在 这个链表的头部去插入一个元素20 接着我，接着push back是吧，我们就30 然后呢，这个push back 30，3个30 之后呢我又push front 40是吧，也就是说我要重新把40也插到这个 头上去，那么我就在20前面要插入40，然后又push back 40 啊，我们看到说通过这样两个一系列的插入的操作呢，我们就构建好了 两个链表，分别是list1和list2，那么我们首先可以做的事呢就是去cout 对应的这两个链表，那么我们在这里头就使用到了这个 PrintList这样的一个函数模板,相应地去 匹配这个list1和list2这样两个 容器的这个类型，那么它的这个每一个类这个list中间的元素的类型呢都是 类A，我们自己定义的一个类型。 那么有了这样的一个输出之后，我们就会看到我们第一个输出的就是list1是吧，我们输出1，3，2，4，2 接着呢，我们输出list2,就分别是40，20，10，30，30，30和40 那么之后我们接着做的操作呢，我们会去使用list这个容器自身的sort函数 那么自身这个无参的sort函数呢它本身去做 就是从小到大排序这样的一个工作。因此呢我们，它作用在 就list2这样的一个容器上，所以呢我们在这一步cout 3的时候我们会看到 我们会对刚才这个序列来进行重排序 我们会得到10， 20，3个30以及两个40 啊，那么我们接着做的操作呢就是要让list2呢去pop出去第一个首元素。 因为我们再回忆一下，刚才这个类似的2经过sign函数之后，它的排序是：10 、 20 、三个30 、两个40。 是吧？那么要有了这样一个，呃， pop_front这样的一个 操作之后，那么第一个10呢实际上就会在列表当中呢被删除掉。 所以我们在cout<<"4这条语句的时候，我们会看到如果我们打印输出lst2, 那么它对应的值呢，就是20，30，30和两个40 。啊。 之后我们接着做，啊，接着做我们做的事儿是什么呢？我们 remove （2）。 remove 2 这个函数呢他作用在lst 1，那么lst 1呢，刚刚我们看到是 大家还记不记得list 1呢？lst 1是1 3 2 4 2，对吧？ 如果我没有记错的话。那么，这时候我们通过remove（2） 呢开始这样就是删除所有和 A2相等的元素。啊，那么在lst 1里面呢也就是说我们需要把2这个两个元素呢删除掉。 那么这时候如果我们cout>>"5，lst 1 的话呢我们会看到我们输出就是1、3、4。 之后呢我们接做，那我们接着作用在谁上呢？我们要 做回作用回到lst 2了，对吧？第二的lst 2这样的一个列表。 那么它呢我们需要做的事儿呢，是我们调用了Unique这样的一个成员函数。那么它会删除 所有和前一个元素相等的元素。比如说：我们会删掉具有相同值的元素，啊。 所以我们看到说，这三个30呢只能保留一个，而两个40 呢也只能保留一个。所以这 时候我们看到，如果我们cout>>“6， 啊，Printlist (lst2)的时候呢我们会看到我们只能输出20、30、40。 这样三个值。 那么有了这样两个新的lst 1 和lst 2之后我们接着做，我们可以把两个链表 merge在一起，啊，注意，我们是让merge这个函数作用在lst1 这样的一个链表上。而被Merge的对象呢是lst 2。 也就是说我们会将lst 2呢 放到list 1中间并且要清空lst 2。 所以通过这样的lst1.merge （lst 2)这样一个操作之后呢，我们会看到说 lst1就被扩充为了1、3、4、20 、30、40 也就是说我们把这个 链表放到了1、3、4后，而相应的lst2呢就变为了空。 之後呢，我还可以让lst1也就是我们现在这个lst1 让这个链表reverse一下，让它去 逆序排成新重置一下。那么这时候如果我们相应的去 cout9的话呢。你会看到实际上我们就会把刚才这个 序列呢由 最后呢又排到了首，啊，也就是说通过这样的reverse一下。 那么经过上述，那么经过上述一系列操作之后呢 那么，我们看到lst1呢实际上它包含的就是40 、 30 、20 、4、3、1这样一系列的元素。 而lst2呢，它就被清空了。 应该清空之后呢我们就要重新对lst2呢，进行了push_back。那我们重新插入了一些元素，插入了100、 200、300和400。 那么重新构建了lst1和lst2之後呢我们接着做了一些操作。 我们去定义了三个新的迭代器P1、P2、P3他们都是lst a 这样的一个类型。那么这三个迭代器它都分别指向谁呢？ 它指向了是find的这个算法本身 它所返回的相应的那个我们 查找的对应人数所在的迭代器。啊，我们看到说 我们在这里p1指向的就是我在lst1从开始拟定到n的中间 3这个元素所在的这个位置的迭代器。 而这个p2呢它指向的是lst2 这个链表当中从今开始到结束中间 200这个元素那么它所在的这个，嗯，迭代器。 以及p3呢指向的是400这个元素本身。 那么有了这样的一个p1、p2、p3迭代器的这个具体的 这个赋值之后呢，我们来做的操作呢就是我们要在lst1 这个链表上面呢去做splice。splice是谁呢？我们希望能够在p1 这样第一个参数所定义的位置之前 去插入p2 到p3 这样的两个迭代器所定义的这样一个区间的当中的内容，把这个内容呢插入进来。 同时要注意呢，要在 当这个p2到p3的这个内容它作用在lst2这样的链表上。 注意，我们要插入之後呢要在lst2当中去删除p2到p3 这段已经插入到p1当中内容的 插入到这个lst1当中内容的这样一个，嗯，操作。 那么我们看到说，注意，这个P2到p3呢是前毖后开的这么一个区间。 我们要做的事儿呢，p1因为它指向的是lst1 当中3这个元素所在的位置，啊。那么， P2呢它指向的是lst2中间200，p3 指向的是400 这样相应的几个位置。 那么我们做了splice之後呢，我们要做个事儿，实际上就是在3这个元素的前面 去插入p2到 p3这一段内容。注意，它是不包含400的， 啊， 因为是后开这样的区间。 那么我们会看到我们要做的事儿实际上是我们在lst1里面 3这个位置之前 插入这段两个值，200、300、 然後是3和1。那么相应的，因为splice这个函数它会从 lst2当中删除掉已经插入到st1当中的内容。 所以lst2就会变成100和400。 所以我们看到我们通过这个lst1.splice这个操作之后呢，我们实际上如果 cout11的话呢你会看到，你输出的就是这个40 、30 、20 、4 然後200和300 是被splice进来的，然后是3和1。而相应的lst2呢，就变成了100和400. 。 所以这就是我们整个这个程序的对应的输出的结果。 
- 那么最后呢，就是简单的介绍一下deque这个容器。 那么deque呢它实际上是一个双向的队列。 那么，我们在对于这个Deque来劲使用的时候呢，也要去引用相应的头文件。 那么大家要注意的就是，我们所有能够用在vector上面的操作呢它本身都是使用于deque。 此外呢，因为deque 它是双向队列，所以呢它还包含了这个 push_front和pop_front这样两个操作。比如说你可以是把 这个元素呢插入到容器的头部，以及呢去删除掉 头部的这个 
## 5. 函数对象
- 接下来咱们来说这个STL里面一个很重要的概念函数对象，什么是函数对象呢， 如果一个类重载了圆括号运算符，那么这个类的对象就成为函数对象，然后下面这个CMyAverage它重载了圆括号运算符，
  ```C++
  //若一个类重载了运算符"()",则该类的对象就成了函数对象
  #include <iostream>
  using namespace::std;

  class CMyAverage {                                    //函数对象类
    public:
      double operator()(int a1, int a2, int a3)
      {
        return (double)(a1 + a2 + a3)/3;
      }
  };

  int main()
  {
      CMyAverage average;                               //函数对象
      cout << average(3,2,3);                           //调用：average.operator()(3,2,3)，输出：2.66667    
      return 0;
  }
  ```  
  它的功能呢是求三个参数的平均值，然后返回 那如果我们定义了一个CMyAverage的对象，这个Average那我们就称这个Average是 这一个函数对象为什么呢，因为这个Average我们会按下面这个方式来使用，啊就是后面跟个圆括号里头给参数，那我们以前会在什么东西后面跟着圆括号呢，一般来说我们会在一个函数的名字后面，跟圆括号里面给参数或者是在一个函数指针的 后面跟圆括号里面给参数，可这块并不是函数也不是函数指针，是一个对象.这个表达式依然能够成立，那是为什么呢？当然是因为这个表达式它就等价于Average.operator()(3,2,3)也就说这个表达式，它看上去像个函数调用的形式，而且它实际上也执行了一个函数调用，而这个Average又不是一个函数，它是一个对象，所以我们把这个Average又称为函数对象， 那刚才Average这个表达式它的返回值就是3,2,3的平均值就是2.6667 
- 那函数对象是在STL里面就有很广泛的应用的， 呃，我们来看一个accumulate函数模板的例子， 
  ```C++
  //Dev-C++ 中的Accumulate源代码1：
  template<typename _InputIterator, typename _Tp>                                 //此处 typename 等价于 class
  _Tp accumulate(_InputIterator __first, InputIterator __last, _Tp __init)
  {
    for(; __first != __last; ++__first)
      __init = __init + *__first;
      return __init;
  }
  ```  
  呃，这是在Dev C++里面accumulate的源代码， 这个函数模板它有两个类型参数，一个是Inputlterator, 一个是Tp 这个Inputlterator就暗示你这个类型参数应该是一个迭代式类型的， 起码说可以是一个迭代式类型的，然后我们看这个accumulate的函数参数有三个，一个first，last，init 那这个first，last很像是这个accumulate所操作的容器上面一个区间的 起始位置和终止位置，这个区间都是左闭右开的，那这个init呢， 顾名思义，它应该像是一个起始值，初始值，那我们看到这个accumulate在里面做了什么事情， 它从一个循环，让first走到last，然后把这个 新first加到init上面 那么也就是说这个循环实际上在做一个累加的工作 怎么累加呢，就是把first，last这个区间里面，每一个元素 都通过一个加号加到初始值init上面，然后再返回到最终的这个init， 那这块这个typename就等价与class的啊，而且这个class也是一样的。 那这个accumulate在STL里面它是有两个版本的，这边列出了第二个版本 
  ```C++
  //Dev-C++ 中的Accumulate源代码2：
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>      //此处 typename 等价于 class
  _Tp accumulate(_InputIterator __first, InputIterator __last, _Tp __init, _BinaryOperation __binary_op)
  {
    for(; __first != __last; ++__first)
      __init = __binary_op(__init, *__first);     //调用Accumulate时，和__binary_op对应的实参可以是函数名字，函数指针，或者是函数对象
      return __init;
  }
  ```    
  比刚才第一个版本多出来一个类型参数，BinaryOperation，于是它的这个accumulate的函数参数也多了一个Binary_op 那我们看看accumulate这个版本源代码是这样的啊，就是 它对这个区间，first，last里面呢每一个元素 都拿它来跟这个初始值init 做一个运算，然后把运算的结果呢，又赋值给这个初始值，下次呢又用这个新的初始值和下一个元素做运算， 然后最终返回这个初始值， 那我们看accumulate是一个函数模板，那将来从这个模板实力化出来的 函数里面也会原模原样的出现这一条语句，那么为了使这个 表达式能够编译通过这个Binary_op本身是一个什么东西呢？ 它可以是个函数指针，可以是一个函数的名字，也可以说一个函数对象， 如果这个Binary_op是一个函数对象的话， 那么这个表达式实际上就是在调用这个函数对象operator的圆括号成员函数，所以是说得通的， 那也就是说我们真正的调用accumulate模板的时候， 最后一个参数呢，可以是函数名字，函数指针，或者是函数对象。 
- 那下面我们通过一个程序来看一下这个函数对象到底如何起作用， 
  ```C++
  //若一个类重载了运算符"()",则该类的对象就成了函数对象
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <numeric>
  #include <functional>
  using namespace::std;

  int sumSquares(int total, int value)
  {
    return total + value * value;
  }

  template<class T>
  void PrintInterval(T first, T last)         //输出区间[first,last)中的元素
  {
    for(; first != last; ++first)
      cout << *first << " ";
    cout << endl;
  }

  template<class T>
  class SumPowers {
    private:
      int power;
    public:
      SumPowers(int p):power(p) {}
      const T operator()(const T &total, const T &value)    //计算value的power次方，加到total上
      {
        T v = value;
        for(int i = 0; i < power - 1; ++i)
          v = v * value;
        return total + v;
      }
  };

  int main()
  {
    const int SIZE = 10;
    int a1[] = {1,2,3,4,5,6,7,8,9,10};
    vector<int> v(a1, a1 + SIZE);
    cout <<"1)";PrintInterval(v.begin(), v.end());                          //输出：1 2 3 4 5 6 7 8 9 10
    int result = accumulate(v.begin(), v.end(), 0, sumSquares);
    cout << "2)平方和:" << result << endl;                                   //输出：平方和：385
    result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(3));           //类的名字后面跟着构造函数的参数列表，就代表一个临时对象
    cout << "3)立方和:" << result << endl;                                   //输出：平方和：3025
    result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(4));
    cout << "4)4次方和:" << result << endl;                                  //输出：4次方和：25333  
    return 0;
  }
  ```  
  呃，在一个程序里面呢，有个SumSquare这个函数，它的功能是把 第二个参数的iii加到第一个上面，然后返回，啊记住这个函数的功能， 呃，这个Printinterval这个模板它的功能就是把一个区间first，last里面的 每一个元素都给它打出来， 然后这里有一个类模板，SumPowers, 它的作用实际上是求一个区间的，呃，power次方的和， 呃， 这个power要求多少次方的和，它的构造函数就初始化这个power，然后它的圆括号成员函数是在求这个power次方的和， 把这个和加到total上面，我们看到这里面要计算value的power次方，然后加到total上面， 一开始让这个一个iii v的值等于value，然后在下面这个循环里面让这个v成了power减一次value， 那当然算下来这个v就是value的次方，然后我们把这个power次发加到了这个total上面，返回。在这里面呢有一个数组a1, 里面有1,2,3,4,5,6,7,8,9,10，然后我们进行一个vector int这样的容器类， v是这样一个容器类的对象， 它初始化的方式就是用这个a1数组去初始化这个v,那经过这条语句以后，v里面所包含的 内容就是从a1这个数组里面拷贝过来的，啊，a 这个size一共是10所以就把十个元素都拷贝过来了， 呃，里面就是1,2,3,4,5,6,7,8,9,10 那你输出，啊，从v.begin到v.end当然输出值就是1,2,3,4,5,6,7,8,9,10 接下来呢我们调用的这个accumulate accumulate作用在整个v上面 然后给一个初始值0，然后呢要所做的这种累加的操作呢是求平方和， 所以这条语句实际上就会求出， v上面所有元素的平方和 那因此我们输出result的结果就是平方和385 具体为什么会是这样一个效果，等会再解释一下， 那么下面这条accumulate语句，它就要求这个 v上面所有元素的立方和，如何求立方和呢，在这里用到了这样一个函数对象， 呃，我们看到，SumPowers 是一个类模板的名字， 那么SumPowers int， 就是一个模板类的名字，啊，在类模板后面跟尖括号，尖括号里面给出了具体的类型， 那你得到的就是一个类的名字，然后在类的名字后面又跟了一个圆括号，再给了一些构造函数的参数， 那么这整个的东西都是一个对象的名字了， 只不过它是一个临时对象，那在，那这个对象实际上那就是一个函数对象，因为它所属的类是重展的圆括号， 然后在这个对象里面那个power的值就是3，也就是说这个对象它的圆括号工作的时候， 自然就会求3次方的这个和 呃，所以下面这个第三行输出输出的这个立方和：3025 那么至于下面这一行呢，那当然就是求4次方的和，所以就输出这个数字。 
- 那么来看这个accumulate具体是怎么工作的啊， 那么第一条调用的accumulate语句是这样的， 
  ```C++
  //accumulate的工作原理：
  int result = accumulate(v.begin(), v.end(), 0, SumSquares);
  //实例化出：
  int accumulate(vector<int>::iterator first, vector<int>::iterator last, int init, int (*op)(int, int))
  {
    for(; first != last; ++first)
      init = op(init, *first);     //调用Accumulate时，和_op对应的实参可以是函数名字，函数指针，或者是函数对象
      return init;
  }  
  ```    
  呃，那么根据从这条调用语句就会 经由accumulate模板实例化出来一个accumulate函数， 那这个函数的各个参数是什么样的呢？啊，首先我们第一个实参是v.begin，那v.begin类型是什么就啊？ 是vector int上面的迭代器，啊，所以accumulate上面的 实例化出来的函数的第一个参数就是，就是这样的，它叫first， 那v.end的类型当然也是vector int上面迭代器，所以accumulate的第二个参数是这样一个last。 第三个参数0就对应于整形参数， 那第四个参数呢是一个函数的名字， 那么，呃，什么样的形参才能够跟 函数的名字相匹配呢？当然函数指针式可以跟函数名字相匹配的， iii这块实例化出来的accumulate函数里面，最后一个参数就是这个函数指针op 这个op所指向的函数返回值是int，然后才有两个整形参数， 这正好跟SumSquares的特点是相同的， 那我们看到在这个被实例化出来的这个accumulate的代码里面， 当然就用到了这个op,那我们看到这个表达式是实际上是做什么啊， 就是调用了SumSquares， 那么说SumSquares它的功能是什么呢？就把第二个参数的 平方加到第一个参数上面去，所以我们看在这个循环里面做了什么事情， 就是init一开始一个初始值，然后对first，last区间里面的一个元素， 把它和init做一个运算，然后把算出来的结果呢放到init里面， 得到一个新的init值，然后下一次循环呢就把它新的init的值再跟这个first last里面区间呢下一个元素再做一个运算，又得到一个新的这个init的值， 那我们知道这个op做的实际上就是把第二个参数的平方值加到第一个参数上面， 然后这边init的初始值又是0，所以这整个循环所做的事情就是对 first，last区间里面的每一个元素都平方下，然后再把它们全加起来， 就是求平方和， 
- 那我们再看这个第二条accumulate语句被调用的时候，会实例化出什么东西， 
  ```C++
  //accumulate的工作原理：
  int result = accumulate(v.begin(), v.end(), 0, SumPowers<int>(3));
  //实例化出：
  int accumulate(vector<int>::iterator first, vector<int>::iterator last, int init, SumPowers<int> op)
  {
    for(; first != last; ++first)
      init = op(init, *first);     //调用Accumulate时，和_op对应的实参可以是函数名字，函数指针，或者是函数对象
      return init;
  }  
  ``` 
  呃，前面呢参数都一样就没什么可说了，啊，那我们就看， 最后一个参数，它是一个函数对象，这个函数对象所属的类型本来就是SumPowers int 所以这块实例化出来的accumulate里面，最后一个参数就是这样的，SumPowers<int>op。 然后在这里所做的操作也是op(init,* first)。 那我们回忆一下这个 op现在就是一个函数对象，就是SumPowers<int>(3)。 也就是说，这个op 这个对象里面的Power成员变量它的值是3，那么在这里就调用了op的 圆括号成员函数，这个圆括号成员函数能做什么呢？ 能做的事情就是把*first三次方加到初始值init上去。 所以经过这个循环以后啊，就会把这个first，last这个区间里面的 每一个元素的三次方都加到了这个init上面去。init的初始值 是0嘛。所以说，这整个循环所做的事情， 就是求出了first到last这个区间面的每一个元素的 立方的和。
- 从这个例子呢，我们是能够看出来， 函数对象它的价值的。 同学们设想一下，如果我想用这个accumulate模板来求 v里面的元素的平方和，立方和，四次方和，五次方和， 如果你不用函数对象的话，该怎么解决？一种解决方案就是，我求平方和，我就写一个SumSquares函数用在这。 那我求立方和呢，我就写一个什么SumCurious函数用在这儿， 我要求四次方和呢，我还得另外再写一个Sum什么四次方的函数。 那你就要写一大堆的函数，那实在是不能忍，难受，对吧。 那如果我想只写一个函数，叫做SumPowers， 用在这儿，就能既求三次方和，四次方和，五次方和都可以。 那怎么办呢？关键是你，你只把函数名字写在 这的话，你没有地方把要求几次方和这个几次方的信息传递给这个函数，除非你把这个几次方的信息用一个全局变量来记录。 然后你在调用这条语句的时候，事先把那个全局变量赋上一个值， 然后SumSquares这个函数内部呢，再去取得那个全局变量，然后才能知道要求多少次方和。 这当然是一种做法。但是这个做法呢？ 非常不符合面向对象的思想，因为面向对象思想让我们要少用全局变量。 为了求一个几次方和，就专门开了一个全局变量在那里。 然后这个全局变量 在一个函数里面，又要访问，就显得这个变量也不独立，函数也不独立。 这个程序的所谓的局部性就不太好了，而我们用了这个函数对象呢， 我们在这里只用临时创建出来的函数对象，就能够来求三次方和，四次方和。 而且我们也不需要把求几次方和这个事情用一个全局变量去记录，我们只需要把它设置成这个临时函数对象的一个成员变量就行了， 这样我们这个整个程序的这个局部性就很好，没有用到了全局变量。 
- 在STL里面，实际上就有一些函数对象类模板，比如说有equal_to，greater，less等等。 这些东西首先它是模板，然后它们又都实现了圆括号这个成员函数。 所以我们就称之为函数对象类模板，那通过这些模板，我们可以生成函数对象。 这些模板呢，它们都在头文件`functional`里面定义的。 我们举一个例子，比如说有一个函数对象类模板，叫做greater，struct greater 
  ```C++
  //greater函数对象类模板：
  template<class T>
  struct greater:public binary function<T, T, bool> 
  {
    bool operator()(const T &x, const T &y) const 
    {
      return x > y;
    }
  }
  ``` 
  这个greater呢，是从某个其它东西派生出来的，这个我们不管它，我们所关心的是 这个greater它重载了圆括号成员函数，这个成员函数呢，它用来判断两个参数，谁大谁小，比大小的方式是使用这个大于号， 那x＞y的话， operator圆括号返回值就是true，那我们要知道，如果用哪一个关联容器或者是哪一种算法 使用了这个greater模板作为比较器的话，那么这些容器或者是算法 比较两个元素x，y大小的时候，就会调用这里的operator圆括号成员函数，并且把x，y作为参数传进来。 那么这个函数的返回值如果为true的话，那么这些容器或者是算法就会认为x是小于y的，但是我们看到这里面 实际上，当x＞y这个表达式为true的时候， 整个函数的返回值才是true，也就是说这个greater 所定义出来的比大小的规则， 它是跟传统的方式是相反的，也就是说，传统意义上的这个大， 反而就意味着是小。
- 所以greater有什么用呢，我们举一下list的这个例子， 
  ```C++
  //list有两个sort成员函数
  void sort();        //将list中的元素按"<"规定的方法升序排列
  template<class Compare>
  void sort(Compare op);//将list中的元素按op规定的比较方法升序排列。即要比较x,y大小时，看op(x,y)的返回值，为true则认为x小于y
  ``` 
  list这种容器里面，它有两个sort成员函数。 我们知道list上面的迭代器是双向迭代器，所以你没有办法用 STL的sort算法对list进行排序。但是如果你想对 list进行排序呢，你得调用list自己的sort成员函数。 list的sort成员函数两个版本。第一个版本是没有参数的。 没有参数的这个sort呢，它把list进行 排序的原则是按照小于号所规定的这个比较方法 顺序排列，就是说比大小是用小于号来定义的。那还有 另外一个sort的版本，是一个函数模板， 在这个版本的sort里面，有一个参数op， 这个op实际上就定义了比大小的这个规则。 也就是说，这个版本的sort在执行的过程中，在需要比较两个元素x，y大小的时候， 它会去看op(x,y)这个表达式的返回值。 如果这个表达式的返回值为true，就认为x＜y，也就是说x需要排在y的前面。 我们看一个具体的例子。 
  ```C++
  //greater应用
  #include<list>
  #include<iostream>
  using namespace::std;

  class MyLess {
    public:
      bool operator()(const int &c1, const int &c2)
      {
        return (c1 % 10) < (c2 % 10);
      }
  };

  template<class T>
  void Print(T first, T last) {
    for( ; first != last; ++ first)
      cout << *first << ",";
  }

  int main()
  {
    const int SIZE = 5;
    int a[SIZE] = {5,21,14,2,3};
    list<int> lst(a, a + SIZE);
    lst.sort(MyLess());
    Print(lst.begin(), lst.end());          //输出：21，2，3，14，5
    cout << endl;
    lst.sort(greater<int>());               //greater<int>() 是个对象
    Print(lst.begin(), lst.end());          //输出：21，14，5，3，2
    cout << endl;
    return 0;
  }
  ```   
  在这里，我们写了一个MyLess，这个是一个 函数对象类，在这里面呢，我们重载了 圆括号，这个圆括号所规定的比大小的规则 是两个整数，谁的个位数小，谁就算小。 然后这下面有一个模板， 这个模板是用来输出first到last这个区间里面的所有元素的。 记住这个圆括号的规则是，谁的个位数小，谁就小。 然后我们去看看main里面，main里面有一个整型数组a， 里面有这么多个元素，然后我们定义了一个list容器， lst，它里面放的都是整形变量，然后用这种方式初始化的话，lst里面的内容就 是把a的内容给复制过来了，于是lst里面也就是5，21，14，2，3。 那下面我们就调用 lst的sort成员函数，对这个lst这个容器进行排序。 在这里，我们给出的参数是一个行助对象。 MyLess是一个类的名字，那这个类的名字后面跟圆括号， 实际上就是一个临时对象了，这个临时对象是用无参构的函数初始化的。 那也就是说，我们再要用这个sort的时候，我们就指明了， 这时候排序，比大小的规则是由MyLess这个函数对象决定的。 更准确地说，就是由MyLess里面的，这个类里面的圆括号来 决定比大小的规则。那也就是说，这个比大小的规则就是 哪个元素的个位数小，哪个元素就算小。 因此，经过这个排序以后， lst里面的元素实际上是按照个位数从小到大排序的。 所以我们这个lst的内容给它输出，就变成了21，2，3，14，5。 好，下面我们再次调用 lst的sort成员函数。但这次调用的时候呢，比大小的规则我们变了， 我们用一个greater<int>这个函数对象来作为比大小的规则。 greater是个类模板，那greater<int>就是一个 类，greater<int>再加个圆括号呢， 这就生成了一个临时对象， 它是一个函数对象，因为greater<int>这个类里面重载了圆括号。 而且那个圆括号，它所规定的比大小的规则是什么呢？ 我们回忆一下，等于说就是 x＞y要成立的话，实际上就认为x算是小的， 实际上它说的是这个意思。那因此说 lst.sort这条语句，实际上 对lst进行排序的时候，遵循的规则是， 哪个整数，它的这个大， 哪个整数大，这个大是数学上的大的意思啊， 实际上它就反而算小。因此这条语句会导致lst被 降序排列，所以输出的结果呢，是这个21，14，5， 3，2。 
  - 那现在我们引入了函数对象这个概念以后，我们就有必要再重申一下在STL中使用自定义的“大”，“小” 关系这件事情了。 那有了函数对象，我们就发现，关联容器和STL中的许多算法， 都是可以用函数或者函数对象来自定义比较器的，就是定义比大小的规则。 如果在自己定义了比较器op的情况下，那下面三种说法就是等价的。op（x，y）的返回指数以及y大于x的三个做法就是等价的了。 那我们看一个例题。 这个例题要求你写出my max模板 ，在这个例题里面有一个my less的函数对象类 它的圆括号规定了一个比大小的规则。这个规则是什么呢， 就是谁的个位数小谁就算小。 然后这个程序里面还有另外一个函数叫做mycompare 他也规定了两个常数比大小的规则。这规则是什么呢. 当a1的个位数小于a2的个位数他返回false 否则就返回true。所以这个mycompare规定的比大小规则是 谁的个位数大谁就算小。 
  ```C++
  //greater应用
  #include<iterator>
  #include<iostream>
  using namespace::std;

  class MyLess {
    public:
      bool operator()(int a1, int a2)
      {
        if((a1 % 10) < (a2 % 10))
          return true;
        else
          return false;
      }
  };

  bool MyCompare(int a1, int a2)
  {
    if((a1 % 10) < (a2 % 10))
      return false;
    else
      return true;
  }

  template<class T, class Pred>
  T MyMax(T first, T last, Pred myless)
  {
    T tmpMax = first;
    for( ; first != last; ++first)
      if(myless(*tmpMax, *first))
        tmpMax = first;
    return tmpMax;
  }

  int main()
  {
    int a[] = {35,7,13,19,12};
    cout << *MyMax(a, a + 5, MyLess()) << endl;           //输出：19
    cout << *MyMax(a, a + 5, MyCompare) << endl;          //输出：12
    return 0;
  }
  ```     
  下面我们看main里面这里有一个数组。 然后我们要用一个mymax模板求出这个a里面的 这个所谓的最大值从名字上看最大值 但什么叫最大。有不同的定义。 那如果我们采用myless这个函数对象 所决定的定义，最大的意思就是个位数最大。 那如果我们采用mycompare规定的 比大小的规则。那最大地定义就变成 个位数最小了。 然后这个mymax它返回值是一个 迭代系或者指针类的东西。然后通过星号可以把指向可以取出来。 如果我们要求这个程序输出结果是19和12，也就是说按照myless所定义的这个 我们求出a数组里面的最大值。这个时候意味着个位数最大。 那我们按照mycompare定义的规则我们也可以求出a数组里面的最大值。 这个时候呢最大意味着个位数最小。谁的个位数最小谁就算最大。 所以输出就是19,12.那我们的问题是你如何去写这样一个mymax模板。 大家可以不妨先思考一下。先写一写然后再看答案。 这个mymax是一个函数模板。 这里面有个类型参数T，还有一个类型参数Pred 这个T呢可以是一个迭代系，first，last。 我们可以看到mymax的前脸个参数first，last是T类型的。 他用来指明mymax想要操作的区间的 起始位值和终止位值。 然后mymax的返回值当然也是一个迭代器。T的类型也是一个迭代器。那mymax的返回值 是一个迭代器，指向找到的那个最大元素。 然后mymax的第二个参数函数myless实际上 指明了这个比大小的规则。 那mymax的代码是怎么样的呢。 首先我们要假设一个最大值。 那我们就不妨加设最大值是区间开始的那个元素。现在我们用一个tempmax他是一个迭代器。 让他等于first，就是说我们假设tempmax总是 指向最大的元素。那一开始我们让他等于first。 然后我们就便利这个区间，从first走到last。 然后再便利的过程中我们有可能分析这个tempmax。 tempmax指向当前我们找到的最大的元素的那一个 迭代器。那我们怎么更新呢，我们就要拿* tempmax，就是当前的最大值和* first就是我们新考察的那个元素去进行比较。怎么比较呢，就是用 myless这个东西去进行比较。那mymax这个模板被实例化以后，这个myless它很有可能是一个 函数指针，也有可能是一个函数对象。那不管是函数指针或函数对象后面都可以跟圆括号。 如果myless这个函数对象的话实际上在这里可以调用myless圆括号的成员函数 然后这个成员函数就会有一个返回值。如果这个返回值是true的话就意味着 这个tempmax所指向的函数是比first指向的元素小。 那这种情况下呢我们就要更新tempmax了。 那我们每发现一个比*tempmax更大的 元素，我们就更新tempmax让他指向更大的元素。那么我们最后 这个循环进行完以后tempmax就应该指向最大的元素。然后我们返回tempmax就行了。 