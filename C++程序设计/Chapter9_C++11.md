# [C++11](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/11)
- C++高级主题和C++11新特性: 本模块给大家介绍一些C++程序设计的进阶内容，以及最新C++11标准的部分新特性。该模块内容不属于本课程必须掌握的教学内容，但是通过了解和学习必将为你打开一扇C++学习的新门，继续探索程序设计的各种精妙与美好！
## 1. C++11新特征
- 同学们好，这周我们来讲一讲c++11的这个新特性。c++11是c++标准委员会在2011年发布的一个新的这个c++标准 那距离上一个c++的正式标准c++98的发布已经过了好多年，那实际上c++11的很多特性呢 在前好几年的各种c++编译器里面就获得了支持。 那完全支持c++11标准的编译器 现在也有，就是这个gcc4.8。
- 我们看c++11都带来了那些好处啊。 啊第一个是它用了一个统一的初始化方法 可以用来初始化数组以及各种容器 
    ```C++
    int arr[3]{1, 2, 3};
    vector<int> v{1, 2, 3};
    map<int, string> mp{{1, "a"}, {2, "b"}};
    string str{"hello world"};
    int *p = new int[20]{1, 2, 3};              //前 3 个元素被初始化为 1， 2， 3， 后面的被初始化为 0

    struct A {
        int i, j;
        A(int m, int n): i(m), j(n) {}
    };
    A func(int m, int n) { return {m, n}; }     //返回一个临时的 A 的对象
    A *pa = new A{3, 7};                        //老方法是圆括号初始化

    //成员变量默认初始值
    class B {
        public:
            int m = 123;
    };
    int main()
    {
        B b;
        cout << b.m << endl;                    //输出 123
        return 0;
    }
    ```
  比方说我们对一个整形数组arr进行初始化 只需要后面跟一个花括号然后把这个元素的值写进去就行啦 对于一个vector的变量iv可以用同样的方式初始化，所以这个初始化的方式是统一的嘛 甚至对于一个mp类型的这种容器也可以用花括号初始化，而且可以用花括号嵌套花括号的办法 那我们这条语句里面当然我们看到的就是这个mp容器里面有两个元素，一个元素呢 被初始化成a，也就是说这个元素它这个first的陈源边缘是1，second陈源边缘是a 那第二个元素first陈源边缘是2，second陈源边缘是b 然后我们再看这个对于这个string也可以用相同的方式进行初始化 最让人高兴的就是我们 对于new这种动态分配的数组啊现在也有了统一的初始化方法 额花括号，那现在我们在这里看到的这个new 这个数组呢，它的前三个元素被初始化成123，后面的元素就初始化成0 这个是解决了我们长久以来的一个很大的困惑啊 好了那我们下面再看这个额 另外一个例子，这里我们定义了一个类A，它有构造函数，用来初始化里面的i和j 然后呢我们甚至可以在 一个函数的return语句里面直接写一个初始化列表m ,n 它这样就能返回一个临时的A的对象，因为这块返回值说的是A对象所以你写这个 花括号m n辨析也能判断它是一个A对象 这个写法我觉得很别扭，也不推荐大家去疯狂的使用它，反正看的挺难受的 但是这个东西是挺不错的，就是A*pa=new A 这个初始化方法跟前面统一了，当然你这里写的是圆括号也是没有问题的 那c++11还从Java里面学来了一个好处，就是这个成员变量可以有一个默认的初始值 就像这个我们定义class B的时候它的成员变量m，我们可以直接在这个地方给它赋一个默认的初始值 那带来的好处就是当我们在main里面定义一个这个
  
- 我们再说一下这个auto关键字，在c++11 里面这个auto关键字它的含义跟我们原来c语言和c++语言里面定义自动变量的那个auto是完全两回事了 那auto关键字呢它也是用于定义变量，但是它定义变量的时候这个变量不需要指定类型 编译器可以自动对这个变量进行类型的判别 当然有一个前提就是你定义这个变量的时候必须对这个变量进行初始化 
    ```C++
    //auto 关键字
    //用于定义变量， 编译器可以自动判断变量的类型
    auto i = 100;           //i 是 int
    auto p = new A();       //p 是 A*
    auto k = 123LL;         //k 是 long long

    map<string, int, greater<string> > mp;
    for(auto i = mp.begin(); i != mp.end(); ++i)
        cout << i->first << "," << i->second;       //i 的类型是： map<string, int, greater<string> >::iterator
    ```
  比方说，我写auto i=100，那明显编译器可以推断这个i就是整形的对吧，所以i就是整形的 那下面呢你在这个auto p=new A 假设A是一个类啊，那当然辨析器也能判断出来，以为new A这个表达式的返回值 就是A*类型的对吧，所以这个时候p呢当然也就是A*类型的啊，这个很容易 那你来个auto k=34343LL那这个常数它是一个 带LL后缀的那它就是一个残整形，那当然k就是long long类型的吧 这些看上去还没有带来什么好处对吧，但实际上我们看这个地方 我们定义这个比较复杂的这个map 那我们要写一个这种map上面的迭代器就要把前面这一大串 都写一遍，或者你再来个title dede field什么之类的就稍微有点麻烦 但是有了auto以后呢，我们直接在这里就可以写 auto i=mp.begin,i=!mp.end而用这个方法来便利这个这个mp 在这里呢，编译器自动根据这个mp.begin就能判断出i的类型是什么 那i的类型是什么呢，当然就是这个map.string.int.greter上面这个的 迭代器，这一大长串的这种类型我们用一个auto迭代器对吧 给它替换掉了，这个时候我们就会感觉非常的方便 这个auto关键字它还有更大的 这个用处，不一定仅仅是用来让你少敲几个字符 比如说我们看这个例子，
    ```C++
    //auto 关键字
    //用于定义变量， 编译器可以自动判断变量的类型
    class A {};
    A operator + (int n, const A &a)
    {
        return a;
    }

    template<class T1, class T2>
    auto add(T1 x, T2 y)->decltype(x + y) {
        return x + y;
    }

    auto d = add(100, 1.5);             //d 是 double 类型 d = 101.5
    auto k = add(100, A());             //d 是 A 类型
    ```  
  这有个class A，然后呢我们定义为一个加号，那在这个加号里面呢 我们把一个整型变量n和这个class A的对象给它加起来，然后我们返回 A对象，注意我们这个时候加号的返回值是class A的对象 然后我们写了一个模板，写一个模板叫add 做加法的，它能够把两个不同类型的变量给它加起来 然后我们返回这两个变量相加的这个值， 那这两个变量相加的值到底是什么类型的呢 不确定，如果按照我们以前学的模板的写法，我们这个位置呢 你要么就写T1，要么就写T2，要么就写woid对吧，你总得有一个什么类型或者是woid 但是有了auto关键字以后呢我们这个位置可以写auto，实际上这个位置 被从模板实地化出来以后返回值它甚至可以不是T1也不是T2，可以是一个别的类型都是有可能的 那也就是说编译器对这个add进行实地化的时候会自动去判别这个 add函数它的返回值应该是什么，它怎么自动判别呢，就通过下面这条语句 下面这个表达式 这里我们牵涉到一个新出现的东西叫作decltype 这个下一页片子还会讲，这个decltype是用来做类型判别的 那么在c++11里面你可以把函数的返回值写在函数的后面 就是通过一个剑号然后后面写一个比如说int什么之类的来指明这个函数的返回值 是某种类型的，那我们在这里写剑号 decltype(x+y)这个告诉编译器什么信息呢 它告诉编译器说，这个add它的返回值是 decltype(x+y)这种类型的，这个decltype(x+y)这个 关键字，它会根据(x+y)这个表达式的类型 去返回一个，代表一种类型吧，就是 decltype(x+y)这个式子就代表(x+y)这个表达式的类型 那我们在这边return x+y 跟这个 x+y是一致的，所以说编译器 以后从这个add模板实地化出来add函数的时候就会根据这 x+y的表达式 的类型去推断出这个函数返回值的类型 我们举具体例子来看，比如说这里有一个auto d=add(100.1.50) 那么这个add被实地化出来 以后这个 x+y 不就是100+1.5对吧 那么100+1.5是什么类型的呢 整形和复点数相加它的返回值当然就是浮点数类型对吧 这个1.5你可以看成是floot，也可能是double 这个差不多啦，我们不宜深究啦，假设它是double吧 那总而言之由于100+1.5的返回值是double的话 那么编译器就能自动判断我们从这个实地化出来的那个函数 它的返回值就是auto这个地方就用double去替换了，那当然 你来个auto d=什么东西那d呢就是double 但1.5也有可能被处理成floot,就这块 double也可能实际上是floot，这个可能不同编译器处理的方法不一样啊 好了那么下面我们再看这个，这个add，我们auto k =add，那就是说k的 类型就跟add函数的返回值的类型是一样的 那这个时候编译器就会从add模板实地化出来另外一个add函数 那另外那个add函数它的返回值是什么类型的呢，当然就是由x+y这个 这个表达式的类型所确定的，因为我们在这里说了这个函数的返回值是x+y这个表达式的类型 那x+y是什么呢，就等于是100加上A 对吧，100加上A这个东西怎么解释啊，我们前面也承载了一个加号 它能进行整数跟class A对象的相加，然后它的返回值是一个class A的对象 也就是说100+A它的返回值就是A 这种类型对吧，那自然，这块x+y的类型是A，那 这个add实地化出来以后它的返回值这个auto肯定 这个位置就相当是一个A啦，所以我们说这个k这个对象它的值它的类型也就是A啦 这是auto关键字相当的好用 
  
- 那现在我们再解释一下这个decltype这个关键字，它的作用就是返回表达式的类型 
    ```C++
    //decltype 关键字
    //求表达式的类型
    int i;
    double t;
    struct A { double x; };
    const A *a = new A();

    decltype(a)      x1;            //x1 is A*
    decltype(i)      x2;            //x2 is int
    decltype(a->x)   x3;            //x3 is double
    decltype((a->x)) x4;            //x4 is double&
    ```  
  比方说我们前面定义了这个什么i啊double啊stract还有这个A*类型的变量A 那我们下面就可以写decltype(a)x1,这个时候我们是定义的x1这个这个变量哦，但是X1它的类型是什么呢？它是由前面这个表达式所决定的， 由于这个a,这个东西它的类型是什么，是A*，对吧，所以说第一是要把type算出来，这个东西就是A*,所以X1就是A*。 然后我们再看这个type的，呃，decltype(i), 这个i是什么东西呢？i前面是个int，对吧 所以说X2就是int了。然后这个再看，呃，这个X3 那X3类型就取决于这个a->x 类型，a->x 是什么？ 是a里面的那个成员变量x,是double类型的，所以说X3就是double类型， 但是第一是要type有个很奇怪的地方就是当你把这个a->x 用括号括起来算作一个整体的时候，这个时候呢，第一次要算出来的type就是double的引用了， 而不是double，所以这个时候 这个X4是一个 double类型的引用，啊，我们用t来进行初始化， 这里面有一点特别，那具体这个第一是要type的规则 还有点复杂，我这里就略过不讲了，同学们要是有兴趣，自己去查一查啊，告诉大家这一点稍微奇怪的地方而已。 
  
- 啊，那接下来我们再说这个C++11一个特别好的东西，叫做这个智能指针shared_ptr, 这个shared_ptr能解决什么问题呢？我们知道我们new出来的空间，我们一定要记得delete，对吧，要不然就形成这个内存碎片， 那我们一旦new成本空间，我们就想着要在程序的各条执行路径上去， 都delete它，否则就会有问题。 当你在，你可以说我在对象运行期间，new的成本空间，我在这个类的 虚构函数里面去delete，这是一种解决办法，但它不能解决所有的问题，因为有时候你的new操作是发生在某个全局函数里面的，对吧。 总而言之，呃，动态分配成本空间会造成很重的这个精神负担，我有时候白天用了iii,用了new，我都半夜会爬起来看看我是不是什么地方没有delete，哪条执行上面没有delete， 所以这是一个问题。那有个shared_ptr，那么晚上就可以睡个踏实觉了， 那shared_ptr如何解决这个问题呢，
    ```C++
    //智能指针 shared_ptr
    //头文件： <memory>
    //通过 shared_ptr 的构造函数， 可以让shared_ptr 对象托管一个new 运算符返回的指针， 写法如下：
    shared_ptr<T> ptr(new T);           //T可以是 int, char, 类名等各种类型。此后 ptr 就可以像 T* 类型的指针一样来使用， 即
                                        // *ptr 就是用 new 动态分配的那个对象， 而且不必操心释放内存的事。
    //多个 shared——ptr 对象可以同时托管一个指针， 系统会维护一个托管计数。 当无 shared_ptr 托管该指针时， delete 该指针。
    //sgared——ptr 对象不能托管指向动态分配的数组的指针， 否则程序运行会出错

    #include <memory>
    #include <iostream>
    using namespace::std;
    struct A {
        int n;
        A(int v = 0): n(v) {}
        ~A() { cout << n << "destructor" << end; }
    };

    int main()
    {
        shared_ptr<A> sp1(new A(2));            //sp1 托管 A(2)
        shared_ptr<A> sp2(sp1);                 //sp2 也托管 A(2)
        cout << "1) " << sp1->n << "," << sp2->n << endl;         //输出 1) 2,2
        shared_ptr<A> sp3;
        A *p = sp1.get();                       //p 指向 A(2)
        cout << "2) " << p->n << endl;          //输出 2) 2
        sp3 = sp1;                              //sp3 也托管 A(2)
        cout << "3) " << (*sp3).n << endl;      //输出 3) 2
        sp1.reset();                            //sp1 放弃托管 A(2)
        if( !sp1 )
            cout << "4) sp1 is null" << endl;   //输出 4) sp1 is null
        A *q = new A(3);
        sp1.reset(q);                           //sp1 托管 q
        cout << "5) " << sp1->n << endl;        //输出 5) 3
        shared_ptr<A> sp4(sp1);                 //sp4 托管 A(3)
        shared_ptr<A> sp5;
        //sp5.reset(q);                         //不妥， 会导致程序出错
        sp1.reset();                            //sp1 放弃托管 A(3)
        cout << "before end main" << endl;      //before end main
        sp4.reset();                            //sp4 放弃托管 A(3)      ; 3 destructor
        cout << "end main" << endl;             //end main   ;      2 destructor
        return 0;                               //程序结束， 会 delete 掉 A(2)                
    }
    ```  
  呃，首先我们要使用这个shared_ptr 我们就得include头文件memory，然后这个shared_ptr呢它是一个类模板， 它是一个类模板， 那么它当然就有构造函数，我们通过shared_ptr的构造函数，还有一些其他的比如说 赋值运算符吧，就可以让shared_ptr对象托管，注意托管new运算符返回的指针， 啊，就是说它托管了一个你动态分布的存储空间， 啊，托管以后有什么好处呢？ 我们接下来看啊，首先呢，它怎么托管呢？就是我们定义一个 shared_ptr的对象，然后在构造函数里面就可以去new一个什么T类型的对象出来。 那这个你要托管的是T类型的那种对象的指针，那我们在在把 这个shared_ptr实际上画出来的时候，这块就写一个T，那当然T可以是int，char各类型都可以， 那我们一旦做了这个操作以后啊， 刚才new出来的这一片存储空间就交给了这个ptr,这个对象托管了， 然后从此以后，这个ptr呢就可以向T类型的指针一样来使用了， 比如说你可以写*ptr，你就代表刚才new出来的这个对象。 呃，然后呢 不但这个ptr可以当做指针一样使用，而且从此以后你就不去 不必再去需要操心释放内存的事情了，你根本就不用管什么delete， 啊，当程序运行结束的时候，或者说这个这个ptr对象消亡的时候，自动就会把这个new 出来的存储空间，刚才new出来的存储空间给delete掉，你根本就不用关心这个delete的事情， 以上就轻松了很多。 呃，那么在iii里面啊，多个shared_ptr对象可以同时托管一个指针， 那这个指针当然是指向，指向new出来的一个什么东西呢，啊，一定的是指向new出来的一个什么东西。 呃，在多个shared_ptr对象同时托管 一个指针的情况下，这个系统会维护一个托管计数，啊，它就会算， 这个指针当前有多少个shared_ptr对象在托管它。 呃，当这个指针啊，变成没有shared_ptr对象在托管它的时候， 那么系统就会自动把这个指针给它delete掉，它会delete这个 指针的，所以当然这个指针就得是new出来的，否则delete就出错了。啊， 那在shared_ptr它解决了我们很大的问题，但是它也有一点不完美的地方， 就是这shared_ptr，它不能托管指向动态分配的数组的这个指针， 啊，这个美中不足啊。 你要让它托管指向动态分配的数组的指针，你的程序就会出错，啊，这个还是有待改进啊。 那我们接下来看看shared_ptr如何使用。 首先我们include头文件memory， 然后我们在这里有一个structA，它这个，有这个虚构函数， 输出什么它的成员变量n, destructor 啊，它有构造函数,用来初始化这个成员变量n的。 那好了，那我们在iii里面呢，我们可以new一个A对象， 然后把new出来这个A对象就交给了sp1去托管，准确的说是把 指向A对象的这个指针吧交给sp1托管，然后我们检测sp1托管了A2啊， 然后我们呢，可以，又用了另外一个shared_ptr的这个对象 sp2，我们注意把它实例化出来的时候，这块是A对吧，因为你当初这边是new的是一个A的对象， 好，现在，现在这个sp2是用赋值构造函数初始化的，而且sp1是 参数，因此这个时候效果就是sp2和sp1就共同托管这个A2了， 那接下来我们把这个sp1所指向的这个n 和sp2所指向的这个n都给它输出，那结果就当然是1，啊，2， 我们注意这个shared_ptr的对象它可以像普通的指针那样来使用，否则不就不方便了对吧， 所以我们看，这个时候sp1所以它是一个对象，但是肯定在shared_ptr里面重载了这个键号， 所以说我们用起来就像指针一样就是sp1这个东西指向的n,那不就是前面那个A2里面那个n,就是2对吧。 所以我们对于shared_ptr完全就可以像指针一样来使用，特别方便。 好，接下来我们就让我们定义了一个新的shared_ptr的对象，sp3 呃，暂时还没有对它进行什么，初始化啊，然后呢，我们，呃， 下面这条语句是取得一个shared_ptr对象sp1所托管的那个指针， 也就是你知道了一个，一个shared_ptr 托管了某个东西，那你怎么把那个托管的指针 拿出来呢？就用，就用shared_ptr 的 get 成员函数，啊，那这时候p就指向了前面那个A2了， 所以我们输出p->n, 它也是2。 那前面不是定义了sp3对吧，在这里我们让sp等于sp1, 啊，这个赋值语句它指的sp3也托管了这个A2， 那这个时候A2就一共有三个shared_ptr对象在托管它，就是A1，啊，就是 sp1，sp2，sp3，所以我们输出*sp3.n,它跟sp->n是一样的， 我们只是说明一下sp3可以这么用，前面是可以加*的，这时候当然输出的结果也就是，啊， 也就是2，在这，啊，好那么一个shared_ptr对象可以放弃它所托管的那个 那个指针，嗯，好吧，那我现在这个sp1.reset reset这个函数如果没给参数的话，那么就意味着放弃它托管的这个东西， 也就是说这时候sp1就放弃托管A2， 啊，sp1也就放弃托管A2了。 呃，那这个时候A2还有sp1， 2和sp3在托管它，对吧，然后呢，呃， s，呃，对于shared_ptr 你可以用这个， 感叹号去判断它是否有托管一个指针啊， 就是如果这个sp1没有托管任何东西，那么！sp1它的返回值就会是TRUE， 那我们就这时候不妨把sp1称为一个空指针嘛，因为它没有指向任何东西，没有托管任何东西，也就是说没有托管任何东西。 那我们就刚才sp1执行了Reset，那它就放弃了托管，它就没有托管任何东西了， 所以下面这个非s,呃，null ！sp1它的返回值就是true的， 那我们就输出一个 Sp1 is null 在这，sp1是null。呃，接下呢我们又，呃， new出来一个A3对象，它的地址呢用q来指着， 然后我让sp1reset q ，这时候sp1就去托管这个q了， 那我们在输出这个sp1的n是多少呢？那当然就是3，对吧，因为这个时候q前面是指向这个A3的。 呃，接下来我们让new又新生成一个对象sp4， sp4呢，它是以sp1作为赋值 构造函数的参数的，这个时候实际上就是sp4 和sp1共同托管这个A3。 然后我们再来一个Sp5, 呃，这个sp5呢，这个sp5呢，如果你想让这个sp5也共同去托管这个q， 你这么写的话是不合适的，会导致程序初始化，为什么会iii下页片子 再强调一下啊。那，那 sp5在这里就没有用了。好，下面我们再来sp1.Reset，这个时候sp1就放弃托管这个 A3了，呃，然后我们又输出一个 before end main， 这个时候注意，A3有 A3原来是sp1 sp4都在托管的，对吧，现在我们执行了 sp1.reset这个时候sp1就没有托管A(3)了，但是还有A4在 托管A(3)啊，然后我们就输出一个before end main，在这，然后我们执行了sp4.reset 这个时候啊，这是sp4啊，这个时候是sp4它放弃托管这个A(3)了 也就是这个A(3)，前面new出来这个A(3)啊，已经没有需要的ptr对象再托管它了 在这种情况下，A(3)就会自动被delete掉 就是你new出来的东西你交给需要的ptr对象托管啦 后来这些对象又放弃了托管，导致你new出来的东西已经没有人托管它啦，那这个new出来的东西就会被自动delete掉 表现在程序的输出，我们就看到在这个end main这条语句之前就输出了一个3 destructor 为什么会有3 destructor啊，就是前面new出来这个A(3)， 它被delete掉了，引发了析构函数的调用 然后输出end main，然后程序就结束啦 那程序结束了，那些前面出现的什么sp1,sp2,sp3就全部都消完了对吧，然后这些 前面那个new出来的A2是交给谁托管了呀，不是由sp3,sp2在托管它对吧 那是只要一个需要的ptr对象，它这个 它消完了，那它托管的那个指针就有可能被delete掉，为什么说是有可能而不是一定呢 因为有两个ptr对象可以同时托管一个指针对吧 那其中一个需要的ptr对象消完了它不应该把那个指针delete掉，那两个 托管同一指针的需要的ptr对象同时都消完了，那然后那个 先后都消完了，然后那个指针就没人托管了，在这种情况下 那个指针就会被delete掉 那当然我们这个程序结束的时候所有需要的ptr对象都消完，所以那个前面new出来的A 2也就会delete掉，虽然我们没有显示的去写delete什么 但是这个A2原来是交给sp2对象托管的，现在没人托管它了 那些需要的ptr的对象都消完了，那A2就会被自动delete掉，所以A2的 希望函数也会被调用，输出一个2 destructor 所以这个需要的ptr确实非常好使啊 
- 那这个智能指针使用上有一些需要注意的地方我们来看一下啊 
    ```C++
    #include <memory>
    #include <iostream>
    using namespace::std;
    struct A {
        ~A() { cout << "~A" << endl; }
    };

    int main()
    {
        A *p = new A();
        shared_ptr<A> ptr(p);
        shared_ptr<A> ptr2;
        ptr2.reset(p);              //并不增加 ptr 中对 p 的托管计数
        cout << "end" << endl;      //输出： end
                                    //      ~A
                                    //      ~A
        //之后程序崩溃，因为 p 被 delete 两次
        return 0;                                             
    }
    ```  
  这里有一个class A，它由析构函数输出这个波浪线A 然后我们这里new出来一个class A的对象 然后我们通过这个ptr托管了new出来的这个对象 然后我们又定义了一个ptr2，然后通过ptr.reset(p) 想让ptr2也托管p 那表面上看起来好像这个时候应该能够做到ptr和ptr2共同托管p 但实际上 事实上却不是这个关系，就是这个时候呢你这么做 的话呢，系统并不会去增加ptr中对p的托管技术 所以这个时候在整个系统看来吧，ptr 2它托管了一个指针，ptr1这前面的ptr也托管了一个指针 虽然这两个指针是同一个地址 但是呢，这个需要的ptr系统它不这么认为 它并不知道这里的p跟这里的p是相同的 在这个需要的ptr系统看来 其中有一个ptr指针托管了p,另外一个指针ptr也托管了另一个指针p,虽然这两个p内容是一样的 但是需要的ptr的系统它不知道这一点 那么在这种情况下呢，当这个ptr消完的时候就会delete这个p 所以我们看到，当整个main结束的时候两个 需要的ptr对象都会消完，但ptr对象消完的时候就delete p 就输出了一次波浪线A，调用这个析构函数一次 当这个ptr2也消完的时候呢，它又去delete p，又会调用了析构函数一次 然后这个程序输出这些东西以后就崩溃了，为什么就崩溃了呢 就是因为p被delete了两次，啊我们看到 new出来的一个指针你只能delete一次，你要是去delete它两次，程序就会崩溃 两个波浪线A都是在end这条语句之后出现的，也就是说意味着是在main结束的时候这两个ptr 消完的时候才进行的这个delete 关键就在于这条语句在执行的时候参数就是一个光秃秃的p 这个编译系统也好，还是需要的ptr的实现系统也好，他不会去判断这里的p跟前面某一个需要的ptr对象 所托管的那个p是不是相同的，不做这种判断，所以说 效果就变成了
- 下面我们再看这个空指针nullptr，原来我们在用空指针的时候直接就是大写的null就行了，现在呢我们有这个空指针可以使用了，就是nullptr，
    ```C++
    #include <memory>
    #include <iostream>
    using namespace::std;

    int main()
    {
        int *p1 = NULL;
        int *p2 = nullptr;
        shared_ptr<double> p3 = nullptr;

        if( p1 == p2 )
            cout << "euqal 1" << endl;

        if( p3 == nullptr )
            cout << "euqal 2" << endl;   

        if( p3 == p2 )                  //error, 类型不一致
                
        if( p3 == NULL )
            cout << "euqal 4" << endl; 
        
        bool b = nullptr;               //b = false
        int  i = nullptr;               //error, nullptr不能自动转换为整形 
        return 0;                                             
    }
    ```  
  那它的用法跟大写的NULL有相似之处啊，我们现在对指针进行初始化想把它初始化成空指针就有这两种办法，啊你可以写nullptr 包括对于一种shared ptr的对象我们也可以让 它等于nullptr，那它就没有初始化啊没有托管任何东西 然后像这个一个是这种null，另外一个是nullptr 它两个也可以判断是否相等，只要p1和p2是相同类型的指针就可以判断是否相等 那判断是否相等算出来的结果是相等，也就是这个程序会输出equal 1，在这啊 那如果你要判断p3是不是等于null ptr，当然也是相等的，前面就是这么初始化的对吧，所以就会输出 这个equal 2，那你要判断p3是否等于p2 这个编译是会出错的，因为p3它的类型是一个需要ptr 对象，跟p2类型根本就不匹配，当然编译就会出错，编译出错啊 如果我们判断p3是不是null，这个时候呢也会输出这个 相同，虽然这里p3是个需要的ptr的对象 由于它被初始化成nullptr，然后我们这边是一种空指针，肯定是个等等号是经过某种 形式的重载的，总之会认为p3和这个null是相等的，所以会输出equal 4 然后这个nullptr它可以被自动转换成一个bool类型的变量，然后转换的结果就是false 这样转换过去b就是false，但是nullptr不能被自动转化成一个 整形，写这样一条语句编译的时候就会出错的，这就是nullptr空指针 那这个nullptr你也不能说它有特别大的作用啊，就是从形式上看起来 会好一点，因为原来那个null吧它就 不能很充分的体现指针的这种特点吧 好下面还有一个好东西，
- 就是这个基于范围的for循环，它能够使得我们写for循环的时候 更轻松一些，我们看这个例子 
    ```C++
    #include <memory>
    #include <iostream>
    using namespace::std;

    struct A {
        int n;
        A(int i): n(i) {}
    };

    int main()
    {
        int ary[] = {1, 2, 3, 4, 5};
        for(int &e : ary)
            e *= 10;
        for(int e : ary)
            cout << e << ",";           // 10, 20, 30, 40, 50,
        cout << endl;
        vector<A> st(ary, ary + 5);
        for(auto &it : st)
            it.n *= 10;
        for(A it : st)
            cout << it.n << ",";        // 100, 200, 300, 400, 500,
        return 0;                                             
    }
    ```  
  这里面有一个class A，它有一个成员变量n在构造函数里面初始化了 然后我们这边有一个数组，ary，它里面有12345 现在我们就用新式的基于范围的for循环来便利这个数组，我们怎么写呢，for int&e ary然后e乘等于10 那我们先看这块到底是什么意思，这块的意思就是说，对于ary里面的每一个 元素依次进行，然后这个元素呢就变成是e 而且 这里写的&就说明这里e是那个元素的引用 那也就意味着当你修改e的时候，那个ary数组里面的元素也就被修改了 所以我们在这里在这个for循环里面执行了e乘等于10，由于这个e是引用 实际上这个时候就会对于这个数组里面的每一个元素一次都把它乘等于10 也就是说这个循环执行完以后吧，这个ary这个数组他就变成什么呢，他就变成了10,20,30,40,50了 好下面我们再变一次这个ary数组，只不过这个时候我们使用的这个 东西已经不是引用了 就是int，因为我们知道ary里面是int嘛 所以这块肯定写int，然后你这块可以写引用，如果你想改ary的值的话 如果你不想改ary的值你这里直接就不要写引用了 那现在我们在这个循环里面就把每一个ary数组的元素都给它输出了 ary数组元素就是e嘛，就是我们看到输出的结果就是10,20,30,40,50 好，再接着往下看，我们这里定义的一个vector st，这个st里面放着的内容就是把ary的给拷过来了对吧 那然后我们依然可以用这种基于范围的for循环去便利这个st 然后我甚至懒得指定这个 这个st里面的变量是什么类型，我就可以直接写auto and it 那这个it就代表这个st里面的变量 由于你这边写了&，所以说这it实际上就是代表st里面呢 每一个元素的引用，因此在这里我们让it.n乘等于10，实际上就会修改了st这个 vector里面的元素 那这个循环执行的结果就是，使得st里面的元素都被乘以10了 也就是st里面的元素就变成了什么100,200,300,400,500了 接下来我们就可以用另外一个循环来 输出st里面的内容，就这么写，这么写意味着对st里面每一个 元素，我们把这个元素称为it 那这个元素是A类型的，对吧 那我们前面这边写这个auto，是因为编译器它可以自动去判断，我们可以不写A 这里我们说对于st里面每一个元素it，就是A类型的，我们把这个it的n给它输出，那当然输出的结果就是 这个循环输出就是100，200， 300， 400， 500. 啊， 这个基于范围的for循环还是很不错的。 

- 嗯，那下面还有一个特别重要的这个概念呢叫做这个右值引用还有这个move语义，啊。右值引用。 嗯，那什么叫右值呢？一般来说你可以就是认为就是说如果一个 表达式能出现在等号的，赋值号的左边那它就是个左值。 它不能出现在赋值号的左边呢它就是个右值。你也可以说，如果一个地址不能，一个表达式不能取其地址， 那这个表达式就是一个右值。如果能取其地址，就是左值，啊。一般来说可以这么讲，哦。 嗯，那我们来看，如果有个class A，我们 并列一个class A 的引用。然后，让它等于这个临时的变量， 临时的class A的变量。这条语句编译是出错的。因为这个 A（）它是一个临时的变量，它没有名字。 实际上你也不可以取它的地址，嗯，你不能取它的地址，啊。 所以这个临时变量，这个A（）它是一个右值。 嗯，那我们，呃 前面学引用的时候，说的就是引用啦！没有说他是左值引用还是 右值引用。那在C++11里面引用了右值引用了这个概念以后， 那我们就的知道我们前面学到的那些引用，全部都是左值引用。所谓左值引用 就是说，它只能引用左值不能引用右值。那我们在这里定义的A&r，这个r 这个r是我们前面所学过的那种引用，对吧？那它就是一种左值引用。而我们这边这个A（） 是一个右值，它是临时变量无名变量是个右值。那么你在这里让一个左值引用去引用一个右值， 这个时候编译就会出错。那在C++11里面，就有右值引用这种东西。 那顾名思义右值引用就可以用来引用右值，对吧？ 那么在这里我们就定义了右值引用，右值引用个左值引用的区别 就是它有两个&号，啊。它不是引用了引用，啊，它是右值引用。 那现在这个r就是右值引用，那让我们来看等于A()， 诶，这就是可以的了，右值引用它可引用右值。 这么一看又好像很无聊，啊，拿这个右值引用到底是干嘛使的呢？ 实际上右值引用它的主要目的是提高程序的运行效率， 嗯，它能够减少需要进行深拷贝的对象进行深拷贝的次数。 嗯，那右值引用它的概念还挺复杂的。 如果大家要进行详细的了解，可以看我列出来的这连个参考，啊。 嗯，那右值引用， 嗯，它的作用是提高程序的效率。什么叫减少需要进行深拷贝的对象及深拷贝的次数呢？ 什么叫深拷贝啊？就是，就是如果你写了一个类，这个类里面有一个指针成员变量， 然后这个指针成员变量呢可能会指向动态分配的一个存储空间。 那么，在这种情况下当你这个类的赋值构造函数，啊，在对对象进行赋值的时候， 就不是进行浅拷贝。就是简简单单把两个字变得一模一样，这就叫浅拷贝。 这种情况下我们一般不会用浅拷贝，而会用深拷贝。也就是说，你要把A对象赋值到B，那你一般来说就需要把 A对象里面的那个指针指向了存储空间里面的东西也赋值到 B里面的那个指针所指向的存贮空间里面去，这就叫做深拷贝，那深拷贝很显然是很需要花费时间的，对吧？ 那又有的时候我们写了一个类，里面有指针成员变量， 可能在这个类的赋值构造函数，或者说赋值号被调用的过程中 需要进行深拷贝，这个效率就比较低。然后，有的深拷贝呢其实是不需要的。 那我们如何去去掉这种不需要的深拷贝，就是右值引用所做的事情。那实际上现在有一些编译器，它 它就就能够在某些情况下去自动的去优化，减少你做深拷贝的次数。 那C++11这个提供了右值引用和这边的move语句， 就让程序员自己可以有意识的进行减少这个深拷贝的操作。 那下面呢咱们来看看一个右值引用， 以提高程序效率的具体例子。啊，我们还是通过我们的老朋友就是自己写的这个String类 来进行这个说明，啊。
    ```C++
    #include <iostream>
    #include <string>
    #include <cstring>
    using namespace::std;

    class String{
        public:
            char *str;
            String(): str(new char[1]) { str[0] = 0; }
            String(const char *s) {
                str = new char[strlen(s) + 1];
                srcpy(str, s);
            }
            String(const String &s) {
                cout << "copy constructor called" << endl;
                str = new char[strlen(s.str) + 1];
                strcpy(str, s.str);
            }
            String &operator=(const String &s) {
                cout << "copy operator = called" << endl;
                if(str != s.str) {
                    delete [] str;
                    str = new char[strlen(s.str) + 1];
                    strcpy(str, s.str);
                }
                return *this;
            }
            //move construtor
            String(String &&s): str(s.str) {
                cout << "move constructor called" << endl;
                s.str = ew char[1];
                s.str[0] = 0;
            }
            //move assigment
            String &operator = (String &&s) {
                cout << "move operator = called" << endl;
                if (str != s.str) {
                    delete [] str;
                    str = s.str;
                    s.str = new char[1];
                    s.str[0] = 0;
                }
                return *this;
            }
            ~String() { delete [] str; }
    };

    template <class T>
    void MoveSwap(T &a, T &b)
    {
        T tmp(move(a));         // std::move(a) 为右值， 这里会调用 move construcor
        a = move(b);            // move(b) 为右值， 因此这里会调用 move assigment
        b = move(tmp);          // move(tmp) 为右值， 因此这里会调用 move assigment
    }

    int main()
    {
        // String &r = String("this");          //error
        String s;
        s = String("ok);                        // String("ok") 是右值 , 输出：move operator = called
        cout << "***************" << endl;
        String &&r = String("this");
        cout << r.str << endl;
        String s1 = "hello", s2 = "world";
        MoveSwap(s1, s2);
        cout << s2.str << endl;
        return 0;                                             
    }
    ```          
  那我们自己写的String类嘛里面就有一个 嗯， str这样一个指针成员变量，啊。它指向动态分类的存储空间。 存储空间。我们就用这个动态的存储空间用来放字符串。 所以我们在这个String的无参构造函数里面，我们就已经 动态分配存储空间就只有一个字符，这个字符就是0. 那么也就是说这个时候，这个str就指向一个空的字符串。 嗯，就是对于这种String的对象来说， 嗯，它既然代表一个字符串，那它里面起码也得是一个空串。 你让这个str在某种场合变成NULL 我认为是不太合理的这个设计。就让它，无论如何str都会指向一个字符串，啊。如果你 没有去显示的初始化它，它就只是个空串，这样子比较合理的。 如果str它总是指向一片存储空，那么，我们在定义了str 的时候都不用去判断它是不是NULL。反正就是会 省事儿。那我们再看这边，嗯，另外一个构造函数就是用一个 嗯，Const char*去初始化它，那当然我们就要把这个 str指向new出来的一片存储空间，它要足够大才能放的下 嗯，这个s的长度再加上1，啊，用来放那个iii的。然後，我们用strcopy把s的内容给拷过来就行了。 那有的同学在写这个题的时候可能 可能会去判断这个s是不是等等NULL，如果是等等NULL那就什么都不做，啊。 嗯，这个个人认为这是没有什么必要的，如果S等于NULL你就直接让它出错好了，算了，你不用管它。 嗯，说S等于NULL的时候，我还得处理一下他部署说，不，不。不要做这些事情。 你可以想象strcopy这个C语言的阔函数，如果你这块给的是NULL， 或者你这块给的是NULL它也一定出错的。strcopy在执行的过程中也不会去判断这两个参数到底是不是NULL。 所以该出错的地方就让它出错，啊，有的，有的责任是调用我们这个 函数或者是用我们这个类的程序员呢，我们就不必去为他去考虑问题。 我怕们就简单一点，根本就不用怕它s是不是NULL。 嗯，还有一个赋值构造函数在这儿，赋值构造函数我们输出一个copy constructor called。 然後我们这里当然也就新分配一个存储空间，要足够大，对吧？ 嗯，然后呢我们就把s 里面的str的内容给拷贝到这个str里面去，啊。这就完成了这个 赋值就是深拷贝。 我们在这里同样，我们也不用去判断s.str是不是NULL，为什么？ 因为s.str肯定不会是NULL。因为我们在String的所有的构造函数里面都使得 s.str不是NULL。所以，s.str不会是NULL。 嗯， 接下来再看有一个赋值号我们必须需要进行重载的。对不对？它可以 用于两个，嗯，String对象之间的赋值，两个String对象 之间互相赋值的话，我们知道是需要进行深拷贝的，啊。 所以我们得重载这个赋值号。先从一个copy operator=called，然后 就是要判断end赋值号两边的东西是同一个对象，那就不合适了。所以我们要判断 str是不是等于s.str。只有在不等的情况下，我们才需要做事情。 在这里我们就把原来str给它的delete掉，在这里我们也不用去判断 这个东西是不是等等NULL。为什么呢？因为我们的构造函数确保了这个东西不会是NULL。 所以我们直接定义它就行了。嗯，然後我们就新分配一个存储空间，啊，它足够大。 然後，把这个s.str的内容拷过来。嗯，这里s.str也不会是NULL。 所以这些带来很大的方便。然後最后return *this，它的返回就是引用。 这都是传统的写法啦！那现在有了右值引用以后呢， 嗯，我们可以先写一个 看上去很像赋值构造函数啊，但实际上不叫赋值构造函数，它叫移动构造函数。 因为就是说，它的参数是一个右值引用。啊，两个&的就是右值引用。 所以前面这里所提到的进行的是深拷贝，它是比较花时间的。现在我们想要像一个什么办法使得 在有些情况下呢我们不需要去进行这种深拷贝。而是进行所谓的移动的操作，啊。这就是所谓的移动语句。 所以我们写了一个移动的，这个，构造函数。 参数是一个右值引用，然後在这里面呢我直接就 把str指向了s.str指向的地方。就是这里是s, 嗯，它指向某一个存储空间。嗯，我这个 这是单填对象，我直接让它的str就指向了s指向的地方，对吧？ 嗯，这里并没有进行什么拷贝的操作，而是直接呢我们 对初始化的这个对象它的str 就指向了s.str指向的地方，然後输出一个move constructor called。 然後我们把s.str，把它要改变了。 让它指向一片新的存储空间，这存储空间里面放着一个空串。 这就是我们的移动，嗯，构造函数所做的事情，它并没有进行 深拷贝，对吧？这个深拷贝是很花时间的。 然後同理，我们还需要写一个所谓移动的赋值号。 这个移动的赋值号它接受的参数也是右值引用。 然後在这种情况下我们先输出一个move operator called。然後我们做的事情跟那个赋值有点像。 但是呢，由于这是一个赋值号，所以我们要看到赋值号两边的东西。 千万可别是同一个对象的，对吧，在不是同一个对象的情况下，我们就把 当前对象原有的存储空间给它缩回，delete掉对吧！然后我直接按当前的对象str就指向了这个 s.str指向对象,然后我把s.str对象让它指向新分配的存储空间，里面放一个空串， 这个就是移动的赋值号。 然后接下来就是一个虚构函数，啊，这个虚构函数呢就直接delete str就行了，你也不用判断这个东西是什么， 好，呃， 那我们现在写出了这个iii,它加，加入了，所谓的移动赋值 号和移动构造函数，那我们看看这么写法的时序类 用起来的时候，它在什么情况下能够避免不必要的 生拷贝呢？我们看，接着往下看，在这里我们写了一个模版， 这个模版叫做moveswap就是 交换，它的作用是交换，a b两个实参的这个内容， 呃，但是它不会去进行生拷贝，而是进行所谓的，移动语义，所以我们称之为moveswap。 在这里面做了什么事情呢？先来一个临时变量temp，它是T类型的， 然后我们呃，对这个temp进行初始化的时候，写的是move A， 那同学们知道如果我们这里不写moveA而是直接写A的话，那这个temp是用什么构造函数来初始化呢？ 当然就用赋值构造函数初始化对吧。 那如果你的赋值构造函数里面进行了生拷贝操作的话，那么这条语句就会引发生拷贝，那就会比较耗时。 但是我们这里写的并不是A而是move A，这个move是个什么东西呢？ move在str里面定义好的一个函数模板， 这个move的作用是把一个左值引用 或者把一个左值变成一个右值， 啊，就是说，这个A是一个左值， 啊，或者叫左值引用，左值引用也是左值吧，呃，那我们， 经过一个move的操作，这个move表达式它的返回值就变成一个右值了， 那它同样是a，但它是一个右值， 那由于这个表达式的返回值是一个右值， 那我们前面所看到的普通构造函数，它的参数是 左值引用，所以在这一块就不会调用赋值构造函数了，那它会调用哪一个构造函数呢？ 呃，就会调用我们前面所看到的这个 移动构造函数，因为我们这个移动构造函数，它的参数是一个右值引用，右值引用能够跟右值匹配。 那这个move a 是个右值，那我们应该调用移动构造函数，因为移动构造函数，它的参数是一个右值的 这个引用，跟这个右值啊，是匹配的。 那么也就是说，这个temp是用这个 移动构造函数初始化的，那在temp执行期间，我们考察一下发生了什么事情 就在这，并没有进行生拷贝的操作，对吧，但是它呢， 确实是把参数的内容， 它是让这个s就指向了，这个，它是让当前对象的s对象就指向了参数 s.str所指向的地方，然后它修改了参数的str指向的地方。啊 那也就是说经过这条执行的语句以后呢， 这个temp里面的这个，temp里面的这个str就会指向了原来 a.str所指向的那个地方，是吧。而且呢， a.str就被改成指向一个新的地方了，这就是， 这条初始化语句的效果，啊，它跟调用赋值构造函数相比呢， 它的效率更高，它 没有进行生拷贝，但是，它改变了a的内容， 那改变了a的内容，a的内容被改变了会不会变成一个问题呢？那就取决于 这个a会是一个什么东西了，对吧，如果a是一个临时变量， 它本来以后就再也不会用，是吧，那你把它的内容改变掉，当然就不会有什么问题对吧，那如果a它不是一个临时变量， 那这个时候就会出问题了，啊，就不合适了。好那么我们接下来看a等于move b, 啊那这个时候move b 这个东西返回值，它又是一个右值， 所以在这里，a等于move b,它不会调用我们前面的那个 传统的operator等于，而调用在这里的 move assignment。因为这里的参数是一个右值引用。 是一个move b 这个表达式是一个右值，所以它跟前面那个参数为，呃，这个 左值引用的这个operator等于是不匹配的，它跟参数为右值引用的operator等于是匹配的。 所以这个a等于move b会调用这个move assignment， 那么move assignment所做的事情跟刚才的赋值构造函数是很像的，对吧， 它直接让a的str指向了b的str指向的地方， 然后又让b呢，它里面的str指向了一个新的地方，啊，那新的地方里面放着一个空算， 这里面当然就没有进行这个生拷贝，提高了效率， 但是它改变了b的内容， 那改天b的内容在什么情况下不会造成麻烦呢？就是说b它本来就是一个临时对象， 它以后再也不会用到了，它很快就要，就要被销亡了，那你改了它，反正以后也不会用到它，那就无所谓了，对吧。 所以b应该是这个临时对象，这样的东西才不会有问题。 那b等于move temp就类似了，对吧，temp是一个左值经过move temp，它就 变成一个右值了，所以在这里也会执行这个move assignment， 那总而言之，现在在这里被调用的就是两个move assignment 和一个move contructor 在这个过程中一次生拷贝都没有进行， 那如果按照我们传统的写法你把这个，这个move都去掉直接就写abtemp的话，那么就会 怎么样呢？就会调用一次赋值构造函数，呃，调用两次传统的那个赋值号， 这样就会进行三次生拷贝的这个操作，当然效率就比这中moveswap要 低了，对吧。但是你能， 一定要注意你能使用这种move swap有个前提，这个前提就是这个a b的值，你不在乎它会被修改， 修改掉了不会有麻烦，那如果ab本身就是个临时变量，那你修改它们，当然就不会有麻烦了。 好了，我们就看这个move swap在什么情况下能起作用啊。 好，我们再看这个main里面，main里面我们再回顾一下右值引用的这个概念啊，比如说我们来了一个， 在这边定义了一个临时的对象，那它就是一个右值，那如果你洗写string & r 等于这个右值，这就会是错误的，因为这是一个左值引用，左值引用而这边是一个右值，这就是错的。 那我们来一个这个string s, 然后我们来s等于string OK啊这条语句，就是没问题的。 呃，而且这个时候呢，到底是哪一个啊operator等于被调用的呢， 由于我们这个string OK 是可以是一个临时变量， 它没有名字，它是一个右值，所以此处实际上是会调用那个 前面看到的，move operator等于，因此我们看到， 啊，因此我们看到啊这个程序在*之前就输出了一行move operator= called... 啊在这里，是调用的那个参数为右值的那个，那个赋值重载运算符。 好，接下来我们输出*，然后我们让一个右值引用， 把它等于一个这个临时的这个变量， 然后还可以输出这个临时变量， 输出r.str，我们发现输出的内容就是b,啊就这个名词变量它的引用还在起作用，还在引用这个临时变量， 然后我们让这个string s1, s2啊，呃，它这个分别是 等于hello和world，然后我们调用了moveswap（s1,s2） 那我们调用moveswap（s1,s2）的话呢， 呃，我们在输出， s2的内容，就发现已经是变成hello了，然后在moveswap执行的过程中 我们发现啊调用了一次move contructor, 就是move构造函数调用了两次这个 move的这个这个，调用了两次move的这个赋值运算符对吧。 然后s1，和s2内容被交换了啊，然后输出一个hello， 那，那我们写这样的代码的时候，实际上就是， 我这个程序员在有意识地避免生拷贝，是不是这样的， 那就是说这个s在moveswap执行的过程中 执行到这条语句的时候 a就已经被改了，也就是说这个s1就已经被改了。 但是我不在乎，为什么？反正我这个s1就是要跟s2内容交换的， 你把s1临时改成一个共算无所谓，等会它还能够变回来。对吧， 因此在这种情况下，我们调用move swap 虽然在执行 moveswap 过程中啊，ab都被临时地意外修改成了一个空算， 但这并不影响我们的程序运行的结果，反正s1 s2 就是那个ab本来就都是要内容被修改的。你在这个中间的过程中把它改成一个 别的什么空算，不影响最后的结果是不无关系的，带来的好处就是我们避免掉了在s1 s2的交换过程中 那种三次生拷贝，这当然就提高了程序的执行效率，对吧。所以这个我们这么做是没有问题的。 那我们就看到这个所谓的move语义 就是，就是通过这个operator等于 右值引用的operator等于和这种 move constructor它们体现出来的， 它和右值引用一块使呢， 就能够做到确实避免生拷贝的这种效果。才能够有效地提高程序的执行效率。 
## 2. C++11新特征（续）
- 那c++11不但对c++的语法从核心上做了很多的改进 他还对c++的标准库也做了一些扩充，比方说他把st1 新加进了一些类模板，其中有一个特别好用大家呼声一直很高想要有的就是这个 哈希表，也就是无序容器 哈希表无序容器呢他是在头文件unordered map里面包含了 就这个哈希表它的用法和功能跟map是一模一样的 区别就在于哈希表它的时间效率要比map更高 哈希表是一种数据结构啦，具体 他是怎么实现的是属于数据结构的内容我在这里就不说了啊 但我们知道这个 unordered map这个东西跟map的用法是一模一样的，但是它的效率比map更高，我们知道map在进行插入元素和查找的时候时间复杂度是什么呀，是logN的对吧 那这个unordered map哈希表它进行插入和查找的时候 时间复杂度都几乎就是常数的，这就是哈希表最大的好处 那我们来看一下哈希表的例子，
    ```C++
    //哈希表的插入和查询时间复杂度几乎是常数
    #include <string>
    #include <unordered_map>            //无序容器（哈希表）
    #include <iostream>
    using namespace::std;

    int main()
    {
        unordered_map<string, int> turingWinner;    //图灵奖获奖名单
        turingWinner.insert(make_pair("Dijkstra", 1972));
        turingWinner.insert(make_pair("Scott", 1976));
        turingWinner.insert(make_pair("Wilkes", 1967));
        turingWinner.insert(make_pair("Hamming", 1968));
        turingWinner["Ritchie"] = 1983;     //如果turning winner里面还没有一个元素它的关键字 也就是first成员变量是richie的话 那么，有一个新的元素就会被插入到这个                                          //turningWinner里面去，这个新元素它的 first成员变量就是是richie，然后它的second被复制成了1983
        string name;
        cin >> name;
        unordered_map<string, int>::iterator p = turingWinner.find(name);
        //据姓名查询获奖时间
        if (p != turingWinner.end())
            cout << p->second;
        else 
            cout << "Not Found" << endl;
        return 0;                                             
    }
    ```  
  在这里我们定义一个unordered map 叫做Turing winner ，我们用这个容器来记录 图灵奖的获奖者然后可以根据 获奖者的姓名去查找他获奖的年龄 这个每个元素就放着一个获奖者的姓名和他获奖的年龄 获奖的年份不是年龄啊 好，下面这个turning winner insert make pain dijkstra 1972就是dijkstra1972年获得的图灵奖 好那这个用法不是跟map一模一样的对吧 它里面ordered map里面也不能有这个重复元素的啊重复的 关键字相同的元素的，然后就是insert Scott wilkes hamming等等啊 还有这个Richie，我们看到，这个用法跟map也是一样的 就是，可以直接通过 关键字作为下标去对一个元素的值进行访问 那么在这里，如果turning winner里面还没有一个元素它的关键字 也就是first成员变量是richie的话 那么，有一个新的元素就会被插入到这个 turning winner里面去，这个新元素它的 first成员变量就是是richie，然后它的second被复制成了1983 接下来我们就可以输入一个姓名然后去 对这个turning winner这个容器进行查找 查找的方式跟map也是一样，定义一个迭代器，啊这里写auto的话就更简单了是吧 然后用turning winner的find成员函数去进行查找 如果 如果查找的结果不是这个 and的话那就说明找到，那我们就输出它的 获奖年份，找不到就输出not found，我看到这个用法跟map是 一模一样的，但是它内部的实现机制跟map是不一样 map是用平衡二叉树实现的，那这个 auto the map是用哈希表实现的，所以它的时间效率更高 但它时间效率更高也不是没有代价的，那就是 哈希表需要很多的内存空间，他所需要的内存空间会比map 多得多，但一般来说我们 计算机的内存总是够用的，就是时间往往是更优先于内存空间去考虑的 所以这个哈希表还是比map用起来可以说更爽一些吧 
  
- 下面再看一个c++11在这个库方面的改进，就是引入了正则表达式这个东西 要使用正则表达式include头文件regex,那什么叫正则表达式呢 你可以认为正则表达式实际上他就是一个字符串，这个字符串描述了一种模式 它描述的是一种字符串的模式，那比方说 我们在这里定义了一个regex,这regex就是正则表达式的类，那这里reg就是正则表达式对象 然后我们用一个字符串去对这个对象进行初始化，
    ```C++
    //正则表达式
    #include <regex>
    #include <iostream>
    using namespace::std;

    int main()
    {
        regex reg("b.?p.*k");
        cout << regex_match("bopggk", reg) << endl;         //输出 1， 表示匹配成功
        cout << regex_match("boopgggk", reg) << endl;       //输出 0， 表示匹配失败
        cout << regex_match("b pk", reg) << endl;           //输出 1， 表示匹配成功
        regex reg2("\\d{3}([a-zA-Z]+).(\\d{2}|N/A\\s\\1)");
        string correct = "123Hello N/A hello";
        string incorrect = "123Hello 12 hello";
        cout << regex_match("correct", reg2) << endl;       //输出 1， 表示匹配成功
        cout << regex_match("incorrect", reg2) << endl;     //输出 0， 表示匹配成功
        return 0;                                             
    }
    ```  
  那reg就是一个正则表达式，它代表了一种模式 一种字符串的模式，这个字符串的模式呢，是跟这个 是被这个b点什么问号 是由这个b点问号p点*k来说明的 那这串东西说明了一种什么样的模式呢 它代表某一类的字符串，这类字符串有以下特点，什么特点呢，这个字符串必须是以b开头 然后呢这个点呢他是代表任意字符，也就是b后面跟任意字符 然后这个问号就表示刚才这个任意字符它应该出现这个 0次或者是1次，只能是0次或者是1次，刚才这个任意字符可以出现0次或者1次 然后下面就是一个P，那等于就是说在b和 p之间可以有0个或者1个字符 然后这里点就说明这里可以出现任意字符，这*就是说的是 刚才这个任意的字符可以出现0次或者是任意多次 然后呢紧接着就是一个k，那就是说p和k之间可以出现相同的 字符，任意多次，或者是没有字符 那么这个 字符串常量也就是这个正则表达式所对应的那个字符串的模式是什么呢 就是说以b开头，然后后面跟着 0个或一个字符，然后再是一个p，然后后面再跟着 0个或者是任意多个相同的字符，然后面再跟着一个k,就是这个意思 那好了，我们定义了一个正则表达式以后呢，我们就可以用reg match这个 函数，去判断某一个指定的字符串是不是 能跟这个正则表达式相匹配，相匹配的意思就是这个字符串符合这个正则表达式所规定的那一种模式 如果能够匹配的话这个 常数调用它的的返回值就是1，不匹配的返回值就是0，那我们看这个bopggk是不是符合 这种模式呢，它是以b打头的，然后后面跟着一个o字符，出现了一次对吧，然后接着就是一个p 然后有一个g，它出现了两次，这符合新的这个定义对吧，所以说 这条语句会输出1，表示这个bopggk它是符合reg所规定的这个模式的 那下面这条语句呢输出0，它的意思就是说boopgggk 它不符合reg所定义的模式，在什么地方不符合啊 这块说了，这里是一个字符，它出现，这个字符呢得出现 0次或者1次，而你这里出现了两个o，b和p之间有两个字符，这就不匹配了 那包括下面这个b空格pk 那它是不是匹配呢，它是匹配的，他为什么是匹配啊，因为空格嘛出现了一次没问题对吧 出现相同的字符若干次或者什么字符都不出现 也可以，那我这里p和k之间没有字符啊，就符合这个条件，所以就没有问题 那就是说这个正则表达式吧 它所代表的这个模式可以非常复杂，比方说下面我们定义的另外一个正则表达式reg2 他就规定了一种字符串的模式，这种模式呢我们用这一大串东西来代表 额 这一大串东西代表什么呢，那我们就一个个看啊，这里是两个斜杠 那我们知道在c++里面的字符串你要是一个斜杠的话他就被表示成两个斜杠对吧 所以这两个斜杠实际上是代表杠d的，那这个杠d是什么呢，杠d代表 数字，啊就是0到9，然后这个花括号3，就代表刚才那个东西应该出现3次 那也就是说，这个模式所对应的字符串它应该是以三个数字打头 好了接下来，有一个圆括号，这个圆括号就代表项 就代表里面的东西是一个项，这个项在后面可能还会引用到，反正圆括号代表一个项 括号本身并不要跟任何东西匹配，圆括号本身并不需要跟任何 东西匹配，它指明在这里要出现里面这一项，那里面这一项又是什么呢 里面这一项这有一个中括号 然后里面写着a到z，就说明整个中括号这一块代表 字母，就是这个项是由什么组成的啊，它是由 字母，出现 一次或者若干次组成的，这个加号代表什么啊，这个加号代表它前面的东西必须出现 一次或者是任意多次 那它前面东西是什么呢，用中括号表明，就说明这前面这东西是小写的a到z和大写的a到z，也就是 通常的英文字母，所以这个项 代表什么呀，就是一个英文单词，就是完全由大小写字母组成的英文单词 这个英文单词长度至少是1，这就是这个项 的含义，然后下面有一个点，点就代表这个地方可以出现任意一个字符 再接下来就是第二项了 第二项呢是什么样呢，第二项中间有一个竖线，这个竖线是或的意义，就是第二项它 可以是杠d花括号2，也可以是这个N杠A 啊，那这个“\\d{2}”，{2}代表什么呢？就代表两个数字。 啊，那这个“N/A”它就是N/A了，它没有别的意思，就是，就是N/A，这个字符串 反正这里的第二项，它要么是两个数字，要么是N /A。然后接下来这个“\\S”，“\\S就是空格，啊然后“\\1” “\\1”就代表第一项，啊就是在这个 地方出现的东西必须跟刚才这个第一项，在这里 出现的东西是一模一样。啊这个就是 整个这个，这个模式串它的这个含义。那这个正确表达式的这种 什么，呃什么方括号代表什么，“\\d”代表什么，它是很复杂的，有一系列的这个规定，写出来有好几页纸。 这个我没法在这里细说啦，大家真正要用的时候得去 查那个文档，因为这些东西它挺不好记的啊。那下面我们看 呃，有一个string correct,啊，这个string correct它是能够跟这个reg2 所代表的模式能配得上的，而这个incorrect是配不上，所以我们在，在 在输出regex_match(correct,reg2)的时候自然就会输出1 因为这个，这个correct是能够配上，而incorrect是配不上的。 那correct为什么能够配得上呢？我们逐个分析，这“\\d{3}”不是 说是3个数字对吧？然后这个，嗯这个第一项不是说是一个英文单词吗所以就Hello 它是一个英文单词没问题对吧？然后这里说是出现一个字符诶那我这个字符是个空格也没问题，然后然后这里的第二项 是两个数字或者是N/A，诶那我这里是个N/A能够匹配得上对吧 然后这里说来一个空格，啊我这里确实有一个空格啊，这也没有问题，然后呢 接下来这个 “\\1”说明这里应该出现第一项，那刚才第一项不是一个Hello吗 诶这里正好有一个Hello,所以就完全匹配得上。但这个incorrect它是 呃，匹配不上的，啊为什么呢？ 诶我们看到，呃这个123Hello都没问题，然后这个空格也没问题，然后这一块，诶写的是12，也没有问题 因为第二项它可以是两个数字或者是N/A，那我写的是12也没问题，然后这里\\s是个空格也没问题，但是这一块的是小写的 hello,啊，而我们这里要求的是出现的第一项，而我们的第一项是这个Hello H是大写的，这一块是小写的，这个就匹配不上，所以incorrect这个字符串 是没法跟reg2匹配的。那正则 表达式它使用很灵活啦，我这里只仅仅列出了一点点 让同学们对这个正则表达式有那么一点印象，就是说它可以用来做 呃，字符串的匹配，只不过这个字符串 不是一模一样去匹配了，而是看这个字符串是不是符合某种模式 啊，实际上它还有，正则表达式还有其他的这个功能，那我们就，在这里就 时间所限呢就不做了。

- 那最后我们 再介绍C++1里面一个特别酷的东西，叫做这个Lambda表达式。 啊这个Lambda表达式这个概念呢是从那个函数是程序设计语言，就是list那边过来的。那这个Lambda表达式 需要解决的问题是什么呢？啊就是我们在 使用这个换，换新程序设计使用S1的时候啊我们经常会用到 函数对象，啊我们用到一个函数对象呢，我们要专门编写一个类，对吧？那可能有的 函数对象我只在这个地方用一次，我还得到别处去把这个类也定义一下，然后后来别人看我的程序的时候看到了这个函数对象 他也到前面去翻，啊这个函数对象所指的类到底是怎么样，是不是挺讨厌对吧？ 然后你用了一大堆的函数对象，很可能你的程序里面就出现了一大堆的函数对象类，这个看上去也 挺烦的，啊，所以，能不能我们减少 定义函数对象类？啊，不要定义那么多函数对象类 这样使我们的程序看得精神一点，尤其是只用一次的函数对象，我们跑别处 专门分一个类，这确实太浪费了；那同理，就是说有的简单的函数我可能只调用一次我也得在 呃，所有的呃函数外面，专门定义一下，这个反正呢 也挺烦的，啊，就是说如果有的函数只用一次，而且又很简单，我是不是能够在调用的时候 就直接把它函数体写出来啦？啊不需要拿到外面再去写这个函数啦。 那Lambda表达式就能解决这种问题，啊它能够使得程序的可读性更好，更容易 理解。实际上java里面就有类似的这种语法啦，啊 但它不叫Lambda表达式，java里面也是可以，呃 拿一整个函数的函数体作为参数去，去调用某个函数的iii 那这个Lambda表达式啊它本质上就是一个函数，所以它写起来也像是一个函数，
    ```C++
    //Lambda 表达式
    形式：
    [外部变量访问方式说明符](参数表) -> 返回值类型
    {
        语句组
    }

    [=]         以传值形式使用所有外部变量
    []          不使用任何外部变量
    [&]         以引用形式使用所有外部变量
    [x, &y]     x 以传值形式使用， y 以引用形式使用
    [=, &x, &y] x, y 以引用形式使用， 其余变量以传值形式使用
    [&, x, y]   x, y 以传值形式使用， 其余变量以引用形式使用
    "-> 返回值类型" 也可以不写， 没有则编译器自动判断返回值类型。
    ```
  啊它是以所谓的这个这个外部变量访问方式说明符开头，然后后面跟着一个函数的参数表，然后箭号后面还可以 跟返回值类型，那这一部分呢 呃也可以不写，呃没有的话编译器可以自动根据return语句后面东西来判断这个函数的返回值类型。然后里面就是语句组啊 就跟函数里面的语句是一样的。 那么这一块这个外部变量访问说明符，它可以是下面这几种形式啊，呃比如说 写个“=”就意味着以传值的形式使用所有的外部变量，那什么叫外部变量啊？呃就是这个Lambda 表达式吧它一般是出现在一个函数内部的，那么 只要不是在Lambda表达式里面定义的变量 都称为外部变量，那外部变量就可以是全局变量，也可以是调用了这个Lambda 表达式的那个函数里面定义的局部变量，反正只要有定义就可以啦，啊就可以在这里面 使用外部变量。那使用外部变量可以有两种方式，一种是传值，一种是传引用，如果是传值方式使用的话 Lambda表达式内部就不允许去修改这个外部变量的值，而且以传值方式 使用的话，如果那个外部变量是个对象，那就会 有可能引发，复制过多函数的调用，啊因为要传值嘛，呃那 Lambda表达式也可以传引用的方式使用外部变量，那以传引用的方式使用的话，呃这块儿就写个 “&”就行啦，以传引用方式使用外部变量，外部变量就可以在 Lambda表达式执行的过程中被修改，当然你也可以 这一块写个空的“[ ]”，这就意味着我这个Lambda表达式啊，它不使用任何外部变量，那 这个外部变量访问方式说明符还可以比较复杂，比如说[x,&y] 这就是说，呃我这个Lambda表达式要以x 要以传值的方式使用x这个外部变量，但是呢以引用的话呢 使用外部的变量，那其他变量不用。 你可以写[=，&x,&y]就意味
    ```C++
    //Lambda 表达式
    int main()
    {
        int x = 1, y = 2, z = 3;
        cout << [](double a, double b) { return a + b; } (1.2, 2.5) << endl;
        auto ff = [=, &y, &z](int n) {
            cout << x << endl;
            y++;
            z++;
            return n * n;
        };
        cout << ff(15) << endl;
        cout << y << "," << z << endl;
    }
    ```  
  啊这里定义了，面里面 定义了3个变量:x,y,z,接下来我们就调用了一个Lambda表达式，在这，啊这个Lambda表达式呢它当然是没有名字的 它有两个参数:double a,double b 然后它的函数的代码是return a+b,那 再下面呢不是Lambda表达式的一部分啊,它是调用这个Lambda表达式的时候所给的这个参数，就是1，2,2,5 那这个Lambda表达式它的返回值当然就是3.7，所以这条语句就会输出3.7，啊这儿，我们看到 使用到了这个Lambda表达式，这个Lambda表达式内部不使用任何外部变量，所以可以[]。下面，这又是 一个Lambda表达式，在这一块，啊，这是一个Lambda表达式，它有一个整形参数 然后呢它，呃它用到了外部变量，就是 y和z是以引用的方式来使用的，其他的外部变量是用 传值的方式来使用的，而在这里面呢输出了x,那这个x就是这一块的x啦，然后呢 呃又修改了y和z,嗯然后返回n的平方，啊那我们 可以把这个Lambda表达式整个赋值给一个变量ff，那这个ff到底是什么类型的呢？搞不清楚，我们就偷懒一点 我们写个auto吧，那么编译器就自动会给ff一个适当的类型 那ff在这里看上去有点像函数指针对吧，因为 Lambda表达式本质上就是一个函数，好了我们把这个Lambda表达式啊 赋值给ff,那这条赋值语句并不导致这个Lambda表达式被调用，那我们要调动它怎么办呢？ 我就可以写ff(15)这就调用了这个Lambda表达式啦，有点像函数指针的用法；那调用这个表达式以后 执行这些语句，然后就会输出x,x是100，然后呢把y和z的值 修改了，然后返回n平方，就是15的平方，然后输出，那当然就是225 然后y和z的值都被加1了嘛，你再把它输出就是201,301 那刚才那两个例子只是说明了Lambda表达式的用法，并没有体现出 很明显的优势。啊下面我们就要看看Lambda表达式到底真正能够起到什么好的 作用。啊，这里有一个数组a,呃然后我们 现在要做的事情呢是用sort这个算法 把这个数组a呀，按照个位数从小到大进行排序，呃那前两个 参数当然就是a和a+4啦，那如果按照前面的做法，我们sort的第3个参数 这一块就应该写一个函数的名字或者写一个函数对象对吧？ 如果写函数对象的话，你就在这个函数对象类的那个中括号那个地方 啊圆括号那个地方指明这个比较大小的规则。 那反正你要写一个函数或者函数对象类 写到外面比较啰嗦，如果我这个，这种排序方式只做一次，你还要专门去写就很麻烦。 那要用Lambda表达式的话呢就可以把整个比较大小的规则就全部写在这儿了，在这里我们写了一个Lambda表达式 这个Lambda表达式呢它是由两个参数x和y,那返回值是bool类型的。 然后呢，它返回的就是，第一个参数的个位数，是不是小于第二个参数的个位数， 也就是说，它规定了一种比大小的规则。那这个 sort 在 执行期间，需要比较两个元素 x ，y 的大小的时候呢， 就会调用这个任务的表达式，并且以 x ，y 作为参数， 然后看这个返回值，如果返回值是 true ，那就认为 x 小于 y。 那这样的规则实际上就是按个位数从小到大排序。 呃，那这条语句总之就对 a 进行排序了。下面呢，for each ， 对这个 a 进行一下处理，遍历这个 a 啊， 呃，在这里呢，对这个区间里面的每一个元素，都要， 以其为参数，去调用这个 lembda 表达式。这个 lembda 表达式呢， 有一个参数 x ，然后它输出了 x 的值。那 for each 在执行的过程中，对每一个元素， 都调用了这个 lembda 表达式，并且以 x ，以这个元素作为参数，x 就是元素嘛，那当然会把每个元素都输出啦。 所以这个程序的输出结果就是 11，2，33，4。 再看一个例子。在这个例子里面呢， 我们看有一个 vector，啊， 它里面是 1，2，3，4。 然后有个 total ，一开始初始值0。 然后 for each 对这个 vector a 里面的元素进行遍历，啊，对每一个元素都做某种操作。 这个，这个操作呢，就是通过这个 lembda 表达式来进行体现的。 这个 lembda 表达式，这里写了一个 ＆，就意味着我这里面需要以引用的方式去使用外部变量。 然后这个 lembda 表达式有一个参数 x ， 而且这个参数是引用的形式，呃， 这意味着什么呢，就是 for each， 对于 a 里面的每一个元素，都会以这个元素作为参数去调用这个 lembda 表达式。也就是说，这个时候 x 是， a 里面的元素啦，可是这时候，可是这时候，我们这个 x 是传引用的，也就是说我们在这个 lembd 表达式里面，如果修改了 x 的值， 这个 vector 里面的元素，就会被修改了。那我们看这个 lembda 表达式做什么。 它把 x 的值先加到 total 上面，然后把 x 乘以 2， 那么，呃，这个 for each 循环执行完的话呢，呃，遍历执行完了以后呢，肯定就会把这个，呃，数组里面， 所有被修改之前的元素的值，都加到了这个 total 上面，对吧？等于就是对这个数组进行求和。 然后每一个元素呢还被 double 了，乘以2了，所有我们输出 total 呢就是1 一直加到 4 ，就是 10。 然后下面这个 for each ，就是对这个 a 里面， 的每一个元素 x 都调用，呃，这个 lembda 表达式，啊，并且把这个 x 的，给它，值给它输出了， 那当然，这个程序的输出结果，后面就是2，4，6，8。 呃，那 lembda 表达式还可以实现递归的这个功能，啊，这个， 写法看上去比较奇葩，我们来看一下啊。呃， 在这里，我们写个 f ，function，int，int，fib， 啊。呃，这个 function int int fib 是个什么意思呢？ 它实际上表示一个，一种类型，这种类型类似于这个函数，或者函数指针啊。 它表示一个返回值为 int，有一个参，int 参数的函数，返回值 int 是在这个地方体现的。 有一个 int 参数是这个圆括号里面只有一个 int ，所以这就是，它要有一个 int 参数。 好，现在我们定义的这种， 类似于函数或者是什么，lembda 表达式这样一种类型的东西，叫作 fib，fib 是个变量。 然后我对 fib 这个变量进行初始化，我怎么初始化呢? 我用一个 lembda 表达式对这个 fib 变量进行初始化。 那对于这个 lembda 表达式来说，这个 fib 就是外部变量，对吧？ 然后我们在这个 lembda 表达式的开头，我说了，唉，我这个 lembda 里面要使用 fib 这个外部变量， 而且是以引用的方式来使用的哦。然后这个 lembda 表达式它的参数就是 n 。然后这个 lembda 表达式里面干什么呢？ 它不是要求斐波那契数列的第 n 项，对吧？那就首先判断 n 是不是小于等于2 ，如果是第1项和第2项的话， 那就返回1就完了。那如果这个 n 是大于等于3呢？呃，那么第 n 项就是， 前两项之和，那怎么表示前两项之和啊，呃，我们就递归调用 fib ， 并且以 n-1 作为参数， fib 以 n-2 作为参数了，这就是递归了，对不对啊？因为 fib 是什么？ fib 就是 整个这个 lembda 表达式，对吧？所以我们在这里写了 fib， 就等于又调用了这整个 lembda 表达式， 这就实现了这个递归。呃，那我们要真正调用 fib 的时候，就， 这时候就这么做了， 就 fib 5，这就求出了第5 项，然后输出就是5 啦。 那这里面有一个问题，就是，啊，这个东西写起来好麻烦啊，我能不能这个不写，我也写个 all too？ 唉，让编译器自动去判断这个 fib 的类型，我们岂不是就省事儿了对吧？这么做行不行呢？ 啊，实际上是不可以的，为什么呢？ 你想啊，编译器要判断 fib 类型的时候，它根据什么呀？ 它根据你这里 return 的这个返回值，对吧？ 那你 return 的返回值它是有可能是 fib n-1，再加上 fib n -2 的。 那在这种情况下，你要求这个 fib 的类型，还得 依赖于这个 fib 算出来的这个表达式的类型，才行。 这不就循环了，对吧？要求 fib 的类型，就得先知道 fib 的类型，这算什么啊？ 所以，编译器没有办法完成这个任务，你得自己把这个 fib 的类型给它写好啦。 那这个功能强大的 lembda 表达式就说完了，实际上我们整个C++ 11的 这个新特性就讲这么多了， 那么现在的 C++ 的编译器，比如说 GCC4.8，什么 ES2013 什么的啊， 对 C++11的特性都支持得非常好啦，大家可以放心大胆地使用这些很强的功能，enjoy it ，bye bye！ 
## 3. 强制类型转换
- 同学们好啊,现在我们说说强制类型转换， 这个C++里面强制类型转换的话呢，它有呃，四种运算符可以使用， 就这个static_cast ,，interpret_cast，const_cast，和dynamic_cast 这几个东西特别让人觉得容易混淆到底它们的区别在什么地方呢？什么场合去用这些东西呢？ 这个还真是很容易搞混的一件事情。 
- 那我们就以依次地说一说先说这个static_cast， 叫做静态的转换。呃，它用进行比较自然的和低风险的转换， 比方说整型，实数型，字符型之间的相互转换， 什么叫低风险的转换啊，就是类型转换， 是有风险的，简单的风险比方说你把浮点数转换成整型的话， 就会损失精度，这也算是一种风险，你以后再拿这个转换过来的整数去算可能跟用浮点数相比肯定精度就损失了。 结果就有可能不正确，然后我们知道， 你如果，发一个这个，派生类的指针 强制转换成，呃，如果你把一个基类的指针强制转化成一个派生类的指针， 然后你就， 使用这个派生类的指针，而这个指针此时实际上指向的是一个基类的对象， 那么你这个时候在使用，把它当派生类的指针来使的时候，你可能就用到派生类的成员函数， 这时候就会可能出错， 总之各种类型的自动转化或者强制转换，它是有可能带来一些风险的， 这些风险的程度是不一样的， 比方说整型和实数型之间转换，字符型之间的转换 这样的风险就比较小一点，而指针之间的转换，它的风险就比较大一些。 呃， 本来强制类型的转换，用名字就可以了，对吧，你可以写什么，比如说， int（X），这就把X转化成int了，或者你写这个（int）X， 也能把X转化成int，对吧， 呃，哪怕你写这个（A）X，也能把X全部转化成class A 的这种类型， 当然这里面这个，你得把A这个类型转化成重载才可以， 那有了这些类型强制转换的方式，就我们以前用的这种方式，为什么我们现在还需要 这四个各种什么cast这种这种东西呢？那就是因为我们 用了那种老的强制类型转化方式比如说什么int啊，这种类型转化方式，这也是类型转化运算符对吧， 这种老的类型转化方式它不能够区分类型转化所带来的风险的这个高低，就是你这程序出了iii，这个iii是有可能发生在 强制类型转换上面的，就是你可能作为一个强制类型转换导致精度损失，或者 导致基类变强，基类指针强制转化为派生类指针，这都有可能导致你 后续的程序出错。那比如说我想要， 我发现我的程序有错，然后我想，我可能是因为， 我某些地方做了强制类型转换说不定导致我的程序出错。那我就要在 我的程序里面搜查，到底在什么地方进行了强制类型转换。 那我们如果不用这种cast的话，你要去找出各种各样的类型转换，它们的形式都不统一， 那你要去找这个就很麻烦，你怎么去找啊你用关键字搜索的方法，那你转成int的， 你试一下，转成castA的这种你又试一下， 转成double的，呃，什么的，你又试一下，你要查找的字符串都不一样， 这就是说为找出在什么地方进行了强制类型转换， 增加了很多麻烦如果我们强制类型转换全部都用这个什么什么cast的话，那你 只要去去搜寻这个_cast这个关键字，你就能够把所有强制类型转换语句都找出来。 这就方便了一些，对吧！而且老式的强制类型转换它是不分这个风险的等级的， 有的强制类型转换风险是很高的，比方说我进行了指针之间的强制类型转换， 典型的就是我曾经把 基类的指针强制转化成派生类的这个这个指针了， 那我的程序里面可能会有各种类型的这种基类指针 到派生类指针之间的转换，这个基类和派生类可能都是不一样的类，对吧， 那我程序出错的时候，我有可能就怀疑，我是不是在某些地方 把基类指针转换成派生类指针，然后在后续在使用它的时候就导致出错了， 那我想要把这个基类指针到派生类的指针这个转换， 所有的这个转换的场合我都给它找出来，那我怎么找啊，如果我用老式的那种类型转换的方式， 那个基类它类的名字都不一样的，那所有这些类的转换我要一个个去说就会很麻烦， 那我们有了这个不同的cast这个呃，这个这个 呃，强制类型转换运算符呃，以后 你要用指针转换，你就会用，比如说interpret_cast或者是dynamic_cast， 那你要觉得这个指针转换可能有风险的话 你就去搜寻dynamic_cast和interpret_cast这两个关键字，你就能够找出 进行指针类型转换的这些语句，你就能够观察容易去看一下，哎，这些语句是不是导致了错误， 就方便多了，对吧，所以说，把各种强制类型转换按照风险程度分级也是有必要的， 不光是风险程度了，就转化的形式和风险程度， 呃，不同，我们就会用不同的cast，然后我们有个这不同的cast，我们就能够很容易在这程序里面搜寻， 我都在什么地方进行了某一类的转换。 好吧，总而言之这个static_cast它很常用，它进行了就是最简单的转换，就是整型和实数型，字符型之间的这些转换啊， 当然它不能够进行指针之间的转换，也不能进行指针和整型之间的转换， 也不能用于同，不同类型的引用之间的转换。啊反正它能做到的转换都是最基本的，风险最小的。 那再看这个static_cast怎么用啊。 呃，比如说我我个classA，它里面重载了（），它重载了这个int， 这个是什么意思呢？这就重载了int这个类型转换运算符， 然后又重载了char*这个类型转换运算符， 啊，类型的名字本身也是类型转换运算符，现在我们重载了这两个类型运算符， 那这个时候，呃，这两个重载的函数在什么时候会起作用呢，我们看main里面int n，char*p等于 这个东西啊，然后我现在要把3.14， 强制转化成int，我就可以这么做，当然你，你这边不写强制转化 它就能自动转化了，对吧，那你想要强制转化的话你就写static_cast int， 这就意味着我想要把3.14转化成这个int，static是一个看成是像模板的东西， 我们要真正用它的时候，后面要加（），然后给具体的类型，这个类型代表你要，啊，后面的东西转成什么类型。 然后我们可以写static_cast int (a)啊，现在我就是要把一个 class A的对象强制转换成int， 那这个怎么转化啊，那当然就要求 int这个强制转化运算符被重载，所以这条语句就等价于调用了a.operator int 啊，那 a.operator int 执行的结果返回值是1，所以说N的值就变成1了。 那这边我们还可以把一个class A的对象啊强制转化成一个 char*类型的指针，那当然就等价于调用a.operator char * 那我们看到前面这个a.operator char *它就返回一个null，所以 转化的结果肯定是用一个空指针过去了。那补充一点这个 类型强制转换运算符被重载成函数的时候是不写返回值的， 这个被重载的类型是什么，返回值就是什么类型。啊，比如说这个函数返回值就是int，这个函数返回值就是char*， 呃，那现在这个p就变成了空指针。 然后下面我们要把p强制转化成整型，用static_cast的话是不允许的，容易会出错，它不能把 static_cast不能将指针转化成整型，也不能将整型转化成指针，所以下面这个你想把n转化成一个指针char* 的指针也是不行的。
- 那接下来再看reinterpret_cast， 这个东西呢是用来进行各种不同类型的指针之间的转换，不同类型的引用之间的转换， 还有从指针到能够容纳的下的指针的整数类型之间的转换。 呃，什么叫容纳的下的指针整数的类型啊，就是说你把 一个指针可以转换到int没问题，因为指针是四个字节，int也是四个字节， 但是你要把指针转化成一个iii就不行了，啊，因为iii只有两个字节，它不能容纳的下一个指针。 然后这个reinterpret_cast它做转换的时候啊，执行的是逐个比特拷贝的操作，也就是说它把被转换的东西 每一个比特都拷贝到转换的目的地里面去了， 啊，它是用来进行，主要是用来进行指针和指针之间的引用和 引用之间还没有这个指针和整数之间的转换的。 那我们看这个例子程序啊， 这里面有个classA的对象，它有i，j这两个成员变量，在构造函数里面初始化， 然后这a（100）的话，就a.i 和a.j 都是100了对吧， 下面这个东西很怪异啊，它把a这个对象强制转换成一个整型的引用，然后赋值给这个一个整型的引用r， 啊，这个，只能用reinterpret_cast 来做这件事情，我们就强行让r 引用了这个a， 至于你这么做的目的是什么，这个好像这个心怀叵测啊，这我们不管，我们想要告诉大家的就是， 这个C++的功能是非常的强，几乎你想干任何事情都能支持，但是你要做这个事情， 你得为自己的行为负责，啊，好下面r就引用了这个a了，然后我们让r等于200， a等于200 到底是什么意思呢？ 就是把a所引用的那个三个字节的地址空间里面去写200, 因为r 是整型的引用，所以这里边是一起把r 引用了 整型是四个字节的，所以编译器就把r引用的四个字节地址空间里面写200。 那这个r引用在什么地方呢？a在内存里面是这样的，对吧，它前面 四个字节是是算i的，后面四个字节是算j的。那r 呢，它引用了a，所以 说这个r实际上就，等于就引用了这个 a前面的这四个字节。因为r是整型的。 所以编译器认为r=200，就是往r引用的那个四个字节里面去写个200。也就是说往 a的放i的位置写了个200，也就是说改变了a点i的值，所以我们输出以后，就是200，100。 然后我们来n=300，接下来呢，我们把一个 int*类型的指针，就是& n，它指向n的地址。 把它强制转换成一个A*类型的指针，我们通过reinterpret_cast来进行转换， 转换到pa里面去，由于这个转换从，是一个 byte一个byte拷贝的，所以说这个时候呢，这个 pa就指向了这个n，啊，pa就指向了这个n。 那接下来我们把，让 pa→i=400，那这个时候产生的效果是什么呢？ 就是pa→i=400这条语句在编译器处理起来会是怎么样的？就是编译器比如说，生成的代码。假设pa 指向的是一个class A的对象，这里面前四个字节放i，后四个字节放j， 那pa→i=400，就会往pa指向的地方，也就是这个i这个位置，放了400。 可是这个时候，pa实际上指向的是n，对吧。那编译器不管了，它编成，生成的指令还是以为这块空间是 pa的指向的a的对象的那个i，所以就是说往n的上的存储空间里面放了400。 结果n就变成400了。那么pa→j=500是怎么样的呢？ 这个j是在i后面，对吧。所以说pa→j=500是往j放的地方放个500。 放j的地方写了500，那，那就是说 放i的地方是n， 这块，那放j的地方，那就变成是n后面的这四个字节了。 也就是说pa→j=500就是往n后面那四个字节写一个500. 可以是n后面这个四个字节是属于谁的呢？不知道。 它也许属于其它变量，也许你根本就不能往这里面写。那如果不能往这个空间里面写东西的话，这条语句马上就会导致你的程序崩溃。 如果这个这块空间是属于别的变量的，那你就莫名其妙地把别的变量改成了500，那你程序后续执行就可能会 出错了。所以我们下面呢再输出n的话，会发现它变成400。 接下来我们把一个long long类型的这个常量， 的变量，啊，强制转换成一个 这个A*这种类型的指针，reinterpret_cast 可以做这件事情，但是由于这个la，它太长了，它有8个字节。 所以reinterpret_cast只会把低32位四个字节 的内容拷贝给这个pa，逐个byte拷贝过去，所以 pa的内容就变成了这个东西。然后呢，我们又用reinterpret_cast把这个pa里面的内容 转换给这个u，而且是逐个byte拷贝过去的，结果这时候u里面的内容就是 5678abcd，我们在这输出就是这个结果。 那reinterpret_cast还可以把两种类型完全不同的 函数指针来进行转换。我们在这里typedef了一个PF1， PF1这种类型，它是一个函数指针类型，它所指针指向的那个函数， 返回，参数是int，返回值是void。而PF2呢，这种类型的函数指针指向的函数 它有两个参数，它的返回值是int。反正PF1这种指针和PF2这种指针啦，类型完全不兼容， 可是呢，我们还是可以用reinterpret_cast 把一个PF1这种类型的指针强制转换到一个PF2这种类型的指针。 至于你做这种，指针 强制转换，你想干什么，后面安全不安全。 你只能求这个菩萨保佑了，反正C++允许你干这个事情。 
- 那接下来再看这个const_cast，这个东西比较简单，它就是用来进行去 除const属性的转换，也就是说把一个const的指针强制转换成一个非const的指针。 或者是把一个const的引用强制转换成一个非const的引用。 那比方说，我们这里有一个const的对象，string，s啊，那我们 本来你只可以把s复制给一个const的引用，你直接复制给一个非const的引用，编译会出错的。 但是我可以进行一个强制类型转换，去除s的这个const属性。 我们就能够把它复制给一个非const引用了。 那实际上，你下面，通过p是可以去修改掉s的这个内容的。 这里&s是一个const string*类型的这个指针，因为s 是const的嘛，我们也可以通过强制类型转换，const_cast，去除它的const属性， 把它转换以后的结果复制给这个ps，然后我们以后通过ps可以改这个 来使得内容 这是去除const_cost的。
- 那最后一个cast，就是dynamic_cast，这个东西特别有用。 就是我们经常会做，从基类指针到派生类指针的转换。 基类指针转换成派生类指针是需要强制转换的，那这个强制转换是否安全，取决于什么呢？ 就取决于你这个基类指针是不是确实指向一个派生类的对象。 如果基类指针确实指向一个派生类的对象，那你把它转换成派生类指针，以后你用 这个派生类指针去调用派生类各种什么成员函数，那都没有问题，对吧。因为它反正指向的是一个派生类对象。 那如果基类指针指向的不是一个派生类对象，那你把它强 制转换成派生类的指针，以后你再用它，那就有风险了。 总之，基类指针转换成派生类的指针， 仅在基类指向的确实是派生类的对象的情况下，这种转换才安全，否则就不大安全。 那我们做这种转换的时候，我怎么判断这个转换是不是安全的呢？ 用什么手段去判断这个基类指针到底是不是确实指向一个派生类的指针的？ 这个不是不好办的。dynamic_cast能够部分解决这个问题。啊，它专门 用于将多态基类的指针或引用，强制转换为派生类的指针或者引用。 而且呢，它能够检查转换的这个安全性，实际上就说的是基类指针 或者基类引用到底是不是指向或者引用一个派生类的对象了啊。 对于不安全的指针转换，转换的结果是NULL，它不会转换出一个 真正的指针出来，它转换成一个空指针。 但这里要强调一点，就是它专门用于将多态基类的 指针或引用拿来转换。它不能用于非多态基类的指针或者引用。 那什么叫多态基类啊？就是包含 虚函数的基类就叫做多态基类。 记住了，dynamic_cast仅适用于多态基类啊。 那我们看dynamic_cast的例子，这里有一个Base，是个基类，它有虚虚构函数，所以它是多态基类喽。 然后Derived从Base派生而来，这里面定义了一个基类对象b， 派生类对象d，然后这个派生类的指针pd。 然后我们在这里呢，这个&b是什么啊？就是一个基类指针，指向Base对象，对吧。现在 我在这里用reinterpret_cast这种强制转换，要把这个基类的指针强制转换成一个派生类的指针。 那这个转换是一定能够成功的。不管安全不安全，它肯定能够成功。因为 reinterpret_cast它会忠实的把这个基类指针里面的内容全部都拷贝到 这个，这个派生类指针里面。那基类指针里面的内容就是这个基类对象的地址嘛。 那经过这个转换，pd就指向一个基类的对象b了。 虽然不安全啊。 所以你没有办法来通过这个转换的结果是不是来NULL来判别安全性，因为它肯定不会是NULL了。所以这个程序不会输出这一条。 那如果我想进行这个 基类指针到派生类指针的转换，而且我还想判别安全性，那我怎么办呢？我就应该用dynamic_cast。 比如说我现在把一个基类指针，&b当然是基类指针，我用dynamic_cast强制转换成一个派生类的指针。 由于这个基类，它确实是多态基类。所以这个转换呢， 就可以判别安全性，也就是说，这个转换它并不总是成功的。 如果这个基类指针指向的是一个基类对象，那转换就不成功。不成功的情况下， 这个dynamic_cast的返回值就是NULL。那我们看看这个东西确实 指向了基类对象，对吧。所以这次转换是不成功的，所以pd就会等于NULL。 因为这是一个不安全的转换，pd就等于NULL，然后会输出unsafe dynamic_cast1，在这啊。 下面我们再看，我们现在拿一个基类的指针，让它指向 d这个对象，d是派生类的对象。 接下来，我们把这个基类指针，也用dynamic_cast进行强制类型转换，转换成一个Derived的这种 指针，复制给pb。这个转换就是安全的。因为这个pb指向的是d，是一个派生类的对象，对吧，这是安全的。 在安全的情况下，这个时候pd就确实是一个指向 d的指针了，它不会是空指针。所以下面这行就不会输出了。 那你说dynamic_cast到底怎么去判断它所，一个被转换的指针指向的对象，到底是基类和 派生类对象呢？关键就是它只适用于多态基类的指针。我们知道多态类里面 它的前四个字节是一个相当于虚函数表的指针的这样的东西。 那它这个虚函数表的指针，从某种程度上，当然也能够用来说明 这个对象所属的类了。对吧。所以dynamic_cast等于是有办法去判断这个对象所属的类到底是 哪一个的。所以它也只能作用于这个多态基类。 如果你这个类不是多态基类，那这个对象里面就不可能放有什么虚函数表的指针，那dynamic_cast 当然也就没有办法进行判断，说这个对象是属于哪个类了。 那这个dynamic_cast还可以进行 基类的引用到派生类引用的转换，并且可以判断是否安全。 那比如说，我们看，这儿有一个b，它是一个基类的对象，那你也可以把它看作是一个 一个基类的引用吧。现在我们要把它强制转换成一个派生类的引用。所以用dynamic_cast，这块写 派生类的引用。这里是一个派生类的引用。那这个转换到底是否安全？ 如果判断呢？ 你没法通过它的返回值是不是一个什么空来 判断，对吧。因为引用它不会有什么空指针啊，或者空引用这种说法。 那如何判断转换是否安全呢？那解决问题的办法就是 如果转换不安全，这条语句就会抛出异常。 那我们捕获这个异常，就能够知道，刚才发生了不安全的转换。 那至于什么叫这个异常啊？我们等会再说。 
## 4. 异常处理
- 好，咱们现在要讲到这个异常处理，啊。 呃，什么叫异常呢？ 就是你程序运行中吧，难免会发生各种各样的错误。啊，比方 说，这个整个数组下标越界啦，除数为零啊，new不出来足够的存储空间啦， 等等各种各样的错误，呃， 有时候输入数据不符合要求，也会产生各种各样的这种错误吧。那我们总会希望，啊，在发生这个异常的时候呢，你这个程序不能简简单单的就终止运行了事了，对吧？当然更不能， 就快速崩溃掉了，啊。最好是能够，你这个程序能够反馈，反馈这个异常的信息告诉用户，啊， 呃，发生了什么事情，啊，呃，然后，呃，推进下一步的操作， 呃，等等，这样才是符合要求的。那， 那，对这种有可能发生的异常，我们怎么应付呢？ 一种办法就是，分散地处理，就是任何由， 任何一条，有可能，发生异常的操作过后，我都写个 if else 一句，什么的去判断一下，如果发生了异常我怎么办。 对吧，如果没有异常我就正常继续。 这种做法显得很罗嗦，啊，每一个有可能发生异常的地方，你后面加个，都要加个 if ， 一句去判断，就很啰嗦。 另外还有，有的情况下呢，这种做法呢，不能达，满足你的， 这个需要，比方说，呃，你写的一个函数，啊， 对文件进行操作，或者做一些别的什么操作。你写的这个函数呢，是你提供给别人， 调用的，啊，因为你的这个， 参加的软件项目有多人合作，你的任务就写这个函数。 至于这个函数怎么用，是别人的事情。 那么在你写的这个函数的运，运行过程中有可能发生异常，比如说他想打开一个文件，结果打不开，对吧？ 那在产生了这个异常的情况下，该怎么处理， 可能并不是有你这个函数设计者来决定的，应该是由调用这个函数的这个人决定的。 那么你就，很难在这个函数里面去对这个异常去进行处理，对吧？ 比方说你，你哪怕要告诉调用者发生了异常，也不是一件很容易的事情。 比如说你，你，你可能会想通过，呃，这个函数的返回值，去告诉调用者发生了异常。 那假设你这个函数的返回值是一个整数，而且在正常的情况下就，每一个整数都， 都有可能成为返回值，那你怎么通过返回值来通知别人是异常呢？比如说你说 返回 -1代表异常，那如果这个函数正常情况下，就应该返回 -1，你怎么区分， 正常的-1和异常的这个-1呢？没有办法对吧？ 或者说你说我可以通过在这个函数里面， 来一个传引用的参数，啊，然后通过这个参数来告诉调用者，唉，我这个函数里面， 可能发生了异常。那这就非常累赘了，你就，你就会，这个函数就会携带一个大多数情况下根本都用不着的参数。 这个实在是，非常让人难受的。 所以我们呃，在这个函数每发生异常的时候，要，由这个函数本身来处理，有时候可能是并不太， 合适的一件事情。所以我们，可能就会需要一种手段，啊， 把有可能发生异常的地方，和处理异常的地方，给它， 分开，啊，在这个地方可能发生了异常，比如在这个函数里面发生了异常，我可以在， 调用这个函数的地方，也就是说这个函数的外面，去进行这个，这个处理。 那这个C++里面，是通过这个 try ，catch 语句对异常进行这个处理的。 那我们看呃，这段程序啊，呃，这段程序输入， 两个整数 m 和 n，然后对它们进行这个除法运算，啊， 我们看这个，呃，异常，用，处理用到了 try ， 和 catch 语句，其中就有一个 try 块，所谓 try 块就是在 try 后面跟了一对花括号，里面的所有的东西都称为这个 try 块 ， try 的块。我们应该把有可能， 产生异常的这个语句，都写到这个 try 块里面去。 啊，那我们在这个 try 块里面先输出，啊， before dividing，就是在做除法之前， 那我们看看，啊，如果n=0，这时候除数为0啦，这就是一种不赞成，不正常的现象。 那我们就要产生出一个异常，啊。呃， 就是我们现在做的这个异常处理，要产生的异常呢，指的是我们程序员人为地产生出来的， 而不是说什么，文件找不到啊，这种异常，啊，现在我们要处理的这种异常都是， 程序员人为产生的这种异常，而我们程序员之所以要人为产生异常， 是因为我们程序的运，运行过程中，发生了一些不正常的现象， 好现在我们就称不正常现象和异常，把这两个东西给，区分开。 那 C++ 的异常处理，这一整套的机制，是为了处理程序运行， 中间出现的不正常现象。好，现在这个除数为0就是一种不正常的现象， 所以我们，写的程序就应该抛出一个异常。 抛出一个，异常的目的是，后续在别的地方能够对这个异常进行处理。 抛出异常的语法就是，throw 关键字，后面跟一个表达式，这个表达式 可以是任何类型的这个表达式，啊。现在我们 throw 一个 -1，就表示抛出了一个异常， 异常是有类型的，啊，它可以是各种各样的类型都行。那我们抛出的是 -1，那么这个异常就是整型的异常。 啊，至于抛出去的异常怎么处理，等会儿再说啊。 那除数为0的时候，我们就抛出一个整型异常，除数不为0呢，我们就输出， 两个相除的这个3，啊，然后再输出一个 after dividing 。那要注意的是，呃，在 try 块执行的过程中， 只要一旦运行到了抛出异常的语句， 那么抛出异常以后， try 块就立即停止运行了。 也就是说，如果除数为0，就会判断这个为 true ，就会走 throw -1，就会抛出异常。 这个时候，不会说抛完异常以后，就接着往下走，走这一条， 不会的。只要一旦抛出异常， try 块马上就停止运行了。 那停止运行以后，程序往哪里走呢？答案是，往 catch 块里面走，啊。 就是一个 try 块后面会跟好多个 catch 块。catch 块的语法就是 catch ，后面跟一个括号，括号里面放着的就是， 像函数参数类似的东西，它也可以是引用，也可以是对象，啊，也可以是基本类型，看来就像是一个函数参数，当然只有一个。 呃，然后 catch 块就是用花括号括起来了，然后一个 try 块后面可以跟很多个 catch 块。 呃，catch 块里面也有各种各样的这个语句，那么，以 这个 try 块和 catch 块执行的过程是这样的，就是， 如果在 try 块执行的过程中，没有抛出任何异常， 啊，没有抛出任何异常，那么这个时候，所有的 catch 块就都不会被执行， 注意啦，没有抛出异常的情况下，所有的 catch 块都不会被执行，而是 把 try 块执行完了以后，接着执行 catch 块下面的指令，就接着往下走，啊。 那如果在，呃，try 块执行的过程中，抛出了异常， 那会怎么样呢？那就会立即终止 try 块的执行， 然后，就要看看会不会进入某一个 catch 块。 注意 catch 块可能有好多个，这时候只可能进入某一个 catch 块，也可能一个 catch 块都进入不了，直接就，绕过了， 如果一个 catch 块都进入不了的的话，这个程序就会终止，就会崩溃了，啊。 那么这个时候，如果抛出了一个异常，怎么判断能否进入某个 catch 块呢？ 那我们看到，catch 块这边的这个参数，它都是有类型的，对吧？ 那也就是说，你抛出的那个异常， 如果，它的类型跟 catch 块这边儿的这个东西的类型匹配，那就会进入这个 catch 块。 比方说我们刚才抛出的是一个整型的，那我们这边 catch 块有 catch double 的异常，有 catch 整型的异常， 那很明显，当我们这个程序，执行了 throw -1 以后，接着怎么走呢？ 就跳过这个 after dividing ，进入这个 catch 块，因为这个 catch 块 ，抛， 能够捕获整型的异常，而前面那个 catch 块呢，它只能捕获， double 类型的异常，所以就会进入这个，如果执行了 throw -1，就会进入这个， catch（ int e）这个 catch 块，然后执行 catch 块里面的东西，就是c out，catch int， catch， 呃，catch int ，把这个字符串输出，然后输出 e ，e 是多少呢？让你 ，好，e 就是-1，你 throw 了-1，这边捕获的这个异常，这个 e 的值就是 -1。 然后 catch 块执行完了以后，再，程序还可以继续才，它不会终止，就直接再往下走了。 但是如果一旦抛出了异常，而这个异常却没有被任何一个 catch 块捕获的话，那你的程，程序就真的会， 异常地，很不正常地这个终止了啊。 所以我们可以分析一下这个程序的运行结果啊，啊，针对不同的输入，会有不同的运行结果。比方说我们输入， 9，6，任何敲回车，这个时候程序怎么执行呢? 好，那这个时候 m 和 n 都不是0对吧？所以说 try 块的话，会输出一个 before dividing ，然后， 这个不会被执行，所以就会输出9除以6得3，任何输出一个 after dividing，对吧？ 呃，输出一个 after dividing，然后呢， catch 块，catch 块都不会被执行，啊， 啊，然后会走 finished。所以输出结果就是 before dividing，两个1.5，然后 after dividing，然后 finished。 啊，那如果你的这个输入是，呃， 呃，那我们再看啊， 再换一个，这个这个这个程序啊，来看看啊。假设我们把这个程序改了一下，呃， try 块里面增加了另外一种情况，就是如果这个，呃，呃，除数为0，我们就， 我们就抛出一个整型异常，如果，如果这个被除数为0，假设我也认为这是一个不正常的情况， 我就抛出一个浮点型的，double 型的异常，然后 一切正常的话，我就输出两个3，然后再输出 after dividing，啊。那在这种情况下， 啊，我们看看，呃，注意这块儿开始有一个 double d 啊，它能够捕获浮点型的异常，然后， 这个 catch ，里面输的是…，…是什么意思呢？ …，catch … 就能够捕获任何类型的异常。 啊，等于这个东西是一个，是一个百搭，啊，它能够对付任何类型的这个异常。 那我们如果产生了一个浮点 double 的异常，到底是由这个 捕获，还是由这个捕获呢？那答案就是， catch 块是从上到下依次匹配的。 最先匹配到哪个catch就去执行哪一个catch了，就是这样一个过程 所以我们这个程序，我们看一下运行结果，如果我们输入的是9，0，那也就是说 除数是0，除数是0的话就会抛出这个-1这个异常，然后after dividing就不会被执行对吧 那不会被执行，-1这个异常由谁捕获啊，它不是由 这块捕获的，因为它这块是捕获double异常的，它是走到这里面来了 所以如果你输入的除数为0的话就会输出before dividing，然后就会跑到这个catch里面来 那就输出catch...，然后catch执行完了再接着输出finished 那如果你程序的输入是0和6的话也就是那个被除数为0 当然就会进行before diving，然后呢就会 在这块抛出一个复点型的异常，然后就会走到这个 开始double d的这个catch块里面，那当然就是输出一个catch double -1，然后再finished 就是这样一个过程，那如果一个函数在执行的过程中发现了不正常的现象 它可以通过抛出异常来通知调用者发生了这个事情 他也可以抛出异常然后在自己函数内部就把这个异常给 处理掉，就是说，它可以抛出一个异常，然后本函数内就写一个catch块把这个异常给处理掉 那如果在一个函数执行期间，这个函数通过throw语句抛出了异常，但这个throw 出来的异常在本函数内就通过catch块捕获并且处理了，那么这个异常就不会被抛给 给这个函数的调用者，也就是说上一层的函数吧，就是说这个函数的调用者他就不会觉察到这个异常 如果我们throw一个异常，然后这个异常在本函数中没有被处理，那这个异常就会被 抛给上一层的函数，就是调用者，调用者能够感知到这个异常，那我们看 程序，这里面我们定义了一个CExceptinon这个类，它代表一个异常，这里面有一个string message 它用构造函数可以初始化这个message 这个message是用来存放这个异常的信息的，就是不正常事件的信息的 然后我们一个devide,devide这个函数呢作除法，它如果发生了除数 等于0的情况下，这个devide函数他也不知道该怎么处理好 所以他就简简单单的抛出一个异常就完了 他不做进一步的处理，他只是通过抛出异常的方法来告诉调用者 这个不正常啦， 那为什么不正常呢，他就把原因以一个字符串的形式写在这儿，他抛出的是一个CException 这种类型的对象，这个对象里面的那个message成员边缘被初始化成了一个devided by zero 这里面存放的就是这个不正常现象的具体信息，那如果y除数不为0的话那他就 正常输出，然后返回两者相除的这个结果 那我们devided在除数为0的情况下他并不擅自做主张说我们应该怎么办，他只是 抛出一个异常，让调用者能有机会捕获这个异常，并且进行处理 然后我们这里有一个count salary，函数啊，它是 算count tax，算稅的，根据salary工资算税 那在这里面所做的事情就是 如果发现工资是小于0的那肯定是不正常对吧，那我们就抛出一个整形的异常，这个异常的值是-1 如果工资不小于0，那我们就正常，输出一个counting tax 来算税 那这个函数里面呢我们把异常就自己处理掉了，就是说抛出了异常就会得到catch块 得到catch块就会输出salary小于0就拉到了对吧，那反正不同的函数的设计方法不一样有的时候 你觉得这个异常应该在这个函数处理掉，有的时候你会觉得这种异常我们应该抛出去让调用者处理吧 反正c++让你都能够做得到 这个count salary在正常情况下还会往下走输出tax counted然后return 这个salary乘以0.15，这个税率是15% 然后我们看在main里面有个f等于1.2，这个f被初始化成1.2了 然后我们在try块里面写了个count salary -1 然后又写了一个f=devide（3,0）然后try块里面还输出end of try block 然后我们catch块呢只捕获一种异常就是CException 这种类型的异常，然后在这里面输出e的message 这里面实际上应该存放的是这个不正常现象的具体 信息对吧，然后我们在输出f看一下f的值有没有变那最后输出finished 那这个程序也没用输入啦，我们就直接说他输出什么结果啊 这个count tax -1进到这个count tax里面去 这个salary就是负数，那肯定就在try 块里面就抛出-1了对吧，那这个counting tax就不会被执行啦 那会执行的是什么呢，就跑到这个catch块里面，跑到catch块就输出一个salary小于0 然后catch块后面的还能够继续执行，就返回，就输出一个tax counted 然后他的返回值是-1乘以0.5这个时候也就没有用了啊 所以我们输出的结果先是salary小于0，然后tax counted对吧 额 接下来这个，因为counttax运行过程中发生的 异常，抛出的异常，counttax本身就已经处理掉了，所以在这里就不 try块里面在执行 counttax就不会导致说counttax抛出的异常还跑到这个catch块里面去处理不会的 因为counttax自己已经处理完了，那它的调用者main里面就感知不到 这个counttax运行期间抛出的异常了，那接下来我们就走这个f等于 devide（3,0） 那devide（3,0）显然除数为0对吧，那除数为0进去以后呢 就会抛出一个异常，这个异常的类型是CException 这种类型的一个对象，它里面放着的message是这样一个字符串 那既然抛出了这个异常这边in devide肯定就不会执行了，甚至连return语句都不 会执行了，然后我们看到这个devide他本身对抛出的异常 并没有用catch 块去处理它对吧，他没有try块也没有catch块，也就是这个异常并没有被处理，没有被处理的后果是什么呢 没有被处理的后果就是这条语句在执行的过程中 产生了异常，然后这个try块就会立即终止 处理，也就是说这个end of try block是不会被执行的 那程序跳到哪里去了呢，由于我们这个在devide在执行期间抛出的异常 是CEexception这种类型的异常，那我们这个catch块正好是能够捕获它的 所以这个时候程序就会走到catch块里面，走到catch里面那这个时候e是等于多少啊 e呢就是前面刚才这里throw出来的一个对象的 一个复制品，因为这里不是传引用，不是传引用所以就是一个复制品 那既然是个复制品，它里面的e.message嘛也是这个devide by zero，所以我们把这个e.mesage输出呢就是devided by zero 那catch块执行完了这个catch块后面的东西还是能够正常往下走的 然后我们就输出f等于多少的 我们看到f前面被复制成1.2，然后在这块本来说应该会修改f的值 但是由于devided执行到一半就发生异常了，它甚至return语句都没有襄阳的执行 可以说是算是没执行还是怎么样，反正他不能够把值返回给f了 所以说f输出的值还是1.2，然后再执行finished，这个程序就 结束了，通过这个例子我们看到，一个函数执行期间 可以抛出异常，抛出的异常这个函数可以自己处理，也可以不管，让调用者去处理 
- 那这个c++标准库里面就有 一些类，这些类都代表异常，这些类都是从exception这个类派生而来的 常用的几个跟异常有关的类是这样的 exception就是，然后他派生出bad typeid这跟类型转换有关的exception 我们后面还会，然后这个bad-cast是跟 类型转换有关的啊，这个bad typeid是跟类型判断有关的 然后bad alloc这个是用运算上分配不成功的时候抛出的异常，不管他 这个ios base failure是在输入输出产生错误的时候抛出的这个异常 然后exception派生出一个logic error，logic error又派生出一个out of range out of range是在什么数组下标业界啊容器的下标业界之类的产生的异常 那接下来我们就来看一看c++这些标准异常类是怎么起作用的 我们先看bad cast ，他是在类型转换发生异常的时候产生的，发生不正常不安全的类型转换的时候会 抛出这种异常，就是我们前面说了在用dynamic cast进行从 多态基类对象或者引用到派生类的引用的强制类型转换的时候 如果转化是不安全的就会抛出异常，就是说这个dynamic cast运行 期间会抛出这个异常，那你就得在这个异常进行处理，否则你的程序就会 崩溃了啊，那我们要使用异常处理我们就 要这个include这个头文件stdexcept 这个例子里面有一个基类，
    ```C++
    //bad_cast
    //在用 dynamic_cast 进行从多态基类对象（或引用），到派生类的引用的强制类型转换时，如果转换是不安全的，则会抛出异常
    #include <iostream>
    #include <stdexcept>
    #include <typeinfo>
    using namespace::std;

    class Base {
        virtual void func() {}
    };

    class Derived : public Base {
        public:
            void Print() {}
    };

    void PrintObj(base &b)
    {
        try {
            Derived &rd = dynamic_cast<Derived&>(b);    //此转换若不安全， 会抛出 bad_cast 异常
            rd.Print();
        }
        catch (bad_cast &e) {
            cerr << e.what() << endl;
        }
    }    

    int main()
    {
        Base b;

        PrintObj(b);
        system("pause");
        return 0;
    }
    ```  
  基类它是多态基类啊，他有func这个虚函数 然后派生类，还有print，然后这个printobj呢是 参数是一个基类的引用 在这里面呢参数虽然是基类的引用， 但是呢在这里面做了一个类型的转换，就是把这个基类的引用 强制转换成派生类的这个引用，用dynamic cast去做这个类型转换 那我们知道，如果这个b 它是基类的引用，它当然实际上也可以引用派生类的对象，对吧。如果b确 实引用的是一个派生类的对象。那我们这个转换就是安全的。 安全的话就什么事都没有啦， 什么事都没有就会执行rd.Print，那我们知道，执行rd.Print 这个时候执行的会是哪一个类的Print呢？基类并没有Print，对吧。我们派生类 有这个Print。那没有问题啊，因为这个时候， b 就是说rd引用的确实是一个派生类的对象，所以你在上面执行Print就是安全的，就没有问题的。 好了，如果执行到这条语句的时候，这个b，它并没有引用一个派生类 的对象，而引用的是一个基类对象，那这个转换就不安全，对吧。如果你放任自流的话，接着往下去走rd.Print。 好了，这个时候rd实际上引用的是一个基类对象，然后你在上面执行 Print，那很可能就出问题了。因为，因为这个时候，你是把基类对象 当做派生类对象来用的。然后这个Print在运行的过程中，可能就会去反问这个只属于 派生类而不属于基类的那些成员变量。那那些成员变量所占的那个空间，根本就不是在那个派生类对象里面。 那你就不知道对这些空间干了些什么。就有可能出错了。 那总而言之吧，这个转换如果是不安全的，也就是说b引用的不是派生类对象。那么 dynamic_cast在运行期间，就会抛出一个异常。 它抛出的异常就是就是bad_cast类型的。 而且dynamic_cast运行期间抛出的这个异常，它自己并不处理。那并不处理的话， 那就会交由dynamic_cast的调用者来处理了，也就是说我们这个PrintObj来处理了。 这个PrintObj呢，在try块里面，好， 这条语句抛出了异常，那这个rd点Print就不会被执行。我可以走到 看看能不能走到哪一个catch块里面。 好，这个地方抛出的异常是bad_cast这种类型的对象。那我们这里的 catch正好能catch一个bad_cast的对象。你这里写不写这个引用都可以哦。 那现在我们当然就捕获到了刚才这里抛出的异常。也就是说，程序就会走到这里面来。 就是如果b不是引用 一个派生类对象的话，那程序就会走这，而不走这，那就会输出e.what。e.what就是 这个，就是那些exception这个类里面有一个what成员函数， 能够返回一个字符串，这个字符串是用来说明 e这个对象里面 所代表的这个事情。e就代表发生了一种异常，那这个异常到底是 什么样的异常呢？这个字符串里面就存放了跟这些异常有关的一些描述信息。 那具体到我们这个程序，我们在main里面来了一个Base b，然后PrintObj(b)，那很显然进到这里面 以后，这个b是一个基类对象，那于是就会引发异常，然后就会走e.what，就输出了e.what。 到cerr，cerr是标准输出，在屏幕上，结果输出的信息就是Bad dynamic_cast！ 那也就是说，这个bad_cast& e这个 对象里面放着有一个字符串的信息，用what就可以把它调出来。 它这个信息是Bad dynamic_cast！ 但是这个bad_cast对象里面放的是这种信息，具体文字是怎么样的？不同的编译器可能会有不同的处理。 
- 下面再看一个bad_alloc， 它是指的是在内存分配失败的时候会产生的一种异常对象。也就说，用new运算符进行动态内存分配时，如果没有足够的内存，就会引发这个异常。 那具体的例子就是我们new 运算符用来分配存储空间的时候，几乎就没有失败的时候。 除非你真的硬要分配一片特别特别大的空间，然后我在这个main里面 就是很作地就分配了一个这么大的存储空间。 那这个它会失败了。结果这条语句就会抛出一个异常。那就，这个异常它的类型就是bad_alloc。 于是这个程序就会走到这个catch块里面，然后就会输出这个异常所附加的那些信息，就是bad allocation。 那具体这个文字信息是什么样的？不同编译器也会有所不同了。 最后再看一个特别常用的异常的这个类，叫做 out_of_range，out_of_range就是越界的意思啊。 当我们用vector或者string的at成员函数， 来根据下标访问元素的时候，如果下标越界，就会抛出此异常。 我们知道这个vector和string，我们都可以用中括号 然后中括号里面写一个下标的方式，去访问里面的元素，或者是string里面的字符，对吧。 然后这两个东西，同样也都有at成员函数， 也可以接受一个下标。at和中括号的差别在哪呢？就是中括号不检查下标越界， 那越界了，你的程序就崩溃了。 然后at呢，它检查下标越界，如果发生了越界，就会抛出一个异常。那你的程序还可以捕获这个异常。 然后做一些处理，你的程序就不会崩溃。 那由于at要检查越界，中括号不检查，那at的速度，运行速度就会比中括号 更慢一些啊，但是它安全性也更好一些。那我们就来看看这个out_of_range是怎么起作用的啊。 在这里面，我们main里面定义了一个vector，它有10个元素。 然后呢，我们就访问下标为100的这个元素。用at这个办法来访问。 那当然这个时候就越界了，于是这个at在运行的过程中，就抛出了 一个out_of_range异常。然后这个at在运行期间，它是自己不处理这个异常的。 所以这个out_of_range异常呢，就会在try块里面， 会察觉到，然后呢，try块就立即停止运行。然后这个catch块，它正好能捕获out_of_range异常。 那它就能够使得程序走到这里面来。如果你写的catch块不是捕获这种类型的异常。 那异常没有被捕获，也会导致你的程序这个崩溃。现在我们正好能捕获，所以我们就 这个e就代表它抛出的这个异常的那个对象的引用，那我们就输出e.what 。e.what 是个字符串，里面能显示这个 不正常现象的一些原因啊，什么之类的信息。 那同样，我们来了一个string hello，然后我们用at 加下标的方式要访问里面下标为100的那个字符。那当然这个时候 也会抛出out_of_range异常，那同样也会被我们这个catch块给抓住。 被这个catch块给抓住以后呢，就会输出e.what。那这里的e.what的结果。 跟上面这个e.what的结果，它可能就会有所不一样，因为一个是在 vector下标越界的时候产生的，一个是在string下标越界的时候产生的。所以我们看到这两行输出还真的不一样。 第一行输出是invalid vector <T> subscript，就是vector的下标 无效，第二个呢是invalid string position，就是什么 字符串的位置无效，它的信息不一样的。但是 具体你这个程序在不同编译器上面编译运行的话，这两个字符串 它是有可能不一样的。好，这就是异常处理。 在写大规模的程序的时候，还是挺有用的啊。 
    ```C++
    //bad_cast
    //在用 dynamic_cast 进行从多态基类对象（或引用），到派生类的引用的强制类型转换时，如果转换是不安全的，则会抛出异常
    #include <iostream>
    //#include <stdexcept>              //貌似不用也可以产生异常的错误报告
    //#include <typeinfo>               //貌似不用也可以产生异常的错误报告
    #include <vector>
    #include <string>
    using namespace::std;

    class Base {
        public:
            virtual void func() { cout << "Base" << endl; }
    };

    class Derived : public Base {
        public:
            virtual void Print() { cout << "Derived" << endl; }
    };

    class Derived1 : public Derived {
        public:
            void Print() { cout << "Derived1" << endl; }
    };

    void PrintObj(Base &b)
    {
        try {
            Derived &rd = dynamic_cast<Derived&>(b);    //此转换若不安全， 会抛出 bad_cast 异常
            rd.Print();
        }
        catch (bad_cast &e) {
            cerr << e.what() << "-----Some wrong has happened" << endl;                   //有异常时输出：  std::bad_cast
        }
    }    

    int main()
    {
        Derived d;
        Derived1 d1;
        Base b;
        PrintObj(d);                // 传递了派生类对象， 安全
        PrintObj(d1);
        PrintObj(b);                // 传递了基类对象， 不安全

        //bad_alloc
        //在用 new 运算符进行动态内存分配时， 如果没有足够的内存， 则会引发此异常
        try {
            char *p = new char[0x7ffffffffffffff];      //无法分配这么多空间， 会抛出异常
        }
        catch (bad_alloc &e) {
            cerr << e.what() << "-----Some wrong has happened" << endl;
        }

        //out_of_range
        //用 vector 或 string 的 at 成员函数根据下标访问元素时， 如果下标越界， 就会抛出此异常
        vector<int> v(10);
        try {
            v.at(100);          //抛出 out_of_range 异常
        }
        catch (out_of_range &e) {
            //cerr << e.what() << "-----Some wrong has happened" << endl;
        }

        string s = "hello";
        try {
            char c = s.at(100);          //抛出 out_of_range 异常
        }
        catch (out_of_range &e) {
            cerr << e.what() << "-----Some wrong has happened" << endl;
        }
        
        system("pause");
        return 0;
    }
    ```
