#[继承与派生](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/5)
> 代码重用是提高软件开发效率的重要手段，因此C++对代码重用有很强的支持，继承与派生就是支持代码重用的机制之一。例如，要编写一个学生管理程序，必然要设计一个“学生”类，“学生”类会包含学生共有的姓名、学号等属性，但是中学生、大学生、研究生又有各自不同的属性和方法，如果为每种学生单独编写一个类会造成重复与浪费。本模块将介绍通过继承和派生机制，可以在基类的基础上派生出不同的类，从而达到代码重用的目的。
## 1. 继承与派生
- 下面来讲面向对象里面特别重要的概念，叫做继承和派生。 那继承和派生这两程序是一回事哦。 我们知道C++里面有很多机制，是为了提高软件的重用性来设计的。 
  - 什么叫重用性好呢？就是你有一部分代码实现了一个功能， 后面你要新写一个代码，从那里要实现了一个功能的时候呢，你不必重头写。你把原来的代码直接拿来用就可以了。 这就叫做可重用性好。那我们在写面向对象程序的时候，啊，我们经常会碰到这样的情况。 就是我要写新的类B的时候，我会发现，咦，这类B，和某个已有的类A， 类A，可能很相似。啊，这里所说的相似就是类B拥有类A所有的全部特点。 那么，在这种情况下，我们写B的时候，当然用不着傻傻地去把 写A的时候已经实现过的那个东西重头写一遍，对不对啊？ 那怎么来减少这个代码量呢？我们就可以把类A做成一个基类。 把类B作为基类A的一个派生类，也称为子类来写。 A和B重头的部分，我们就不需要重头去写了。那这个派生类，它拥有基类的全部特点。 此外呢，派生类还可以对基类进行修改和扩充。 扩充比较简单一点，就是我们可以为这个派生类添加新的成员变量 和成员函数。那所谓修改，后面会看到，指的就是在派生类里面，我们可以 呃，写和基类 名称相同的成员函数，但这成员函数的行为跟基类不太一样，这可以称作一种修改。 然后这个派生类呢，它一经定义以后，就可以用来独立使用。那就是说我们可以用它来 定义对象。我们用它来定义对象的时候呢，不需要再扯进基类。 再强调一点，这个派生类啊，一，它拥有基类的全部成员函数和成员变量。 啊，不管是公有的，私有的还是保护的成员，都会被派生类继承下来。 **但是呢，尽管派生类它继承得到了基类private的成员， 但是在派生类的成员函数中，依然不能够访问 这些继承自基类的private成员。** 那现实中，我们很容易可以找到需要继承机制的这种list。 比方说，我们要写这个呃，学级管理程序。啊，那就是要管理各种各样的学生，就是有中学生，大学生，本科生，研究生等等。 那我们知道所有的学生都有些共同的特点。 比方说，他们都会有这个姓名，学号，性别，成绩， 这些共同特点，对不对?呃，这是共同的属性啊。 此外，学生还有些共同的方法的成员函数。 比如说，入学，毕业，等等，对吧？ 学生还有是否留级，是否该奖励，这样的这些，这些方法，呃，用成员函数来实现。 但是呢，不同种类的学生，他会有各自不同的属性的方法。 比方说，对研究生来说，还有导师和系的概念，这是中学生没有的。 那研究生还有什么方法呢？比方说，他有当助教的方法。 本科生和中学生不会有的。那对于本科生，作为大学生来说，他有系的这个，这个 概念。那他当然还有一些独自的方法，比方说，看他能不能够保研。 啊，那这个中学生呢，他有竞赛特长加分。啊，这个独有的这个方法。 **那派生类的具体写法是怎么样的呢？ 它的做法就是class派生类名，后面用一个冒号，再写public，然后再写基类名。 这是意味这个派生类是从基类派上用来的**。那下面我们就看一个学生管理程序的具体的例子。 
    ```C++
    class CStudent {
        private:
            string sName;
            int nAge;
        public:
            bool IsThreeGood() {}
            void SetName(const string &name)
            {
                sName = name;
            }
    };
    class CUndergraduateStudent:public CStudent {
        private:
            int nDepartment;
        public:
            bool IsThreeGood() {}           //覆盖了基类，大学生的三好生评判标准
            bool CanBaoYan() {}
    };
    ```  
    我们写了一个CStudent类作为基类。 这个基类包含所有学生的共性，比如说总算形似的姓名，还有年龄。 这个贡献还包括成员函数IsThreeGood，啊，这是用来评算好生的。 啊，SetName，设置姓名。然后我们再看，有一个派生类CUndergraduateStudent，就是本科生类。 这里写了public CStudent。这意味着它从CStudent的派生而来。 那么前面的这全部的成员变量的成员函数，当然就自动成为 CUndergraduateStudent的成员变量和成员函数了。 然后这个本科生类，还有个添加进 自己的新的成员变量，这就是CDepartment。然后这个本科生， 它等于平盖的方法不是跟所有的学生一样的，对不对。所以它有自己平置好的方法。 这个现象称这为覆盖。 就是所它这里成员函数的名字跟基类函数的名字一样。但是呢行为可能不一样。 这也叫对基类的修改，或者称之为覆盖。那CUndergraduateStudent还有一个成员函数有叫做CanBaoYan，啊 就是看他能不能保研。 这里说点题外话。就是这两个函数的英语看起来很山寨，对吧？ 啊，那我每次在课堂上用这个讲义的时候，地下都会轰然大笑，觉得这个英语太中国了。 但我，实际上我觉得，英语吧，我觉得不能够叫外语了。 它是世界通用的语言。就是数学物理不能称为西方科学一样。 那我们要对数学物理施加影响，对不对?那中国人也可以对英语施加影响。 怎么施加影响呢?就是往英语里面添加我们很典型中国式的说法。 并且让全世界的人都能够理解。就像这样，IsThreeGood, CanBaoYan。那我以前到泰国出差。 去买东西，或者去餐厅吃饭。他们要没有东西，他们就说no have， no have，我觉得特别有意思。 那，那什么时候， 我们这些中国式的英语都被全世界广泛理解，也说明我们的文化影响力上一点才见。 比如说我们希望到美国这宾馆去，跟前台的人说 I want to beat a car。他就知道，哦，你是要去打车的。那我觉得中国人的影响力是有的。 啊，这是题外话。
  - 好了，那现在呢，我们接着讲这个派生的概念。 现在我们再看一个新的类，叫做CGraduatedStudent。
    ```C++
    class CStudent {
        private:
            string sName;
            int nAge;
        public:
            bool IsThreeGood() {}
            void SetName(const string &name)
            {
                sName = name;
            }
    };
    class CGraduateStudent:public CStudent {
        private:
            int nDepartment;
            char szMentorName[20];
        public:
            int CountSalary() {}
    };
    ```    
    啊，它也是从CStudent的派生来的。 然后它添加了C的成员函数，对不起，成员变量，还有szMentorName， 就是导师，啊，这个成员变量。那它还有CountSalary，啊CountSalary这个 计算工资，啊，这个成员函数。 
- 那对派生类的写法有个基本了解以后，我们再看看派生类对象的内存空间是怎么样的。 基本上我们可以说啊，派生类对象的体积，啊，它是等于基类对象的体积， 再加上派生类对象自己的成员变量的体积。 那我们要记住一点。就是在派生类对象中，它是包含着这个基类对象。啊一定要记住这点。 而且，派生类对象中所包含的基类对象， 它是，它的存储位置是位于派生类对象的新增成员对象的前面。 啊，我们看这个基类，
    ```C++
    class CBase {
        private:
            int v1,v2;
    };
    class CDerived:public CBase {
        private:
            int v3;
    };
    ```  
  它有两个成员变量，v1和v2。 那基类对象，它的体积就是8个字点。 那这CDerived是从CBase派上来的。它有新的成员变量v3。 还有一个CDerived的那个成员，一个CDerived的那个对象。它的体积是多大呢？ 就是v1，v2，再加上v3的体积。 那就是12个字点。啊，那么看。 那整个是一个CDerived的对象，啊，派上的对象。我们要牢记，派上的对象，它里面是包含 一个基类对象的。那这包含的基类对象在哪儿呢？就是这一块，就是它所包含的一个CBase的对象。 那我们看到这个CBase的对象，它存储的位子，是在整个的派生类对象里面最靠前的这个部分。 啊，先把基类对象存好了，才会放派生类自己的成员变量。 
- 接下来咱们来看一下前面提到的学生管理程序它的具体一点的实现。
    ```C++
    #include <iostream>
    #include <string>
    using namespace::std;

    class CStudent {
        private:
            string name;
            string id;                              //学号
            char gender;                            //性别，'F'代表女，'M'代表男
            int age;
        public:
            void PrintInfo();
            void SetInfo(const string &name_,const string &id_,int age_,char gender_);
            string GetName()
            {
                return name;
            }
    };
    class CUndergraduateStudent:public CStudent {    //本科生类，继承了CStudent类
        private:
            string department;                      //学生所属的系的名称
        public:
            void QualifiedForBaoyan()               //给予保研资格
            {
                cout << "qualefied for baoyan" << endl;
            }
            void PrintInfo()
            {
                CStudent::PrintInfo();              //调用基类的PrintInfo
                cout << "Department：" << department << endl;
            }
            void SetInfo(const string &name_,const string &id_,int age_,char gender_,const string &deparment_)
            {
                CStudent::SetInfo(const string &name_,const string &id_,int age_,char gender_);     //调用基类的SetInfo
                department = department_;
            }
    };

    int main()
    {
        CUndergraduateStudent s2;
        s2.SetInfo("Harry Potter","123456",19,'M',"Computer Science");
        cout << s2.GetName() << " ";
        s2.QualifiedForBaoyan();
        s2.PrintInfo();
        return 0;
    }
    ```  
  啊，这里有一个基类， CStudent，它概括学生的共同特点，包括这个姓名，id，还有这个性别，年龄等等。 这些是共同的成员变量。然后还有一些共同的成员函数。比如说这个PrintInfo，就是打出一个学生的具体讯息。 比如名，年龄，姓名之类的啊。SetInfo就是设置一个学生的各种讯息。 GetName就是返回学生的姓名。那么这一快CStudent概括了所有的学生的共同特点。 接下来我们看CUndergraduateStudent本科学生，它是CStudent的类派生而来。它就继承得到了 CStudent的类的全部成员变量和全部成员函数。此外，它还添加了一个自己的成员变量 department，代表系。呃，当然这个本科生类也有自己的成员函数啦。 比如这个，QualifiedForBaoyan，就是给与这个学生保研资格，还输出"qualified for baoyan"。这个名字没那么山寨啊。 然后呢，这个本科生类还有一个成员函数叫PrintInfo。那我们注意到，这PrintInfo 不管名字还有参数表都跟基类里面的PrintInfo是一致的。那它当然不是重载的，对吧。 重载要求参数表不一样。当然它也不是重复第一。那这种现象这样就称之为覆盖。它说的， 它体象的一种派生类对基类的修改。这就是这个基类的PrintInfo的动作跟它那个PrintInfo的基类的动作，它可能是不一样的。 啊，所以我们派生类里面要重新写一个PrintInfo，就是这个意思。那我们派生类的PrintInfo就要打出派生类的全部讯息。 要说出从基类继承得到的那些讯息，如果我们能用好几条cout语句来做的话， 这样是比较浪费的。因为在基类的PrintInfo里面，身上已经做了， 把基类里面的各种讯息都输出的这种事情啦。所以我们在这里呢，只需要调用 基类的PrintInfo就能够把这些共同特点，姓名年龄之类的都给输出了。 那在这里，我们在PrintInfo前面加了CStudent两个冒号。那就等于告诉别人， 咦，这个PrintInfo是基类的PrintInfo。那如果你不写CStudent加两个冒号呢， 那便应器就认为PrintInfo就是你UndergraduateStudent自己的PrintInfo，那这样就依归了，对吧。 好，那我们在派生类里面先调用基类的PrintInfo， 输出所有学生的共性，就是姓名年龄之类的。 然后再输出它自己独有的特点，就是系。 那通过这个PrintInfo可以看出来在这个C++ 程序设计的时候，并且派生类里面 添加了跟基类同名同参数表的成员函数。而且这个成员函数里面 先调用了基类里面的同名成员函数，完成跟基类有关的事。 然后再写一些代码，完成跟派生有关的事。啊，一种做法实际上是特别常见的。 那同样的事情也发生在SetInfo上面。SetInfo还要设置派生类各种各样的讯息。 那当然我们在里面都可以先调用基类的SetInfo。设置的从基类继承的得到的那些 讯息以后，然后再设置一下自己独有的讯息。 接着我们看到在main里面做了些什么。啊，我们定义了CUndergraduateStudent 的对象s2。然后我们设置s2的不同讯息。 他叫Harry Potter，他的学号，他19岁，男性，专业是计算性科学。 然后我们输出s2点GetName，啊，就把他名字给打出来了。 接下来，我们哈里波特Baoyan，s2点QualifiedForBaoyan， 好，我们就要用s2点PrintInfo，把Harry Potter 的全部讯息都打出来。 这个程序的输出结果就是Harry Potter，就是s2点GetName的结果 qualifed for baoyan就是s2点QualifiedForBaoyan的结果。 那下面这一块就是s2点PrintInfo的结果了，所有的讯息都打出来了。 好了，继承我们就讲到这。 
## 2. 复合关系和继承关系
- 用面向对象的方法写程序，我们不但要学会设计类 还要学会处理类和类之间的关系，那么类和类之间主要有三种关系： 第一种关系就是没关系，第二种关系之继承关系，第三种关系是复合关系。接下来我们就来讲讲继承关系和复合关系。 
- 继承关系呢，也被称之为“是”的关系。 如果从类A派生出类B， 那这两种关系就是继承关系。那前面我们说继承的目的 是为了实现代码的重用，如果类B 和类A很相似，我们就可以考虑从类A派生出B，从而节省写代码的这个工作。 但并不是只要能够节省代码的这个继承就都是好的继承。 嗯，一个合理的，嗯，继承关系应该满足 一下这个要求。**就是如果你想从类A派生出类B，那么逻辑上 那么逻辑上下面这个命题应该成立。就是说，一个类B对象也应该是一个类A对象**。 就好比说我们从学生类派生出中学生类， 这是合理的，为什么呢？因为一个中学生他同时也是一个学生。所以这种派生就合理。 再看复合关系。 
- 复合关系也被称之为是“有”的关系。那么比方说类C中有一个成员变量K。 这个K是类定义的对象。那么C和D都是复合，复合关系。 那么一般上，一般来说你要使用复合关系，在逻辑上应该满足这样的要求， 就是说这个D对象它是C对象的固有属性；或者是组成部分。 
- 下面我们先来看看如何合理的使用继承关系。 比如说，我写了一个人事管理程序，嗯， 里面有一个CMan代表这个男人，啊，处理男人之间的事情。 后来随来，后来随着单位扩大及女权运动的不断发展啊， 嗯，我们也需要处理女人的事情了，所以就是说当然要引入CWomen类。 那CWomen类当然跟CMan类它有很多相似之处，因为我就从CMan类 派生出CWomen类。这种做法到底对不对呢？ 那你就要问一下你自己， 一个女人是不是一个男人？从男人派生出女人嘛，你就要问，一个女人是不是一个那男人？ 一个女人当然不是一个男人，哪怕她是女汉子她也不是男人。啊，所以这种派生关系呢 当然就是不合适的。那么，这个正确的做大应该是怎么样的呢？ 啊，就应该是我们概括男人和女人的共同特点， 写一个CHuman类，嗯，这个CHuman类代表人， 然後我们让CMan和CWomen都从CHuman类派生而来。嗯，就像这样。 嗯，这就对了。
- 那下面我们再来看使用复合关系的例子。 然说有一个几何形体的绘图程序，要画圆啊点啊之类的东西。 那当然这个时候我们需要写“点”类，我们同时也需要写一个“圆”类。 那么有的教科书上都犯了一些错误，它是这么教你的啊，这个点类嘛， 
    ```C++
    class CPoint {
        double x,y;
    };
    ```  
  它有x、y两个成员变量，对吧？代表它的坐标。 那圆这个类呢，它有圆心，圆心呢也有x、y两个，嗯，属性。 代表它的位置。那既然如此呢，我们就知道这个圆类从点类派生而来。 然後呢，再加上它自己的一个成员变量半径R，是不是就行了呢？实现了代码重用嘛！ 那要怎么做的话我们可以看到，这个CCircle和CPoint这两个类之间的关系是什么样？ 就是继承关系了。拿这个继承关系是不是合理的呢？ 那就问一下，你说一个圆是不会死一个点啊？ 不是一个点啊！所以这种继承关系就是不合理的。 那正确的做法应该是怎么样的呢？嗯，正确的做法应该是使用复合关系。 为什么是复合关系？因为我们知道圆是有圆心的， 那也就是说每一个圆里面都有一个特殊的点。 这个特殊的点就是圆心。 因此我们可以用复合关系。
    ```C++
    class CCircle {
        double r;
        CPoint center;
    };
    ```    
  好，这是点类。 这个是圆类。 圆类里面呢有成员变量R代表半径，另外还有一个成员圆变量对象 就是CPoint类的对象。Center，这个centre 是一个点，代表圆心。 好吧，**那这样CCircle跟CPoint之间就是复合关系。 每一个CCircle 对象里面都包含一个CPoint的对象。 就是它的圆心**。那么为了使得这个，嗯，CCircle类能够方便的操作 Center这个成员变量里面的x和y坐标。 那么我们最好呢，把这个，嗯， CCircle类 嗯，声明为CPoint的类，CPoint类的友元， 
    ```C++
    class CPoint {
        double x,y;
        friend class CCircle;           //便于CCircle类操作其圆心
    };
    ```    
  因为我们这里的x、y是私有的，对吧? 如果你不把CCircle变成友元的话， 你就，在CCircle类就没有办法访问Center这个成员对象它的x、y了。 
- 下面呢，我们再看一个更复杂一点的使用复合关系的例子。 嗯，比方说我们要写一个小区养狗管理程序。 嗯，现在小区里面养狗可是大问题。 那么在这里面我们需要有业主类，还需要写一个狗类，对吧？因为狗是有主人的。 主人当然就是业主。在这个程序里面我们假定 狗很忠实它只有一个主人。但一个业主呢最多可以有10条狗，太恐怖了！ 所以这里面有很多的业主，有很多的狗。 如何处理这个主人类和狗类之间的关系？ 才能使得这个人和狗的关系和谐相处呢？ 好，有的同学就说了：我这么来做。
    ```C++
    //错误混乱的例子
    class CDog;
    class CMaster {
        CDog dogs[10];
    };
    class CDog {
        CMaster m;
    }
    ```  
  我们写一个CMaster的类嗯，这代表主人。 一个主人最多能有10条狗，所以我在这里面用一个成员变量Dog。他是一个数组，这个数组能够容纳10个 Dog的对象。CDog的对象。然後这里由于用到了CDog的这个类，我在前面要把CDog提前拿出来声明一下。 嗯，然後呢在这个CDog 这个类里面呢我 又有一个成员对象叫做M，它代表这条狗的主人。 这样呢，这个成员就说我们实现了人中有狗，狗中有人。 人狗交融和谐相处啊！ 拿我要对这个成员说：“和谐个鬼，你的C++是保安教的吗？” 嗯，这种，这种处理主人类和狗类之间的关系的做法是完全错误的。 为什么是错误的呀？我们看看。 因为它循环定义了。怎么讲？ 如果我问你一个CMaster的对象，是多少个字节你会算吗？你会说他里面有10个CDog的对象， 所以它的体积是10倍的CDog的体积。那么一个CDog的对象又占多上个字节呢？ 哦，我们看一个CDog的对象，它包含一个CMaster的对象，它的体积应该跟一个CMaster对象一样。 **这不就循环定义了吗？根本就算不出CMaster和CDog的体积，所以这种做法编译的时候就根本就过不了。** 那我们再看看另外一种写法。 
    ```C++
    //依然错误混乱的例子
    class CDog;
    class CMaster {
        CDog *dogs[10];
    };
    class CDog {
        CMaster m;
    }
    ```   
  另外一种写法呢，为这个狗类设一个业主类的成员对象。 在这儿，啊，设业主类的成员对象。然後，为业主类设一个 狗类的对象指针数组。嗯，这个时候就避免了这个， 嗯，循环定义了。 这是后问你一个CMaster，嗯，对象到底是多少个字节？您能算出来了，对吧？ 因为他里面有一个10个元素的数组，每一个元素都是一个指针。 那它的字节数就是40个字节。 嗯，那同理这个CDog的对象死多少个字节你也能够算得出来。 但是这种写法呢，它实际上还是不对的。 为什么是不对的呢？我们看到在这种写法里面啊，人中，嗯，狗中有人。 两条狗它的主人有可能是共同的一个人，对吧？ 那在这种情况下我们就会牵涉到一个问题，就是如何维护 不同的狗里面，相同的主人他的信息的一致性的问题。 就比方说，我，我改变了这条狗里面所包含的主人信息， 那么，另外一条狗它的主人和另外一条狗是相同的；而另外一条狗里面的主人的信息去哦们也要相应的进行修改。 那么，维护相同主人的多条狗里面的所包含的多个主人对象的信息的一致性是一件很罗嗦的事情。 所以这个写法是不正确的。 嗯，那再看一个看上去还过得去的这个写法。 就是我们为狗类设一个业主类的对象指针，
    ```C++
    //凑合的写法
    class CMaster;
    class CDog {
        CMaster *pm;
    }
    class CMaster {
        CDog dogs[10];
    };    
    ```   
  在这儿，业主类的对象指针。 然後这里用到了业主类，所以我们前面把业主类提前声明一下。 然後我们再为这个业主类设一个狗类的对象数组。 在这儿，嗯。这样子的话 看上去似乎问题不大，但却时也不太好。 在这种情况下呢，我们人和狗之间的关系怎样啊？是人中有狗。 然后呢，每一条狗呢都有一个指针，指向它的主人。 这个不好在哪儿呢？首先事实上从逻辑上来讲啊，我们要求复合关系一般是这样的。如果 **有一个类它有成员对象，那么我们就会要求这个成员对象是这个类的一个固有的这个属性**。 是它的组成部分或者固有的属性。那我们在这个主人类里面 有10条狗，有10个狗的对象，我们能说这个 狗它是主人的一部分吗？或者我们能说这个狗是 主人的固有属性吗？ 好像从逻辑上来讲是有那么一点别扭，因此这种，嗯 做法呢就是不太那么好。 那实际上这种做法呢，还有一个比较严重的不好的地方。 就在于在这种做法里面，狗狗都失去了自由，失去了独立的狗格。为什么这么讲呢？ 因为我们看到所有的狗的对象都被包含在 一个或者多个主人对象里面了。 那我们要对这些狗对象操作的话，就要通过他的主人来进行。 这些狗就没有自由了，他们不能独立活动了。所以从逻辑上来讲， 这个做法是不太好的。
- 那正确的做法应该是怎么样的呢？ 就是要为狗类设计一个业主类的对象指针。 在这儿，指向它的主人。然後为业主类设计一个狗类对象的指针数组。
    ```C++
    //正确的写法
    class CMaster;
    class CDog {
        CMaster *pm;
    }
    class CMaster {
        CDog *dogs[10];
    };    
    ```   
  在这儿，啊，这是一个指针数组。 嗯，那这样的话呢，嗯，一个业主里面的这个成员变量dogs 这个数组里面的有一些元素就会指向这个主人所拥有的狗。 那，在**有的教科书上面把这种一个类 有一个成员是另外一个类的指针这种情况， 称之为这两个类是知道的关系**。啊，因为一个类的对象通过指针就能够知道另外一个 嗯，类的对象。或者可以说找到另外一个类的对象。 那，在我们这个人狗关系的这个程序里面，这样处理是比较好的。 然后我们就可以把这个图画出来，啊。在这么写代码的情况下人和狗的关系就是这样，啊。 主人拥有多少狗，所以他有不同的指针指向它的多条狗 然後每一个，每一条狗呢都有一个指针指向它的主人 这样子呢，主人通过指针就能够找到自己的狗，并且对狗进行操作。那狗呢也能够 自由活动。而且呢，狗通过这个通过狗里面存放的指针也能够找到它的主人。 这样就真的实现了人狗关系的和谐。 当然人狗关系的和谐在程序里面是容易做的，在现实生活中就不容易做了。那我们小区养狗，人狗，养狗问题很突出啊！ 我在讲课的时大家如果突然听到有狗叫也不要觉得奇怪哦！ 
## 3. 基类/派生类同名成员和protected访问范围说明符
- 大家好，在这一小节中呢，我们来看以下基类和派生类同名成员的情况 以及Protected这个关键字。 
- 那么基类和派生类呢，有时候会出现同名成员的情况。 也就是说，基类和派生类拥有相同名称的成员变量或者成员函数 
    ```C++
    class base {
        private:
            int j;
        public:
            int i;
            void func();
    };
    class derived:public base {
        public:
            int i;
            void func();
            void access();
    };    

    void derived::access()
    {
        j = 5;          //error，j是基类的私有变量
        i = 5;          //引用的是派生类的i
        base::i = 5;    //引用的是基类的i
        func();         //派生类的
        base::func();   //基类的
    }

    derived obj;
    obj.i = 1;
    obj.base::i = 1;
    ```  
  如果我们有一个基类称为class base， 在这个基类里面呢，它定义了一个成员变量int j，此外还有int i和void func()， 由这个base类呢 派生出来的一个新的类呢称为叫做class derived 那么class derived里头呢也包含了一个int i 还有一个函数void access()和void func()， 我们看到说呢， 这样的一个基类和派生类呢共同拥有相同的成员对象 和相同名称的这个成员函数。那么在使用的时候有时候就会遇到一些问题， 比方说首先我们在这个 derived的派生类里面 对应的这个access函数的这个定义中间呢，如果我们去访问， 去写出j=5，那么j就会报错， 为什么呢？因为j呢是基类的一个私有的成员变量， 在派生类里面呢是不能够被访问到的。那么我们可以用 i=5，那么这时候i是谁呢？我们刚看到说 int i既在base类里面出现过也在derived类里面出现过， 那么在当前的这个函数的实现过程中间呢， 我们实际上呢具体指的是这个派生类， 所以这里引用的是派生类的i 那么如果我们希望去给base这个类的对应的那个变量i来赋值的话怎么办呢？ 我们要在i前面去添加一个域作用符， 啊，base双冒号，来告诉说，哦，原来这个i呢是base这个类的 那进行赋值。那么同样的， 如果我们直接写func这个函数，那么它是指的是那个派生类对应的成员函数， 如果我们需要调用基类的话，那么 我们就必须在前面加上base::来调用func这个函数。 那么有了这样的一个access这样一个函数的定义之后呢，如果我们去定义derived 派生类生成的一个新的对象，叫obj，那么obj.i呢等于1， 实际上呢是对这个派生类里面的成员变量来进行赋值， 那么obj.base::i=1呢是对这个派生类对应的这个基类部分的那个成员变量i来进行赋值 那么我们来具体看看obj本身这个对象那么它占用了存储空间包含哪些呢， 它首先呢，就包含了这个派生类自身 定义的那个成员变量i， 同时呢，还有这个基类的成员变量i， 那么另外呢，还包含了基类的私有的成员变量j， 那么这个时候我们就会看到说基类那一部分 成员变量也被包含在派生类中间， 当然要注意了，一般来说我们是不推荐 基类还派生类具有相同的成员变量名的。 我们一般呢会希望它能区别开来。 当然有时候呢，基类和派生类呢是会具有同名的函数的。 
- 那么我们来具体说一说访问范围说明符， 我们刚才看到，这个对于基类的private的成员j 那么它就不能够被派生类的这个函数所访问，那么我们看因为**基类的private的成员它只能是被基类自身的成员函数以及基类的友员函数进行访问 那么对于基类public的成员呢，那么它可以被很多函数所访问到。 其中包含了基类的成员函数，基类的友员函数，派生类的成员函数，派生类的友员函数 以及其他的函数**。因为它是public，完全公开化的。 所以可以被一系列的函数所访问到。 
- 那么第三种关键字是我们之前没有讲到的，被称为叫做protected， 那么我们在引入这个继承这样的一个关系之后呢，它也会被提到 因为基类的protected成员呢是可以被下列的函数所访问的， 除了像private一样是可以被基类的成员函数和基类的友员函数访问到，那么 protected成员呢稍微特殊一点，ii呢ii一点， 它可以被派生类的成员函数访问， 那么它可以访问谁呢？ 可以访问当前对象的基类的 保护成员。啊，注意一定是当前对象 基类的保护成员。我们具体来看一下。 
    ```C++
    class Father {
        private:
            int nPrivate;
        public:
            int nPublic;
        protected:
            int nProtected;
    };

    class Son:public Father {
            void AccessFather()
            {
                nPublic = 1;            //ok
                nPrivate = 1;           //wrong，不能访问基类私有成员
                nProtected = 1;         //ok，访问从基类继承的protected成员
                Son f;
                f.nProtected = 1;       //wrong,f不是当前对象
            }
    };

    int main()
    {
        Father f;                       
        Son s;
        f.nPublic = 1;                  //ok
        s.nPublic = 1;                  //ok
        f.nProtected = 1;               //wrong
        f.nPrivate = 1;                 //wrong
        s.nProtected = 1;               //wrong
        s.nPrivate = 1;                 //wrong
        return 0;
    }
    ```
  我们有一个基类，称为叫做class Father， 那么它分别有三种不同 访问范围说明符，对应下的这个成员，称之为叫做nPrivate,nPublic和 nProtected，那么 它有一个派生的类叫做class Son，对吧， 我们从爸爸那里派生出来了一个 儿子类，那么在son这个类里面呢，我们定义了一个函数，成员函数 称为叫做access Father,我们要看一看爸爸里面的这些成员哪一些是我们可以拿来用的， 我们发现说呢，nPublic呢是可以直接被赋值访问的， 赋值为1.那么nPrivate等于1这个语句呢就是错误的。 我们不可以访问老爸私有的东西。那么，还有一类叫做nProtected， OK，这个呢是可以被访问到的，因为呢它是从基类继承来的，啊，protected， 那么是作为当前这个对象的这个 保护成员是可以被访问到的。 那么如果我们在这个son这个类里面 又重新定义了一个新的对象称为叫做f，那么如果我们去 调用 f.nProtected=1，那么这个语句呢就是错误的， 因为f.nProtected不是我们当前这个accessFather这个函数 所面对的那个对象，啊， 它是另外一个，所以呢，这个不是当前对象的protected成员呢，我们也一样是不能够访问的。 我们再来看，如果在其他的函数里头，不再是成员函数了， 在main函数里头，那么我们定义了 father的对象，新的一个对象的f和son的对象s，那么 他们相应的nPublic的对应的这个成员都是可以被访问到的， 那么，不管是nProtected还是nPrivate, 都是不可以被访问的，通通不可以访问。 **所以我们要注意，protected成员只能是在这个派生类当前的这个对象中间可以被访问到**。 
## 4. 派生类的构造函数
- 大家好，在这一小节中我们来介绍一下派生类的构造函数。 那么派生类呢，和其他所有的类一样都包含一个构造函数。 那么我们知道说呢，对于派生类而言它的对象呢是包含一个基类的对象的。 所以当派生类去调用构造函数，去完成自身的这样的一个初始化 过程的时候呢，首先就需要去执行基类的构造函数。 去初始化那些派生类中间包含的基类对象的一些初始化。 那么我们来具体看一下， 在派生类去交代基类初始化的时候呢，那么它和我们之前给大家介绍的封闭类一样 都需要通过一个初始化列表明确的告诉 这个派生类的构造函数中间一些对应的参数 是如何在基类通过构造函数来进行初始化的。 我们来看一个具体的例子， 
    ```C++
    class Bug {
        private:
            int nLegs;
            int nColor;
        public:
            int nType;
            Bug(int legs,int color);
            void PrintBug() {}
    };
    class FlyBug:public Bug {                   //FlyBug是Bug的派生类
        private:
            int nWings;
        public:
            FlyBug(int legs,int color,int wings);
    };    

    Bug::Bug(int legs,int color)
    {
        nLegs = legs;
        nColor = color;
    }

    //错误的FlyBug构造函数：
    FlyBug::FlyBug(int legs,int color,int wings)
    {
        nLegs = legs;               //不能访问
        nColor = color;             //不能访问
        nType = 1;                  //ok
        nWings = wings;
    }

    //正确的FlyBug构造函数：
    FlyBug::FlyBug(int legs,int color,int wings)：Bug(legs,color)
    {
        nWings = wings;
    }

    int main()
    {
        FlyBug fb(2,3,4);
        fb.PrintBug();
        fb.nType = 1;
        fb.nLegs = 2;               //error,nLegs is private
        return 0;
    }
    ```
  我们这边呢设计了一个基类，称为叫做class bug一个虫虫类。 那么这个虫虫类呢它本身包含了两个 private类型的成员变量。 此外呢，它还有一个public的成员变量以及对应的两个成员函数。 那么我们看到说这个基类的 构造函数呢就是在bug的这个函数里面去初始化 相应的两个private的成员变量，legs 和 colour。 那么，此外呢它还可以打印输出bug。 那么我们由class bug派生出来了一个派生类， 称为叫做FlyBug。啊，一个飞虫。 那么它是由bug呢派生出来的派生类。 那么在FlyBug里头呢，那么自然而然的因为它会飞，所以它对应的有一个nWings这样的一个成员变量。那么对于FlyBug这个 类的派生类的构造函数的话呢，那么它就需要去初始化这样三个成员变量。 那么我们看到了，对于legs 和 colour这两个 对象来讲呢，实际上它本身是基类的对象。 所以呢，我们在去调用FlyBug这样的一个构造函数的时候 必须呢首先去调用基类的构造函数bug 来去初始化相应的legs和colour。 我们看到说呢，我们如果去这样设计一个相应的 构造函数，啊，也就是说不去调用基类的构造函数的话， 那么如果你想在这个构造，派生类的构造函数里面 去进行初始化，那么它是不能够进行访问的。因为本身呢 nLegs 和nColour是Bug的这个legs自身的 private的成员变量。 即便是派生类也不可以访问其基类的private类型的变量，所以呢，我们需要去利用这样的一个 成员初始化列表来进一步 去初始化相应的legs和colour。啊。 那么，当然你可以对wings呢直接把它写在构造，这个派生类的构造函数里面就可以了。 我们注意呢，在这样的一个初始化列表的 表达式中间呢实际上是可以去相应的 出现Flybug的构造函数的参数的。 那么在这个main函数里头的话呢，我们就看到说，如果我们去定义了一个FlyBug的对象，啊，fb。 那fb呢，它希望通过2、3、4这样 三个参数去具体的去定义，嗯，这么一个对象； 那么，这时候你可以去直接调用fb.PrintBug这样的一个函数，啊。 PrintBug大家不知道还记不记得实际上刚才呢是bug这个类的 public的一个函数。 那么对于fb这样的一个派生类的对象而言呢，他实际上是可以访问的， 访问和调用。那么对于fb.nType呢 等于1这也是一样的，对吧？它也是基类的一个public的一个成员的一个变量。 此外呢，如果对于fb.nLegs呢 这样的一个赋值呢就是不可以的。因为本身呢，这个nLeg呢是一个private. 所以我们说呢，当我们去创建一个派生类 的对象，比方说这里的FlyBug fb，啊， 它是一个派生类的对象。 **那么我们在创建这个派生类的对象的时候呢，首先是要干的事情，就是去调用基类的构造函数。 那么我们在初始化派生类对象中间的 这个基类继承的成员，那首先就要去初始化这部分 也就是我们要收对派生类对象中间 包含的那些基类的成员来进行初始化。 那么在执行一个派生类构造函数之前呢， 首先要执行的，啊。我们反复的强调是基类的构造函数。 那么具体调用基类构造函数的方式呢，其实也有两种形式。 第一种呢，我们把它称为叫做显式的方式。也就是刚才我们在那个bug的那个的例子里面看到的。 我们呢在派生类的构造函数中间呢，去显示的表示基类的构造函数 并且呢，去提供相应的参数。啊，比方说，我们这里表达的，我们去 在派生类derived的这样的一个类里面去 定义相应的这样的一些形参的参数。 而这些参数具体的实参写在哪里呢？写在基类的构造函数的实参列表里，啊。 那么第二种的话呢，是隐式的方式。 那么在派生类的构造函数中间呢，我们也可以直接省略 基类的构造函数的调用。那么它的这个调用形式呢，实际上就是说 我们在派生类构造函数的时候呢，自动的去调用基类的 默认的构造函数。啊。它并不是说没有去调用，而是去直接调用默认的构造函数**。 
- 那么同样相应的和封闭类的形式一模一样， 我们对于派生类的析构函数在执行的时候呢，那么，它首先就要去执行的是派生类自身的析构函数。然后呢，去相应的调用基类的析构函数。 我们来看这样的一个例子， 
    ```C++
    class Base {
        public:
            int n;
            Base(int i):n(i)
            {
                cout << "Base" << n << "constructed" << endl;       //一
            }
            ~Base()
            {
                cout << "Base" << n << "destructed" << endl;        //四
            }            
    };
    class Derived:public Base {
        public:
            Derived(int i):Base(i)
            {
                cout << "Derived constructed" << endl;              //二
            }
            ~Derived(int i):Base(i)
            {
                cout << "Derived destructed" << endl;               //三
            }
    };

    int main()
    {
        Derived Obj(3);
        return 0;
    }
    ```
  我们有一个基类呢称为叫做class Base。 这是一个基类。那么，它呢定义了就是一个很简单的一个 int n的一个成员变量。那么，此外呢他定义了一对 构造函数和析构函数。 那么在构造函数当中呢，就是，就是去初始化这个相应的n值。 并且打印<<"Bass "<<n<<" constructed"。 而为了去标记其相应的这个析构函数 被调用到呢，我们让它cout <<"Bass "<<n<<以及"destructed"。 那么由这个class Base 呢，就可以派生出来一个类称为叫做class Derived。 我们得到这样一个派生类derived呢，那么它其实做的事情也很简单。 我们就是去设计了一个这个派生类的构造函数。 那么在派生类的构造函数里头我们要注意，首先要去调用 这基类的构造函数来进行初始化。此外呢，我们还设计了一个 derived的析构函数， 那么分别在这个构造函数和析构，析构函数里面呢 去打印输出相应的"Derived constructed" 和"Derived destructed"。 那么这样一个非常简单的基类和，嗯， 派生类的一个，嗯，类设计之后呢，我们看看如果我们去定义了一个 派生类的对象。啊。Derived Ojc(3) 也就是说我们利用3去定义相应的这个 基类里面的这个int n。那么，它的这个 对象的的产生和消亡呢就会非常明显能看到 整个基类和派生类构造函数和析构函数的调用。 那根据我们刚讲的，那么实际上我们会首先去调用一个 基类的构造函数，然后是相应的派生类的构造函数。 那么呢，析构函数正好相反。首先呢去调用相应的 派生类的析构函数，然后呢才是调用基类的析构函数。 所以这样的一段程序它的输出的结果就是，我们呢，会打印输出Base 3 constructed, 然后是Derived constructed; 然後是派生类的析构函数Derived destructed以及相应的 基类的析构函数Base 3 destructed。啊，从这个例子呢，我们就可以非常清晰的看到说 这样的一个调用关系。 
- 那么，除了这个最基本的派生类的 构造和析构函数之外呢，我们再来看一下当这个 包含成员对象的派生类。 那么它的这个初始化的时候是怎样去设计这个构造函数的。 那么这里面我们首先看一个例子。
    ```C++
    class Skill {
        public:
            Skill(int n) {}
    };
    class Bug {
        private:
            int nLegs;
            int nColor;
        public:
            int nType;
            Bug(int legs,int color);
            void PrintBug() {}
    };
    class FlyBug:public Bug {                   //FlyBug是Bug的派生类
        private:
            int nWings;
            Skill sk1,sk2;
        public:
            FlyBug(int legs,int color,int wings);
    };    

    Bug::Bug(int legs,int color)
    {
        nLegs = legs;
        nColor = color;
    }

    //正确的FlyBug构造函数：
    FlyBug::FlyBug(int legs,int color,int wings)：Bug(legs,color),sk1(5),sk2(color)      //先调用基类的构造函数，再调用成员对象类的构造函数
    {
        nWings = wings;
    }

    int main()
    {
        
        return 0;
    }
    ```
  啊。我们定义了一个类称为叫做class Skill。一个单独的一个类。 那么这个class Skill呢，它本身只包含了一个构造函数 那么还是刚才的那个派生类和基类，啊，我们定义了一个 派生，基类称为叫做bug, 然后有一个派生类称为FlyBug。 那么对于这个FlyBug呢，它和刚刚那个FlyBug有一个区别就在于说 它除了nWings之外呢，它还多了两个成员对象 那么分别是Skill 类的sk1和sk2，啊，这样两个成员对象。 那么对于FlyBug这样的一个构造函数来讲的话， 那么它就需要说首先去调用 这个相应的、基类的构造函数Bug 来初始化int legs和in color。 那么除此之外呢，还需要去调用其成员对象的那个leg。 啊，也去相应的去进行初始化。 我们看到说呢，在这个表达式中间 初始化列表的这个表达式中间呢，我们可以出现FlyBug本身的构造函数的一些参数 以及一些常量，啊，都可以。 所以我们说呢，在创建派生类对象的时候； 在具体执行一个派生类的构造函数之前， 我们首先呢应该去调用基类的构造函数。 那么在基类的构造函数中间呢，去初始化谁呢？去初始化派生类对象中间 从基类继承的那些成员。啊。首先去初始化这样一部分，然後呢去调用 成员对象类的那个构造函数。 那么去初始化谁呢？去初始化派生类对象中间的那些的成员对象，啊。 所以这是有一个非常明显的顺序的。第一步先去调用基类， 第二步再去调用成员对象类。 那么相应的，执行完派生类的析构函数之后呢，那么也要去首先调用 成员对象类的析构函数。之后呢，再去调用基类的析构函数。 我们看到说呢，这又是之前那样的一个规则。 首先呢，去调用构造的呢，后析构，啊。 基类的这个构造函数呢，首先被调用到最后被析构。 那么，中间呢被这个调用到了这个构造函数呢，先析构。 那么析构函数的调用顺序呢，和构造函数的调用顺序呢 是正好相反的。 
## 5. public继承的赋值兼容规则
- 下面再看，public继承的赋值兼容规则。 我们看到，这里有个基类啊，这里有一个派生类。
    ```C++
    //正确的写法
    class base{

    };
    class derived:public base {

    };
    base b;
    derived d;   
    ```   
  注意派生类的这个地方，写的是public， 那么，这种派生我们就称为公有派生。 实际上这个位置你还可以写private 或者protected，不过很少用， 我们一般都写public，这个叫公有派生。 那这个位置，写public情况下，有以下几条赋值兼容规则。 我们来看，这是一个基类的对象 b，这是一个派生类的对象d， 
    - 那么赋值兼容规则的第一条就是，**派生类的对象可以赋值给基类对象**。啊，这样。因为我们本来就说，一个派生类对象就是一个基类对象。那么，你把派生类对象赋值给基类对象就是没有问题的。 那大家想想看，这个赋值号，在没有经过重载的，缺省的情况下，它做的事情是什么呢？ 那当然就是，我们知道d里面是包含一个base对象的对不对？那么这个b等于d 实际上就是把d里面所包含的这个base对象的内容，拷贝到这个b 里面去。啊，这个就是赋值号。在缺省的，没有被重载的情况下，所做的事情。 那当然，如果你把这个赋值表达式反过来，写d等于b，那就是不行的了。因为一个基类对象，并不是一个派生类对象，所以你不能把基类对象赋值给派生类对象。 
    - 好，赋值兼容规则的第二条是 **派生类对象可以初始化基类的引用**。 那当然了，既然一个派生类对像又是一个基类对象，那么你让一个基类的引用去引用一个派生类的对象， 也是没有问题的。你可以认为，这个基类的引用，实际上它就引用了派生类对象里面，所包含的 那个基类对象。 
    - 那赋值兼容规则的第三条，就是**派生类对象的地址可以赋值给基类的指针**，啊， 像这样。那基类的指针，指向了一个派生类的对象，啊， 因为派生类对象就是一个基类对象，所以这个没有问题。你也可以认为， 这个指针，就指向了派生类对象里面所包含的那个基类对象。 那本来派生类对象里面所包含的那个基类对象就是放在派生类对象存储空间的最前面， 也就是说那个基类对象的起始地址就是整个派生类对象的起始地址， 所以你让基类的指针指向派生类对象，没有问题。 这就是public继承情况下的赋值兼容规则。 
- 那要注意了，如果派生方式不是public，那上述三条，就不成立了。 
- 接下来看一看，直接基类和间接基类的概念。C＋＋里面，类的派生，可以是很多层的。 比如说我们可以从A派生到B，从B派生出C，再从C派生出D。 那么在这种情况下，我们都称A，它是B的直接基类。那A呢，它肯定就是C的间接基类了。 那对于D来说呢，它的直接基类是谁呢，当然就是这个C，对吧？ 那D的间接基类有谁呢？有A和B。这个概念很容易搞明白。那我们在伸明一个派生类的时候呢，我只需要 列出它的直接基类就行了，啊，不用把它前面一堆的间接基类都说清楚。 然后派生类就会沿着类的层次自动向上继承它的间接基类的所有成员。 有一个孙子辈的类，它继承了 父亲辈的所有的成员，它也继承了爷爷辈的所有的成员。 所以一个派生类的成员它就包括派生类自己定义的成员， 直接基类中的所有成员，以及全部的间接基类中的所有成员。 
- 那我们来看一个这个多层派生的例子。啊，在这里面牵涉到多个构造函数的这个调用。 
    ```C++
    #include <iostream>
    using namespace::std;
    
    class Base {
        public:
            int n;
            Base(int i):n(i) 
            {
                cout << "Base" << n << "constructed" << endl;           //一
            }
            ~Base() 
            {
                cout << "Base" << n << "destructed" << endl;            //六
            }
    };
    class Derived:public Base {
        public:
            Derived(int i):Base(i)
            {
                cout << "Derived constructed" << endl;                  //二
            }
            ~Derived()
            {
                cout << "Derived destructed" << endl;                   //五
            }
    };
    class MoreDerived:public Derived {
        public:
            MoreDerived():Derived(4) 
            {
                cout << "MoreDerived constructed" << endl;              //三
            }
            ~MoreDerived():Derived(4) 
            {
                cout << "MoreDerived destructed" << endl;               //四
            }
    };

    int main()
    {
        MoreDerived Obj;
        return 0;
    }
    ```   
  这是最上层的基类，Base，它的构造参数，然后它输出Base constructed， 它的析构函数就是Base, n, destructed。 这是中间那一层的类，Derived的类，它从Base派生而来， 它有构造函数，啊，它也有析构函数。 然后呢，下面这个是最下一层的类，啊，相当于孙子辈的类， 它是从中间那一层，Derived这个类派生而来。我们看到，它的间接基类，Base，就不用列出来了，对吧？ 然后，在这个MoreDerived里面，也有构造函数， 在这构造函数的初始化列表里面，它只需要指名直接基类 是如何初始化的就行了。它不需要指名那些间接基类如何初始化。 那些间接基类如何初始化是由它的直接基类 的构造函数来决定的。啊，在这里，间接的底层基类不用管上面这么多的事情。 然后，我们看这个Main程序里面，它只有一个MoreDerived的对象， 然后，程序就结束了。那很显然，这个程序的输出都是由于一系列构造函数的调用产生的。 以及析构函数的调用产生的。 那现在我们将一个第三层的，派生类对象生成的时候， 到底先执行哪个类的构造函数呢？ 答案就是要从最顶层基类开始，一次往下执行各个 基类的构造函数，然后最后再执行这个MoreDerived类，自己的这个构造函数。 所以这个程序的输出结果就是先执行Base的 构造函数，再执行Derived的构造函数，再执行MoreDerived的自己的构造函数。 那当这个MoreDerived类消完的时候，析构函数的执行顺序又是什么样的呢？ 啊，那跟构造函数的执行顺序就相反了嘛。先执行MoreDerived的 析构函数，再执行Derived的析构函数，再执行Base的析构函数。好，就是这样。 