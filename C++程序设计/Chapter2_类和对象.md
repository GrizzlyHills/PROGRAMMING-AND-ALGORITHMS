# [类和对象](https://www.coursera.org/learn/cpp-chengxu-sheji/home/week/3)
> 在对类和对象有了初步的了解后，大家已经知道类是C++中十分重要的概念，它是实现面向对象程序设计的基础。类是所有面向对象的语言的共同特征，所有面向对象的语言都提供了这种类型。本模块将进一步介绍类和对象的相关深入概念与内容，包括用于初始化的构造函数，以及复制构造函数，析构函数等。
## 1. 内联成员函数和重载成员函数
- 大家好，在这一小节中，我们来介绍一下内联成员函数和重载成员函数。 在第一周的课里呢，郭老师已经介绍了内联函数的定义。 那么内联函数呢，其实就考虑到了一类特殊的函数，它自身的这个语句呢非常的少，运行起来呢也非常的快， 那么在这种情况下，由于函数调用是会产生一定的调用语句， 那么当你这个函数被反复的调用到时，就会产生非常大的调用开销， 于是呢， 我们就定义了这样一类内联函数 去实现这个当编译器访问的时候， 那么看到内联函数了呢，它就会把这一系列函数定义的这些语句呢插入到调用的这个地方， 就不会产生额外的调用开销了。那么成员函数呢，也可以被定义为是内联的。 
- 那么内联成员函数呢，有这样两种方式可以定义。 首先呢，就是使用inline关键字。 那么，它使用完之后呢，后面跟上相应的成员函数就可以被定义为是内联成员函数。 此外呢，也可以简单将函数体写在类的定义内部，它同样也是将这个函数定义为是内联成员函数。我们来具体看一下。 
    ```C++
    class B {
        inline void func1();        //方式一
        void func2() {              //方式二

        }
    };
    void B::func1() {}
    ```
  对于class B来讲呢，它包含了两个函数分别是function 1和function 2，那么这两个函数呢都被定义成内联了， 第一种呢，就是去使用inline关键字去定义function 1， 那么这时候呢，function的声明呢可以放在类里面， 但是它具体的定义呢是可以放在类外的。 那么注意呢，因为它是一个成员函数，所以呢要声明说 前面呢要使用到这样的一个B:: 去定义说啊，它是属于class B的， 那么除此之外呢，第二种去定义内联成员函数的方式就是将整个函数体比如说function 2 的实现全部放在类定义内部，那么它同样也是标志着是内联成员函数。 
- 除了内联成员函数之外呢，成员函数还可以去实现重载。 那么，函数的重载呢，就是指说对于具有相同的函数名的一类函数， 因为它本身呢是包含了一个或者多个不同的参数，或者参数本身的类型不同， 所导致的。那么这样的方式呢都被称为叫做函数的重载。 那么同样，成员函数呢也可以进行重载。 此外呢，成员函数自身呢，是可以带有缺省的参数的。 那么在C++语法当中呢规定说， 函数在写的时候呢，可以有让参数呢有缺省值， 那么在调用函数的时候如果你不写参数，参数呢就是缺省值。 我们来看这个具体的例子。
    ```C++
    #include <iostream>
    using namespace::std;
    class Location {
        private:
            int x,y;
        public:
            void init(int x = 0,int y = 0);
            void valueX(int val) {
                x = val;
            }
            int valueX() {
                return x;
            }
    };

    void Location::init(int X,int Y) {
        x = X;
        y = Y;
    }

    int main() {
        Location A;
        A.init(5);
        A.valueX(5);
        cout << A.valueX();
        return 0;
    }
    ```
  我们定义一个class成为叫Location， 那么它中间呢有两个成员变量，x和y， 此外呢还有三个成员函数。 那么这三个成员函数分别呢是init， 啊，初始化x和y，注意呢，这边对init函数里面的参数我们就已经规定了它的缺省值， 除此之外呢，还定义了两个具有同名的函数，都是呢valueX， 那么，这就是一个典型的成员函数重载。注意，他们因为参数不同，一个是要传int型的，一个变量，而另外一个呢，是没有参数的， 那么这样两个参，这样两个函数呢，因为参数的不同， 所以被标记为两个不同的函数，啊，虽然是同名的， 那么这两个函数自身呢它的作用也是不一样的， 第一个函数呢，是用来给x去赋值，第二个呢，只是去返回x的值。 
- 那么我们来看一眼。有了这样两个重载函数之后， 具体的使用。我们在main函数里面，那当然首先你要去定义一个对象， Location呢，对应的一个对象呢称为A，那么A呢，它可以去初始化， 那么初始化的时候，我们看到其实init函数是包含了两个参数的。 但是这里呢，只有一个，就是5， 那么它依次呢，实际上去初始化这个x和y，所以呢，5就被赋给了x， 而相应的y呢， 那么我们就可以使用刚才init函数的缺省参数， 也就是0，来对具体的这个小y进行赋值。 那么， init函数之后呢，就是A.valueX(5)， 那么这时候你看到了，这个函数的调用的时候它是有参的， 那么就意味着它调用的成员函数是哪一个呢？是刚才第一个成员函数，啊，也就是valueX 后面有具体参数的那样的一个函数， 而cout同样是A.valueX，但是它没有参数， 所以呢，它调用的是第二个函数， 也就是valueX 具有空参的那样的一个函数。 那么它实际上只是去返回一个x的值。 所以，这就可以看到说使用不同的函数，由于有了函数的重载， 所以它可以是同名的。但是它的功能是不一样的。 那么对应这时候cout的输出是什么呢？cout的输出是5啊。 
- 我们要注意了，在使用缺省参数的时候呢要避免函数重载时候的二义性。 
    ```C++
    #include <iostream>
    using namespace::std;
    class Location {
        private:
            int x,y;
        public:
            void init(int x = 0,int y = 0);
            void valueX(int val = 0) {
                x = val;
            }
            int valueX() {
                return x;
            }
    };

    void Location::init(int X,int Y) {
        x = X;
        y = Y;
    }

    int main() {
        Location A;
        A.valueX();         //错误，编译器无法判断调用哪个valueX
        return 0;
    }
    ```
  也就是说，我们在使用的时候，比方同时定义了valueX，但是呢，我们同时呢 对于第一个valueX的这个参数来讲呢我们给出了一个这个初始值，也就是说，它是有一个具体的默认的这个缺省值的， 那么当你去调用A.valueX的时候， 那么这个时候，编译器就不知道啦，它有两种可能，对吧？ 
  - 第一种呢是说它调用了第一个valueX这个函数， 那么由于你允许它不写参数，或者说使用缺省参数值，那么实际上是把对应的这个参数呢，初始化为一个零，但是呢，你没有写。 
  - 第二种呢，是说，我调用的是第二个valueX这个函数，它本身是无参的， 那么这两种情况都有可能。 所以对于编译器而言呢，它是不能够判断，它就会去编译报错了。 所以我们在撰写这个重载函数的时候，一定要注意同时使用缺省参数的时候要避免函数重载的二义性。 
## 2.构造函数
- 下面呢我们来说说这个构造函数。 构造函数可是面向对象的程序员居家必备的好东西啊。它呢是成员函数的一种， 它的特点是类名字和类名一样，然后它当然可以有参数， 但是它不能有返回值。啊，返回值哪怕你写void也是不行的。因为构造函数啊，它的作用就是对对象进行初始化。 比方说给成员变量做一些初值，那么初学者从constructor这个构造函数这个名字上往往会误会，就觉得这个对象所占用的存储空间是不是也是构造函数分配的。 啊，其实不是啊，构造函数只是在对象已经占用了存储空间以后，在对象的存储空间里面去做一些初始化的工作， 如果你把对象比作房子的话，这构造函数呢它不盖房子，它只是等房子盖完了以后， 进去装修。
- 啊，那类一定是有构造函数的，那我们前面看到的类并没有写构造函数啊，那怎么回事呢？ 啊就是说我们定义一个类的时候，如果你没有写构造函数的话，编译器就会生成一个默认的没有参数的构造函数。 但这个默认的没有参数的构造函数呢，它实际上什么都不干， 那如果我们定义了构造函数，编译器它就不会再去生成这个默认的没有参数的废柴一样的这个构造函数了。 那构造函数是在对象生成的时候会被自动调用的。 大家牢记一点。只要有对象生成，不管是以什么形式生成的对象， 这个对象生成的时候都一定会调用构造函数，来对它进行初始化。 而且这个对象一旦生成了，那它上面当然就不会再执行构造函数了， 因为已经初始化过了。然后呢，一个类才可以有多个构造函数。 那多个构造函数具体一个对象生成的时候到底由哪个构造函数初始化呢？ 啊，这就要看生成这个对象的语句是不是提供了一些构造函数的参数了。这个我们后面会讲。 那我们为什么会需要构造函数呢？ 因为这个构造函数它能够执行必要的初始化工作，那有了构造函数以后啊，我们就能够把这些初始化的代码写在构造函数里面， 那我们就不需要专门再写一个专门的初始化函数了，对吧？ 然后因为这个对象生成的时候它就会自动调用构造函数初始化，所以我们也就不必去担心这个对象我们忘了去初始化了。我们要记住，一个对象呢，它应该被初始化以后，然后再使用它，这才是正常的。
- 比方说你写了一个学生类，然后定义了一个学生对象，那这个学生对象它代表了学生，对吧， 既然它代表一个学生，它按理说就应该有一些属性，比方说它应该有，有姓名，有年龄，有性别等等， 那你不能说这是一个光秃秃的学生对象它什么属性都没有，那什么属性都没有就相当于你你说一个人，你应该知道他的长相，然后说这个人没有长相，那看上去就像一个无脸鬼， 好恐怖啊。那总之嘛，一个对象，它一定要初始化以后再使用，否则呢，就会 很容易导致程序出错，然后可以举一个例子。 那比方说，你可能写了学生管理程序， 你需要根据学生的年龄去查，他100米跑了多少秒算及格，那这样的话一般来说你会把这个呃，不同年龄所对应的100秒的及格成绩放在一个数组里面， 然后呢以年龄作为下标去查这个数组，就能够得到一个年龄对应的及格成绩了对吧？ 那假设你现在有一个学生对象，你没有对这个学生对象进行初始化， 那这个学生对象里面的年龄，那它的值就是随机的，搞不好就是一个负数， 然后你又拿这个负数的年龄作为下标去查那个那个百米及格成绩的这个数组，那它最后当然就数组越界了，对吧，你的程序就出错了。 哎，所以，你写一个类的时候一定要想好，啊，你要写一个类，写一个构造函数， 那好多年以前啊，我用刚刚用面向对象的方法开发一个软件的时候， 然后我一天写了好几个类，结果我偷懒没写构造函数，结果当天晚上我在床上就翻来覆去就觉得很不放心啊， 最后，还是半夜两三点爬起来把这个构造函数给补上，然后我才觉得安心，踏实的去睡觉了。 啊，一定要写构造函数啊。
- 下面呢，我们就来看看这个构造函数具体起作用的这个例子。
    ```C++
    class Complex {
        private:
            double real,imag;
        public:
            void Set(double r,double i);
    };      //编译器自动生成默认构造函数
    Complex c1;     //默认构造函数被调用
    Complex *pc = new Complex;      //默认构造函数被调用
    ```
  那我们这里写了一个complex类，啊，代表复数，它有实部和虚部两个成员变量。 没有构造函数，对吧？那这时候编译器就会为它自动生成一个默认的无参的一个构造函数。 我们看这里complex c1定义了一个c1对象， 那这个对象就必须要用构造函数初始化，啊，只要有对象生成，就一定要用构造函数初始化， 那这个c1是用哪一个构造函数初始化的呢？当然就是要用编译器自动生成的默认的无参的构造函数初始化的。 那下面这个，new出来的complex对象，动态分配一个对象。 那也是生成了一个对象啊，那当然也要用构造函数初始化，也是用默认的无参构造函数初始化的。 
- 下面这个complex类型呢，我们自己编写了一个构造函数，啊，它的代码在这， 
    ```C++
    class Complex {
        private:
            double real,imag;
        public:
            Complex(double r,double i = 0);
    };      
    Complex::Complex(double r,double i) {
        real = r;
        imag = i;
    }
    Complex c1;         //error,缺少构造函数的参数
    Complex *pc = new Complex;      //error,缺少构造函数的参数
    Complex c1(2);      //OK
    Complex c3(2,4),Complex c4(4,5);        //OK
    Complex *pc = new Complex(3,4);         //OK
    ```
  啊，我们用两个参数对， 这个实部和虚部进行了初始化，啊，那这个时候编译器就不会生成 那个默认的无参的构造函数了啊，你自己写了构造函数，编译器就不再生成了。 那么在这种情况下，如果你来个complex1，哎，编译就会报错， 它为什么会报错呢？因为这个c1必须要用构造函数初始化。 那么这个类里面呢现在只有这样一个构造函数， 可是这个构造函数呢又是需要参数的， 那你定义c1的时候没有给出这个构造函数所需要的参数， 编译器当然就没有办法对这个c1进行初始化了。 所以就会报错。下面这条语句，同样也是错的，啊，你动态生成了一个complex对象， 这个对象需要用构造函数初始化，可是我们这唯一的构造函数呢，是需要参数的，然后你又没给参数，当然就报错了。 再下面这条语句就没问题了，啊，这个c1呢，我们给了一个参数2， 那我们这边这个构造函数不是需要两个参数的嘛？对吧？它需要两个参数，但是我们注意到了，第二个参数是可以缺省掉的， 所以说这边的这个c1就是用这个构造函数初始化的， 然后这个参数r等于2， i等于0，所以，这个c1生成以后，它的实部是 2，虚部是0，对吧。 那同理下面这个下面这条语句的c1,c2 是怎么初始化的就很好解释了，都是用这个构造函数来初始化的。 再来看啊，我们new一个complex的对象，啊，这是动态生成的一个对象， 它是如何初始化的呢？也很简单，同样也是用这个构造函数来初始化的。 

- 那一个类呢它可以有多个构造函数的啊，只要这多个构造函数他们呢，参数个数或者参数类型不同，这多个构造函数就形成了这个重载的关系。
    ```C++
    class Complex {
        private:
            double real,imag;
        public:
            void Set(double r,double i);
            Complex(double r,double i);
            Complex(double r);
            Complex(Complex c1,Complex c2);
    };      
    Complex::Complex(double r,double i) {
        real = r;
        imag = i;
    }
    Complex::Complex(double r) {
        real = r;
        imag = 0;
    }    
    Complex::Complex(Complex c1,Complex c2) {
        real = c1.real + c2.real;
        imag = c1.imag + c2.imag;
    }
    Complex c1(3),c2(1,0),c3(c1,c2);         //c1 = {3,0},c2 = {1,0},c3 = {4,0};
    ```
  就是说这个complex类里面有这三个构造函数。他们之间是重载的这个这个关系， 那这个三个构造函数分别在什么情况下起作用呢？就得看你定义对象的时候，啊，或者生成对象的时候给了什么样的参数了。 我们看， 这里有一个c1对象，那么定义c1对象的时候给了一个参数啊，这个参数是一个整型的， 那哪一个构造函数能够跟这样一个整型参数匹配呢？ 那显然就是这一个，啊，虽然它的参数是double类型的，但我们知道整型可以被自动转换成double类型， 所以说，这个构造函数是 可以用来初始化c1的。 其他的都不行，那c1生成以后它的实部的值是多少呢？就是这个r也就是这个3，虚部呢，当然就是0了， 那我们再看c2，啊，c2它的两个参数呢都是整数， 有哪一个构造函数它的两个参数能跟两个整数匹配呢？ 很显然就是这个。啊，两个整型参数可以被自动转换成 这个double类型的参数嘛。所以c2就是用刚才的双double参数的构造函数初始化的。 再看这个c3，啊， c3我们看到它的两个参数呢都是complex对象，那毫无疑问，只有这个构造函数能跟他匹配。 所以，c3是由这个构造函数初始化，初始化的结果是什么呢？那我们看到了，啊，在这里面， c3的实部被初始化成c1和c2的实部之和， 这个c3的，c3的这个虚部呢，被初始化成c1和c2的虚部之和， 啊，所以c3初始化完以后它的实部是4啊，虚部是0
- 那下面我们再来看呢 这个构造函数在对象数组里面是怎么起作用的。
    ```C++
    class CSample {
            int x;
        public:
            CSample() {
                cout << "Constructor 1 Called" << endl;
            }
            CSample(int n) {
                x = n;
                cout << "Constructor 2 Called" << endl;
            }
    };

    int main() {
        CSample array1[2];                      //Constructor 1 Called  Constructor 1 Called
        cout << "step1" << endl;                //step1
        CSample array2[2] = {4,5};              //Constructor 2 Called  Constructor 2 Called
        cout << "step2" << endl;                //step2
        CSample array3[2] = {3};                //Constructor 2 Called  Constructor 1 Called
        cout << "step3" << endl;                //step3
        CSample *array4 = new CSample[2];       //Constructor 1 Called  Constructor 1 Called
        delete []array4;
        return 0;
    }
    ```
  我们注意这个c3，它有两个构造函数，一个没有参数，一个有一个参数。 没有参数的构造函数输出constructor 1 called，有参数的构造函数输出constructor 2 called， 看这个main函数。 呃，这第一条语句，就定义了一个对象数组array 1，这个数组里面有两个元素。 每个元素都是CSample对象，那这两个CSample对象肯定要初始化啊，到底用哪一个构造函数初始化呢？ 我们看到，对这两个对象初始化的时候所用的参数我们没有做任何交代， 对吧，你对这个初始化的时候你的参数没有做交代，编译器就认为 这个对象应该是用无参的构造函数初始化的。 因此说，这个array 1这个数组里面的两个对象都是用无参构造函数初始化， 也就是说那个无参构造函数会被调用两次，那自然就会输出两行， Constructor 1 Called，对吧？啊，接下来输出step1, 我们再看这个array 2， array 2这个数组里面还同样是有两个对象，那这两个对象是如何初始化的呢？我们在这里给出了 参数的信息，就是下边为0的那个对象，用一个构造函数初始化，然后这个构造函数的参数是4，下面呢我们用 啊，下边唯一那个的元素呢，也要用构造函数初始化，这个构造函数的参数是5 那，于是，这两个元素当然都是用有参构造函数初始化了，所以就可以输出 两行，constructor2 called，再接下来呢， 输出step 2，然后我们再看这个，啊，array 3，那array3 里面也有两个对象喽，!!!，然后我们只给出了 第一个对象的那个初始化的参数，那第二个对象的初始化的那个构造函数的参数没给，没给就等于是用 无参构造函数初始化，啊，那所以，!!!，很明显，这个这个array3[0]就是用有参构造函数初始化，array3[1]呢， 就是用无参构造函数初始化，所以就输出了，啊，constructor 2 called constructor 1 called，再接下来， step3 输出，啊，再下来我们看这一行，啊，这行呢，我们就动态分配了一个数组，对吧，这个数组里边有两个 对象，这两个对象如何初始化呢，我们对参数没有做任何交代，那这么两个对象都是用无参的构造函数 初始化的，所以就接着输出了，两行的constructor 1 called 啊，那最后，我们要注意，我们new出来的对象啊，我们new出来的这个东西啊，我们要用delete 把它,!!!，这个空间给它收回，对吧，在程序结束之前，要给它收回
- 再看一个构造函数跟数组的这个关系的这个例子，
    ```C++
    class Test {
        public:
            Test(int n) {}              //1
            Test(int n,int m) {}        //2
            Test() {}                   //3
    };

    int main() {
        Test array1[3] = {1,Test(1,2)};                 //三个元素分别用1，2，3初始化
        Test array2[3] = {Test(2,3),Test(1,2),1};       //三个元素分别用2，2，1初始化
        Test *pArray[3] = {new Test(4),new Test(1,2)};  //两个元素分别用1，2初始化
        return 0;
    }
    ```
  这个开始的呢，它有，3个构造函数，啊，编号为 1,2,3，分别有 1个参数，2个参数，没参数，好了，那这个array1里面它有，它有3个对象，对吧 好，我们给出的前两个对象的初始化的这个参数，分别是用1个参数和2个参数对它进行初始化，然后，第3个 对象呢，!!!，没有交代它的这个构造函数参数的事情，那么，这个第3个对象当然就是用无参构造函数初始化 的，所以，这个array1里面的3个元素分别就是用1、2、3这3个构造函数来 初始化，好，再看这个array2，! ! ! array2，!!!，里面有3个对象，这3个对象，如何初始化，我们全部都给出来了，啊 将，它们分别是用 !!!，前两个都是用2号构造函数初始化，最后一个呢，是用1号构造函数 初始化，好了，那我们再看，!!!，这个稍微 有一点难的例子了，啊，就这个pArray， 啊，哦，我们一定要注意到，这块是有一个星号，啊，那有一个星号，就说明，这个pArray它是一个指针 数组，对吧，它不是一个对象数组，啊，那如果我们没有后面的这些东西的话，大家想想看 啊，这个，我们定义了这样的一个pArray数组，会不会导致， 对象生成，会不会引发test的构造函数 被调用，那当然，当然，是不会，因为这是一个指针数组，它里面的每一个元素都是一个指针，对吧 是一个指针，又不是一个对象，这个指针你可以不初始化的，那它就，!!!，它就是指针好了，不会引发任何对象的生成 那好了，在这里，我们对这个指针数组进行了初始化，而且对它的前两个元素进行 了初始化，那我们初始化的方法呢，就是，我们new出来两个 对象，大家一定要注意这个，这个new这个表达式的返回值是什么呀？ 是指针，对吧，那么这个表达式的返回值就是test *，!!!，的这种类型的这个指针， 我们用new出来的这个对象，它的地址去初始化， 这个数组里面的元素，啊，那在这个数组里面的前两个元素，都被我们初始化了， 啊，也就是说，这前两个，前两个元素，分别各指向一个new出来的这个对象，那至于这个new出来的对象呢 第一个new出来的对象，啊，是用1号构造函数初始化的，第二个new出来的对象，是用2号构造函数初始化的 那我们就分析完了，看，这条语句一共生成了几个对象， 啊？注意，是生成了2个对象，而不是3个，为什么呀？因为这个， pArray2，也就说，最后这个元素， 我们没有初始化，没有初始化它的话呢，它只不过是一个指针，而且也不知道 指在，指向哪，那这个pArray2 并不会导，!!!，pArray2这个元素生成并不会导致任何对象的生成，对吧，所以这条语句， 只是生成了两个对象，这两个对象呢，分别用1,2进行初始化，!!!,这个 pArray2呢这个元素，它就是一个未经初始化的指针。
## 3.复制构造函数
- 下面我们来说一下复制构造函数， 那复制构造函数的英文名字叫copy constructor，所以有时候也被翻译成拷贝构造函数，我有时候叫它这个什么，抄袭构造函数。 复制构造函数呢它有一个参数， 这个参数呢就是对同类对象的引用， 比如说它的复制构造函数的形状是这样的。形如`X::X(X&) 或 X::X(const X&)` 这里x呢我们是认为是一个类的名字， 那么这个复制构造函数它只有一个参数，这个参数是本类的引用， 或者是本类的const的引用。 那你加进这个const以后呢，这个复制构造函数被调用的时候呢就能以常量对象作为参数了 那复制构造函数你只能写一种，不能两种都写。 那一个类它总是有复制构造函数的，如果你没有定义复制构造函数的话，编译器就会生成一个默认的复制构造函数 这个默认的复制构造函数它是要干事情的，干什么呢？ 就是完成复制的这种功能。可以见到它完成复制的功能。那么下面一个例子来看看。 
    ```C++
    class Complex {
        private:
            double real,imag;
    };      
    Complex c1;                     //调用缺省无参构造函数
    Complex c2(c1);                 //调用缺省的复制构造函数，将c2初始化成和c1一样
    ```
  我们写的这个complex类并没有任何构造函数， 但实际上我们知道它应该至少有两个构造函数，一个呢就是编译器自动生成的无参构造函数， 另外一个就是编译器自动生成的默认的复制构造函数。 这个无参构造函数用来处理化这里的c1了， 那那个默认的复制构造函数就是用来处理化这里的c2. c2是用那个复制构造函数初始化的，而且呢 初始化的时候呢，复制构造函数是以c1作为参数。 那这个默认的复制构造函数做了什么呢？那它做了复制的工作，也就说它起作用的结果就是把c1的所有的成员变量都复制到 c2里面去了。这样c2的值就跟c1完全相等，你可以认为c2就成了c1的一个复制品。所以 所以这种构造函数我们称之为复制构造函数， 那如果你自己定义了一个复制构造函数呢， 那编译器当然就不会再去生成一个复制构造函数了。因为复制构造函数只能有一个。 
- 我们看在这个例子里面，我们自己写了一个复制构造函数， 
    ```C++
    //如果定义自己的复制构造函数，则默认的复制构造函数不存在
    class Complex {
        public:
            double real,imag;
            Complex() {}
            Complex(const Complex &c) {         //自定义的复制构造函数
                real = c.real;
                imag = c.imag;
                cout << "Copy Constructor called";
            }
    };      
    Complex c1;                     //调用缺省无参构造函数
    Complex c2(c1);                 //Copy Constructor called
    ```
  这块加了const，你不加const也没问题。在这个复制构造函数里面呢，我们先做了复制的工作，就是说把这个被初始化对象呢实部，变成跟参数的实部一样。虚部变成跟参数的虚部一样，这是一个复制的工作对吧？ 那实际上复制构造函数并不是一定要做复制工作的，复制构造函数你可以自己编写。 在复制构造函数里面做些什么事情，要不要做复制的工作完全由你自己决定。 那我们看到在这个自己编写的复制构造函数里面，我们客气一点吧，我们先做了复制的工作，然后我又多做了一件事情，就是输出copy constructor called， 那我们接下来看，这里有一个c1对象，然后c2对象。那c2对象呢自然就是用复制构造函数来初始化的，那当然就调用了我们这个 自己写的复制构造函数对吧？那这个复制构造函数被调用就会输出copy constructor called 另外，它当然会把c2的实部和虚部变成跟c1的实部和虚部一模一样，对吧？ 输出copy constructor called。那再强调一下，这个复制构造函数吧它的参数一定是本类的引用， 你不能写一个复制构造函数它的参数是本类的对象。`X::X(X)`这x是类的名字，这样写是不行的。 比方说我们这个cSample类它有一个构造函数，它的参数是本类的对象，这种写法是不行的，它不是复制构造函数而且它根本就编译会过不了。这样的构造函数不允许存在的。 

- 复制构造函数在三种情况下会起作用， 下面我们来看看这三种情况分别是什么。
  - 第一种， 就是用一个对象去初始化同类的另外一个对象，这种情况我们前面已经见过了。最典型的写法就是`complex c2(c1)` 那这种情况还有另外一种写法就是`complex c2=c1` 注意这是一条初始化语句，它跟上面这条语句是完全等价的。 这是，虽然有个这个等号在这，但是它是初始化语句，不是赋值语句。 那如果我们把这个complex字去掉的话，那这个就成了一个赋值语句了。那赋值的语句的情况下，这c2都已经生成了，那上面当然就不会执行这个什么构造函数了对吧？那好，在这条语句是赋， 初始化语句的情况下，c2就是由复制构造函数初始化的， 而且那个复制构造函数的参数就是c1。 
  - 再看复制构造函数起作用的第二种情况， 就是如果某一个函数，它的行参是类A的对象,那么这个函数被调用的时候，类A的复制构造函数就会被调用。 那就是说类A的复制构造函数被调用来初始化谁呢？ 当然就是初始化这个行参了对吧？我们看， 
    ```C++
    //如果定义自己的复制构造函数，则默认的复制构造函数不存在
    class A {
        public:
            A() {}
            A(A &a) {         //自定义的复制构造函数
                cout << "Copy Constructor called";
            }
    };    

    void Func(A a1) {}        //输出：Copy Constructor called

    int main() {
        A a2;
        Func(a2);
        return 0;
    }
    ```
    在这个例子里面，class A它有一个复制构造函数， 那么在这个复制构造函数里面呢，我们没有做什么复制的工作，我们只是输出copy constructor called，告诉你复制构造函数被调用。 接下来我们看这个func函数，它的行参是类A的对象，对吧？ 那我们这时候就要想起来了，如果进到这个函数里面，这个行参肯定就要生成，对吧？那这个行参是用什么构造函数初始化的呢？ 就是用复制构造函数初始化的。那复制构造函数被调用的时候是需要参数的， 那这个参数是谁呢？那我们就看，我们在类里面 调用func，然后以a2作为参数。 好了，这个时候我们就看出来，行参a1是用复制构造函数初始化的， 然后初始化a1的时候，那个复制构造函数的参数就是这个实参a2 好了， 那我们前面学c语言和c++的时候我们都说了这个一个函数的行参它跟实参的 值是相等的对吧？那学到这个片子的时候 大家可以想想看，在这里行参a1的值还会等于 实参a2吗？那答案是不一定了，为什么呢？ 因为这里的a1是用我们自己编写的这个 复制构造函数去初始化的，我们自己编写的这个复制构造函数啊 它并没有做这个复制的工作，它并没有用这个 行参A的成员变量去初始化 class A自己的成员变量，它没有做复制的工作。 那既然没有做复制的工作，那么在这里行参a1的值就未必会等于这个 实参a2 因此这个程序它的输出结果是copy constructor called，因为复制构造函数被调用用来初始化a1了。 那就说如果我们在这个例子里面并没有编写自己的复制构造函数， 那这个行参a1的值会不会等于这个实参a2呢？ 那答案当然是肯定的，为什么呀？ 因为你自己没有写复制构造函数，编译器就自动生成了一个 复制构造函数。那编译器自动生成的复制构造函数它是要执行 复制的工作的。因此如果a1是用编译器自动的生成的那个复制构造函数初始化的 那a1的内容就会变成是a2的一个拷贝，也就说a1就等于a2了。 这是复制构造函数起作用的第二种情况，就是一个参数， 函数的行参是对象的这种情况。 
  - 再来看，如果函数它的返回值是类A的对象， 那这个函数的返回时， 这个函数返回的时候啊，类A的复制构造函数就会被调用。那这个类A的复制构造函数 被调用来初始化谁呢？就是用来初始化作为返回值存在的这个类A的对象。 
    ```C++
    //如果函数返回值是类A的对象时，则函数返回时，A的复制构造函数被调用
    class A {
        public:
            int v;
            A(int n) {
                v = n;
            }
            A(const A &a) {         //自定义的复制构造函数
                v = a.v;
                cout << "Copy Constructor called";
            }
    };    

    A Func() {
        A b(4);
        return b;
    }        //输出：Copy Constructor called

    int main() {
        cout << Func().v << endl;   //注意这种用法   输出：4
        return 0;
    }
    ```
    好， 这个class A有一个复制构造函数，自己写的。它做了复制的工作然后又输出copy constructor called对吧？ 然后我们看，这有个func，它的返回值类型是A，也就说这个函数的返回值啊会是一个class A的对象。 然后我们在这个func里面定义了一个局部对象b，然后我们return b。 然后在类里面呢，我们调用了这个func函数 那func函数它的返回值是一个对象，接下来我们就取这个对象的v 成员变量并且把它输出，那当然得首先生成这个对象，然后才能访问里面的v对吧？ 那是要先生成这个对象。那在 这个对象被生成的时候，我们说，肯定调用了构造函数，到底 是哪一个构造函数呢？按照前面说的这个规则，是用复制构造函数初始化的。所以 说我们自己写的复制构造函数就会被调用，就输出了copy constructor called，对吧？这是怎么回事再说。 呃， 这个复制构造函数被调用来初始化作为返回值存在的这个临时的这个对象， 那调用这个复制构造函数的时候，参数又是谁呢？ 这个答案也比较明显。我们在func里面不是return 了b对吧？我们的访问值是一个class A的对象，那我们return了b， 那所以说这个时候b就是那个返回值对象 被初始化的时候那个复制构造函数的参数了。 然后这个复制构造函数是我们自己写的，在这个复制构造函数里面呢， 我们是调用了，我们是进行了复制的工作，因此说在这个 return b执行完了以后，作为返回值存在的这个 对象被初始化，而且被初始化的结果呢是变成跟这个b一模一样， 所以这个时候，作为返回值存在这个临时对象它的v的值呢当然 也是4，因此我们输出这个v的值，输出的结果就是这个4. 那么现在我们在这里呢又可以发现一个比较奇怪的这个现象了， 就说按理说了我们这里有个return b， 那我这个函数的返回值它一定会跟b相等对吧？这是我们在 以前学到的知识，但是我们学了构造，复制构造函数以后呢， 你还会认为这个函数的返回值一定就跟这个b相等吗？ 那不一定了。就取决于你这个复制构造函数是怎么写的了。 因为这个函数的返回值是用复制构造函数初始化的，所以你那个复制构造函数里面如果没有执行复制的工作， 那么这个返回值的对象它的值当然就未必跟这个b相等了。 这是没学复制构造函数之前可能你想不到的一种情况。 那这就是复制构造函数起作用的三种情况。 

- 那这里就很容易会有一个问题了对吧？就是复制构造函数嘛它按理说都是要做复制的这个工作的，而编译器自动生成的这个复制构造函数它本来就会做这个复制的工作， 那为什么我们自己还需要写复制构造函数呢？刚才那个例子里面只不过是为了输出一些东西让你看到复制构造函数被调用对吧？因为输出并没有什么实际的意义。真实的开发软件的时候我们会需要写自己的复制构造函数吗？ 那如果你认为不需要写的话，那是因为你是too young too simple 这个面向对象的程序设计比你想象的要险恶那么一点点， 那么在后面我们会讲到，有的时候你是必须要写自己的复制构造函数，否则你的程序就会出错。那这个就下回分解。 
## 4.类型转换构造函数
- 大家好，这一小节中我们来看一个特殊的构造函数。被称为类型转换构造函数。 那么类型转换构造函数呢，顾名思义，就是要去实现类型的自动转换。 那么，它的特点是什么呢？首先呢它只有一个参数。 此外呢，它不是赋值构造函数。 那么当使用这样一个类型转换构造函数的时候， 编译系统会自动调用转换构造函数， 同时呢，去建立一个临时的对象或者是变量。 我们来看一个具体的例子，接触一下到底什么是类型转换构造函数。 
    ```C++
    class Complex {
        public:
            double real,imag;
            Complex(int i) {         //类型转换构造函数
                cout << "IntConstructor called";
                real = i;
                imag = 0;
            }
            Complex(double r,double i) {
                real = r;
                imag = i;
            }
    };      

    int main() {
        Complex c1(7,8);
        Complex c2 = 12;    //该等号意味着 初始化    输出：IntConstructor called
        c1 = 9;             //9被自动转换成一个临时Complex对象      输出：IntConstructor called
        cout << c1.real << "," << c1.imag << endl;      //输出：9，0
        return 0;
    }
    ```
  这是一个复数类，class Complex, 那么对于这样的一个复数类而言呢，它首先就要来定义实部和虚部这样两个成员变量。 有了成员变量之后呢，它还定义了一个我们可以认为是传统的构造函数， 那么这个函数呢，它会去传入一个 r和i，分别去初始化实部和虚部。 那么除了这样的一个一般意义上的构造函数之外呢， 它还定义了一个特殊的我们今天提到叫做类型转换构造函数。 那么这种函数呢，它自身是构造函数， 和类同名。同时呢，它又具有一个参数， 通过去传入int i这样的一个参数呢， 在这个类型转换构造函数里头它实现的功能就是首先呢cout这个函数被调用到了， 此外呢，就是用这个i去初始化实部，而虚部呢，就直接赋值为0了。 我们通过这个函数的设计，你就可以想象得到， 那么在这样的一个函数里面，它被使用到的时候， 那么它必然就是将一个整形的一个常数赋值给一个complex类型的 这样的一个复数对象， 那么这个时候呢，它实际上呢 就要把这个复数的虚部呢初始化为0就可以了。 那么来看看main函数里头，main函数中间呢，首先呢 就是去定义了一个complex类型的一个对象c1，那么它的这个初始化 7和8呢实际上调用的就是第一个普通意义上的构造函数。 之后呢，有这样的两个语句。 这两个语句中间呢其实都分别调用了类型转换构造函数， 但是呢，在调用的过程中间呢还有些区别。 对于第一个而言呢，实际上它做的事就是对c2进行初始化， 注意，这个等号是初始化，不是赋值。 那么在初始化的过程中间呢，它调用这个 类型转换构造函数的时候， 它是不会去对应生成一个临时的对象的。 那么它只会去直接把12这样的一个参数啊， 作为一个参数去 传给complex啊，int i这样的一个函数，这样的一个构造函数，来初始化c2， 那么对于第二种情况， c1等于9，这是一个赋值语句， 那么在生成这个赋值语句的坏死后你会看到说 哎，编译器并没有报错，因为 赋值号的两边其实是不一样类型的，对吧？ c1呢，是complex类型，而赋值号的右边9呢是一个整形的一个常量。 那么怎么样才能把它直接进行赋值呢？ 那是因为编译器会自动调用类型转换构造函数， 那么对于这个函数呢，它首先呢就会进行 一个临时对象的生成，也就是说，它生成了一个临时的complex对象， 那么在这个 生成对象的时候呢，它实际上是以 9作为一个实仓，调用complex int i这样的一个啊，类型转换构造函数来进行初始化的。 那么有了这样的一个初始化之后， 我们就可以讲这个临时对象的值啊，也就是说实际上它变成了一个complex对象， 赋给c1， 那么这个时候呢，也可以说是 9被自动的转换成为了一个complex对象，赋值给了 c1，所以，在这样的一个函数中间呢，会有两个语句， 使用到了这个类型转换构造函数， 但是在第二种情况下，它才会去临时生成一个complex的对象， 那么这样的话呢，我们来看一下main函数就会有两次 这个，complex括号int i 相应函数的这个调用，所以它会打印输出 两次这个cout语句， 同时呢，我们来看一下对应的这个c1，啊， 因为呢它在这一步赋值语句当中， 被强制类型转换了， 所以c1的实部呢就变成了9，而虚部呢就变成了0.所以对应输出呢就是9和0。 
## 5.析构函数
- 大家好，在这一小节中 我们来介绍一下析构函数。在正式介绍析构函数之前呢， 我想跟大家简单回顾一下郭老师在之前介绍的构造函数。 那么构造函数呢它是一种特殊的成员函数。 它的名称呢和类名是相同的， 那么对于构造函数而言呢，可以有参数，但是呢不能有返回值。 你可以在一个类里面设计多个构造函数，用于不同的初始化， 所以我们说呢，构造函数主要就是用来初始化对象的。 那么每生成一个新的对象都调用构造函数来对它进行初始化， 那么就会有人想到说，哎，那当这个对象消亡的时候 是不是也会有一个函数对这个消亡的工作，操作呢进行一些处理呢？ 对了。所以C++语法呢就定义了析构函数来完成这些事。 那么析构函数呢它也是一个成员函数。 那么它的名称呢也和类名是相同的。 那么怎么样区别析构函数和构造函数呢？ 析构函数会在函数名之前呢再添加一个一弯， 来表明说它是析构函数。此外呢，析构函数是没有参数和返回值的。 这一点呢，也是和构造函数相区别的。 另外呢，对于一个类而言，最多只能有一个析构函数。 这样的设计呢其实也是有道理的。构造函数呢因为可能会去初始化不同的对象，所以需要通过函数重载生成多个构造函数。 但是析构函数呢，因为它只是对对象消亡前的一些善后的工作做处理， 所以一个析构函数就可以完成所有相应的操作。 那么，析构函数呢在对象消亡的时候会被自动的调用到。在对象消亡前呢，去完成一些善后的工作。 比方说，去释放一些分配的内存空间，是吧？ 那么在对象消亡的时候，如果你只是去这个取消了这个对象的名称，而还保留了相应的内存空间的话，那么内存是会被大量的泄露掉的。 那么，析构函数呢，就可以有效的去完成这样的一个工作。 那么在此之前的话呢，如果你需要去用一个new动态分配的内存，那么在各个地方去编写ii语句的时候，你就要确保程序的每条执行路径上都能去释放掉这些内存。这样的过程呢，当然是比较复杂和麻烦的。 那么有了析构函数之后呢，只需要在析构函数里面去使用delete语句就能够确保对象运行中，使用new分配的空间呢，在对象消亡的时候都被释放掉了。我们在定义类的时候，如果没有写析构函数， 那么编译器呢会自动的生成一个缺省的析构函数。 当然这个缺省的析构函数它本身是不会做什么的，它不会去帮助你去释放用户申请的一些内存， 如果呢，你可以定义一个自己的析构函数的话，那么由于析构函数本身只有一个，所以编译器就不再生成缺省的析构函数了。 我们来看一个具体的例子。
    ```C++
    class String {
        private:
            char *p;
        public:
            String() {
                p = new char[10];
            }
            ~String();
    };
    String::~String() {
        delete [] p;
    }
    ```
  我们有一个类呢，叫做class String， 那么class String本身呢在它的构造函数里它有一个new出了一个数组，啊，char型的数组， 那么，它始终一个char新去指向这个数组的首地址。 那么在你new出了这样的一片数组之后呢， 那么在析构函数里面还要对这个内存空间进行释放的话，我们就需要去写一个相应的delete语句。 那么在调用析构函数的时候，它就会去自动的delete掉相应你生成的这片内存空间。 那么要注意呢，在对于一个数组而言的话呢，要去delete掉的话呢要使用这个方括号， 否则如果只是写delete p的话， 那么它只是去delete掉了一个对象。 
- 对于析构函数和数组而言的话呢， 因为数组里面实际上包含了若干个对象， 那么当这个对象数组本身的生命周期结束的时候， 那么它里面的每个元素的析构函数都会被相应的调用到， 我们来看一个具体的例子。 
    ```C++
    class Ctest {
        public:
            ~Ctest() {
                cout << "destructor called" << endl;
            }
    };

    int main() {
        Ctest array[2];
        cout << "End Main" << endl;         //输出：End Main   destructor called   destructor called
        return 0;
    }
    ```
  对于一个叫做class Ctest这样的一个类，我们为了去标记说， 哎，看一看什么时候这个析构函数被调用到，并且被调用多少次， 那么我们在自己定义的这个析构函数当中呢，cout这样的一个destructor called这样的一个语句， 那么在main函数里头的话呢，我们首先去 这个定义了一个Ctest类下面的一个对象数组，啊，这个对象数组呢叫做array， 它包含了两个对象，之后的话呢，就打印输出End Main这样的一个语句。 那么这个程序呢，就到结束了。结束的时候之前呢， 我们就要释放相应的对象，那么这时候呢，程序就会去调用相应的析构函数，那么这时候就应该会首先去输出 End Main，完了之后，我们因为调用了析构函数，那么析构函数呢， 会被调用几次呢？是因为我这里面有两个数组， 呃，有两个数组对象，啊，对象数组。 那么这时候的话呢，我们就可以看到说，array这个数组在消亡的时候，其中呢包含了两个对象， 那么对应呢就会有两次析构函数的调用。 所以呢对应的这个输出的这个结果的话呢就包括了这样三条语句。啊。其中这两个输出语句呢对应的就是两个数组元素中间的这个对象的消亡和产生的这个析构函数的调用。 
- 那么除此之外的话呢，我们使用delete语句啊，也可以导致析构函数的调用。
    ```C++
    Ctest *pTest;
    pTest = new Ctest;      //构造函数调用
    delete pTest;           //析构函数调用
    ---------------------------------------
    pTest = new Ctest[3];   //构造函数调用3次
    delete []pTest;         //析构函数调用3次
    ```
  那么本身的话呢，如果我们去定义了一个Ctest的新的一个指针，pTest，那么它指向谁呢？它指向了你new出来的一个Ctest， 那么每一次new的这个调用呢，都会使得构造函数被调用到， 那么你new出了一片内存空间之后，你要释放掉的时候，我们就需要delete掉， 那么只要使用到delete运算，就有一个相应的析构函数被调用到。 那么这时候的话呢，pTest所指向的那片内存空间呢，就会被释放掉了。 同样的，如果你是new了一个数组， 那么，这个析构函数呢，构造函数相应的就会 相应的被调用三次。因为这个数组里面包含了有三个对象。 同样的，在delete的时候，我们需要调用析构函数三次， 才能完全释放掉pTest这个指针所指向的那片内存空间。 

- 在了解了构造函数和析构函数之后呢，我们来看一个具体的例题， 看一看这两种函数都分别在什么样的时机下会被调用到。 
    ```C++
    //构造函数和析构函数以及变量的生存期
    class Demo {
            int id;
        public:
            Demo(int i) {
                id = i;
                cout << "id=" << id << "Constructed" << endl;
            }
            ~Demo() {
                cout << "id=" << id << "Destructed" << endl;
            }
    };
    Demo d1(1);
    void Func() {
        static Demo d2(2);      //但是d2呢，它因为是静态的， 那么静态这个呃，变量的话呢，它的消亡会是在整个程序结束之时
        Demo d3(3);
        cout << "Func" << endl;
    }
    int main() {
        Demo d4(4);
        d4 = 6;
        cout << "main" << endl;
        {
            Demo d5(5);
        }
        Func();
        cout << "main ends" << endl;
        return 0;
    }
    ```
  我们有一个类呢称之为叫做class Demo， 那么这个类呢它有一个private的成员对象，变量，称为叫做int id， 因为这个成员变量呢它是私有的， 所以我们要对它进行初始化的时候呢，我们通常利用这个构造函数来进行这个初始化的传递。那么我们通过去使用这样的一个参数int i呢， 来将相应的值初始化给 这个私有的成员变量id， 之后的话呢，打印输出id等于相应的初始化的值，Constructed， 啊，这就是我们涉及的一个构造函数， 也就是说，我们当相应的这样一个对象在生成的时候，我们就可以看到说， 它对应的这个值，id的这个值的这个构造函数呢会被调用到。 同时呢，我们去设计了一个析构函数。 在这个析构函数里头的话呢，你要打印输出相应的id等于 具体的这个初始化的一个值， Destructed，啊，也就是说对应的这个id等于某一个值的对象会被消亡掉。 我们来看有了这样的析构和构造函数之后的话呢， 它分别在程序实行的过程中间会被多次的调用到，分别在什么时候被调用到。 那么整个程序的话呢，首先我们看到了它会定义了一个 全局的变量d1，啊，那么同时它用1这样的一个常量来进行 初始化对象。 由于呢，这个d1本身就是一个对象， 啊，不管它是全局的还是局部的，那么它都要去对应调用。 构造函数，啊，它就会打印输出id=1 Constructed，id赋值为了1， 之后呢，程序就进入到了main函数。 那么在main函数里头的话呢，首先就定义了一个局部的变量d4， 同样的，它被初始化为4，那么 我们就会调，定义这个 调用构造函数，啊，id=4 Constructed 有了这样定义好了一个d4之后，这样的一个对象之后呢，我们执行下一条语句， d4=6，我们把一个常量6赋给d4 这样的一个对象，这个语句呢看起来有一点点似曾相识，对吧，因为我们之前给大家介绍过叫做 类型转换构造函数，啊，这是一种特殊的构造函数。那么它本身呢， 会使得赋值语句的左右两个类型不一致的赋值呢， 变得可以一致化。这就是因为 编译器呢，会将这个邮编的常量 通过类型转换构造函数呢来进行实现。 通过生成定义一个临时的对象，啊， 来生成一个对应相应的一个 临时的demo对象， 把6呢赋给相应的d4，就可以实现了。 那么这时候的话呢，因为要生成一个临时的对象， 所以呢，我们会调用id=6 Constructed这样的一个 构造函数。同时呢， 当这个赋值完成临时对象呢，消亡的时候呢，我们又要对应去 使得这个临时对象呢被析构掉。 所以呢，在这个语句里面， 我们同时去调用了构造和析构两个函数来完成了这样一个赋值的操作。 所以这时候呢，d4的，d4的id呢， 就等于6。然后呢，我们就可以进一步 执行cout main这样的一个语句。之后呢， 我们进入到下一条。啊，demo d5， 那么对于d5这样的一个全局变量的话呢，它呢会有点特殊，区别于d4， 那么它有一个自己的作用域，看到没有，这有一对花括号，那么我们语法规定说呢， 这个离对象最近的一对花括号中间的范围呢， 就是它相应的作用域。 那么这个作用域呢就标志着这个对象的生命，生命周期，啊，也就是说这个对象在离开作用域之后呢，就需要消亡掉。 所以呢我们对应在这个d5里头呢，首先是对应生成了构造函数。啊，初始化id=5， 当这个程序执行到下一条命令， 跃出花括号这个作用域之后呢，这个对象就要 相应的去析构掉，所以又调用id=5 Destructed， 除此之外呢，我们就进入到了func这样的一个函数里头， 那么这个函数首先定义了一个static静态的 变量，d2，d2的话呢用2来进行初始化， 所以呢，我们又调用了id=2 Constructed啊，构造函数， 之外呢，我们又定义了一个d3这样的一个全局的变量， 所以相应的呢，也去调用id=3 Constructed， 之后呢，就打印输出func， 那么这时候，function函数就结束了， 在这对花括号的作用域里头，那么它包含了两个变量，d2和d3， 但是d2呢，它因为是静态的， 那么静态这个呃，变量的话呢，它的消亡会是在整个程序结束之时，所以呢在这个作用域下， 消亡的对象只有d3一个，那么id=3 Destructed 这样的一个析构函数呢就会被调用到了。 然后程序呢，就继续cout main ends， 那么整个程序呢，基本上就已经执行完毕，我们看一看说还剩下哪几个 对象没有被消亡掉，还需要在最后的析构函数调用来完成呢？ 首先一个，就是d1,全局变量， 第二个，d2， 静态变量， 此外呢，还有d4， 就是在main函数里面对应的定义的一个局部变量，因为它还没有超出main函数的 作用域，那么这时候，我们就看到说析构函数 首先去析构掉id=6 Destructed啊，我们让这个 d4析构掉， 接着呢，就是id=2 Destructed，我们让d2这样的一个 静态的局部对象d2呢 消亡掉，最后呢，是这个d1， 全局对象，也被消亡掉。所以这个呢，就是整个 析构和构造函数分别调用的时机。 我们可以看到说呢，这个先被构造的对象 会最后被析构掉，这也是C++语法的一个设计的 一个思想。 
- 此外的话呢大家要注意一点， 就是构造函数呢和析构函数可能会在不同的编译器中呢有不同的表现。 那么个别时候呢，会出现不一致的情况， 当然这中间呢包含有编译器本身有bug以及代码优化的措施，那么在我们这门课里， 啊，包括作业，考试，那么我们讨论的只是C++标准，啊，也就说标准规定在什么时机上， 这个，构造函数和析构函数呢会被调用到，它不仅牵涉编译器的问题， 
## 6.静态成员变量和静态成员函数
- 今天我们要说说静态成员变量和静态成员函数。 那里面的类它的成员有静态成员，所以说，什么叫静态成员呢？ 就是我们在定义成员的时候前面加了static关键字， 那这个成员就成为静态成员。 怎样说，来我们看这个CRectangle这个类， 
    ```C++
    class CRectangle {
        private:
            int w,h;
            static int nTotalArea;      //静态成员变量
            static int nTotalNumber;
        public:
            CRectangle(int w_,int h_);
            ~CRectangle();
            static void PrintTotal();   //静态成员函数
    }
    ```
  w代表这个宽度，h代表高度，然后有一个TotalArea。 我们看TotalArea前面加了一个static关键字，那这个TotalArea就成为静态成员变量。 那这个TotalNumber也一样。 这个TotalArea呢是用来记录所有矩形对象的总面积的。 TotalNumber呢是来记录所有矩形对象的总数的。 那么静态成员可以有两种：一种是静态成员变量，另外一种就是静态成员函数。 像这个PrintTotal前面呢加了static关键字，于是PrintTotal就成了这个静态成员函数。 
- 那这个普通成员变量和静态成员变量到底有什么差别呢？除了形式上差一个static以外呢， 其他它们的差别就是普通的成员变量 每一个对象有各自的一份。 而静态的成员变量一共就一份，被所有的对象所共享。 
- 就是说这个像这个w,h的这样的普通成员变量每个CRectangle对象都有各自的一份。 你打的对象a,e的w那对象a,r的w不受影响，对吧？ 而这一种静态的成员变量TotalArea和TotalNumber呢是被所有的CRectangle它们对象所共享的。 你改了a,e的nTotalArea，那a,r的 这个nTotalArea也跟着被修改了。这些静态成员变量是对所有对象所共享的。 这个是。 另外还有一个差别呢就是**sizeof运算符，它不会计算静态成员变量**。sizeof我们知道可以用来计算一个对象和在用的自点数，对吧。 那我们这里有一个CMyclass，那它有一个普通的成员变量n，还有一个静态的成为变量s。 那sizeof CMyclass到底是多少呢？不会把这个s算进去， 所以sizeof CMyclass等于四。 为什么，因为这个静态成员变量它实上不是放在一个对象内部了。 它是放在所有的对象外面，被所有的对象所共享了。 静态成员变量一共就那么一份。 
- 那刚刚说了静态成员变量和普通成员变量的差别。 那静态成员函数和普通成员函数的差别又在哪儿呢？就是这个普通成员函数呢，它必须具体作用于某一个对象。 我们前面看到怎么调用函数，得通过对象名、 点儿、程序函数名，或者是指针、箭号、程序函数名对吧， 或者是引用、点儿、程序函数名。总之，这些成员函数它都一定是作用在某一个对象上面的。 那对于静态的程序函数呢，它并不具体作用于某一个对象。 调用普通程序函数你需要交代普通程序函数作用在哪个对象上面。 调用静态程序函数你就不要交代这一点了，你也没法交代，因为它并不具体作用于某个对象。 那么我们说了这个静态的成员变量，静态的成员不管是成员变量也好还是静态成员函数也好，它们都不是属于某一个对象的，也不是具体作于某一个对象的， 所以这个静态成员它不需要通过对象就能访问。 不管是静态成员变量还是静态成员函数，都是不需要通过对象就能访问了。 我们看具体的例子。怎么访问静态成员呢？ 有各种方法，
  - 第一种方法是通过类名成员名。 比如说CRectangle::PrintTotal，这样就直接调用PrintTotal这个成员函数。你说它具体作用哪一个对象呢？说不出来吧。它不具体作用于哪个对象， 所以我们通过类名成员名的办法可以直接访问类的静态成员。这里类名成员是访问一个类的静态成员函数是要你把这个PrintTotal换成一个静态成员变量的名字， 也是没有问题的。 
  - 那第二种访问静态成员的方法就跟传统的方法是一样的，可以通过对象名成员名的办法。那这个CRectangle r。 r.PrintTotal。 那要注意了，虽然写的是r.PrintTotal，但PrintTotal并不是作用在r这个对象上面呢。 这只是一种形式而已，它并不以为着PrintTotal作用在r这个对象上面。 静态成员函数和静态成员变量它都不具体属于某一个对象，也不是具体作用于某一个对象的。当然我们也可以通过指针建好成员名的办法来访问静态的成员函数或者是静态的成员变量。 虽然形是如此，实上这个PrintTotal也并不是作用在p所指向的那一个对象上了。 然后我们还可以通过引用点成员名的方法来访问静态成员变量，比如说这个nTotalNumber在CRectangle里面是静态成员变量对吧， 我们可以 如此来访问它。但这个时候呢，我们 能说nTotalNumber它就是属于ref所引用的那一个对象的吗？ 它实上并不是指属于，ref所引用的对象r它是被所有的 CRectangle对象所共享呢，所以你也不好说它是特定地属于这个r的。
- 那最重要的一点，大家需要搞清楚的就是， 静态成员变量本质上它是全局变量， 哪怕一个对象都不存在，一个类的静态成员变量也存在。 因为它是全局变量。那普通的成员变量， 它必须得属于某一个对象，有了对象以后这个对象的成员，它是一个普通的成员变量。 然后这个静态成员函数它本质上呢就是一个全局的函数。 那这个全局的函数它不需要作用在某一个对象。 普通的成员函数它必须具体地作用在某一个对象上。 
- 那既然这个静态成员变量是全局变量，然后静态函数又是全局函数，那我们还为什么要引入这样一种东西呢？我们直接就写全局变量，直接就写全局函数不就行了吗？ 那我们设置静态成员的这种机制 它的目的呢实上是把和某些紧密相关的全局变量 和全局函数写到类里面，这样看上去呢就成为一个整体，易于理解和维护。 我们去看一个具体的例子。 就是我们考录一个需要随时知道矩形总数和总面积的图形处理程序。 那当然我们可以用全局变量来记录总数和总面积， 对吧？我们肯定不需要在每一个矩形对象里面来记录一个总面积， 也不需要在每一个矩形对象里面都记录一个总数。那我们用全局变量来记录总数和总面积。 那这样做的话呢实上是有一个不好的地方，就是你没法很直观地看出这两个的全局变量跟那个矩形这个类之间的这个关系。而且实上这两个全局变量它只跟矩形类有关系，那你把它写成一个全局变量的话呢，那看来就其他的类的全局函数也能够来访问它。这就不太好了，对吧，因为它是让直跟矩形类有关系。 那竟然这两个变成这样，直跟具矩形类有关系，那我们把它作为静态成员写到这个矩形类里面， 不就很充分地体现了它跟矩形类的关系，对吧。而且当我们把这两个全局变量作为静态成员写到矩形类里面以后， 那别的类就没有办法来访问这两个变量。 这样的话我们就很容易理解和维护这两个全局变量。 那具体地说刚才已经提到了，我们写一个CRectangle的这个类， 那这个每一个CRectangle呢有 w和h这两个成员变量代表矩形的宽和高，这个是普通的成员变量。每一个矩形变量有各自的一份，每一个矩形对象都代表一个矩形。 然后呢，我们有两个静态成员变量，用来记录所有矩形对象的总面积和所有矩形对象的这个总数，这就是矩形对象的总数。 那这两个变量我们当然可以用全局变量来完成，对吧，但是由于你写成员变量全局变量的话就没办法 体现它跟CRectangle类的紧密关系。 它可能被其他类所访问，就不容易维护，所以我们把它写到这个 CRectangle类里面成为 静态的成员变量，这就赢不了，这两个东西是指跟CRectangle这个 类有关的。那好了，我们还会需要一些 函数能够把这两个 直给打出来。那能打出这两个直的函数我们名义为 PrintTotal。那PrintTotal当然如果你nTotalArea跟nTotalNumber 都是全局变量的话，那我们PrintTotal也就写成全局函数就好了，对吧。但现在呢，这两个变量都是静态成员变量，那相应地我们也可以把PrintTotal写成静态的这个成员函数。那也赢不了这个PrintTotal 只跟CRectangle有关，跟其他东西是没有关的。 
- 那现在我们来看看我们如何用这个TotalNumber、TotalArea来进入这个在运行的时候，我们要随时用这两个变量来进入 当前的矩形对象的总数和矩形对象的总面积，怎么做到这一点呢？ 
    ```C++
    #include <iostream>
    using namespace::std;

    class CRectangle {
        private:
            int w,h;
            static int nTotalArea;      //静态成员变量
            static int nTotalNumber;
        public:
            CRectangle(int w_,int h_);
            ~CRectangle();
            static void PrintTotal();   //静态成员函数
    };

    CRectangle::CRectangle(int w_,int h_) {
        w = w_;
        h = h_;
        nTotalNumber++;
        nTotalArea += w * h;
    }

    CRectangle::~CRectangle() {
        nTotalNumber--;
        nTotalArea -= w * h;
    }

    void CRectangle::PrintTotal() {
        cout << nTotalNumber << "," << nTotalArea << endl;
    }

    //必须在定义类的文件中对静态成员变量进行一次说明或初始化。
    //否则编译不能通过，链接不能通过
    int CRectangle::nTotalNumber = 0;
    int CRectangle::nTotalArea = 0;

    int main()
    {
        CRectangle r1(3,3),r2(2,2);
        //cout << CRectangle::nTotalNumber;     //Wrong,私有
        CRectangle::PrintTotal();               //输出结果：2,13   
        r1.PrintTotal();                        //输出结果：2,13
        return 0;
    }
    ```
  啊，一个很直接的想法就是我们在矩形的CRectangle类的构造函数里面要增加TotalNumber, 增加TotalArea对吧？这个很明显，因为只要有矩形对象生成就一定会引发构造函数的调用，那我们在构造函数里面就可以增加矩形的总数和矩形的总面积，对吧。 那当然，那矩形对象有可能消亡，对吧？比如说 一个局部的矩形对象变量，在出了这个包含它的函数以后就消亡了，那这时候矩形的总数就减少了，总面积也减少了， 所以我们在CRegtangle类的析构函数里面呢 要减少TotalNumber，减少TotalArea，这是很直观的对吧， 然后呢，我们在PrintTotal里面可以打印出 TotalNumber和TotalArea，啊，在这个PrintTotal里面，访问这两个静态成员变量把它给打出来， **但是要注意一点，就是在C++里面啊，静态成员变量你必须拿到外面，就是所有的函数外面来单独的给它声明一下，像这样啊， 这两个CRegtangle的静态成员变量，我们要单独拿出来生声明一下，像这种形式， 啊，类型，类名，然后跟这个变量名。 那声明的同时呢，你可以对它进行初始化，也可以不对它进行初始化**。 但具体到这个例子，我们需要用这两个变量来计入矩形的总数和总面积，对吧， 那我们当然要给它初始化成0，啊一开始没有矩形，那总面积和总数都是0， 然后只要有矩形对象生成，构造函数就会增加TotalNumber和TotalArea， 然后只要有矩形对象消亡，析构函数就会减少TotalNumber，减少TotalArea， 哎，看上去很美，是吧， 
- 呃，下面我们就来看看这些静态成员函数或者静态成员变量是怎么起作用的啊，在main里面定义了两个矩形对象， 然后我们试图输出TotalNumber， 那么呢这条语句这样写的话就会编译过不了，为什么呢？ 因为这个跟TotalNumber它是私有的，啊， 虽然这个表达式没问题，但你在这里在main里面 试图访问CRectangle类的私有成员，啊，这个时候当然就会出错， 哪怕它是静态成员，也是不行的。在接下来的这个 CRectangel啊，PrintTotal这样就打出了这个此时的总面积和总数。 那这个句型总数是多少呢？一共生成了两个矩形对象，所以总数当然就是2，总面积是多少呢？ 这个r1的面积是9嘛，r2的面积是4，所以总数和总面积就都是分布是2 和这个13，当然这里输出了两行2和13是因为下面还有一个r1.PrintTotal， r1.PrintTotal跟上面这个CRectangel::PrintTotal它完全是等价的，啊， 虽然这么写，但并不意味着PrintTotal作用在r1上面， 
- 喝点水 接着， 那我们一定要注意一点啊， 就是在静态成员函数中，不能够访问非静态成员函数， 呃，呃，不能访问非静态成员变量，啊，要注意，那我们一定要注意一点啊，就是在非静态成员函数中， 那我们一定要注意一点啊，**就是在非静态成员函数中，不能访问非静态成员变量， 也不能调用非静态成员函数**。啊。比方说我们下面这个PrintTotal， 
    ```C++
    void CRectangle::PrintTotal() {
        cout << w << nTotalNumber << "," << nTotalArea << endl;
    }
    ```
  如果我想把w给它输出出来，这行不行呢？ 唉这个是不行的，因为这是一个静态成员函数，在这里面你试图访问非静态的成员变量 是不可以的。那为什么不可以呢？那就是因为这个静态成员函数啊，它不是 作用在某一个对象上面的。那如果你执行到这的时候要访问这个w， 这PrintTotal又不是具体作用在某一个对象上面的，那你这里来一个w， 这个w是属于谁的啊，解释不通，对吧。很明显，我可以用这样一个办法来调用PrintTotal， 那这样的办法来调用PrintTotal，进到这个PrintTotal里面，你说这个w是属于哪个对象的啊？ 说不清楚，所以这样做是不允许的。 那为什么静态成员函数里面也不能调用非静态成员函数呢？ 哎，那这个结果也挺明显，啊，那因为你在这个你在一个非静态的成员函数里面是有可能访问到一个非静态的成员变量，对吧， 啊，所以同理，如果静态成员函数调用了非静态成员函数，然后那个非静态成员函数又访问到了非静态的成员变量，那最后就会发生， 被访问的那个成员变量是属于哪个对象的呢？说不清楚。 所以这也是不行的。 
- 那下面我们再回到刚才这个CRectangle这个类里面，啊，这个类呢我们说了， 要用TotalNumber计入当前系统里面矩形的总数，用TotalArea计入当前所有矩形的总面积，然后我们在构造函数里面增加这些值，在析构函数里面减少这些值，看上去很对，对吧？ **实际上这个CRectangle类的写法，它是有严重的缺陷的**。 它会导致在某一种时刻，哎，这个TotalNumber和TotalArea的值是不正确的。那这个缺陷到底是什么产生的呢？ **我们看，就说我们这个时候忽略掉了复制构造函数。啊。我们前面写了这个，在这个构造函数里面，对TotalNumber和TotalArea进行增加，这是没问题的对吧， 但问题是，是否搜有 CRectangle对象都会用这个构造函数来初始化呢？ 啊，这个问题就来了，我们知道不是的**。 
- 有一些CRectangle的对象它可能不会用这个构造函数来初始化。 那用哪个构造函数来初始化啊？啊，那我们看编译器会缺省，会自动生成什么样的构造函数啊？ 现在我们自己写了这个构造函数了，编译器就不会自动生成无参构造函数了， 但是呢，编译器它会自动生成复制构造函数。因为我们没有写复制构造函数对吧？ 那编译器自动生成的那个复制构造函数，它会去修改这两个变量的值吗？ 它当然不会，对吧？而，而我们知道， 我们在使用这个CRectangle类的过程中，就有可能有一些CRectangle的对象它是用复制构造函数来初始化的，这种情况时有可能发生的，对吧？ 什么情况下啊？ 
  - 比方说如果我们调用了一个以CRectangle对象作为形参的函数的时候，啊这个形参对象就是由复制构造函数初始化的。 
  - 或者我们调用了一个以CRectangle对象作为返回值的函数的时候，那这个返回值对象它也是用复制构造函数初始化的。
- 那这样的对象它们生成的时候并没有走这里，对吧？也就是并没有增加TotalNumber和TotalArea， 那这样的对象呢，它们在消亡的时候，却一定要走析构函数，就会减掉TotalNumber和TotalArea，所以这个时候问题就产生了，会产生什么样的问题呢？啊就是 如果有这样用复制构造对象，啊，复制构造函数初始化对象生成的话，就会发生总数和这个总面积比实际的情况要多还是少啊，大家说？ 当然是变少的情况，对吧，因为这样这些对象在生成的时候 并没有增加总数，可他们消亡的时候却减掉了总数，那当然总数就会变少，比实际的情况要少。 这就出问题了。啊，就像这种还有些临时对象啊，它在生成的时候，消亡的时候也会调用析构函数， 什么是临时对象啊？呃，这个，如果一个函数的返回值是一个对象的话，那这个函数的返回值就是一个临时对象。 那怎么来解决这个问题呢？ 啊，解决的办法我们就是用为复制，呃，为这个CRectangle类编写一个复制构造函数， 啊，怎么解决这个问题呢？那当然问题是出在复制构造函数上面， 那我们就要用复制构造函数来解决。啊。 如果我们为CRectangle类编写一个复制构造函数，这个问题就迎刃而解啦。 我们自己写一个复制构造函数，
    ```C++
    CRectangle::CRectangle(CRectangle &r) {
        w = w_;
        h = h_;
        nTotalNumber++;
        nTotalArea += w * h;
    }
    ```
  在这个复制构造函数里面，除了我们做复制的工作以外，还要对这个两个总数进行修改，啊，那么这个时候就不会发生 对象生成没有，没有增加总数，对象消亡却减掉了总数这个怪异的现象， 那当然就能确保TotalNumber和TotalArea总是正确的了。 
## 7.成员对象和封闭类的概念
- 大家好，在这一小节中呢我们来具体介绍一下成员对象和封闭类。所谓成员对象呢，具体就是指一个类的成员变量呢，其实是另一个类的对象。 也就是说，一个类里面的具体的某一个成员呢，实际上是另外一个我们定义的类的对象。 而不再是一些传统意义上常规类型的变量了。 那么包含成员对象的这样的类呢，又被称为叫做封闭类。那么有了成员对象和封闭类这个概念之后，我们就会看到说，其实类和类之间呢也是可以交织在一起的。 我们具体看一个例子，
    ```C++
    class CTyre {
        private:
            int radius;     //半径
            int width;      //宽度
        public:
            CTyre(int r,int w):radius(r),width(w) {}        //初始化列表
    };
    class CEngine {         //引擎类

    };
    class CCar {            //汽车类
        private:
            int price;      //价格
            CTyre tyre;
            CEngine engine;
        public:
            CCar(int p,int tr,int tw);
    };

    CCar::CCar(int p,int tr,int tw):price(p),tyre(tr,tw) {

    }

    int main()
    {
        CCar car(20000,17,225);
        return 0;
    }
    ```
  我们首先呢，定义了一个轮胎类。 CTyre，那么CTyre呢它包含了两个private的成员变量，分别是半径 int radius 和宽度 int width， 那么有了这样两个成员变量之后呢， 我们在相应的构造函数里面CTyre呢，我们要对其进行初始化。那么初始化呢，我们在这个边介绍一个新的方式叫做**初始化列表**。那么它不再是简单地用啊，radius等于r，width 等于w 这样的两个赋值语句来进行这样的一个初始化， 而是使得CTyre这样的一个构造函数里面呢， 后面跟着相应的需要初始化的成员变量， 并且呢，把相应进行初始化的值呢放在这个小括号里面， 我们推荐大家说呢，使用这样的初始化 方式呢，会比进行赋值的风格呢看起来更好一些。 那么除了轮胎类之外呢，我们还有一个叫做引擎类，CEngine， 定义好了这两个类之后呢，你自然而然就会想到，这样两个一定会构成另外一个类， 那么就是CCar这样的一个汽车类， 在这个汽车类里面呢，除了一些传统的成员变量， 比如说int型的price之外呢， 我们还有两个成员对象，那么分别是CTyre 这样的一个类，实例化的这样的一个对象tyre以及CEngine这样的一个类， 实例化的一个对象，engine， 那么这样两个成员变量呢，它都是 不同类的对象。 那么有了这样的两个，三个成员变量的定义之后呢 我们看到，对于CCar这样的一个构造函数而言的话， 那么它的初始化，在构造函数里的初始化， 我们也同样去使用了 这个初始化列表。初始化列表的话呢 我们在构造函数里面要初始化三个参数， 分别是对应了price，以及tyre 这样的一个成员对象里面的radius和width这样两个具体的成员变量。所以呢，我们在构造函数里面就通过初始化列表，把p初始化给price，把相应的这个tr和tw呢，去初始化给tyre这样的一个对象中间的radius和width，那么有了这样的一个构造函数的话呢，那么相应的CCar里面的每一个成员变量都会有其相应参数的一个初始化。 **那么汽车类呢，就被称之为叫做封闭类，因为它包含了这样的一个成员对象**， 那么所以在main函数里头如果我们去定义一个Car这样的一个新的实例化的对象的话呢，我们希望能够对它进行初始化， 分别是20000的价格， 17的半径，和225宽度的话呢，我们只需要在括号里面传入这样三个常量的参数， 就可以在相应的构造函数调用的时候呢把它们赋给相应对应的不同的成员变量。 
- 那么如果我们在CCar这样的一个类里面， 不去定义构造函数，啊，比方说我们去使编译器用默认的构造函数的话， 那么编译器呢就会报错，为什么呢？因为编译器不知道car.tyre 这样的一个成员对象里面相应的那些变量都应该怎么样进行初始化。 而CEngine呢，car.engine呢相应倒是没有什么问题， 因为呢它本身是没有对应的参数的，所以可以使用默认的构造函数就可以了。 所以我们在生成封闭类对象的语句的时候呢，要非常明确 对象中间的那些成员对象是否都需要进行相应的初始化。 
- 那么怎么样来完成这样的一个工作呢？ 我们主要就是通过刚才初步在代码里头看到了介绍的那个叫做初始化列表来实现的。 我们在定义封闭类的构造函数的时候呢，通过去添加初始化列表，也就是在构造函数的参数表之后， 使用一个冒号去定义一系列的成员变量， 并且呢利用这个成员变量后面小括号里面的参数表来对相应的成员变量来进行初始化。 那么就可以完成封闭类构造函数的设计。 那么大家注意，成员对象初始化列表中间的参数呢 它其实是可以是任意复杂的表达式， 那么它也可以是函数，变量，或者是表达式中的函数等等。 那么注意呢变量是要有定义的。 所以呢，我们就可以通过这样的初始化列表的形式完成整个封闭类构造函数的设计。 
- 那么在生成封闭类对象的时候的话呢， 它会有一个构造和析构函数调用的顺序。 那么我们在生成封闭类对象的时候呢，
  - step1首先执行的是所有的成员对象自身的构造函数。 啊，只有把成员对象的构造函数执行完之后， 
  - step2才回去执行相应外层的这个封闭类的构造函数。 
- 那么，如果本身这个封闭类里面包含了多个成员对象的话， 那么这几个成员对象的构造函数又是怎么样来调用的呢？它的这个调用顺序啊， 是和成员对象在类中的说明顺序保持一致的。 注意，它和你成员本身在初始化列表里面出现的顺序是没有关系的。 那么它只和你在类中的说明顺序是一致的。那么有了这样的一个啊，生成过程中间的一个构造函数调用之后呢，我们再看一看对象消亡的时候，啊，这个封闭类对象消亡的时候，
  - 它首先执行的是相应封闭类的析构函数的调用。 
  - 之后呢，才会执行所有成员对象的析构函数的调用。 
- 那么这个设计呢，其实仍旧满足了之前我们介绍的构造函数和析构函数的一个设计思想，也就是，先构造的后析构，后构造的先析构，这样的一个思想。 所以呢，这就是封闭类对象生成和消亡的一个，调用的一个顺序。 我们说呢，这个析构函数和构造函数的调用顺序呢， 正好是相反的。我们来看一个封闭类的例子。 
    ```C++
    //封闭类析构函数和构造函数的调用顺序
    class CTyre {
        public:
            CTyre() {
                cout << "CTyre contructor" << endl;         //②二
            }
            ~CTyre() {
                cout << "CTyre destructor" << endl;         //⑤五
            }
    };
    class CEngine {         //引擎类
        public:
            CEngine() {
                cout << "CEngine contructor" << endl;       //①一
            }
            ~CEngine() {
                cout << "CEngine destructor" << endl;       //⑥六
            }
    };
    class CCar {            //汽车类
        private:
            CEngine engine;
            CTyre tyre;  
        public:
            CCar() {
                cout << "CCar contructor" << endl;          //③三
            }
            ~CCar() {
                cout << "CCar destructor" << endl;          //④四
            }
    };    

    int main()
    {
        CCar car;
        return 0;
    }
    ```
  啊，我们有一个class CTyre，这样的一个轮胎类，那么我们来看一看在这个构造函数里头呢我们让它去打印输出CTyre constructor， 然后在析构函数里面呢让它去输出CTyre destructor， 同样的呢我们在CEngine里面也相应的让它去输入 输出，这个constructor和destructor这样的 这个语句，去标识呢，构造和析构函数调用， 之后我们再CCar这样的一个封闭类里面，啊， 去看一看它是怎么样实际去调用的。那么当然我们在CCar的构造和析构函数里面呢 也会去分别输出，那么如果我们只是简单的去定义一个Car 这样的一个实例化的对象，当然它是CCar类型的，那么它是一个封闭类类型的， 这样的一个对象的时候，按照我们刚才给大家介绍的一个呃，调用函数的一个生成顺序的话， 那么因为它里面包含了一系列的这个成员对象， 所以呢，我们首先应该执行的就是成员对象的 构造函数。成员对象的构造函数呢，又是按照 这个在类里面的说明顺序来执行的。所以呢，首先就是CEngine constructor，然后是CTyre constructor， 之后呢会去执行封闭类自身的构造函数，啊，CCar constructor， 那么当这个程序结束的时候，这个对象Car要消亡的时候呢， 程序首先调用的是CCar destructor，啊，那么这个 封闭类的析构函数首先被调用到， 完了之后呢，又逆序啊，按照跟之前的这个顺序正好相反， 我们呢调用的是CTyre destructor， 最后呢，是CEngine destructor， 所以呢，这个例子呢就会很明显的看出，我们的这个调用顺序呢分别是成员对象， 封闭类的一个构造函数调用，之后是封闭类成员对象的析构函数的调用， 那么注意构造函数和析构函数的调用顺序呢是正好相反的， 而在，分别这两种函数调用的时候呢，它们的这个 相应的成员变量的顺序呢又是根据在类中间的说明顺序来依次定义的。 
## 8.友元
- 大家好，在这一小节中，我们来介绍一个新的概念，称为叫做友元，那么这个友元呢，对应C++关键字里面呢，被称为叫做Friend， 我们来具体看一下这个Friend是一个怎么回事呢？它其实包含了两种类型。 
  - 一种呢，被称为叫做友元函数，
  - 另外一种呢，称为叫做友元类。 
- 我们首先呢来看一下友元函数。 那么一个类的友元函数就可以访问该类的私有成员。 我们之前在类的访问范围说明符里面讲过， 如果一个成员被声明为是Private的， 那么只有在这个类的成员函数内部才可以被访问到。 除此之外，都不可以访问。 但是在有些时候在涉及函数的时候，有些公共的函数，或者说类成员函数之外的地方呢你可能会需要用到某个类的私有成员，那怎么办呢？并不是说就被一刀禁止了， 那么你就可以去声明说这个函数是这个类的友元函数。比方呢， 这个例子为例。
    ```C++
    //封闭类析构函数和构造函数的调用顺序
    class CCar;             //提前声明CCar类，以便后面CDriver类使用
    class CDriver {
        public:
            void ModifyCar(CCar *pCar);         //改装汽车
    };
    class CCar {            //汽车类
        private:
            int price; 
        friend int MostExpensiveCar(CCar cars[],int total);     //声明友元
        friend void CDriver::ModifyCar(CCar *pCar);             //声明友元
    };    
    void CDriver::ModifyCar(CCar *pCar)
    {
        pCar->price += 1000;                    //汽车改装后价值增加
    }
    int MostExpensiveCar(CCar cars[],int total) //求最贵汽车的价格
    {
        int tmpMax = -1;
        for(int i = 0;i < total;++i)
            if(cars[i].price > tmpMax)
                tmpMax = cars[i].price;
        return tmpMax;
    }
    int main()
    {
        CCar car;
        return 0;
    }
    ```
  我们看到呢，有两个类分别称为叫做CCar和CDriver， 注意，因为在CDriver里头要用到CCar类型定义的一个指针， 所以呢，我们需要首先在CDriver之前呢， 去声明有CCar这样一个类。那么，在CCar这个类里面呢， 它定义了一个私有的成员变量，叫做price，啊也就是说这个车的价格，是只有CCar类型的成员函数才能够访问到的。那么这个时候我可能会需要在一些其他的场合去访问这个汽车的价格，比方说我有一个函数称为叫做MostExpensiveCar， 那么我需要知道说最贵的车是哪一个，那么这种时候呢，它本身是一个在成员函数之外的函数， 那么，我们就把它声明为是友元，这个时候呢它就可以去访问 price这样的一个私有成员。 同时呢，我们也可以去定义其他类的成员函数，是吧，比方说CDriver对应有一个函数 称为叫做ModifyCar,可能是改装这个汽车，那么改装车也需要知道这个车的原始价格啊， 所以呢，那么你作为 其他类的成员函数，你想访问 CCar对应的这样一个私有成员怎么办呢？ 你也可以把它声明为是一个friend类型，啊，友元， 那么这时候呢，你就可以在相应的函数内部比如说可以在ModifyCar这个里面 访问对应CCar类型的一个私有成员变量， 同时呢，你也可以在一个全局函数啊，比方说这样的一个MostExpensiveCar里面去访问对应的汽车的价格。 那么有了这样的一个友元函数的设计呢就允许大家可以在某些情况下去访问对应这个类的私有成员。 
- 除了这个友元函数之外呢，我们还可以将一个成员函数定义为是另外一个类的友元， 比如说，
    ```C++
    class B {
        public:
            void function();
    };
    class A {
        friend void B::function();
    };
    ```
  我们可以看到说呢这个 class B里面对应的有这个一个函数称为叫做function， 同时呢，我们又发现说，咦，我们可以将这个 class B中间的function呢 声明为是class A的友元， 那么这种方式呢，使得说在class A中间也可以通过class B的方式来进行访问， 那么注意了，这种成员函数呢，那同样是包含构造和析构函数的。 
- 那么除了友元函数之外呢，还有一种叫做友元类， 那么所谓友元类呢，就是我们把A称之为是B的友元类， 那么A的成员函数就可以去访问B的私有成员。我们来看一眼，
    ```C++
    //A是B的友元类--->A的成员可以访问B的私有成员
    //友元类之间的关系不能传递，不能继承
    class CCar {            //汽车类
        private:
            int price; 
        friend class CDriver;           //声明CDriver为友元类
    };    
    class CDriver {
        public:
            CCar myCar；
            void ModifyCar(CCar *pCar){ //改装汽车
                myCar.price += 1000;    //CDriver是CCar的友元类--->可以访问其私有成员
            }       
    };
    int main()
    {
        return 0;
    }
    ```
  还是刚才这个CCar和CDriver的例子。 我们如果在CCar这个类型里面去声明说 CDriver是我CCar的友元类， 那么这就意味着说CDriver里面的 任何的一个函数，比如说ModifyCar中间 就可以任意访问到CCar类型的私有成员。 啊，也就是，我不需要再在这个里面去声明说ModifyCar这个函数是friend了， 我只需要去定义一个统一的， 这样的一个友元类，那么它同样可以去访问CCar中间的private的一些成员变量。 那么如果我还有其他的一些函数，那么只要在CDriver里头的话，都可以去访问 price这样的一个私有成员。 那么大家要注意的就是友元类呢，是，之间的这个关系呢， 是不能够传递也不能够继承的， 你不能说，A是B的friend，B又是C的friend， 所以A一定是C的friend， 这种关系呢是不成立的。这就是所谓不能传递。 
## 9.this指针
- 嗯，同学们好，接下来我们要讲一讲这个This指针。 This 指针。嗯, This 指针它是起什么作用的呢？我们要先要从这个C++程序到C程序的翻译来说起。 就是这个C++原刚刚出来的时候 ，并没有这个 ，嗯， 编译器。那怎么编译C++的程序呢？ 嗯，就可以通过把，嗯，一段C++程序翻译成C程序。然後再用C的编译去编译。 用这个办法来。 那，那我们看看像这样一段C++的程序，我们如果想把它翻译成C程序的话，大家想想会是个什么样子？啊？ 
    ```C++
    class CCar {
        public:
            int price;
            void SetPrice(int p);
    };
    void CCar::SetPrice(int p) {
        price = p;
    }
    int main()
    {
        CCar car;
        car.SetPrice(20000);
        return 0;
    }
    //-----------C++程序到C程序的翻译--------------
    struct CCar {
        int price;
    };
    void SetPrice(struct CCar *this,int p)
    {
        this->price = p;
    }
    int main()
    {
        struct CCar car;
        SetPrice(&car,20000);
        return 0;
    }
    ```
  首先我们看，Class在C语言里面是没有的，对吧？那Class 对应什么呢？ Class 当然就对应于C语言里面的Struct 结构体，对吧？那这个 Car里面的这个成员变量， 它 对应于结构体里面的什么呢？当然也对应于结构体里面的那些int对吧？所以说着个Class 我们嗯，大概知道怎么翻译。怎么翻呢？嗯，我们把这个Class CCar翻译成了struct CCar。 然，然後这个成员变量的Price， 变成这个Struct里面的一个int的price. 那问题是，这个成员函数到底应该怎么翻译？ 对吧？因为在C语言里面没有成员函数这个概念。好。 这个是成员函数我们函数提起来，这，在C语言里面呢，当然我们知道 只有全局函数无所谓什么成员函数，对吧？那么我们也只能把这个成员函数 翻译成一个全局的函数了。 但是我们在翻译成全局函数的时候我们看到，在这里多加了一个 参数，啊，这个参数它的类型是一个指针，它是指向C。 Struct CCar这种结构体，变量的这个，这个指针，第二个差数不变。 然后在这里面这条语句，price = p,我们把它变成 this->price =p。那这为什么要加一个this这样的指针？ 我们再往下看就会知道。好，那接下来我们要翻译的就是，就是这个，这个main了。 main函数当然前面这个基本上可以照抄，但是不好翻译的是这条语句，对吧？ SetPrice。 现在我们看看这个C++程序，是调用了SetPrice这个成员函数。 然后这个SetPrice它是作用在car这个对象上面的。 也就是说我们走到这个SetPrice函数里面以后， 在这里修改了price，修改了price这个改的是谁的price呢？ 当然是这个car这个对象的price. 对吧？那现在我们把main 翻译，翻译成这个C程序的话它应该是这样。嗯，这个定义的一个CCar的对象，这里对应于，对应于一个 CCar的结构变量。然後这个SetPrice,调用SetPrice，那么我们当然这里也应该要调用SetPrice函数，对吧？ 但是，这个SetPrice呢在C++程序里面呢是作用在car这个对像上面的。 它要修改car的成员变量。 那在C原呢？翻译过来C原程序里面，我们怎么做到这一点呢？ 那当然具体的办法就是我们调用SetPrice，然後我以这个car的，这个，嗯， 地址作为参数。去调用SetPrice，嗯，car的地址作为第一个参数 调用SetPrice， 当然这个要修改的，的这个价格就作为第二个参数。 接下来我们就看到进到这个，进到这个，呃，嗯，SetPrice这个全局函数里面以后，诶，这个this指针 指向谁啊？是不是就指向这个car对象？ 那么我们在这里执行了this -> price = p,大家说 会修改了哪一个变量的这个，修改了谁的price的值呢？ 当然就是修改了这个这个car的，这个price的值，对吧？ 所以我们看到这个从C++程序翻译到C程序。 其实最难的一点，最不容易理解的一点嘛，就是一个成员函数是怎么翻译的。那我们发现，诶，成员函数 会被翻译成一个全局的这个函数。然後呢这个全局的函数它的差数个数 要比成员函数多一个。多出来的这个，多出来这个差数个数是什么呢？ 就是所谓的一个this指针。那这个this指针指向谁呢？ 就指向在C++程序里面那个成员函数所作用的这个对像。 来看是不是这样。 嗯，那实际上，嗯，实际上你完全可以这样理解。 就是C++的编译，你就完全可以把它理解成先翻译成C，然後再拿C去 C的编译去编译。嗯，你可以完全那么去理解，这是没有问题的。 那实际上我们也就是说你看到C++程序里面一个成员函数里面他有多少个参数， 那，那真实的这个被，编，编译成机器指令以后的这样一个程序 里面成员函数所对应的那个机械指令面，机器指令里面的那个函数 它的参数实际上要增加一个，增加的那个参数就是所谓的this指针。 那这个this指针呢我们是 可以在，在C++里面这个this指针我们可以把它用在这个成员函数里面，就是我们在写成员函数的时候，在里面可以写this指针。 那this指针它是做什么用的呢？它的作用就是指向成员函数所作用的那个对像。 我们说一般来说就是非静态的成员函数嘛，它都会具体作用于某一个，这个对像。对吧？那我们如果在这个成员函数里面写了这个this指针， 这个this指针就会指向这个函数所作用的对象。 
- 我们具体看看一个例子。
    ```C++
    class Complex {
        public:
            double real,imag;
            void Print() 
            {
                cout << real << "," <<imag;
            }
            Complex(double r,double i):real(r),imag(i) {}
            Complex AddOne()
            {
                this->eal++;            //等价于real++
                this->Print();          //等价于Print
                return *this;
            }
    };
    int main()
    {
        Complex c1(1,1),c2(0,0);
        c2 = c1.AddOne();
        return 0;
    }                                   //输出2，1
    ```
  这里有一个附属类Complex。 然後这里面，嗯，它有这个print的输出实部和虚部的值。 然後这个是构造函数。嗯，构造函数的后面跟了一个初始化列表 就能够把实部初始化成r,虚部初始化成这个i。嗯，然後这儿有个AddOne成员函数。 AddOne成员函数，嗯，它的作用就是把 实部加一然後并且把这个，把实部和虚部都打出来。 在这里我们看到，嗯，在AddOne里面我们使用了这个this指针。我们使用this->real++, 然後this->print。那按照我们前面说的，这个this指针 它就指向了 这个AddOne这个成员函数所作用的那个对象。 那实际上这个this->real++它就等价于real++，啊。 你写real++或者this->real++ 是没有差别的。这个this->print呢它也等价于print 的。然後，然後这个AddOne呢它 返回只是一个Complex对像。我们在这个程序里面希望它能够返回，这个AddOne 所作用的对像自身。就AddOne作用在一个对像上面，然後它把这个对像的实部加一，并且输出它的实部和虚部。 之後呢，这个AddOne能返回这个对像自身。啊。那我们看看我们怎么使用这个AddOne。 如果我们在这个，这个main里面，我们定义了，嗯， Complex c1、c2。c1的实部是，嗯，是，是1 ，虚部是1。 呃，c2的实部和虚部都是0。然後c2 = c1.AddOne. 那我们先看这个c1.AddOne。c1.AddOne的话，就会调用这个，AddOne的这个成员函数。 那走到这成员函数里面来，this->real++这个this指向谁啊？ 啊，前面说了，this指针就会指向 这个，成员函数所作用的那个对像。那现在这个AddOne成员函数是作用于c1的，所以 这个this指向的就是 什么啊？就是这个c1.那this->real当然就是c1的real了，对吧？ 所以说，嗯， 这条语句执行完了以后呢，嗯， 这个c1它的实部就加了一，而且执行的过程中会把这个c1它的实部和虚部都给它输出出来。 然后我们看这个AddOne它要返回一个，返回一个对像，对吧？我们 在这段程序里面我们，我们希望AddOne返回就是c1这个对象自身。而且是被修改以后的这个c1。 那你在这个AddOne成员函数里面怎么做到这一点呢？你如何去返回 AddOne 所作用的这个对像这个东西？ 嗯，这个时候我们就 必须要使用到这个，这个this 指针了。嗯，因为this指针就指向了AddOne所作用的对像。 那么*this就等价于是AddOne所作用的那个对象，对吧？所以我们在这里return*this。 相当于在这个位置AddOne就返回了哪个对像啊？返回了就是c1 这个，这个对像。然后把c1这个对象呢则负责了给c2。 那所以这个程序它，嗯， 它输出的结果就是2，1。嗯， 因为在AddOne执行的过程中，你修改了实部和虚部的值，又把实部和虚部都打出来了。 
- 那我们还可以通过，这个看上去稍微有一点怪的程序进一步说明这个this指针它的这个作用。
    ```C++
    class A {
            int i;
        public:
            void Hello()                //相当于 void Hello(A *this) {cout << "hello" << endl;}
            {
                cout << "hello" << endl;
            }
    };
    int main()
    {
        A *p = NULL;
        p->Hello();                     //结果会怎样？   输出：hello     //相当于 Hellp(p);
        return 0;
    }
    ```
  嗯，我们看看这个程序的这个class A 有一个成员变量i，然後它有一个这个这个 成员函数。嗯，这个成员函数输出"hello"。 然後在main里面呢，我们定义了一个，嗯， class A的指针，让它成为一个空指针。 然後我们通过这个空指针去调用Hello。 这条语句怎么解释呢？这条语句按理说应该说的是 嗯，我们要调用Hello,然后要Hello作用在 p所指向的那个对像上面，对吧？就是我们前面所学的这个知识。当然，大家一看就觉得这个东西 很，很怪异，对吧？因为p它是一个空指针。它没有指向任何的对像。那么你现在 调用Hello，想要Hello作用在p所指向的对像上面。然后， p没指向任何对像。 这个，这个看上去肯定是不对的，对吧？嗯，就是你这么直观一看就觉得，诶？这个程序肯定是出错了。 因为我们前面就强调过很多遍，就是说这个，这个空指针，嗯， 是不能拿来乱用的，对吧？现在这个p是一个空指针，你还要通过这个空指针去调用Hello。 这肯定结果不对嘛！但实际上你要运行一下这个程序， 你会发现这个程序它是不会出错的，它会输出Hello。 然后这看上去就很怪哦，这个-这个p它没有指向任何对象，然后你这Hello还作用在 也就不能作用在任何对象上面，那怎么还能够正确的执行并且有数字结果呢？ 看上去很怪，但是实际上呢这个是没有问题的，我们可以 如果你理解力了this指针的含义，你就会知道这个为什么会是正确的。 来想想看，这个Hello这个函数 它是一个成员函数，那我们把它真正编印器把它编印成一个机器指令的函数了以后呢，那我们前面说的参数的个数会多出来一个，你可以想象先把iii程序 翻译成c程序然后再去编一个对吧，那翻译成c程-c程序以后 这个它所对应的这个c的那个程序函数它会参数多出一个来，就是一个this指针。然后这边 这里面该-该怎么翻译呢？这里面照样是一样的是cout<<hello<<endl的对吗？ hello<<end-l 是这样的。那-那我们看看这个p箭号Hello 被翻译成什么？被翻译成Hello(p)对吗？ 我们回顾一下前面说的那个this指针的这个-这个作用。 这个程序函数Hello所对应的那个c程序里面的全局函数，它是要有一个this指针作为参数的对吧！那这个this指针又指向了什么啊？指向 Hello所作用的那个对象，那现在，在这条语句里面，Hello所作用的对象应该是由p这个指向所指向的 因此我们把p作为参数写在Hello这个，这个是很顺理成章的对吧！ 那现在我们看看实际上就调用了这个被翻译以后的这个c程序里面的Hello 就是这一条语句被翻译成c程序就是这个样子的，那实际上调用Hello (p)实际上就会执行这-这个函数对吧！ 在执行这个函数的过程中我们看看做了什么，就执行了cout<<hello 那-那cout<<hello当然它不需要任何什么class A的对象存在，这条语句就能够正确执行 没有问题的是吧，所以这个程序它就输出了这个Hello，它实际上不会出错。 那-那好像跟我们前面学的这个常识有点违反，但实际上我们如果理解力这个this指针的含义 就知道这个是没有问题的。
- 但是我再看下下面的一个例子，会出错的这个例子。看这，
    ```C++
    class A {
            int i;
        public:
            void Hello()                //相当于 void Hello(A *this) {cout << this->i << "hello" << endl;}
            {
                cout << i << "hello" << endl;
            }
    };
    int main()
    {
        A *p = NULL;
        p->Hello();                     //结果会怎样？   输出：error     //相当于 Hellp(p);
        return 0;
    }
    ```
  如果我们把Hello成员函数改写了改成Cout<<i, 然后再Hello<<end 那么这个程序就会出错了。下面这一块还是一样的 还是调用这个-这个-这个p箭号Hello，main是不变的。 那如果我们He-Hello的成员函数这么写，这个程序就会出错了。 为什么呢？我们还是要把这个整个的成员函数翻译成c 程序的全局函数，翻译完了那我们再来看看，翻译成这个c的全局函数之后就变成这样 然后这里面呢我们就cout<<this箭号i对吧！ this，这个i是谁的i啊？就是this指针所指向的那个对象它的i,所以这里就变成了this箭号i。 然后这下面的p箭号Hello，还是Hello(p)对吧！那我们要看程序执行到这的时候是不是会有问题。 为什么有问题啊？因为我们看这里执行了Hello（p)，p 是时差，那进到这个函数里面以后呢p就跟这个形参this是相等的对吧？ 那p是NULL，那进到这个Hello函数里面以后，this也就是NULL，是个空指针。 那现在这个this箭号i就有问题了，因为this是个空指针，然后你要去找这个空指针所指向的一个对象里面的i 那当然是找不到的对吧！所以这条语句事实上就会产生这个常见的那一种空指针的这个错误，它可能会导致你的程序崩溃。 这样一个程序就是不正确的了。那通过这两个例子我们应该能够很好的理解this指针到底是做什么用的。 this为NULL，可能这条语句就会出错了。
- 那最后再讲一点。就是因为这个静态成员函数啊它并不会具体作用于某一个对象,而这个this指针呢又是指向成员函数所作用的那个对象,所以说你在静态成员函数之中肯定就不能使用this指针。 你如果使用的话，这个this指针指向谁呢？这个静态成员函数并没有作为任何对象。那所以说啊，这个静态成员函数中它的真实的参数的个数 就跟你在程序里面写的那个参数的个数是一样的。 而普通的成员函数它的真实的参数个数是比你写出来的要多一个的，多出来的这个实际上就是this指针。 
## 10. 常量对象、常量成员函数和常函数
- 常量对象，常量成员函数和常引用 我们可以用const的关键字来定一个常量 那我们定一个对象的时候也可以在前面加const的关键字 那么这个对象在初始化以后，它的值就不会被改变了 看这个例子，
    ```C++
    class Demo {
        private:
            int value;
        public:
            void SetValue() {}
    };
    int main()
    {
        const Demo Obj;     //常量对象           
        return 0;
    }
    ```
  这有一个demo位 那我们定一个demo对象object的时候 如果我在前面加了const的关键字 那么这个object一旦初始化完了以后，在后续的程序里面你就 不能去修改它的值了，然后这object就变成一个常量对象。 
- 实际上我们还可以在类的成员函数说明后面加上一个const的关键字 那这样的一个成员函数就成为所谓的常量成员函数 常量成员函数跟普通成员函数有什么区别 在于这个常量成员函数执行期间，它不应该修改 它所作用的对象，所以它前面成员函数中就不能修改成员变量的值 但是这个静态的成员变量是例外，因为静态的成员变量 其实它不属于对象的一部分，它被属于对象的共享 然后这个常量成员函数执行期间也不能调用同类的非常量成员函数 因为这个同类的非常量成员函数在执行期间 有可能修改了它所作用的对象，所以当然你也不能调用 那静态的成员函数是可以在常量成员函数执行期间来调用 因为静态成员函数那一部不会访问非静态成员变量 下面我们通过具体的例子来看一看常量成员 函数和常量对象之间有什么样的关系，
    ```C++
    class Sample {
        public:
            int value;
            void GetValue() const;
            void func() {}
            Sample() {}
    };
    void Sample::GetValue() const
    {
        value = 0;          //wrong
        func();             //wrong
    }
    int main()
    {   
        const Sample o;
        o.value = 100;      //error.常量对象不可被修改
        o.func();           //error.常量对象上面不能执行非常量对象成员函数
        o.GetValue();       //ok.常量对象上可以执行常量成员函数       
        return 0;
    }
    ```
  在这里我们定义了一个sample类 还有一个成员被量的value，然后在这里面有一个成员函数getvalue 我们在类里面说明它的时候，**后面加了一个const关键字所以它就是一个 常量的成员函数**。那这边有非常量的成员函数func 还有构造函数 我们把这个getvalue拿到类的外面来写了 他是一个常量的成员函数所以拿到累的外面写的时候也要加上const 然后我们看到在getvalue里面，执行value=0 这样的语句会编译出错的 因为我们说的getvalue它是一个常量成员函数 **常量成员函数在执行的过程中是不应该修改他所作用的变量的值** 那我们这里调value等于0就修改了它所作用的变量的 对象的成员变量的值，那当然就不行了 包括下面这一条语句调用func也是不行的 因为常量成员函数那一部不能调用 非常量的其他的成员函数 因为非常量的其它成员函数在执行过程中是有可能修改掉它所作用的对象的值。 所以这两条语句的编译都出错 下面我们再看看内函数里面怎么用常量对象，我们在这里第一常量对象o 那下面这条语句o.value等于100，当然这个出错的了因为产量对象它的值是不能被修改的 包括这个o.func也是出错的，因为常量对象上面不能执行非常量成员函数 为什么不能执行？因为非常量成员函数 在执行过程中是有可能修改掉o的值 当然这个程序里面func没这么做，可是编译器不会去分析func到底做了些什么的 它只是看到o是一个常量对象 func它是一个非常量的成员函数，那func是危险的，它执行过程中说不定就会改了o的值所以编译器干脆就报错了 下面一条语句o.getvalue这个就没有问题 因为常量对象上面可以执行常量成员函数 常量成员函数是安全的，因为在常量成员函数中它是不会出现 修改对象的值的真阳的语句的 因此o.getvalue不会修改o的值，所以就没有问题。
- 还有一点一定要注意就是一个类里面 可以有两个成员函数，他们的名字和参数表都一样，但一个是const一个不是。这样的两个成员函数算是重载而不是冲突定义 
    ```C++
    class CTest {
        private:
            int n;
        public:
            CTest()
            {
                n = 1;
            }
            int GetValue() const
            {
                return n;
            }
            int GetValue
            {
                return 2 * n;
            }
    };
    int main()
    {      
        const CTest objTest1;
        CTest objTest2;
        cout << objTest1.GetValue() << "," << objTest2.GetValue();          //输出：1，2
        return 0;
    }
    ```
  这个Ctest里面 我们看到有两个getvalue，它们的名字参数表都是一样 但是一个getvalue后面加了const，它是常量的成员函数 另外一个getvalue它是非常量的成员函数 那我们看到这两个getvalue就是重载关系而不是重定义 然后我们在main里面定义了一个对象 const Ctest objTest1，这个objTest1就是常量对象 下面这个objTest2就是非常量对象。这下来我们的 objTest1上面调用getvalue把它的范围值给它数数 那这个时候到底调用的是哪一个getvalue呢？ 那边一起就看到了objtest1它是const的 常量对象。那显然常量对象上面是不能够执行非常量成员函数的 所以这个getvalue只能是这个const的getvalue 因此，这个表达是它的范围值 就是objtest1.n,那就是1 那下面表达是objtest2.getvalue，那这个getvalue到底是哪个getvalue呢? 编译器看到objtest2它是非常量对象。所以这个getvalue 就可以是 非常量的getvalue 所以这个objtest2.getvalue表达的是 它范围的值是2*n，那就是2，因此这个程序就这样 
- 这下来要注意就是我们 在引用的前面也是可以加const的关键字，那引用就成为常引用 不能通过常引用修改其引用的变量 那常引用经常被用来作为函数的参数 因为我们在写一个函数的时候，如果你把对象作为函数的参数，那么生成 这个参数对象，它是需要调用复制构造函数的 这样就有时间和空间上的开销。用指针作为参数，代码又不太好看，那怎么解决这个问题呢？ 为了避免 对象参数引发的复制构造函数调用开销，我们可以使用对象的引用作为参数，
    ```C++
    class Sample {
        ...
    };
    void PrintfObj(Sample &o)
    {
        ...
    }
    ```
  比如说我们这里有一个printfobj 要打一个object的值出来我就可以用 sample类的引用作为参数，这个时候o这个参数 它不是对象，因此o未引发复制构造函数的调用 就结成了这个开销，让我们在这个函数里面可以访问这个o对象的字 也就是实参的字，但是这里面有个问题，对象引用作为函数的参数 那么这个引用等价于这个实参了 那如果函数中不小心修改了形参o，因为o赢了实参，所以实参也就会跟着变 这可能是我们需要避免的，那怎么避免这种情况呢？ 我们可以使用对象的常引用作为参数 
    ```C++
    class Sample {
        ...
    };
    void PrintfObj(const Sample &o)
    {
        ...
    }
    ```  
  就是我把一个类的常引用 作为函数的参数类型 在这里面o它引用了实参，那我们使用实参的值都不需要复制这个实参对象 而且由于加了这个const，所以我们这里面 Printfobj里面就不会出现试图修改o的这样的语句 因为o成为一个常量了 任何试图修改o的语句，编译器都会发现并且报错，所以我们能确保 printfobj里面不会出现修改o的语句，也就不会使得o的值无意的被修改了 