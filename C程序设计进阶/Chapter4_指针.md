# [指针](https://www.coursera.org/learn/c-chengxu-sheji/home/week/4)
> 本次课我们为大家讲解“指针”“指针变量”“指向变量的指针”等名词的基本含义。在此，需要特别提示大家：请大家务必明确区分上述的基本概念，以便在后面的课程中准确的使用它们。 同时，我们还将向大家阐述一个重要的理解——数组名 与 指向数组首元素的指针 之间的关系，也请大家务必反复印证，以便日后轻松使用：）
## 1. 什么是指针
- 各位同学大家好， 接下来啊，我们开始指针这部分的内容。 指针呢，在C语言中啊，占有非常重要的一个地位。 关于指针这个部分呢，我们计划讲几次课。 当然一方面呢取决于我们课程的一个进度安排。另一方面呢，也不希望搞得大家特别地紧张。 我们希望啊，在这部分，从概念上给大家打好一个基础。 ok，那么我们就开始这部分的内容。今天呢，是指针的第一节。 
- 那说到指针啊，我首先想强调一下， 在这个部分里头啊，概念是一个非常重要的东西。 如果搞不清楚与指针相关的这些概念是什么意思， 那么在接下来的课程里头，你也没办法再去搞清楚其他更复杂的东西了。 所以说啊，在这次课上我们就花 一些时间，专门去讨论几个非常重要的概念。
  - 第一个概念，无疑，我们先来讨论一下 什么是指针？啊，先来看一下什么是指针。老说指针，指针，它到底是个什么东西啊？要讨论它啊，咱们先不着急，先来看一张图。 啊，看这样一张图。啊这个图真是太漂亮了啊。这是 一个星云的一张图，是哈勃望远镜拍下来的。 在太空里面某个星云的一张照片。 那么这一张照片我们之所以喜欢它呢，就是因为这个星云啊，看上去 真的像一个人一样。不知道大家有这样的感觉没有。 这张照片呢，是我从NASA的网站上，啊，拿下来的。 我不知道大家有没有这样的冲动，想去获得更多的关于星云的漂亮的 照片。这样的一些照片甚至可以直接拿来做桌面用，非常非常地漂亮。 那么我要把这个照片给你的话我当然最好的办法就是给你一个 网址。告诉你这个网址以后啊， 你就可以拿着这个网址啊，去寻找这个照片了。 啊，等你找到这个照片的时候你会发现，喔，它实际上是叫N49星云，第49号星云。 这是它的地址。那同学说，那你说这么多这个玩意儿，跟指针有什么系啊？ 有关系。我只要把这个地址给了你， 你呢，就可以拿到这个图片了，对不对？ 那么，我们就把这个网址， 称为指向这个资源的指针。这个网址啊，给出了这个图片在互联网上的地址。于是呢，我们就把这个地址，互联网上的这个地址称为指向这个资源的指针。 那一点都不复杂，就是这个地址，我们就把它称作指针嘛。 就是这么一个非常简单的一个概念。那同学说，这跟C语言里的指针有什么关系啊？ 哎，有关系。下面呢，我们就来看一个程序。看这个程序：
    ```C++
    void main()
    {
        int a = 15;
        int b = 2;
        int c = 76;
        int i = 30;
        int j = 126;
        int k = 5;
        .........
    }
    ```
  在这个程序里头啊，我们定义了好多个变量。 比方说我们在这儿定义了一个int c等于76。 我们之前曾经讲过啊，当你定义下这样一个变量的时候，它程序运行起来之后，它会怎么做啊？ 它会在内存里面开辟一片存储空间，把这个76呢，放进去。那么， 内存里边的任何一片存储空间啊，都有与这个存储空间相对应的地址。比方说这个76， 它的地址，啊就是在某一个地方。当然有的同学说，76是占4 个字节呢，因为它是一个整型嘛。你说得很对，我在这儿写的这个地址啊， 是76所占的这片内存空间的起始地址。 你看看啊，当我们定义下一个变量，并且对它进行初始化以后，我们得到了一些什么呢？ 我们得到了一片存储空间。这片存储空间呢，有一个起始的地址。这个变量呢，还有一个变量的名字。也就是说啊，我们得到的是这三样东西。**其实这三样东西，在有的书上，把它称作变量的三要素。第一个，是一个变量的地址。肯定这个变量在内存里边是有一个起始的地址的。然后呢，这个变量肯定是有一个值的。而且呢，它有一个变量的名字，那就是所谓的变量的三要素**。 通常，**我们把某个变量的地址称为指向该变量的指针**。 也就是说，一个变量的地址就是指向这个变量的指针。 特别特别需要在这儿说明我讲的是指针， 而不是指针变量，这两个是不同的东西。 指针变量我还没提呢，还没讲呢，这儿讲的是指针。拿我们刚才讲过的星云 图的这个例子做一个对比的话，那么我们就说，这个http的地址，就 是指向这个图片的指针。 那么对于一个变量而言我能不能搞到它的地址呢？怎么样才能看到这个变量的地址呢？ 很容易，那在C语言里头啊，我们曾经讲过很多的运算符。在讲这些运算符的时候啊，有几个运算符我们 没讲到。啊在这儿呢，多讲一个运算符。 那么这个运算符呢，就是这个`&`符号。 用这个符号，我们就可以提取到一个变量的地址。 怎么提取呢，很容易。直接把这个符号放在一个变量名的前面， 你就可以得到与这个变量相对应的那一段地址空间的起始地址了。 比方说我们可以在程序里头这么写，cout<<&c。用这种方式呢，就可以打印出c这个变量，在内存中的起始地址。 那有的同学可能要问了，那么这个地址本身如果要把它存储下来的话，它到底占了多少的存储空间呢？也就是说一个变量的地址要把它存储下来的话，我们需要用多大的存储空间？ 那么要解决这个问题其实一点也不难。因为我们以前曾经讲过这么一个运算符叫做sizeof。所以说我们就可以直接cout<<sizeof(&c)。 然后呢，你就可以看到，在VC2013的环境之下，那么打印出结果是4。 也就是说啊，一个变量的地址，也就是指向这个变量的指针，它占用几个字节啊？占用4个字节。所以说啊，通过这种方式，我们就可以获得一个变量的地址，并且呢，我们还知道这个变量的地址的长度 是4个字节。那有的同学可能接着问了， 有这个地址能干什么用呢？那我定义完这个变量 我用得好好地，你给我一个地址，这个地址有什么用啊？ 其实啊，这个问题很好回答。任何时候，你拿到一个叫地址的东西，你的目标都是要去访问，由这个地址所标定的资源。啊，那么在这儿也一样。我们可以通过资源的地址去访问这个资源。比方说我们刚才举的这个例子，只要给了这个图片的地址，我就可以利用这个地址去访问这个图片资源了。那么对于程序而言呢，也一样啊。 如果我们拿到了一个变量的地址，我们就可以去利用这个 地址，去访问这个变量的值。那怎么才能用一个地址， 去访问一个变量的值呢？难道我把这个地址直接写出来就行吗？ 直接写出来还不行。还要用另外一个运算符号。指针运算符，指针运算符。 当我们拿到一个地址的时候，那么我们用这个指针 运算符，就可以去访问这个地址里的 那个资源。比方说，对于这个变量c。我们又可以用*， 加上这个地址，去访问这个资源。比方说， 我如果想用这个地址把c的值，这个76，给打印出来，怎么办呢？ 很好办。直接cout<<*,后面放上c变量的地址，就可以。 啊那同学说，哎呀，那这太费劲了，我本来只要直接 cout<<c 就可以了。我不需要写那么多。 你说的一点错都没有。其实呢*&c和c它的意义是等价的。 
## 2.什么叫指针变量
- Ok，那说完了什么叫指针， 接下来呀，我们再来说一下指针变量。 什么叫指针变量呢？ 首先我们一定要严格区分这两个概念。 **也就是说指针和指针变量是两个完全不同的概念**。 
  - 那什么叫指针变量呢？很好理解。 你比方说对于刚才我们举过的这个例子，那么这个呢，就是这个星云图片的地址。如果我们写程序的话我们可以找一个变量， 啊，用这个变量来存放星云图片的地址。那么同样的道理， 当我们定义了一个变量c并且在内存里边对它进行了初始化， 那么我们就知道，这个c 呢，会有一片起始的地址。 那么这个地址呢，也就是指向变量c的指针。那么既然我们可以定义一个变量来存放这个星云图片的地址， 那么当然，我也可以定义一个变量 来存放变量c的这个地址。 啊，这是毫无疑问的。于是呢，**我们就把专门用于存放指针的那个变量，叫作指针变量。也就是说， 专门用于存放地址的那个变量，就叫指针变量**。 啊，比方说对于这样一个变量c，那么它有这样一个地址，我们就可以新定义一个其他类型的变量，比方说这个变量叫做pointer。 那么既然pointer是一个变量，那么在内存里头也必然有一片空间与这个 pointer，是属于这个pointer的。那么，在这一片内存里头，放什么值进去呢？就把上面的这个地址，给它放下来。也就是说，pointer就变成了用于存放指向变量c的指针的，也就是这个地址的变量了。那么，这个pointer，我们就把它称作指针变量。那么当然，既然它是一个指针变量，那么它也必定有一个地址。 对不对？啊，因为变量名，地址和变量的值是变量的三要素嘛。 那么当一个指针变量, 这个指针变量的值是另外一个变量的地址的时候，我们就把这个pointer称为指向变量c的指针变量。啊，首先pointer是一个指针变量，这个刚才我们已经说过了，因为它是用来存放地址的。 同时呢，由于pointer中所存放的这个地址，是变量c的地址， 那么我们就把pointer 称为指向变量c的指针变量，一定要搞清楚这个概念。 什么叫指针，什么叫指针变量，什么叫做指向变量c的指针变量。 啊，一定要搞清楚这些概念。其实非常地简单，但是一定要搞清楚。 那么有的同学可能就问了，我应该怎么去定义这个pointer呢？那么接下来啊，我们就来看一下， 如何去定义一个指针变量。比方说对于现在的这个pointer， 我们怎么去定以它呢？这么去定义它。        `int ＊pointer`， 啊，这样的话我就完成了对pointer这个变量的定义。这个是什么意思呢？我们来解读一下。 毫无疑问，pointer是变量的名字。那么根据变量 的定义方式，啊，那么变量名字前面是写的是什么？ 变量的类型。那么在这儿呢？也一样。 这个＊就代表着变量的类型。 这个＊就是刚才我们讲过了，指针运算符。 它在这儿呢，雕饰了pointer这个变量的类型。 那么，前面为什么还加了一个int呢？这个int， 用来指明这个指针变量的基类型。 什么叫做基类型呢？ 基类型啊，其实指的就是这个指针变量pointer 所指向的那个变量的类型。 就比方说在刚才我们所举的这个例子里头，有一个变量c它的地址是这个。 我们定义了一个指针变量pointer来存放这个地址。也就是说，pointer中，所存放的这个地址，是变量c的地址。**那么这个int指的是谁的类型呢？ 就是这个变量c的类型。 在这种情况下我们把这个int称作指针变量的基类型**。 有的同学说，哎呀，干嘛要去指定这个基类型呢？ 你看，所有的指针变量中，存放的都是啊，地址。 而且呢，所有的地址的位数都是四位的。那我为什么要去指定这个变量的基类型呢？ 这是非常有用的。我知道很多同学有可能会产生类似的问题，但是呢，请你不要着急，待会儿，我们会解释这个问题。那么在这儿呢，我们先接着往下看。 那当我定义好了一个指针变量的时候我应该怎么去给一个指针变量赋值呢？ 好，我们来看一下。比方说还是对于这个例子，
    ```C++
    void main()
    {
        int c = 76;
        int *pointer;
        pointer = &c;
    }
    ```  
    啊，有一个变量c。 我定义了一个指针变量pointer，用这个pointer来指向c。 我应该怎么进去赋值呢？很简单。 把c的地址，我们刚刚讲过这个操作符号，&的符号，作用就是提取c的地址。把这个地址直接赋给pointer，啊，就结束了。通过这种方式，那么完成这个赋值以后我们就称指针变量pointer指向了变量c。 其实就是，完全都是一些概念。但是如果搞不清楚， 特别是加上有些书上写的呀，也不是特别清楚的时候， 就容易发生混乱。通过它的描述，你往往不知道它指的到底是那个指针变量，还是那个指针。 啊，在很多书上会出现这种情况。所以说呢，我们在这儿，特别跟大家敲定一下。 那么在这儿我想多问一句，在这啊，我赋值的时候我赋的是&c，我给了pointer。 那我能不能直接写成pointer等于c？可以不可以啊？ 当然不可以。 绝对不行。因为pointer是一个指针变量，它是用来存放地址的。 所以说不能这样写。 Ok，那么说到这儿啊，关于指针变量的定义，我们就已经解释完了。 希望大家严格区分这几个概念，特别是什么是指针，什么是指针变量， 那我就不再去重复了。
    ```C++
    void main()
    {
        int c = 76;
        int *pointer;
        pointer = &c;
    }
    ```      
- Ok，那么有了指针变量以后啊， 有的同学也可能想问了，既然指针变量中存放的是某个变量的地址， 那我是否可以通过指针变量去访问它所指向的那个变量呢？ 比方说，再来看一下这个例子。有一个变量c，它的值是76,地址是它。 有一个指针变量pointer，它的值是它，也就是说pointer指向了c。 现在我的问题是，能不能利用pointer？我们不直接利用&c这种方式。 我能不能利用这个pointer，去访问到指针变量的值？ 也就是说这个76呢？能不能去访问到它的值呢？ 当然是可以的，也是用指针运算符来实现的。比方说 对于这样一个定义，int c 等于76，然后呢，我们把c的地址赋给了pointer。当运行完这样一段程序的时候，内存的状况应该是这样的。也就是说啊，变量c啊，在内存中对应了一片存储单元。那么变量c呢，总有一个起始的地址，pointer存放了这个地址。 那么在这种状况下，我就可以用* pointer来访问这个变量。 什么意思呢？那个* pointer是什么意思呢？ 这个* pointer啊，就是pointer所指向的存储单元的内容。那么对于上面这个例子而言，这个内容指的是什么呢？ 很多书上都写了* pointer指的是pointer所指向的存储单元的内容。 这个内容到底是什么？是这个数字76呢， 还是变量c呢？ 变量c和数字76可是不一样的东西。如果是变量c的话，那么利用* pointer所 提取到的就是一个变量。如果是数值76的话，那么利用* pointer所提取到的就是一个 数字，这两者是不同的。 啊，那么我们在这儿，特别做一个解释。 那这个内容指的是什么呢？是变量c。 也就是说* pointer实际上就可以当作变量c来使用， *pointer就可以当作变量c来使用。 这是什么意思呢？通过一个例子，来看一下。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int iCount = 18;
        int *iPtr = &iCount;
        *iPtr = 58;
        cout << iCount << endl;
        cout << iPtr << endl;
        cout << &iCount << endl;
        cout << *iPtr << endl;
        cout << &iPtr << endl;
        return 0;
    }
    ```  
## 3. 指针变量示例
- 这个程序里头啊，我先定义了一个普通的变量icount是吧。然后呢我定义了一个指针变量 iPtr，它呢指向icount。然后呢我对 iPtr所指向的那片内存单元的那个内容进行重新的赋值。 赋完值以后呢，我再去检查icount的值有没有变化。 iPtr的值有没有变化，同时呢我们还打印了icount的地址* iPtr和iPtr的地址。我们看看 这些内容打印出来之后分别是什么， 然后如何进行解释。我们看这个程序的运行结果。 首先当我们去打印icount的时候啊，我们打印出来的值是58， 因为icount原来的值是18，现在打印出58， 这说明啊，我们用* iPtr这种方式完全可以对iPtr所指向的那个变量也就是icount进行重新赋值。 也就是说，我们完全可以用* iPtr的这种形式去操作原来的icount的这个变量。 这是第一句程序所说明的问题。 第二个我们去打印iPtr，iPtr打印的结果呢是这个，0028FB10. 打印这样一个结果完全在我们的意料之中，因为iPtr是一个指针变量，也就是说iPtr中存放的本身就是一个地址，所以当你打印iPtr的值的时候，打印出来的当然是个地址。那这个地址是个什么地址呢？其实在这一条赋值语句里头我们就说清楚了对不对？它的地址就是icount变量的地址。所以说当你再去打印icount地址的时候你会发现这两个地址是一样的。这符合我们的逻辑。同时呢我们再去打印* iPtr，那这个就更好理解了，因为我们刚刚在这对* iPtr进行了赋值，打印出来当然应该是58. 最后呢，我们再去打印end iPtr，也就是说 我去打印iPtr这个指针变量的地址。 指针变量也是变量啊，它完全具有一个普通变量所具有的所有的东西。所以说对于iPtr这个变量来说也有它的存储地址。这个地址呢跟上面的这个地址是不同的。有别于上面的就是，它会存在自己的存储空间里头，所以说这个程序的结果啊完全在我们的意料之中。ok,那么说到这儿啊,关于指针变量一些基本的东西我们已经接触的差不多了. 
- 下面我们来看两个例子. 第一个例子，
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a = 0,b = 0,temp;
        int *p1 = NULL,*p2 = NULL; //空指针
        cin >> a >> b;
        p1 = &a;
        p2 = &b;
        if(*p1 < *p2){
            temp = *p1;
            *p1 = *p2;
            *p2 = temp;
        }
        cout << "max=" << *p1 << ",min=" << *p2 << endl;
        return 0;
    }
    ```  
  在这个例子里头啊我做了这么一件事情，首先呢我定义了两个变量a和b, 比方说，假如说这个是内存啊，在内存中我定义了两个变量，一个是a，一个是b. 然后呢，我又定义了两个指针变量p1 和p2，在定义指针变量的时候啊 ，**大家注意这个地方， 我对每一个刚刚定义的指针变量都进行了赋初值的动作，赋的初值呢叫做NULL, 全部都大写。这个NULL表示什么东西呢，表示一个空指针。 这是一个特殊字符，它说明这个指针变量的值 是空的。通常我们在定义一个指针变量的时候， 我们都采用这种方式给指针变量赋予初始值。 因为指针变量如果没有初始值的话，那么万一这个指针 变量里边存了一个你不知道的值，然后呢这个不知道的值代表了一个地址， 如果你通过这个地址去操作那个指针变量的话，有可能会比较 危险。所以说当我们去定义一个指针变量的时候，我们都要用这种方式， 要养成这个习惯对指针变量进行赋初值**。 把它的初始值赋成NULL,那赋完初始值之后呢，我又从键盘上读入a和b的值。 比方说我们输入的初始值是3和7， 那么输入完这个初始值之后呢，我把变量a的地址赋给p1，把变量b的地址赋给p2。 那么进行完这个动作之后是不是p1就指向了变量a，p2就指向了变量b啊？ 然后呢，我做了一个判断，如果* p1小于* p2， 请问* p1代表什么？我们刚刚讲过既然p1指向了a， 那么* p1实际上它就代表了a，* p2就等价于 b。如果a小于b，满足这个条件的话，那么我们做什么呢？ 把* p1先给一个temp，然后把* p2给了* p1，然后把temp给了* p2，这是干嘛呀？ 是不是做了一个交换啊？ 请问当我做完这个交换以后，内存里面应该是一个什么样的状况啊？ 是不是因为它检查的本身就是*p1和*p2的值，也就是a和b的值， 所以说如果a小于b，比方说3小于7的话，我就交换的什么呀，我就把* p1的值和* p2的值交换一下。于是在这个程序执行完的时候，这个地方就不是3了，它们变成 7.那么这个地方呢也不是7了，它会变成 3.也就是说* p1仍然指向a，* p2仍然指向b。但是a的值被换成了7，b的值被换成了3. 这个时候呢，我再去打印一下，最大的肯定是在p，* p1里面，最小的肯定在* p2里面。那么打印的结果呢， 应该就是7和3.这是这个程序的执行。 
  
  那么跟这个程序类似，我们再看另外一个程序， 看这个程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a = 0,b = 0;
        int *p1 = NULL,*p2 = NULL; //空指针
        int *temp = NULL;
        cin >> a >> b;
        p1 = &a;
        p2 = &b;
        if(*p1 < *p2){
            temp = p1;
            p1 = p2;
            p2 = temp;
        }
        cout << "max=" << *p1 << ",min=" << *p2 << endl;
        return 0;
    }
    ```   
    在这个程序里头啊，我仍然定义了两个变量a和b，然后呢也仍然定义了两个指针变量p1和p2， 并且呢用now对它们进行了初始化。 然后呢我定义了一个临时的指针变量* temp，临时变量。那么你想，当我定义完这些东西的时候，那么在内存里头应该是这样的。 这个是a，这个是b，那么这个是p1，这个是p2. 然后呢输入a和b，我们照例仍然输入3和7. 然后呢我把a的地址赋给了p1， b的地址呢赋给了p2。那么赋完值之后呢，p1指向了a，p2指向了b。 然后呢这个时候我就做一个判定，如果*p1小于*p2，跟刚才一样，* p1 是谁啊？是a，* p2是b。如果a小于b的话，我就做什么呢这次？ 我就把p1直接给temp， 那这个地方就要注意了，p1和temo都是指针变量， 也就是说，把p1的值先给了temp，然后把p2 的值给了p1，然后把temp的值又给了p2，这是干的什么事情啊？ 是不是把p1和p2的内容 做了一个互换啊？对不对？ 那么当我们把两个指针变量的值做了一个互换的话那就相当于怎样啊？ 相当于让p2指向了 a，p1指向了b。 对不对？原来的这个指向关系呢就消失了。 这个时候呢我再去打印max就等于* p1。 * p1现在是指向是谁啊？p1指向了b，如果你打印这个*  p1的话，你打印的是b的值。所以说这个地方应该会打印出来7，而后面那个地方会打印出来 3.ok，这是一个非常简单的一个应用。通过这两个例子啊，我希望大家能够进一步理解 什么叫指针变量，什么叫指向某个变量的一个指针变量。 这，要理解这些基本的概念。理解了这些基本的概念以后我们再去看其它的东西就容易了。 
- ok，那么说到这儿呢基本上关于指针以及指针变量的基本的信息呢我们就介绍完了。只剩了最后一点点的东西，但这些东西呢也比较重要，我们把它补充一下。首先我们要提到的是，今天啊我们又学了两个操作符。一个是end符号，一个是* ，啊就指针运算符。谈到运算符的话，我们就必谈运算符的优先级。 那么通过这个图啊，你可以清晰地看到，它们的运算符优先级还是挺高的。 它们比算术运算符都要高，那么当然比算术运算符高的话就一定比 关系运算符和逻辑运算符要高很多啦。跟它同级别的，也有一些运算符。比方说逻辑非， 比方说前置的加加减减运算。这些都是跟指针运算符和取地址运算符具有相同的优先级的。 那么当这些具有相同优先级的操作符碰到一起的时候，那么应该按照从右往左的结合顺序，也就是说哪个运算符 距离那个被操作的标识符越近，那么就先执行哪个运算符。待会儿我们举几个例子。 同时我们要说明的是，虽然这两个运算符跟 前置的加加减减具有相同的优先级，那么就意味着 它的优先级低于后置的加加减减。后置的加加减减 具有比较高的优先级。这点是需要特别注意的。下面我们看几个例子。例如比方说我们遇到一个式子，写的是 & * pointer,& * pointer. 那对这个式子怎么去解读呢？很好解读。按照从右往左的结算顺序就相当于先对pointer求* ，然后括起来， 再去求整个这个东西的地址。我们在这儿呢先别着急，先来讨论优先级，然后我们再讨论它的意义。当我们碰到的是这样的一个写法的时候，* &a 其实它就相当于* （ &a），* &a要括起来。那么特别注意的呢，就是后置的加加减减。比方说当我们碰到* pointer加加的时候，这个时候我们要特别注意，是先去求* 啊，还是先去对pointer进行加加呀？ 根据这个优先级关系，我们必须先去计算这个部分，也就是说，我们必须先对pointer进行加加的运算，然后我们再对这个运算的结果进行* 的运算。所以这个式子 完全不等于这样一个式子，至少通过运算符优先级我们就可以看得出来，这两个式子具有完全不同的含义。 
## 4. 指针变量的 ++ --
- 那现在呢我们再来讨论一下，有些同学说对比这两个式子啊* pointer++我还能理解它的意思 因为我知道如果pointer指向的是一个变量的话那么* pointer就相当于那个变量。那么* pointer++呢就相当于对这个变量做++的运算。那这个我还能理解，但是后面我就不能理解啦。* pointer++那就意味着对pointer先进行++的运算。pointer里面存放的是一个地址。 那我对这个地址进行++的运算会是一个什么样的结果呢？ 好下面我们就专门来讨论一下pointer++的 专门来讨论一下这个pointer++到底是什么样的含义。 
- 我们来分析一下这个问题。假设说啊我在程序里头定义了一个int类型的变量。比方说int a等于0，那定义了这样的一个变量。 那么当我完成这个定义的时候a呢这个变量 a呢就在内存里面占用了一片存储区域。 通过我们以前的学习我们知道这个存储区域的大小是4个字节对不对？ 4个字节，而且呢这4个字节肯定是有一个开始的地址的，起始地址的一定是这样的。然后呢我又定义了一个指针变量 int * p2 那就等于NULL。 定义完这个指针变量以后呢我就把 变量a的地址赋给这个指针变量。那么当我执行完这3句程序的话内存里面的状况应该是这样的。指针变量p2中所存放的地址应该就是变量a的起始地址。那么这个时候我们也称 p2指向了a，就是刚才我们讲过的。 那么现在呢我需要做的是我对p2啊这个变量啊执行一个++的操作。好我执行一下p2++。那么执行完p2++之后现在请问p2里面的这个地址的值应该是多少呢？iii例如他们说这很显而易见啊，因为p2里边所存放的值就是这样的一个值。如果我对这样的一个值进行加1运算的话那得到的结果肯定是啊0x0012FF77啊应该是这个值啊对不对？也就是说按我们以前的理解p2进行++之后 p2应该指向哪个地方啊？p2是不是应该指向这个地方啊？对不对？这是按照我们以前的理解，那我们得的结果会是这样的。那真实的结果会是这样吗？不是的。真实的结果是当你对p2执行了++操作以后p2指向哪里了呢？ p2指向了这里。注意，注意，它指向了这里。有些同学说p2为什么会指向这里呢？其实很简单。p2啊虽然的确是一个指针变量这没有错。它里面存放的是一个地址。但是请你不要忘记你在定义p2的时候你还指定了一个类型也就是p2的基类型，指针变量的基类型。也就是这个指针变量所指向的那片区域的类型。既然这个指针变量比方说这个p2它所指向的这一片区域是一个整型的变量是一个不可分割的，这片区域是一个不可分割的内容。 所以说当你对p2进行++操作的时候那么系统 只能把你的这个操作理解成为跨过一整个这样的区域。也就是说啊当你执行++运算的时候p2的值会在这个值的基础上增加多少啊？ 增加4个字节。16进制增加到10也就是a。所以说p2才会指向这一片存储单元。这就是pointer++的含义。非常非常的重要。那么通过这个解释你也就意识到了我们在定义一个指针变量的时候为什么要去定义它的基类型，也就是说它能够体现出基类型的作用。 
- 那说到这儿有些同学可能还是觉得有点怀疑。没关系，接下来呢我们再通过一个程序来展示一下。看这个程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int n = 0;
        int *p = &n;
        cout << p << endl;
        p++;
        cout << p << endl;
        return 0;
    }
    ```  
  这程序非常的简单，定义了一个普通变量n初始值为0，然后呢把n的地址赋给了一个新的指针变量p。n的地址给了p，也就是p指向了n。这样呢我首先打印一下p的值。p是一个指针变量，打印p的值的话会打印一个地址。然后接下来呢我对p进行++的操作，p++。做完++操作之后呢再打印p的值。好我们看看它能打印多少。在看这个程序执行结果之前啊我们先来推理一下根据刚才我们所讲过的因为p所指向的变量的类型 是一个int类型，所以说当对p进行++运算的时候应该跨过啊4个字节对不对？也就是说第二次打印p-p的值的时候 应该比第一次打印多了4，好我们看看程序的执行结果是不是这样的。这个程序的执行结果是这样的。第一次打印00CEFED 8，那么如果在这个计算加4的话应该是加多少啊? 12对不对？12换成iii16进制的话刚好是C。 也就是说这个结果是完全符合的。ok那么说到这儿 关于pointer++的含义 我相信大家就能够清楚了。
- 所以说啊根据我们讲过的这一些呢我们可以得到一些这样的推论。 
  - 那比方说如果假设iPtr是一个指针变量，并且呢它当前存放的地址是0x00000100 那这样一个地址。那么我们就可以得到这样一个结论。实际上如果iPtr所指向的是一个整型元素的话，因为整型元素占4个字节，所以说 iPtr++其实就等价于iPtr加上1乘以4，它的结果就是最后104。 
  - 那如果它指向的是一个实型变量的话一样，因为实型变量也占了4个字节 ,所以说它的执行结果也是104。
  - 那如果iPtr指向的是一个字符元素，我们都知道字符元素占一个字节，所以说如果这个时候你对它进行++的话你得到的地址应该是啊 101。 
- ok，那么说到这儿啊，那么关于指针变量一个基础的信息 我们就全部介绍给大家了。稍微做一个总结。那么刚才我们讲过什么了呢？ 其实啊刚才我们就讲了这么几个概念。
  - 第一个，什么是指针。 
  - 第二个，什么是指针变量。还是那句话，千万要去分清楚这两个 概念。指针和指针变量是不同的。指针是地址，指针变量就是一个普通的变量。它里面存放的是一个地址。然后呢关于指针变量我们特别讨论了* pointer的含义。 其实*pointer指的是这个指针变量所指向的那片内存空间里面的那个内容。比方说如果这个pointer指向变量a的话，那么那个内容是谁啊?那个内容指的就是变量a。那么在这个基础上呢我们又讨论了pointer++的含义，也就是对一个指针变量++进行运算的话它会怎样？其实呢++运算的含义体现出了基类型的作用，就是刚刚我们所讲过的一些内容。特别需要跟大家反复的去强调的。 
## 5. 数组与指针
- 好，那么讨论完这些基本的概念之后啊，我们就可以学学怎么来用指针了。其实指针在使用的过程中啊，一个很大的用途,是跟另外一个东西一起使用。 这个东西就是数组。啊，所以说接下来我们讨论一下， 指针与数组。看看当我们利用指针来操作数组的话， 啊，应该怎么样去处理。
- 首先我们来看一个最简单的，当我们用一个指针指向数组中的某个元素的时候，会是怎样的一种情况。我们来看这个程序，
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a[5] = {1,2,3,4,5};
        int *p = &a[3];           //指针初始化
        cout << *p << endl;
        *p = 100;
        cout << a[3] << endl;
        return 0;
    }
    ```  
  在这个程序里头啊， 我定义了一个数组，a[5]。然后呢，我对它进行了初始化。 赋值为1,2,3,4,5。 然后呢我定义了一个普通的指针，* p 。给这个指针赋值的时候呢， 注意我给它赋值，赋了这个结果。赋的是 a[3] 这个数组元素的 地址， &a[3]， 表示的就是，a[3] 这个数组元素的地址。 那么赋完这个值之后我们可以说什么？我们是不是可以说，指针 p 指向了 a[3] ，啊，可以这样说了。 然后呢我接下来我打印 * p 的值。 那么如果是指向的是一个普通变量的话，*p 的值应该是什么？ 应该就是相当于打印的那个普通变量。对不对？啊， 然后呢，我对 *p 的值进行重新的赋值，赋值为 100。 然后呢，做完这个赋值以后呢，我再去打印 a[3] 的值。 在我们去看这个程序的运行结果之前啊，我就想先告诉大家， 其实，当我们利用一个指针变量去指向一个数组元素的时候， 这个时候啊，指向一个数组元素跟指向一个普通的变量没有任何区别。也就是说，既然它指向 a[3] ， 跟指向普通变量都没有区别，那么当我打印 *p 的时候，其实是不是就相当于我去打印 a[3] 吗？在这个地方。那么当我利用 *p 进行重新赋值的时候，是不是这个地方就相当于对 a[3] 进行重新赋值啊？ 那如果我去打印 a[3] 的话，当然就会打印出来这个 * 的值100。 对吧？这是我们对这个程序的一个推理。我们看了它的运行结果，是不是这样。 看这个结果。当 p 指向 a[3] 的时候，我直接去打印 a[3] 的值。a[3] 的值是 4, 所以说就打印 4 。那么当我对 *p 进行重新赋值，把它赋值为100以后， 再去打印 a[3] 的值，变成了新的值，100。 所以说啊，**当我们把一个指针变量指向数组元素的时候， 啊，其实跟指向普通的变量，是没有任何区别的**。 ok, 这是我们得到的第一个结论。 

- 那下面呢，我们再来看一个例子。 看这个例子。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a[5] = {10,11,12,13,14};
        cout << a << endl;
        cout << *a << endl;
        cout << &a[0] << endl;
        cout << a[0] << endl;
        return 0;
    }
    ```  
  在这个例子里头啊，我也定义了一个数组， a[5] 。赋初值呢，10，11，12，13，14。 然后，接下来为了搞清楚这个数组名字，也就是这个 a 到底是什么含义，我做了这么几个输出。第一个，我打印输出 a。 啊，我们已经知道了，刚才的程序里头已经打印了，肯定会输出 一个地址。然后呢，我打印输出 *a。 *a 。根据指针运算符的含义， 那么打印 *a 的话，将打印出 a 这个地址所指向的哪片内存单元中的那个内容，结果它打印出来。 这个内容是什么呢？我不知道。那么待会儿打印完了我就知道了。 然后呢，我再去打印一下 a[0] ， a[0] 也就是数组的第一个元素。 它的地址，我把它打印一下，看看是什么。然后呢，我最后再打印一下 a[0] ， 啊这里一般，毫无疑问我们知道结果的，是打印 a[0] ， 啊，我们毫无疑问打印 a[0] 的话，这个地方一定会输出 10 。对不对？ 那么在第一个呢，刚才我们就看过这个地方会输出一个地址。 这是我们已经知道的。那么中间这两个数，我们所不知道的。我们来看一下， 运行的结果。首先打印 a 的时候啊，打印出来这个地址。 0017F754 。我不知道这个地址是什么，但是我确信 a 是一个地址。然后呢，我打印 *a。 *a ， 打印出来的是什么呢？ 是 10 。这个 10 是什么呢？10 在这儿。 是数组中第一个元素，也就是 a[0] 它的值。 也就是说啊，在这个地方，你用 cout打印输出 *a。 其实就相当于你打印输出了 a[0]。 是这个意思。然后接下来我们再去打印 a[0] 的地址。 a[0] 的数组元素 a[0] 的地址。结果，我们来看这个结果。 结果是这样的一个值。这个值跟上面的这个值一模一样。也就是说， 当我们打印数组中第一个元素的地址的时候， 跟我们使用数组名直接打印出来的这个地址是一模一样的。 而且，当我们使用 * 指针运算符去打印 数组的名字，也就是这个地址所指向那片内存空间的那个 内容的时候，跟我们使用 a[0] 打印出来的结果是一模一样的。 那么通过这个例子，我们可以看得出来， 我们能够啊，得到这样的一个结论。关于数组的地址的这么一个结论。 什么结论呢？
    - 第一个，**数组名啊，代表数组首元素的地址**。 从而呢，我们就可以得到一个这样的结论： **数组名相当于指向数组第一个元素的指针**。原来当我们拿到一个数组的名字的时候，就相当于拿到了 指向数组第一个元素的指针。那么在这儿呢，我多解释一句。之所以要， 举个例子，比方说对于数组 a[10] ，数组名呢， a 其实就相当于它的第一个元素，也就是 a[0] ，它的指针。 也就是说，如果拿到 a 的话，就相当于我们拿到了& 的 a[0] 的值。 这就是数组名的含义。当然，在这儿我们还是要强调一点。 **数组名啊，不是变量。所以说我们在任何时候都不能给 a 去赋值**。ok, 那么在这儿呢， 我稍微多说明一句，之所以把原来的 ppt 里面， '是'指向数组第一个元素的指针，改成了'相当于'指向数组元素的指针。 我希望啊，这个修改能让它更准确一点。 当然，原来之所以使用'是'这个词，是为了简单，啊，我实在不想引入太多的概念。因为我们是一个入门的课程。我实在不想引入太多的概念，给大家增加一些麻烦。 比方说，如果我用相当于的话，那有的同学可能就要问了，为什么叫相当于？ 好吧，在这儿呢，我考虑再三，在这儿呢，我还是增加这样的 一个解释。其实啊，在 C语言的规范中， 那么在这儿呢，我从 C语言的规范的 2011 版中， 截起了一些片段，把它放在这儿。这个规范呢，我们以前跟大家提到过， 大家呢，都可以直接从 ISO 的网站上去查询到这个规范。到 internet 上去搜，啊。 都可以搜得到。因为有些人会把它放到 internet 的上面，啊献让出来。 那么，在这个规范的第6.2.5 节，Types 这一节中， 对数组的类型也就是 array type ，有这样一段描述。啊，我们看这里。 **An array type is said to be derived from its element type. If its element type is T, the array type is sometimes called array of T**. 啊，有这样的一段描述。 是什么意思呢？是说啊，一个数组的类型是由它元素的类型延伸出来的。啊，那么如果 比方说我们定义一个数组，啊，比方说， int a[10] ，定义这样一个数组， 啊，它每一个元素的类型呢，是 int 型。那这个数组的类型应该是什么类型呢？ 应该是 array of T, 啊应该是这样的一个类型。啊因为在这个规范里面说， If its element type is T, the array type is sometimes called array of T. Sometimes ，啊，看到这个词的时候，是不是大家对这个规范有点失望啊。哈。 一个规范怎么可以定义得这么不严谨。啊， sometimes, 用这样的词。 那么在这儿呢，需要说明一下，其实， 这个规范这个东西啊，本身就是很多人坐在一起商讨的一个结果， 也就是很多人在做妥协的一个结果。 在这样一个场景中，势必会产生一些模棱两可的东西出来。 啊，比方说在这儿，用了一个 sometimes 的词，实在无奈之极。所以说， 在这个规范里面说一个数组的类型是什么类型呢？ sometimes array of T， 它是这样一个类型。那我们为什么又说数组名相当于， 指向数组首元素的指针呢？ 看这里，在这个规范的第6.3.2.1节里面，关于 Lvaules, arrays, and function designators 这样一段描述里头啊，有这样一段描述， 说 except when it is the operand of the size of operator. the Align of operator, or the unary & operator, or is a string literal used to initialize an array. An expression that has type "array of type' is converted to an expression with type"pointer to type" ， that points to the initial element of the array object and is not an Lvalue. 也就是说，如果一个表达式， 它不是size of 或Align of 或者是& 这些操作符的操作术， 也就是说它不出现在这些操作符的右边， 而且呢，它也不是string literal, 如果不是这些情况的话，那么一个数组类型 array of type， 一个数组类型的expression表达式， is converted to an expression with type"pointer to type"， 就会被转变成， 指向这种类型的指针的这么一种类型。那么，这个指针指向哪里呢？ that points to the initial element of the array object and is not an Lvalue. 什么意思啊？指向数组的第一个起始元素的指针 那这句话说的很长啦，**也就是说如果一个数组名不是被用在size of 或者& 后面的话， 那么这个数组名将会被转换成指针类型**。那指针类型指向哪里呢？ 指向数组的第一个元素，ok. 通过这两段话我们就可以知道， 如果从严格意义上说的话，在C语言的规范里头数组的类型是什么类型啊？ sometimes called array of T. 有时被称作T的数组的类型。那么这种类型的表达式如果 不出现在size of, Align of, or & operator, 这些操作符的后面的话， 它会被转换成指针类型，这个指针类型是指向哪里的呢？ that points to the initial element of the array object 指向数组的第一个元素。 那么这就是C语言的规范中关于数组名的一个彻底的解释。 那有的同学会说，那老师你为什么说相当于呢？ ok，很简单，看这里在C语言的6.5.2.1节，关于， 关于Array subscripting 这一节描述里头有这样一段话， because of conversion rules that apply to the binary +operator, 这个我们不用管，在这种情况下， if E1 is an array object ,比方说有一个数组叫E1【E2】， 那么在这描述的E1就是这个a，E2呢就是这个10， 两个表达式。那么在这个时候呢， 它关于这个E1有一个注释，它说： equivalently,a pointer to the initial element of an array object, 其实这样的描述在C语言中啊，比较多， 这段描述是这样的，在一个句子的描述里，它提到了E1，E1也就是一个数组的名， 在提到数组名的时候，它直接加了一个注释，在这个注释里面，它怎么去解释数组名呢？ 他说equivalently a pointer to the initial element of an array object. 什么意思啊？如果翻译过来这句话就可以翻译成等价的，或者是相当于， a pointer to the initial element of an array object.相当于指向数组首元素的指针。 
- 所以说我们在这里沿用了C语言规范里的这样一个说法， 数组名相当于指向数组第一个元素的指针。 那这个呢，就关于整个这句话的一个解释。 那么虽然只有短短的几个字，但是确实背后包含了太多的这种信息。 虽然课前发挥以后也没有同学，也没有其他的人跟我反应 过这个问题，但是思之再三，我觉得 还是呢希望把它写的更准确一些。所以说在这呢我就用了相当于 这个词。ok，这是关于数组名问题的解释。 我希望大家能够很好的去理解这句话，因为这句话， 非常非常的有用，它不单是在我们现在是有用的， 等到我们讲到多维数组的时候，它照样是非常非常有作用的。 ok，这个部分我们就先讲到这。接下来那我们看， 如何利用指针来引用数组中的元素。 
## 6. 用指针访问数组
- ok, 既然有了这样一个结论，我们就可以 写出来很多挺有意思的程序了。 比方说，我们以前对数组的控制都是用数组名加下标的这种方式来进行的，其实啊 你还可以有其他的方式，比方说看这个程序， 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a[5] = {10,11,12,13,14};
        int *p = NULL;    //指针初始化
        cout << a << endl;
        p = a;
        cout << p << endl;
        cout << *p << endl;
        cout << *p++ << endl;
        cout << *p++ << endl;
        return 0;
    }
    ```  
  在这个程序里头我定义了一个数组a 5，仍然付出式值10,11,12,13,14； 定义了一个指针变量p，付出数值NULL， 先打印a，毫无疑问我会打印出来数组的地址， 然后把a付给p，再去打印p，这也毫无疑问， 还会打印数值地址。然后接下来呢我打印* p， 先不去看结果，我们就能够推论出来 * p 应该打印谁呀， 因为a，a， 数组名是指向数组的第一个元素的指针，所以当你把这个数组， 把a付给p以后，p也指向了数组的第一个元素， 所以，当你打印 * p 的时候，实际上就相当于 你去打印数组的第一个元素，也就是在这个地方，实际上你要打印谁呀， a0， 对不对？ ok，然后呢，打印完这个a 0 以后， 接下来去打印 * p++， 那么看到这个 * p++，我们首先要考虑的一个问题是什么啊？ 运算符优先级，两个运算符在这里，我们应该先听谁的呀， 谁的优先级高啊，是不是++运算的优先级高啊？ 所以说，对于这个表达式而言，我们一定要先听从++运算的， 先听＋＋运算的指挥，然后呢再去进行新运算。 那么如果上面打印是 a 0 的话， 那么应该打印出什么来呢？在这个地方？它是会打印 a 0 呢， 还是会打印出 a 1 呢？ 应该会打印a o。 那有的人会说为什么呀？你不是先要进行＋＋，然后在取这个 * 嘛 所以说当然应该打印a 1 咯，no， 你忘记了，加加运算的含义是说先使用前面的变量， 然后再进行加加。 虽然它具有比较高的等级，它是我们的大领导， 大领导发话了，你先去做，做完了之后你在加加， 听从了这一个命令以后，我们在去做这个 * 的运算， 做完 * 的运算之后再来加加，所以说这个地方会打印出a 0 的值，同时呢，p指向了谁呀？ 指向了a 1， 那么在底下在进行一次新p++运算，那么会打印出什么来？ 先打印出a1 的值，然后在对p进行加加运算，所以打印完了之后， p应该指向a 2，p应该指向a 2。ok，我们来看这个程序的运行结果。 首先呢打印出数组的地址，也就是数组的起始地址，也就是数组的首元素的地址。 然后呢把它付给p又打印一遍，这两个肯定是一样的，毫无疑问。 然后呢，我就打印 * p， 因为数组名是指向数组第一个元素的地址，所以打印 * p的时候，应该 打印数组第一个元素的值，也就是10，先把它打印出来， 后然呢打印 * p ++, 因为++运算的含义是说先去使用这个P，然后再进行++，所以说会先打印出10， 在打印完这个10以后呢，指针会从这里移到这里， 然后呢再去打印* p ++，这个时候呢， 先去打印* p 的值，也就是a1的值，先打印11， 然后在去加加，加加运算之后，指针指向这里， 这就是整个程序的运行结果，当打印完最后一个11以后， 指针指向了数组的第三个元素。

- ok， 通过这个程序我们就可以看得出来，当我们遇到一个数组的时候， 除了我们可以用原来的这种用数组名和下标结合起来去访问数组元素的这种方式以外， 我们还可以利用指针变量去访问一个数组， 于是我们可以得出这样的结论来。 如果你定义了一个数组 int a[10]，然后呢你又定义了一个指针变量， 当然这个指针变量是int型元素的， 其实通过这个，通过指针的基类型，我们也可以看的出来，这个指针其实只能指向数组的一个元素， 如果有这样的定义的话，我就可以进行这样的赋值，Pointer=a， 这一句赋值其实就等价于 pointer=& a（0） 这是我们讲过的。 那么当赋完这样的值之后，那么数组的访问啊， 就可以不再去使用a i 的这种方式了，当然你仍然可以用， 不过你又多了一种方式，你用 pointer + i 的这种方式， 比方说 pointer + i 其实就等价于 a+ i， 因为a是首元素的地址，对不对? 那这个地址跟 i 进行相加，其实就等于第i 个元素的地址，所以说p+ i， 就等价于第i 个元素的地址。 我们前面刚刚讲过， 对于一个指针变量进行加加的操作，它的含义是说， 跨过这个指针变量所指向的那片区域， 所以说如果是加 i 的话，刚好相当于是第i 个元素的地址， 那么在这个基础上，我们就可以看的出来，如果我们去写 * pointer + i 的话， 是不是这个东西就完全等价于 * a+i， 于是它也完全等价于 a （i） 这是我们想要的一个结论。也就是说如果我们使用一个指针变量来访问一个数组的话， 原来的 a i 都可以写成 * pointer + i， 这种方式。其实除了这种方式之外啊， 你甚至可以直接对pointer使用下标运算符， 写出这样一个东西来 pointer （i），其实这个也是允许的。 写这个东西，就相当于上面我们刚刚讲过的 * （pointer +i）， 所以当我们定义完这样一个东西之后，其实它， 它和它，这三者的含义是等价的， 你可以使用它们中的任何一个来获取数组中第i 个元素的值。 比方说啊， 原来的一个对数组访问的程序，我们就可以完全用指针来重写一下。比放说对这一个程序，
    ```C++
    //数组下标操作
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[10],i;
        for(i = 0;i < 10;i++){
            cin >> a[i];
        }
        for(i = 9;i >= 0;i--){
            cout << setw(4) << a[i];
        }
        return 0;
    }
    //数组指针操作
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[10],i,*p = a;
        for(i = 0;i < 10;i++){
            cin >> *p++;
        }
        for(p--;p >= a;){
            cout << setw(4) << *p--;
        }
        return 0;
    }    
    ```  
  这两个程序完成了相同的功能，在左边的这个程序里头，我们仍然用原来的方法定义了一个数组，然后呢，用一个for循环，通过cin，a（i）的这种方式对每个元素进行赋值， 同时呢，我们用cout， a（i）的这种方式把每个元素都打印出来，那么如果你使用了指针的话，你就可以直接写成这样子了啦， 定义完数组之后呢，定义一个指针变量，并且呢把a付给它，那么通过这样一个程序呢，指针就指向了数组的第一个元素，然后呢我就可以使用这样的一个程序 cin 点 * p++，通过这种方式， 对数组中的元素进行逐一的赋值。 然后呢，我还可以用一个办法，就是说用一个for循环，通过* p--这种方式去逆序的去打印这个数组， 所以原始的这个程序就完全的被转化成了这样一个程序。 当然这个程序只是一个展示，那么未来呀，我们会在其他的程序里头给大家展示这样做有什么好处。 
- **不过啊，在这我们需要强调一点， 要使用这种方式来对数组进行操作，有一点必须一定要注意，什么意思呢， 当我们啊使用一个指针来指向数组的第一个元素的时候， 无论把数组名和第一个元素的地址付给它都可以， 我们特别需要注意，a++ 是没有任何意义的，为什么呢？ 因为a不是一个变量，它是一个常量。这是我们已经知道的，但是p++就有意义， 因为p是一个普通的指针变量，所以说我们可以对p进行++,--的操作，这是没有问题的，同时呢，因为p是一个指针，所以说p其实没有，p其实可以指向任意的一个存储区域，包括它可以指向数组最后一个元素以后的元素。其实以前的也可以，就是说p完全可以指向一个数组元素以外的一片区域，它是有这个能力的，这个p是有这个能力的。所以说当我们使用指针来操作数组的时候，一定一定要注意， 指针加减操作时一定要注意有效的范围。也就是说这个指针实际上是非常灵活的一个东西，它完全可能跑出数组的那个范围。如果你超出了数组在内存中的存储区域，那么对p的任何操作，其实就是没有意义的。而且是危险的。所以说，你一定要注意有效的范围。其实呢，从这个意义上，这也是指针的一个缺点，它的安全性不太好。这是指针的一个缺点**。
- 比方说对于这样一个程序，
    ```C++
    int a[5];
    int *iPtr = &a[1];
    iPtr--;             //指向&[0]
    *iPtr = 3;          //OK,a[0]=3
    iPtr--;             //指向&a[-1],dangerous
    *iPtr=6;            //damage
    ```  
  定义一个a5数组，然后呢，我们让一个iPtr指向这样一个数组的第二个元素，可以吗？完全可以。能让iPtr指向数组的第一个元素我们就可以让iPtr直接指向数组的第二个元素。没什么不可以。 然后接下来我们做一个iPtr减减，做iPtr减减以后， iPtr就指向了a0.这个时候如果我们对新iPtr进行一个操作，没有问题，实际上就相当于把a0赋成3了，但是如果接下来继续 进行减减，这个时候就要特别小心因为它就指向了数组第一个元素之前的又一个元素。这个就非常非常的危险，因为谁知道那片空间里面保存的是什么东西啊？而且呢在很多编译环境之下进行这样的一个操作，编译器不会报任何错误出来。这个时候如果我们再对新iPtr做一个赋值的话，那就有可能会对内存造成损害。所以说阿，这是我们特别需要注意的一件事情。好，那说到这儿阿，用指针指向一维数组的相关的知识，我们就已经介绍的差不多了。
- 接下来呢，我们看两个小例子。第一个例子， 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[5] = {1,2,3,4,5};
        int *p = &a[3];
        *p = 100;
        cout << *p++ << endl;
        cout << *p-- << endl;
        cout << *--p << endl;
        return 0;
    }    
    ```  
  那么在这个例子中呢，我首先定义了一个数组 a5，然后呢定义了一个指针p, 让它呢指向数组中的元素a3，然后呢我对新p进行重新赋值，赋值成100。赋完值以后呢，我来打印几个数。 比方首先我去打印* p++，那当然在这个地方会打印出100，打印完之后呢， 那指针p呢，执行加加的操作。于是呢，指针p指向了数组的最后一个元素。 然后再去打印* p--，这个时候呢，会首先先把这个5打印出来。 然后呢，执行减减的操作，于是指针又指向了 这个元素，a3这个元素。 那么指向a3这个元素之后呢，再去执行* --p， 因为--p和* 的优先级是相同的，所以说呢这个表达式执行的时候会先去执行减减p，然后再去执行新的运算， 所以说呢，首先指针会移到这个位置。 然后呢，再去执行新的运算，最后打印出3来。 
- 执行的一个结果。我们再看一个例子。 这个例子的作用阿，是利用两个指针对数组中的元素啊，进行一个倒置的操作。 倒置的一个操作。我们来看一下这个程序。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[10],*p = NULL,*q = NULL,temp;
        for(p = q;p < a + 10;p++)
            cin >> *p;
        for(p = a,q = a + 9;p < q;p++,q--){
            temp = *p;
            *p = *q;
            *q = temp;
        }
        for(p = a;p < a + 10;p++){
            cout << setw(3) << *p;
        }        
        return 0;
    }    
    ```
  定义一个数组a时，两个指针p和q，那么初始值呢都是now. 然后利用指针变量p从键盘上读入 10个数，给数组a10赋值。赋完值以后呢， 再用一个循环，但注意这个循环中，p等于a，也就是说p指针指向了数组的头， q呢等于a加9，也就是说，q指向了数组的结尾。 如果p小于q的话， 就是说如果指针q仍然处于指针p的右边， 那么就执行把* p和*q的值进行一个 互换。那么通过这种方式我们就实现了把一个数组的元素 原来从正序调整为逆序。比方说这个程序的执行结果就是这样的。 输入1，2，3，4，5，6，7，8，9，0 那么输出的结果呢0，9，8，7，6，5，4，3，2，1。 是这样的一个结果。OK,那么说到这儿呢，我们基本上 把指向一维数组的指针跟大家介绍了一下。那么大家在写程序的过程中呢，可以锻炼着使用指针来完成一些数组的任务。 OK，那么这次课呢我们就先讲到这， 下次课呢我们将介绍指向多维数组的指针。OK，好，谢谢大家。
## 7. 指向二维数组的指针
- 好，那么在讨论过刚才的这些基本的概念以及 对二维数组中各种表达式的这个理解以后啊，我们就来看几道例题。 虽然是几道例题，但是实际上我们是想通过这几道例题 来告诉大家几个很重要的结论。首先我们来看这样一个例题，一个程序填空题。这个程序的作用呢，是遍历数组元素。 什么叫遍历数组元素啊？就是一个一个的访问。也就是说把数组元素的值一个一个地打出来， 就叫遍历数组元素了。 为了让大家清楚地知道这个程序干了什么，我就直接地把程序的运行结果贴在这儿了。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
        int *p;
        for(p =    &a[0][0]    ;p < &a[0][0] + 12;p++)
            cout << p << " " << *p << endl;       
        return 0;
    }    
    ```
  好，那么我们来看一下这个题里面的空应该怎么去填。 首先我定义一个二维数组a[3][4]，把它的值呢都赋好。 接下来呢我定义一个普通的指针， 接下来啊，用一个for循环来打印这些东西。 在for循环的里面呢，开始我先要对p，对这个指针 进行赋值。 然后呢，我接下来打印的东西是这样的: cout p，这当然会打印一个地址，因为在前面定义了p是一个指针嘛。 然后呢*p，而*p打印出来的东西呢，我 希望它打印的是值，这个二维数组中的值。 那么现在呢，让我们来填这个空。 这个空的地方啊，是对指针p进行赋值。 赋一个什么样的值进去呢？那就要取决于指针p它是一个什么样的含义了。 那我们就来分析一下，既然如果我们打印* p的话会把元素的值打印出来， 那么就意味着p应该是指向数组元素 的指针，它应该是指向数组的元素的。 所以说，在这儿填写的应该是数组元素的地址。 那么数组元素的地址应该怎么去填写啊？ 那最好办的方式就是写一个&a[0][1]。 那么这样的一个赋值呢，就使得p成为一个指向二维数组中每一个小元素的这么一个指针。从而呢满足，如果我们写* p的话，他就可以把二维数组中每一个元素的值给打印出来。 OK!这是这个空。这个空填上了，但是这个事情我并没有讲完。你看，在这个程序中， 通过这个赋值啊，实际上我们是让p指向了数组的第一个元素， 然后接下来呢，我们是一直对p进行++的运算。 直到++到12，也就是说a一共有12个元素嘛， 我就++到12。其实我们中间根本就没有考虑什么第一个小数组，第二个小数组的问题，对不对？但是我们也把这些数组的元素一个一个全都打印出来了。那这是为什么呀？大家还记得我们在讲二维数组的存储方式的时候曾经用过这张图吗？ 当我们把一个二维数组存放到内存里的时候，实际上我们是把这个二维数组给它拉成了直线来存储的，对不对？我们会把二维数组中的各个小元素在内存里面依次排开，排成一条线 这样来存储。数组呢，都会存储在一片连续的地址空间里头，那么二维数组也一样。在这片连续的地址空间里头就把二维数组的各个元素依次排开。所以说当我们使用这个程序不断地通过对指向每一个元素的这么一个指针进行++的运算，它就会不断地去指向下一个元素，下一个元素，下一个元素，下一个元素，直到12个元素全部遍历完。所以说啊，通过这种方式我们可以把二维数组中所有的元素全部都打印出来。这其实是指向二维数组的指针非常常用的一种方法，用指针来访问二维数组中的元素。这是这个例子。
- 同学我们再来看一道题。程序填空，并且呢，判断正误。就是在这个题里头你既需要把这个空填起来，又需要判定这个红色的程序是对还是错。那在这儿呢，我需要特别跟大家强调，这个题啊，非常的重要。 它不只是一道简单的例题，我们呢，需要从这个例题中啊，学习一些东西。 OK，我们来看一下这道题。 这道题完成了什么功能呢？完成一个非常简单的功能，从键盘上输入i,j， 然后呢，让你打印出一个二维数组中 a[i][j]的值。好，我们来看一下这道题。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
        int    (*p)[4]          ,i,j;      //填空：先完成变量p的定义 
        p = a;
        cing >> i >> j;             //i < 3代表行号，j < 4代表列号
        cout << setw(4) << *(*(p + i) + j);  //正误判断：访问元素a[i][j]        right!
        return 0;
    }    
    ```
  首先我定义的是一个二维数组，a[3][4]。 然后呢，在这儿我给p赋值的时候啊，赋的是a。 在这个条件下，我希望你完成对p的定义。 OK，那如何去定义p呢？很显然， 如果我们能够把a赋给p的话，那就意味着 p和a的含义必须是相同的。 于是呢，我们就从这点上先来分析这个空，应该怎么去填。 也就是说这个p，应该如何去定义。我们先来分析一下， 那么要分析这样一个问题呀，我们就可以从p等于a这句程序啊，开始分析。 那么既然我要根据p等于a这句程序写出p的定义， 那我就得分析一下什么是a。a呢相当于指向a[3][4]的“第一个元素”的指针。 然后呢，所谓的这个“第一个元素”是一个 “包含了4个int型元素的一个一维数组”。 这些都是我们讲过的了。所以，a相当于一个“包含4个int型元素的一维数组”的地址。既然我们要把一个这样的地址赋给p，所以我们就可以得出来，如果要去定义一个p的话，p的那个基类型应该是什么呢？还记得什么是基类型吧？比方说对于一个指向int型的变量，指针变量p而言，那么它的基类型就是int型。就是写在指针并列定义最前面的这个类型。那么在这里，既然我们要把一个“包含4个int型元素的一维数组”的这么一个地址给p的话，那p的基类型也只能是“包含4个int型元素的一维数组”。怎么去定义呢？你可以这样来定义。变量的定义语句是这样来写的，括号* p[4]。 通过这种方式，你就定义了一个指针变量p。这个p呢， 它是指向一个具有4个int型元素的这么一个一维数组的。这就是这个p的基本含义。也就是说通过这样一个定义啊，你就得到这样一个p，它是指向一个“包含4个int型元素的一维数组”。 那么说到这儿啊，那个空我们终于可以去完成了。所以呢回来我们先把这个空填上。 因为前面的Int已经写好了，所以说我们只需要在这儿填* p[4]就可以了。注意呢，括号不能够省略。 如果省略的话完全就是另外一个意思了。OK，那么在这儿呢，我们 就完成了变量p的定义。那么接下来呢，我们再来看一下变量的输出。 那么定义完之后呢，我们就可以把a啊赋给p了。把a赋给p之后呢，输入i和， 这是行号和列号。然后呢，我希望打印出来 a[i][j]。想把这个值打印出来。我是怎么写的呢？我是这样来写的。 *(*(p+i)+j) 这个式子正确吗？ 其实关于这个式子的判别啊，那同学们啊，现在完全可以独立地去判别一下。 那么在这儿呢，我们一起来分析一下。*(*(p+i)+j) 到底表示什么含义呢？也就是说它是什么呢？ 我们一步一步地来分析。先来分析p的含义。 刚刚定义过，p是指向一个“包含4个int型元素的一维数组”的。 既然它指向一个“包含4个int型元素的一维数组”，所以 p+i的含义就是第i+1个“包含4个int型元素的一维数组”的地址， 这是我们分析过很多遍的。由此呢我们就可以得到 一个结论，其实p+i就相当于&a[i]。 因为i从0开始嘛，所以说它是第i+1个一维小数组的名字，对不对？ 也就是说a[i]呢，也就是代表着 指向了第i+1个小数组的第一个元素的指针， 对不对？于是&a[i]它的含义就是 指向“包含4个int型元素的一维数组”的 这个地址。也就是它的指针。 这是p+i的含义。那么接下来我们继续分析， 那么p+i的含义有了，那么*(p+i)的含义是什么呢？ 那很明显了，*(p+i)就相当于a[i]。 那么有了这个之后呢，我们再去分析* (p+i)+j 的这个含义。如果再给它加上j的话，其实就像等于a[i]+j。 那有的同学问了，a[i]+j是什么含义啊？含义很明显啊。 因为a[i]是第i+1个小数组的第一个元素的指针， 对不对？所以a[i]+j就是 第i+1个小数组的第j个元素的指针。其实它就相当于 &a[i][j]，是不是这意思啊？ 完全相同。那么有了这个之后我们再去分析 整个的*(*(p+i)+j)的含义，那么整个的* (p+i)+j的含义就是啊， 相当于a[i][j]。其实它的含义就等价于a[i][j]。 那么所以说我们在这儿写，*(*(p+i)+j) 这个是正确的。 其实啊，那么根据C语言的规范 *(*(p+i)+j)又可以直接把它写成p[i][j]。 这也是可以的。 也就是说整个这个程序，如果在这儿写p[i][j]的话， 也完全是成立的。那么从这个例子啊，我们就可以看出指针的很重要的一个用途， 那如果我定义一个这样的指针的话，我直接可以用这个指针来代替数组名来使用了。 所以说指针呢，具有非常强大的功能。那么我们在这儿呢， 只是列述了一些关于指针的一些基本的知识。 那么关于指针的使用呢，还需要大家在实际的程序里头啊， 不断地去磨练。OK，那关于指针 与多维数组的关系我们就先讲这么多。 那么在下一次课中呢，我们会介绍指针与函数的关系。 好，谢谢大家。 希望大家啊，听的明白，学的愉快。 