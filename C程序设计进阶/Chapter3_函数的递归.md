# [函数的递归](https://www.coursera.org/learn/c-chengxu-sheji/home/week/3)
> 本次课是C程序设计部分的一个难点。但，请不要担心，我们将按照“由简单到复杂”的方式进行讲解。我们先为大家讲解“递归调用”的执行过程，以便让大家看到“其实，递归调用与普通函数调用没什么不同”的道理，在此基础上，再去详细分解递归调用的过程，以印证我们学到的知识。 在此基础上，我们将通过几个典型的递归函数设计范例，向大家讲授递归函数的作用和使用技巧。 需要强调的是，如果在这个部分大家感觉到困难，请不要气馁：）因为，根据我们的教学经验，80%以上的同学都会感觉到同样的困难。当你也感觉困难时，可以先耐心听完我们的讲解，然后再通过练习慢慢体会。只要稍加练习，这个困难的感觉就会逐渐消失，因为，到那时，你已经对递归越来越熟悉了：）
## 1. 如何理解递归
- 好，各位同学大家好。 那么，这次课呢，我们来讨论函数的递归。 那么递归呢，是一个非常重要的一个部分。 那么在这一个部分里头啊，我们将讨论这么一些内容。 
  - 首先，我们来看一下什么是递归。 啊，理解一下什么是递归。 
  - 然后接下来呢，我们通过一个例子，来更加深入的理解一下， 递归的过程，看一下这个递归的程序到底是怎么去执行的。 
  - 再接下来呢，我们讨论一下递归的作用。 在作用的这部分呢，我分了三个段落。
    - 第一个呢，是用递归来完成递推。 
    - 第二部分呢，是模拟连续发生的这种动作。 
    - 第三个呢，是利用递归来进行自动的分析。 
- **Ok, 我们先来讨论一下什么是递归**。那么在讨论递归这个概念之前， 我们先来讨论这样的一个概念，一个函数的嵌套调用。 那什么叫做函数的嵌套调用呢? 我们先来看一个例子。 这个例子啊，是以前我们曾经讲过的一个例题。 
    ```C++
    #include <iostream>
    using namespace::std;

    int fact(int n)
    {
      if(n==1)
        return 1;
      else
        return n*fact(n-1);
    }
    int main()
    {
      cout << fact(4) << endl;
      }
    }
    ```
    这个程序的作用呢，啊是用来判定一个数，它到底是不是一个实数。 啊，我们以前讲过这个例子。在这儿呢，我们不需要重复这个例子的内容， 我们只需要看这个程序的形式就可以了。 我们可以看到啊，在这个程序里头，主函数里头啊，又调用了另外一个函数。 在主函数里面，调用了 checkPrime 这样的一个函数。 也就是说，我们如果把它画一个图的话，是这样的，主函数里头调用了 checkPrime。 但是啊，这个调用并没有完。我们再来看一下这个 checkPrime。 其实在这个 checkPrime 这个函数里头啊，它又调用了另外一个函数， 叫 sqrt。 这是一个系统定义的函数。这个函数的作用是求平方根。啊我们已经用过很多次了。 如果把它画到这个图上的话应该是这样的。 哎，大家看这个函数调用的这个图，main 函数调用了 checkPrime 这个函数。 然后 checkPrime 呢，又调用了 sqrt。 啊，一个函数调用了另外一个函数，在这个函数还没有运行结束的时候又调用了另外一个函数。 像这种类型的调用，我们就把它称作嵌套调用。 其实啊，嵌套调用大家并不陌生。因为在以前很多程序里头我们都使用过嵌套调用。 啊，不过呢，我们没有给大家介绍这个概念而已。 那么，我呀，在这儿想多问一句。 那么如果呢，在程序里头我不是想嵌套的调用，而是啊， 想在一个函数里头重新再定义一个函数。 也就是说，我把另外一个函数的程序体直接写到啊某一个函数的内部，这样可以吗? 这个呢，以前我们提到过，所有的函数都是平等的。 **函数，毫无疑问，是可以进行嵌套的调用的。 但是呢，函数不能够进行嵌套的定义。 Ok, 讲到这儿啊，我们就先来整理一下，我们的思路。 我们已经知道啊， 函数，是不能够嵌套定义的。也就是说在一个函数的里头，不能再定义另外一个函数。 啊，这是不允许的。也就是说所有函数一律平等，不允许嵌套定义。 但是呢，函数可以嵌套的去调用**。 啊，也就是说，在主程序里头啊，你可以调用一个函数。在这个函数里头呢，你可以再调用别的函数， 在别的函数里头你可以再调用别的函数。可以调用多少层呢，多少层都可以。 多少层都可以嵌套下去，像刚才我们举的这个例子，它就嵌套了两层。这都是允许的。 Ok， 那我们已经知道，函数是能够嵌套调用的。 
  - **那讲到这儿呢，我就想问大家一个问题。 请问，一个函数能调用它自己吗** ？ 哇，这个问题听上去怪怪的。哈 ！ 别着急，我们先来看一个例子。我举个例子， 来说明一下这个问题是咋回事。 先看这个例子。请你写一个程序，求 n 的阶层是多少。 当然，大家都知道阶层的定义。 n 的阶层其实就等于 n-1 的阶层乘以 n。 n-1 的阶层又可以分解成 n-2 的阶层乘以 n-1。 那么 n-2 的阶层就等以 n-3 的阶层乘以 n-2 等等等等，可以一直算下去。 一直算到 3 的阶层等于 2 的阶层乘以3， 2 的阶层等于 1 的阶层乘以 2。 1 的阶层呢，等于 1 。好，从这个计算方法，我们可以归结出来， 如果有这样的一个函数 fact(n) ，它呢，能够计算出 n 的阶层。 那么这个函数呢，就可以写成 fact(n-1)乘以 n。 那么当然，由于 1 的阶层等于 1, 所以 fact(1) 的阶层呢，等于 1。 由此呢, 我们就可以写出一个这样的程序来，看这个程序。

  ```C++
  #include <iostream>
  #include <cmath>
  using namespace::std;

  bool checkPrime(int);
  int main()
  {
    int a;
    cout << "请输入一个整数" << endl;
    while(cin >> a){
      if(checkPrime(a))
        cout << "是质数" << endl;
      else 
        cout << "不是质数" << endl;
    }
  }
  bool checkPrime(int number)
  {
    int i,k;
    k = sqrt(number);
    for(i=2;i<=k;i++){
      if(number % i == 0)
        return 0;  //只要有一个数被除尽，则不是素数
    }
    return 1;   //走到这一步，说明没能被除尽
  }
  ```
  在这个程序里头，我定义了一个函数， fact(n) 。它就是用来求 n 的阶层的。 那么在主函数里头呢，我就直接调用了这个函数， cout<<fact(4)。 把 4 个阶层打印出来。当然 4 个阶层比较简单，我们来作一个例子啊。 那么，在这个 fact 这个函数里头呢，如果 n 等于 1 的话， 那我就返回 1，啊，因为 1 的阶层就等于 1 嘛。 否则的话，那么 fact(n) 的阶层等于多少呢? 就等于 n 乘以个 fact(n-1)。 好，我们先不管这个程序的意义是怎样的。 我们先来看这个程序的样子。你看在这个程序里头啊，有这么一个现象。 什么现象呢？ fact 是一个函数。 在这个函数的函数体里头，就是在这一块里头， 又调用了一个函数。这个函数是谁呢？ 也是 fact。 也就是说，在 fact 这个函数里头又嵌套的调用了fact。 这就是刚才我所问的那个问题了。 一个函数能调用它自己吗？也就是说，这个程序对吗？ 它能够顺利运行吗？ Ok ，首先告诉大家，这个程序是正确的。 而且呢，这一种方式就被称为 ‘递归调用‘。 
- 当然这是通过一个例子，啊，跟大家展示一下什么是递归。 那如果我们给递归下一个定义的话，应该怎么说呢？ Ok ，在很多的书上， 咱们给递归啊，下的定义是这样的。啊，在这儿呢，我故意用了一个‘他说‘。 啊，就是那个大多数啊，都是这么来说的。 **一个函数在其定义中直接或者间接调用自身的一种方法。 那么如果一个函数在它的定义里头，又调用了它自己，那么这种调用就被称为递归调用**。首先，这个描述呢，是没有错的。 但是，这个描述啊，很容易让我们产生问题。 什么问题呢？我们来看一下这个程序。 请问，在你的想象当中，这个程序，到底是怎么去执行的呢？ 其实啊，在我刚刚开始学习递归的时候， 啊，很多年前了，当我看了这个程序，又读了这个定义以后啊， 我是这样来想象的。 那么既然啊，这个定义是说一个函数在它定义中 直接或者间接的调用它自己， 于是我那个时候想象的是这样的， 当 fact 的函数执行到中间的时候又调用了它自己，那么不就又回去了吗？ 那么回去以后，fact 函数又接着往下执行， 执行到中间的时候又调用了它自己，那么又回去了吗？ 那这个循环不就死循环了吗？那这个程序还能够往下执行吗？ 啊，那个时候我就碰到了一个这样的问题。 在后来的交流中呢，我发现很多其实刚刚开始学习递归的同学啊，也有类似的问题。 所以啊，在这儿啊，我特别想提示大家， 咱们不要这样来想象递归。其实在这个想象过程中，是有错误的。
- 那我们应该怎么去理解递归呢？ 在这儿，我特别给出‘我说’ ， **递归调用啊，其实与普通的函数调用没有区别**。 我们来看一下这个程序的执行过程。 还记得吗？在我们上一次课中，讲到函数的执行的时候， 我特别强调了函数的执行啊，是这样的一个过程。 主函数去调用一个函数的时候啊， 总是在内存里面新开辟一片内存空间。 也就是说，每次调用新的函数， 都会新开辟新的内存空间。 递归调用啊，其实也一样。啊，也是这样的。 好，那我们来分析一下这个例子的执行过程。首先呢，main 函数开始执行。 当 main 函数执行到 fact(4) 的时候，main 函数就开始调用fact 函数。 那参数呢是 4 。然后，在这片内存空间里面执行 fact(4）。 那么在 fact(4) 的执行过程中呢，当执行到这一句的时候， fact(4) 又调用了 fact(3) 。于是在内存里面又新开辟一片内存空间 来执行 fact(3) 。那么在 fact(3) 执行的过程中，当执行到这句的时候， 它又调用了 fact(2) 。于是在内存里面再新开辟一片空间来执行 fact(2)。 fact(2) 执行的过程中又执行到这一句，就会调用 fact(1) ， 于是在内存里面再开辟一片新的内存空间来执行 fact(1)。 在 fact(1) 执行的过程中，还会再调用新的 fact 吗？ 不会了。因为当执行 fact(1) 的时候啊，n=1 我就直接 return 1。 于是，fact(1) 就会返回一个 1 给 fact(2)。 然后 fact(2) 呢，继续往下执行。那么继续往下执行没有其它的代码了。 所以 fact(2) 也返回，返回给 fact(3) 。然后 fact(3) 呢， 再继续往下执行，也返回给 fact(4) 。fact(4) 继续往下执行， 返回给 main 函数。这就是整个这个程序的执行过程。 通过这个执行过程，我们可以看到，**虽然从形式上讲， fact 函数的定义里面，又调用了fact 函数， 啊，也就是好像看上去它调用了它自己， 但实际上，函数的每次调用跟普通的调用都是一样的。 你完全可以把递归调用的过程， 看作一个函数的嵌套调用。 那么当有了这个概念以后，我们再来看递归调用， 我们就很容易理解了。啊，其实它没有什么神秘的。 它跟普通的嵌套调用是一样的。 啊，我们完全可以按照普通嵌套调用的这种理解方式 来理解递归调用**。 Ok ，那么说到这儿呢，我们就解释了一个问题， 什么叫做递归。 
## 2. 递归调用的过程
- 好，这是关于递归的定义。 但是啊，光理解了这个定义，还是不够的。 我希望呢，同学们啊，能够了解更多的，关于递归调用的细节。 所以，接下来啊，我们通过几个例子来深入理解一下递归的过程。 
  - Ok, 我们先来看一个例子。 这个例子程序啊， 非常的简单。一共呢，没有多少行。 这个程序呢，是我为了帮助大家理解递归调用的过程，而特别构造的一个程序。 
  ```C++
  #include <iostream>
  using namespace::std;
  int recur()
  {
      char c;
      c = cin.get();
      if(c != '\n')
        recur();
      cout << c;
      return 0;
  }
  int main()
  {
      recur();
      return 0;
  }
  ```
  在这个程序里头啊，我定义了一个函数，这个 recur。 在 main 函数里头直接调用了 recur。 我们来看一下 recur 的执行过程。首先呢，定义了一个字符变量 c。 然后呢，我们使用 cin.get 来给 c 赋值。 啊，从键盘上读入一个字符给 c 赋值。 啊，上次课，我们刚刚讲过 cin.get 的作用。 cin.get 的功能还是很强大的。 它可以把空格和回车全部都读入进来。啊，不只是不能跳过输入结束标志。 这是上次课我们讲过的。 Ok, 那么用 cin.get 呢读入一个字符。 赋完值以后呢，我做了一个简单的判定。 如果，我所读取到的这个字符不等于换行符， 那么，我就再次调用 recur。 Ok, 那么这个 if 语句呢，就结束了。结束了这个 if 语句以后呢， cout ，我再把这个字符啊，给它打印出来。 整个函数结束， return。 我现在希望你啊， 想象一下这个程序的执行结果。 比方说，当这个程序运行起来以后啊，我在键盘上输入 a b c ， 然后呢， 回车。 请问，这个程序的输出会是什么样子的呢? 好，那有的同学啊，可能说是 a b c ，换行。 有的同学可能说呢， 那有的同学就认为呢， 是 c b a 换行。 那有的同学可能说呢，先输出了一个换行符以后，又输出 c b a。 那哪个答案是正确的呢 ？ Ok ，那我们就来分析一下这个递归程序执行的过程。那么当这个程序开始执行的时候啊，首先 main 函数开始往下执行。 当 main 函数执行到 recur 这一句的时候，它就开始调用 recur 这个函数。 我们把这次调用称作 recur1 。在调用以后呢，recur 就开始往下执行。于是呢，在内存里面开辟一片内存空间， 把 recur 放进去，从头往下执行。那么 recur 会怎么去执行呢？在这片内存空间里面，会定义一个变量，并且呢，用 cin.get 给这个变量赋值。 那么，当我们从键盘上输入的是 a b c 回车的时候， 在这儿我们用 cin.get 读取的应该是哪个字符啊？ 会把 a 读取进来。 啊，在这儿把 a 读取进来。读取进来以后呢， 因为字符 a 不等于反序岗 n ， 于是， 又会再次调用 recur 。它会在内存空间里面 再开辟出一片新的内存空间，把这个 recur 再放进去。 然后，再去执行它。啊，那我们把这次执行呢，称作 recur2。 啊，在这一个执行的过程中，它又会定义一个新的变量 c。 然后呢，又会用 cin.get 再次 从输入缓冲区里头读取一个字符。 于是呢，把 b 读入了进来。读入进来之后，继续往下执行。 于是，又执行到了 recur ，又调用了 recur。 于是，在内存里面再开辟出一片新的内存区域来。 再从头去执行 recur。 这个时候会读取哪个字符啊? 读取 c 这个字符。于是把 c 再读取进来。 读取进来 c 之后因为 c 不等于换行符又执行了 recur。 那就再次调用 recur ，于是在内存里面再产生一片新的内存区域， 再定义出一个字符变量 c ，然后再用 cin.get 从 缓冲区里面再读取一个字符。这个时候会读取谁啊 ？ 因为用的是 cin.get ，所以说，这个字符将读取到换行符。 也就是说，在这一步我们会把换行符读入进来。 读入进来之后呢，程序继续往下执行，这个 recur 还会执行吗? 不会再被执行，这个时候。于是，应该执行哪一句啊? 应该执行这一句， cout<<c。 所以说，在 recur 的第四次调用过程中，当读入了 换行符以后，紧接着把这个换行符又打印了出来。 那么打印完这个换行符以后，是不是程序就执行完了呀 ？ 于是， recur4 执行完毕以后，返回它的调用者 recur3, 返回到 recur3 的调用的地方。 啊也就是说，当 recur4 返回 recur3 的时候，其实是返回到这个地方来。 啊于是呢， recur3 接着往下执行。它应该执行这一句。 因为当 recur4 返回以后，recur3 中的这个 if 语句就已经执行完了。 啊，所以说呢，它会执行到 cout<<c 这一句。 于是呢， recur3 会把自己的这片存储空间中保存下来的这个字符变量的值打印出来。这个时候，这个字符变量的值是多少啊 ？ 应该是字符 c 。于是，在这个地方，recur3 会把 c 打印出来。 也就是说，第一个打印出来的字符是换行符。第二个被打印出来的字符应该是字符 c。 当 recur3 打印完 c 之后，recur3 也就执行完了。 当 recur3 执行完毕之后，它就返回了它的调用者也就是 recur2。 一样的道理，当 recur3 返回的时候， if 语句也就执行完了。 于是 recur2 也去执行 cout<<c。 那么， recur2 会打印出来在它的程序体里面保存的那个字符变量。那里面那个值是多少啊？ 应该是这个 ｂ 。于是呢，ｒｅｃｕｒ２ 继续执行，ｂ 会打印出来。 这是被打印出来的第三个字符。打印出 ｂ 之后呢， recur2 也执行完了。又是返回 recur1 ，recur1 呢继续往下执行。同样的道理， 它会把自己这片内存空间中所保存的这个字符变量的值， 也就是那个 a 给打印出来。 当把字符 a 打印出来之后呢，recur1 也执行完毕了。 于是返回它的调用者， 也就是 main 函数。 返回 main 函数以后，因为在 recur 调用之后没有其他语句了，于是 main 函数也执行完毕。于是，整个程序就执行完毕了。 

- **Ok ，我们来看一下这个程序的执行结果。 当我们输入 a b c 回车以后， 那么程序呢，会先打印出来一个换行符， 然后呢，紧接着打印 c b a。 这跟我们推列的结果是一样的。 那么通过这个例子啊，我想让大家看清楚，递归程序的执行过程。 而且呢，我们要特别注意， 当一个函数 在调用另一个函数以后，在被调用函数返回以后， 那么调用它的这个函数啊，还会继续往下执行。 当我们把一个输出写在函数调用之后的话， 那么这个输出实际上是在每次返回之后执行**。 好，这是关于递归的过程。那么通过这个程序啊，我希望大家能够对 递归调用的过程有一个更加深入的了解。 那么，这样呢，在以后的程序设计里头啊，我们就可以利用 递归的这些特性。 
## 3. 递归应用示例（切饼、斐波那契数列）
- ok，那么在了解了递归调用的过程以后，我们就来看一下递归的作用。在这个部分我们要 介绍三种递归最常用的三个场景。 

  - 先来看第一个，就是**用递归来完成递推**。这什么意思呢？不着急，我们先来看一个例子。 还记得这个例子吗？**切饼。 就说一百刀去切一个饼，问你最多可以切出多少块**？ 这是我们以前在从iii问题到计算机程序那个部分举的第一个例子。 那么当时呢我们对这个例子是这么来解的。因为啊第0刀的时候这个饼是一块的。然后第一刀的时候呢在第0刀的基础上多了一块。 第二刀切下去多了两块。第三刀 切下去又在上一刀的基础上多了三块。 第四刀切下去多四块。也就是说第n刀切下去就会在前一刀的基础上增加n块。这是饼的块数增加的一个规律。 那么按照这个规律呢我们曾经写过一个程序，在这个程序里头我们用了 一个循环来计算那么切到n刀的时候我们能得到多少块。这是当时我们所写的程序。那么现在呢我想让你考虑一下。 我们可不可能利用递归来解决这个问题。 那如果想用递归来解决的话我们应该怎么思考呢？ 好我们来分析一下。 你看我们现在所采取的这种思考问题的方式，我们是从最简单的情况开始。 也就是说我们思考问题的方向是从切第0刀第一刀第二刀 一直向切第n刀的方向去考虑的。 也就是说从i=0的情况向着i=n的情况去考虑。 所以我们才得出一个用循环来解决这个问题的办法。那么现在呢我希望啊我们能把这个视角转换一下。 我们直接去看第n刀和第n-1刀有些什么样的关系。比如说我们可以这样来思考。假设我们切下第n刀的时候我们得到的是q(n)块。当然虽然我不知道q(n)这个值到底是多少，但是呢根据刚才那个规律我却知道 q(n)跟q(n-1)存在这样一个关系。它就等于q(n-1)加上 n。那么其实这个式子已经给了我们足够多的信息了。 因为这个式子清晰的表达出来了q(n)和q(n-1)之间的 递推关系。 也就是说只要有了这样一个表达式那么剩下的 信息不需要我在程序里头逐一体现。 有了这个式子以后其实那个递归关系就已经建立起来了，比方说我们知道了q(n)=q(n-1)+n 我们也就知道q(n-1)就等于q(n-2)+n-1。 那么也就知道q(n-2)跟q(n-3)之间是什么关系 等等等等。那么q(1)跟q(0)之间是什么样的关系。 这个式子就已经统统都告诉我们了。所以说我们的关注点只要放在这个式子上面就可以了。有了 这个式子底下的这些递推关系我们根本就不需要逐一的去体现。当然要想解决这个问题除了能够表达递推关系的这个关系式以外, 我们还必须再获取一个信息。 那就是当n处于边界条件下的时候函数的返回结果。 也就是说我们必须还得知道当n=0的时候q(0) 等于1。那也就是说只要有了这两个条件，其实 关于这个问题的解决方案的所有信息我们全部都 掌握了。那么利用这样一个信息我们就可以写出解决这个问题的逻辑。 也就是说当我们切n刀的时候能得到多少块呢？ 我们假设当我们切下n刀的时候我们能获得q(n)块。 那怎么去求解这个q(n)呢？那我们就可以通过这样一个关系去求解。 只要n不等于0 那么这个q(n)就等于n加上q(n-1)。 那么这里呢给出我们的第一个信息点。那么当n=0 的时候应该怎样呢？应该return 1，就是当n=0的时候 函数的返回值是1。这是我们提供的第二个信息点。正如刚才我们讲过的 有了这两个信息点那么程序就可以去运算了。那么借着 这样一个递归函数很容易我们就可以写出整个递归程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int q(int n)
    {
        if(n == 0)
          return 1;
        else 
          return (n + q(n - 1));
    }
    int main()
    {
        cout << q(4) << endl;
        return 0;
    }
    ```  
    那么这儿呢是我们定义的q函数。 那么在主程序里头呢我们直接调用了这个函数，并且打印了这个函数的 值。当然这个时候呢当然作为一个测试呢我们去计算一下n=4的情况。 那么关于这个程序的执行情况我们仍然可以利用这样一张 图来表示。有同学说哎呀你怎么老是去用这样一张图啊？ok 那么这个图呢确实是我在这个课上给出来用它来表示函数之间调用关系的这样一张图。 那么这种表示方式呢比较简明，特别是对于复杂递归的情况啊用这种方法表示出来之后啊 会变得容易理解。那么大家在分析问题的时候啊也可以使用这种图来帮助自己做一个分析。ok我们来看一下这个调用关系。 Main函数先运行，运行到中间呢它调用了 q(4)，于是呢我们把它标定在这里，q(4)就开始执行。 那么当q(4)执行到这一句的时候它就会去调用 q(3)，当然q(4)还没有执行完。 在没有执行完的情况下它就会去调用q(3)，那q(3)呢再开始执行，又 执行到这一句q(3)又会调用q(2)，那么当q(2)再执行到这一句的时候呢又会调用q(1)。 那么q(1)呢也是执行到这一句的时候呢就会调用q(0)。当然 我们反复强调在这个调用过程中你最好把每次调用都想象成 开辟了一片新的全新的内存空间。这样才能保证 你的对应关系不会乱。当q(0)再去执行的时候还会执行到这一句吗？ 哦不会了。因为q(0)呢在这里就会进入if的这个分支，最后呢返回1。 于是呢q(0)就带着它的返回值1 返回到调用q(0)的那个函数 q(1)。q(1)呢在调用q(0)之前执行到这一句了，但是它还没有执行完。 它在这个地方等着q(0)的返回值呢。 所以说当q(0)带着这个返回值1 回到q(1)的时候那么q(1)呢接着去执行这一句。 那请问在q(1)中n等于多少？n就是这个参数，所以说这个地方是 1。于是呢q(1)会计算一个1+1=2。然后呢q(1)带着这个 2返回它的调用者，也就是q(2)。 那么q(2)呢也是在它的这一句上等着q(1)呢。 那q(1)返回2以后q(2)去用它自己的那个 n以q(1)的返回值2相加，于是2+2得到4。 那么当q(2)计算出这个4以后呢q(2)也就执行完毕了，于是带着这个4返回 q(3)。那么同理q(3)呢把它的内存空间中的那个n与q(2) 的返回值4 进行相加，于是呢3+4获得7。当得到7以后呢q(3)也执行完毕，于是带着7返回了它的 调用者q(4)。那么q(4)呢也把它的空间里的n跟这个7进行相加于是得到 11带着11返回到Main函数。于是Main函数呢在这里 打印出q(4)返回的这个11。 所以整个程序的执行结果会打印出11。 这就是这个函数的执行过程。

  - 那么透过这个执行过程我们可以看到 虽然这个图很简单，但是啊它可以帮助我们来进行一个比较清楚的 分析。ok，那么通过这个例子呀我们就可以看得出来 其实呢我们可以利用递归这 种方法来解决具有递推性质的问题。 比方说切饼，那切饼就是一个典型的具有递推性质的一个 问题。我们就可以用递归程序来解决这样的一个问题。 那当然啦在解决这个问题的过程中我们必须要注意递归和递推的不同。 首先递推的关注点往往是在问题的起始点上。就是说它会先去关注i 等于0的情况。然后呢从i等于0的情况向着i等于n的情况慢慢地 去推理。然而呢递归程序 不是这样的。要写一个递归程序的话我们的关注点 必须直接的放到求解目标上，也就是说我们会直接的去考虑 i=n的情况。然后呢找出i=n的情况下 应该如何去计算函数的结果。 这就是递推和递归最大的一个不同，它们的 它们看待问题的视角是完全不同的。 当然它们两个之间也有非常大的相同，那就是说它们两者都非常的 关注。函数的第i次执行和第i+1次执行之间的 关系。那么通过这个程序我们可以感受到其实用递归来实现具有递推性质 的这种问题呢是有它的优势的。 它可以让程序一下子变得简明了很多。 **那么对于一个普通的问题，我们怎样才能找到那个合适的递归函数呢？ 那在这儿我们对这个方法稍微做一个小总结。 如果我们想使用一个递归程序 来实现或者是解决一个具有递推性质的问题的时候 就需要我们做这么几点工作。第一个呢我们需要把关注点直接放在 要求解的那个目标上。那么直接对这个目标进行分析。 所谓的目标也就是说i=n的情况。在这个基础上呢我们再去找到 这个函数的第n次执行和第n-1次执行之间的 关系。找到那个递推关系。然后呢我们再去确定第 1次执行的时候返回的结果是什么。那么有了这三个条件呢我们就可以 写出我们的递归函数来了。这就是当我们使用 递归的方法来结局具有递推性质的问题的时候应该使用的一种思考方法**。 
  
  - ok，那为了让大家对这个方法有更强烈的一个感性的认识，我们再来看一个程序。 看这个数列。我们来观察一下。 这数列是这样的。1，1，2，2，3，5， 3，5，8，5，8，13。通过这个观察 我们就可以看到这个数列里头任何一个数字都是它的前两个数的和。 其实这个数列呢就是非常著名的Fibonacci（斐波那契）数列。 当然这样一个数列在很多的状况下我们都会用到。 很多人喜欢把这个数列当作密码来使用以至于 很多的网站那么拒绝接受这样的一种密码。 ok，那么现在呢我希望你写一个程序来求解斐波那契数列的第n个数字将会是多少。 首先我们非常明确，斐波那契数列呢是一个递推数列。 **那么现在呢我希望你使用一个递归的程序来计算这个数列的第n个数到底是多少**。那么根据刚才我们总结的，我们看问题的视角 不从第一个开始。我们要直接放在第n个数上。既然它是一个 Fibonacci数列，所以说我们就可以得出来第n个数跟第n-1个数之间具有什么关系呀 是不是它就有一种这样的关系呀？ 第n个数其实就等于第n-1个数和第n-2个数的和。这是我们站在第n个数的角度去考虑的第n个数和第n-1个数之间的这种关系。那我们找到了。那么接下来呢我们还需要再去寻找最简单的情况下就是当n=1的时候会怎样。 那么对于Fibonacci数列呢就必须要考虑n=1的情况和n=2的情况。那么对于Fibonacci数列呢这两个情况都已经预订好了，它们都等于1。 于是呢我们就可以基于此来写出一个递归的程序。那么这个程序呢也非常的明确。 对于Fibonacci数列中的第n个数如果n=1或者是n=2的话 那么这个数列将都会返回1，因为它的前两个数都是1。那么除此之外呢Fibonacci数列的第n个数就等于这个数列的第n-1个数和第n-2个数的 加和。其实这个程序逻辑描述的就是刚才我们所得出来的那个逻辑。那么就用这样一个函数再去写程序我们就非常非常的简单了。 
    ```C++
    #include <iostream>
    using namespace::std;
    int Fibonacci(int n)
    {
        if(n == 1)
          return 1;
        else if(n == 2)
          return 1;
        else
          return (Fibonacci(n - 1) + Fibonacci(n - 2));
    }
    int main()
    {
        cout << Fibonacci(12) << endl;
        return 0;
    }
    ```    
  ok，这是关于如何用递归来解决具有递推性质的问题。 
## 4. 递归应用示例（进制转换、汉诺塔）
- 那下面呢,我们再来看一下递归程序的第二个应用场景。 **我们可以用递归呀来模拟连续发生的动作**。 
  - 好，首先呢我们也是先看一个例子。 那么看到这个例子，大家都非常的熟悉。啊这个例子呢是把一个十进制的数， 比方说123转换成了相应的二进制数1111011。 现在啊我们希望大家写一个递归的 程序。这个程序呢要接受一个十进制的数作为输入， 并且呢打印出它所对应的二进制数。 那怎么来写这个程序呢？我们来分析一下。 首先我们来看一下这个计算过程。要想求解123所对应的 二进制数，我们采取的办法是这样的。把123啊 除以2，我们会得到一个商和一个余数。 如果这个商啊不等于0，我们就继续把这个商除以2，然后再得到一个新的商和一个余数。然后如果它不等于0，我们再对它进行除以2，然后得到一个新的商和一个余数。 然后再判定一下它这个结果是不是0，如果不是0的话再除以2，然后又获得一个余数。然后再判定这个结果是不是0，然后再除以2得余数。判断结果是否是0，除以2得余数，判断结果是否是0，除以2得余数。你看在这个过程里头，是不是我们在反复的重复这个动作啊。 OK，好。那么既然我们一直在重复这样一个 过程，我们就可以用一个函数来描述这个过程。 比方说我们有这样一个函数叫convert，这个函数呢能够描述刚才我们不断重复的那个动作。 啊也就是说，刚才我们其实一直在执行这样一个动作， 面对任何一个新的输入x，我们首先要判定一下 这个x除以2是否等于0。 如果它不等于0，我就把x除以2，然后呢重复下一个动作。并且呢，我把x模2的值打印出来。 那如果x除以2等于0，那就意味着x不是0，就是1， 那这个时候很好办，我就把x打印出来，是这样的一个逻辑。 那说到这我们来看一下，是不是这个函数的函数体就描述了 刚才我们不断反复执行的那个动作呀。是不是啊？哎。 **所以说对于这样的一个问题我们可以这样来思考。我们假设啊 有一个函数它能够完成我们反复执行的这个动作。 那么借由这个函数呢，我们再把这个动作的序列，这个动作执行的方式给它描述下来。 那于是呢我们就获得了一个递归函数**。 那么有了这样一个递归函数体，我们再去写程序也就变得容易了。我们看一下这个程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    int convert(int x)
    {
        if((x/2 != 0)){
          convert(x/2);
          cout << x % 2;
        else 
          cout << x;
        }
    }
    int main()
    {
        int x;
        cin >> x;
        convert(x);
        return 0;
    }
    ```     
    这就是我们所定义的convert。 因为在convert的里面我们会处理所有的输出，所以说我们不需要 convert返回任何的值。所以说它的类型是void的类型。 那么在主函数里头呢，我们只要直接去调用一下convert， 就可以了。那么在这呢有一点我需要多说明一下。 在这儿啊，我们我们把每一个二进制位的输出放在了递归调用之后。为什么要放在递归调用之后啊？ 那是因为我们以前讲过，去计算一个十进制数的二进制的时候，最后的输出是一个反向输出的过程。也就是说只有把cout 放在递归调用之后，它才会逆序打印出来。 这是刚才我们曾经讲过的一个特性。于是呢，我们来看一下这个程序的执行结果。 输入123，输出1111011。 这个结果是正确的。那么通过这个例子，我们可以看到，我们可以用递归的这种方式来描述那些反复连续发生的动作。 

  - OK。我们再来看一个例子。 这个例子啊非常非常的经典。 **它就是汉诺塔问题。这个例子经典到什么程度呢？ 那么基本上呢我们可以用这个例子来区分一个同学是否是学过计算机的。 啊那么基本上学过计算机的人都会知道汉诺塔问题**。 OK我们来看一下什么是汉诺塔问题。 相传哪在一个古印度的庙里面， 这个庙宇的名字我也不知道该怎么去读啊。那么在这个庙里面呢， 有一个僧人，大概是在修行吧。他整天把三根柱子上的金盘啊 倒来倒去，他想把64个一个比一个小的金盘从一根柱子上 移到另外一根柱子上去，而且呢移动的过程要恪守以下的规则。 每次啊只移动一只盘子， 而且呢大盘子永远都不能放在小盘子的上面。 OK。我来解释一下这个事。我们来看这个图，在这个图上啊有三根柱子。 在第一根柱子上面放了一些圆盘。这个圆盘呢，大小是不同的。 大的圆盘在下面，小的圆盘在上面。那现在 这个僧人做的事情呢，就是把这一堆的圆盘 从这根柱子上移到这根柱子上。那就有的同学说，哎呀 这个移动还不很简单嘛，直接把这个圆盘拿起来放过来不就完了嘛。 不行。啊有这样一个规则，第一个， 每次移动这个盘子的时候啊只能移动一个盘子。 也就说你不能同时搬动两个或者两个以上的盘子，是不允许的。 这是第一个规则。第二个规则，你可以啊利用中间的这根柱子， 你可以用它来做缓冲啊。 但是每次出现在柱子上面的圆盘都必须满足一个条件。什么条件呢？ 大的圆盘永远放在下面。小的圆盘永远放在上面。 也就是说，不能出现 大的圆盘在上面小的圆盘在下面的这种情况。OK，这就是 所有的这个规则。OK为了辅助大家来了解这个规则啊。我们来看一个动画。 好，我们来看这个动画。那么在这个动画上呢，有三个柱子，一、二、三，三个柱子。 其中呢，第一个柱子上放了好些圆盘。啊你看所有的盘子的罗列都是底下大， 上头小。然后呢我的任务是把这三个盘子从第一根柱子移到第三根柱子。 那么能不能一次把它三个盘子全搬起来啊？不行。我每次只能动一个盘子。 啊这是一个规则。那么要把最底下的这个盘子从 这个柱子移到这个柱子，那么我就必须要把上面的这两个盘子找个地方先放一下。 当然了，我可以用中间的这个柱子啊来做缓冲。这是允许的。 但是缓冲的过程中呢，又不能够把把这个盘子这样摞起来。因为如果这样放的话， 就会大盘子就会在上面，小盘子在底下。这又违这就会违反规则。所以这是不允许这么去放的。 所以说呢，为了能够把上面的这两个 盘子缓冲到中间的这个柱子上，我需要这么做。 啊先把这个移过来，再把这个移过来， 然后呢再把这个移过来。 OK，那么这两个盘子就被缓冲到中间的这个柱子上了。而且呢，大的盘子在下面，小的盘子在上面。 然后呢底下这个盘子你就可以从这移动到第三根柱子，把它放下来。 那现在呢，我们需要把这两个盘子移动到这来。毫无疑问，我们又要用 第一根柱子做一个缓冲，啊我们要把这个圆盘先暂时放在这。 然后呢把第二个圆盘把它放过来。然后第三，第一个盘子再给它放下来。 OK。那这样呢，我的这个移动就完成了。 那么通过这个过程啊，我们就会看到当盘子数目增加的时候，其实要移动这些盘子还是挺麻烦的。对不对？ 那么有人呢就简单地计算过，如果以每秒钟 移动一个盘子这样的速度来计算的话， 那么按照这个规则要移动具有64只盘子的一个汉诺塔，那么就需要多长时间呢？ 需要5800亿年。 哇，这是一个太长太长的时间了。基本上这件事情是不可能完成了，对不对？啊，那么既然人不能完成，那么现在呢我们就来写一个程序，来模拟一下盘子的移动过程。什么意思呢，就是要写一个程序把盘子搬动的过程啊给它打印出来。 那么为了让大家明白我们需要写一个什么样的程序。我们先来看一下这个程序的运行过程。 比方说对于刚才的汉诺塔的问题。我们假设啊三根柱子的名字分别叫做A、B、C。我就可以这样来打印。程序运行起来之后呢，首先提示请输入盘子的数目。假设说我输入的是4个。那么程序呢就会打印出来在三根柱子上移动四只盘子的步骤为。底下每一行就是一个步骤。比方说第一行。把一个盘子从a移动到b，这是第1步。第2步呢，把一个盘子从a再移动到c， 那么第3行呢，把一个盘子再从b再移动到c， 然后第4行呢，把一个盘子从a再移动到b，等等等等。每行一个步骤，那么现在需要我们做的， 就是要写一个程序，当用户给出来一个n，我们就把这个步骤， 给它打印出来，这是我们要完成的事情。那现在的问题来了， 怎么去解决呢？那么看上去这个问题还是 有点难，当碰到这样问题的时候啊， 我就想起来，我们刚刚开始c程序设计这个部分的时候，曾经给大家讲过的， 当你面临一个问题的时候啊， 你一定要先去思考这个问题的 解决方案，因为没有解决方案就没有程序。 所以阿，我们先放下程序不说，我们先来考虑 一下解决这个问题的方案。我们先来分析一下这个问题。 还是那句话，既然要分析问题啊，我们就要从最简单的情况开始考虑。 假设说现在只有一个盘子需要我们移动， 那么对于一个盘子的情况实在是太简单了，对不对？我们只要把这一个盘子从 a上面拿起来放到c上面，就ok了，这是一个盘子的情况。 那两个盘子的情况呢，也很简单。比方说， 我要把这两个盘子从a经过b移动到c， 那么应该怎么办啊？很简单，我们可以把a上面的这个小盘子先拿起来， 放到b的上面，然后呢再把底下这个大的盘子移到 c的上面，然后呢再把b上面的这个小盘子，移到c的上面， 这是两个盘子的情况。那么三个盘子的情况呢？ 为了把a柱子上面三个盘子通过b柱子移动到c， 我们只能这么做。怎么做呢？把a柱子上面， 上面的两个盘子先移动到b柱子上， 然后a柱子上这个最大的盘子就可以移动了，于是呢我们就把a柱子上的这个 最大的盘子从柱子移动到c柱子，在c柱子上放好以后， 我们再把b柱子上的这两个盘子移动到c柱子上面去，那么这三个盘子就都 被移动到c柱子上了。那有的同学说，那怎么才能把 a柱子上最上面的两个盘子移动到b柱子上呢？ 有怎么样才能把b柱子上面的两个盘子一下子移动到c柱子上呢？ 我说啊，这个过程一点都不复杂。因为刚刚你已经解决过了。 你看我们在第2步，是不是已经移动过两个盘子啦。 是不是？我们在第2步已经把两个盘子 从a柱子跨越b柱子移动到c柱子上面了。 那么在这，当我们想把两个盘子从a柱子 上面移动到b柱子上面的时候，那我们只需要把 这儿的c柱子当作刚才的b柱子来使就可以了。 所以说阿，当我们要移动三个盘子的时候，我们完全可以把它 化简成以两个盘子的情况，也就是说啊，我们可以 得出来这样一个表示，我们要实现把三个盘子从 a柱子上面通过b柱子移动到c柱子， 那我应该怎么办呢？我完全可以这样来做。 先把a柱子上面的两个盘子 从a柱子上面经过c柱子移动到b柱子上面， 这就是我们刚才所叙述的这第一个过程。然后呢， 我把第三个盘子从a柱子上再移动到c柱子上， 这就对应着我们刚才所进行的第2步。 进行完这两步之后呢，然后再把两个盘子从 b柱子上经过a柱子移动到c柱子上，这就对应着 刚才的第3步。那么通过这样3步， 是不是我就可以把三个盘子从a移动到c啦。 ok，是这样的。通过这个分析我们就可以看到，是不是移动三个盘子的问题就被简化成了两次移动两个盘子的问题啦。 对于对？那么我再问一下，如果对于四个盘子的情况呢？ 那如何移动四个盘子的情况就会被简化成如何移动三个盘子的情况。然后呢，进而又被简化成你如何移动两个盘子的情况。 这样一步一步下去，当我们有n个盘子的时候， 就被演化成了如何移动n减1个盘子的 情况了。好，那么接下来就来看一下如何移动n个盘子。 这有n个盘子，我们不去管它一共有几个阿。我们假设这一共有n个盘子， 那当我想把这n个盘子从a柱子上面经过 b柱子移动到c柱子上面的时候， 我是怎么来进行的呢？ 一样的办法。既然要从a柱子上移动到c柱子上， 于是呢，我就必须要把a柱子上面 除了最底下这个盘子之外的所有其他 盘子先从a柱子移动到b柱子， 先给它从a移动到b。 移动完毕以后呢，第2步，再把a柱子上 最底下的这个盘子给它移动到c柱子，移动到c。 那么这个完成了以后呢，再把b柱子上所有的盘子从b柱子再移动到 c柱子。那完成这个步骤以后呢，那么所有的盘子就都在 c柱子上了。如果我们把刚才的这个整个的这个过程 写下来的话，那么可以表述成这个样子。 如果我们想要实现把n个盘子 从a柱子上经过b柱子移动到c柱子， 那么我们应该这样去做。 先把a柱子上面最上面的n减1个盘子， 从a柱子经过c柱子移动到b柱子， 然后呢，再把a柱子上面剩下的这个盘子，移动到c柱子。 那么移动完以后呢，再把刚刚移到b柱子上的n减1个盘子， 从b柱子经过a柱子移动到c柱子。 那么这样一个描述也就告诉我们，对于想要移动 n个盘子的情况，我们完全可以把它化简成要移动 n减1个盘子的情况。 也就是说阿，当我们有5个盘子的时候，我们就可以 约简成4个盘子的情况，有4个盘子的时候我们就可以约简成有3个盘子的情况。 有3个盘子就可以约简成有两个盘子的情况，那有两个盘子的情况我们就 可解了。那步骤是我们已经知道的。于是整个这个问题就可以解决了。 是不是这样的呀？所以如果把这个 逻辑描述下来呢，我们就可以得到一个这样的程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    void move(int m,char x,char y,char z)
    {
        if(m == 1){
          cout << "把第一个盘子从" << x << "移动到" << z << endl;
        }else{
          move(m - 1,x,z,y);
          cout << "把第一个盘子从" << x << "移动到" << z << endl;
          move(m - 1,y,x,z);
        }
    }
    int main()
    {
        int n;
        cout << "请输入盘数n ="；
        cin >> n;
        cout << "在3根柱子上移" << n << "只盘的步骤为：" << endl;
        move(n,'A','B','C');
        return 0;
    }
    ```   
  我们来看一下这个程序。 假设阿，有这样一个函数move,它呢表示要把m个盘子从 原始的柱子，这个x呢表示起始的柱子，经过 中间的柱子y移动到最终的柱子z. 有的同学说，哎，你在这为什么不使用abc呢？ 因为在移动的过程中啊，哪个柱子是原始的柱子 哪个柱子是最终的柱子，哪个柱子当中间的柱子使用 是一件不断变化的事情。所以说呢，我在这用了3个变量， 把它们当作变量写在函数参数里头。 那么当我们想把m个盘子 从x柱子经过y柱子移动到z柱子的时候， 我们就需要这么去做。先判定一下m是多少. 如果m等于1，也就是说只有一个盘子，那我们就直接把这个盘子从x移动到z, 从原始移动到目标。 如果m不等于1，那我们就把最上面的m减1个盘子先从原始的起点，经过z，移动到y， 然后呢，我们再把x上面剩下的最后一个盘子从x移动到z, 之后呢，我们再把刚刚移动到y上面去的m减1个盘子从y上面， 经过x，移动到z。就是这样的一个逻辑。 那么有了这样一个逻辑之后，我们再去写程序就变得容易了。我们来看一下这个这个程序。 这个呢，是刚刚我们所定义的move函数，它表示啊， 把m个盘子从与原始的数字x经过中间的柱子y移动到目标柱子z上面去，这是它的含义。那么在主函数里头呢，我们输入一个盘子的数目，然后呢，直接去调用move这个函数， 并且呢，我们去写明每一个柱子的名字。 比方说，我们是把原始的柱子命名为a，把中间的柱子命名为b， 然后呢，把目标柱子命名为c。那么这个调用呢，就表示我要把n个盘子从a经过b，移动到c， 那么结果会是怎样呢？我们来看一下运行的结果。输入4， 然后呢，它就会打印出来每一步运行的步骤。ok,我们来总结一下。 通过这两个例子，我们可以看到 我们可以利用递归啊，来模拟连续发生的动作。 我们可以通过这种方式阿，来解决问题。那么，当我们想通过这种方式 解决问题的时候我们应该怎么去思考呢？也就说那个方法是什么呢？我们首先来看， 第一，首先你要搞清楚，那么连续发生的动作 它是什么。比方说在第一个例子里头，那个连续发生的动作就是 你需要不断地对十进制数处以2，得到 余数，并且判定商是否等于0。 

- 那么在刚刚我们所讲过的汉诺塔问题中呢，你需要不断的做的动作就是 把m个盘子从原始的柱子x 经过中间的柱子y移动到柱子z，
  - 你首先要搞清楚，那些连续发生的动作 是什么。其次呢，在这个基础上，你要搞清楚不同次动作之间的 关系。这个关系是什么？比方说，在进制转换的例子里头，那个关系就是把商当作下一次你要除的那个十进制数。 
  - 在刚刚我们讲过的汉诺塔的例子里面，那么不同次动作之间的关系其实就意味着当我要移动m个盘子的时候，我需要先把m减1个盘子移动出来，然后呢，再把底下的[盘子从x移动到z, 然后再把刚刚移出来的m减1个盘子从y移动到z。这就是前一次动作和后一次动作之间的关系是什么。
  - 然后在这个基础上，你还需要确定一点，那就是要确定边界条件是什么。比方说，再刚才我们的汉诺塔的例子里头，边界条件就是当m等于1，也就是说只有一个盘子需要移动的时候那就好办了。盘子直接从x移动到z就可以了。那么搞清楚这3点之后，我们就可以根据第一点来定义那个函数。根据第2点来描述递归函数之间的关系，然后第3点呢，来描述递归推出的边界条件。于是整个程序你就可以得到了。这就是当我们利用递归来模拟连续发生的动作这样的一种方式来解题的时候，我们需要做的一些事情。 
## 5. 递归应用示例（放苹果）
- ok，下面我们再看一个例子。 这个例子呢比较有意思。 这个例子名字叫放苹果。这是open judge的上面比较经典的一道题目。 我们来看一下这个题目。说啊，有M个同样的苹果。 这M个苹果呢一模一样没有区别。现在呢要把这M个苹果放在N个同样的盘子里头。 也就是说有N个一模一样的盘子，现在呢我们 要把这M个苹果放到这N个盘子里头。 而且呢你喜欢怎么放都行。允许有的盘子空着不放。 它允许可以你有空的盘子不放。他问你啊请问一共有多少种不同的分法或者放法？ 也就是说要把这M个一模一样的苹果放到N个一模一样的盘子上并且呢允许有的盘子空着不放。请问有多少种放置方法？ 在这呢它特别给了一个提示，也就是说这个放置方法跟顺序是没关系的，也就比方说如果你有7个苹果3个盘子 你第一个放5个，第二放1个，第三个放1个。 这种放法其实跟第一个放1个，第二放5个，第三个放1个是 同一种分法，也就是说跟顺序排列顺序没有关系。 也就是说这个题目提给我们的问题就是 当我们有M个一模一样的苹果要放入N个一模一样的盘子里头的时候 有多少种放法？ 这儿有一个输入输出的例子，比方说有7个苹果3个盘子的时候那么它放法的总数就是8。 也就是说程序的输出应该是8。

- 那对于这样一个问题我们应该怎么去求解呢？ ok 我们啊仍然采用刚才使用过的那个办法。 现在我们假设存在这样一个函数f(m,n)，它能告诉我们答案。也就是说我假设f(m,n)能告诉我们当m个苹果放到n个盘子里的时候有多少种的解决方案。那么接下来呢我们就来分析一下f(m,n)的执行过程。 也就是说我们假设存在这样一个函数它能告诉我结果。 那么在有这样一个假设的前提下呢我们去分析一下这个函数是如何来进行计算的。那怎么进行分析呢？那么对于这样一个问题我们就可以分情况来讨论。比方说我们可以这么来做。
  - 首先我们来分析一下当盘子的数目多于苹果数目的时候可能出现的情况。比方说我们现在面临的状况是这样的。 我们一共有1234567，7个苹果。 但是摆在我们面前呢有9个一样的盘子。 现在呢盘子的数目比苹果的数目要多。 那么现在我们就要考虑一下了，既然盘子的数目比苹果的数目还要多，那就意味着 就算每个盘子里头只放一个苹果。 比方说这儿有9个盘子，就算每个盘子里头只放 一个苹果也总会有两个盘子是空着的。 也就是说这两个空着的盘子其实跟放苹果办法那个放法的数目 是完全没有关系的。 也就是说在这种情况下当盘子的数目比苹果的数目 还要多的时候我们完全可以把多余的盘子给砍掉。让它消失掉。 那么进行这样一个转换砍掉多余的盘子呢完全不会影响我们最终的计算结果。 于是呢我们就得到了第一个规律。 也就是说如果n大于m这个条件成立的话那么其实在这种情况下f(m,n)其实就等于f(m,m)是不是这个意思啊?因为多余的盘子是完全用不着的。这是我们得到的第一个结论。
  - 那么接下来呢我们再去分析另外一种情况。也就是说当苹果的数目大于或者等于盘子的数目的时候会是什么样的状况？ 比方法说现在我们有1，2，3，4，5，6，7，8，9，10，11，12，12只苹果。 但是呢我们有9个盘子放在这儿。那么到底有多少种的放法呢？ 那么在这儿我们就把所有的放置方法分成两类。那么根据这个题的提议在把苹果放到盘子上面的时候允许有的盘子空着不放。 那么根据这个条件我们就把所有可能的放置方法 分成两大类。一类呢是有盘子空着的情况。 另一类呢是没有盘子空着的情况。分成这两大类。 那么在这种情况下那么所有可能存在的那些放法的那个数目就等于分别在这两种情况下出现的放法数目的和。那么说到这儿我们就可以感受到我们的解决思路了。 也就是说呢如果盘子的数目比苹果的数目多，那么我们就可以砍掉多余的盘子使得苹果的数目保持大于或等于盘子。 然而呢当苹果的数目大于或等于盘子的时候 那么所有可能存在的放置方法的数目就等价于这两种情况下所出现的放置方法的数目的和。**所以无论如何我们都可以把所有可能存在的放置方法分成这两大类。一个是有盘子空着的情况，一个是没盘子空着的情况**。 所以啊只要我们分析清楚这两种情况下放置方法的数目应该如何计算我们就能够得到最后的结果了。

- 那么现在呢我们就 先来对第一种情况就是有盘子空着的这种情况进行分析。那么对这一类情况也就是说如果这种放的方法总是至少有一个盘子空着，那么就意味着这个空的盘子对于放置方法的数目是没有任何影响的。 因为你假设在这种情况下总会至少有一个盘子空着。就像我们看到的这种情况，有12个苹果在这儿，但是呢我们总是有一个盘子让它保持 空着不放，那么在这种情况下这个盘子是否存在 其实对于放置方法的数目是没有任何影响的。 因为你已经假设它总是空着。所以说在这种 情况下当我们仍掉这个总是空着的盘子 对于放置方法的数目是没有任何影响的。 也就是说我们可以得到这样一个数字。 也就是f(m,n)如果m大于n 并且呢总是至少有一个盘子空着，那么 f(m,n)就等于f(m,n-1)，因为n呢代表盘子的数目。 而在这种情况下呢又至少有一个盘子是空着的，所以说 我们把这一个盘子扔掉，也就是n-1，对于放置方法的数目是没有 任何影响的。所以说我们可以得到这样一个等式。这是第一种情况。 当有盘子空着的时候。现在呢我们 再来讨论另外一种情况，当没有盘子空着的时候。 比方说我们现在的这种状况下，在现在的这种状况下 每个盘子里面都至少放有一个苹果。 也就是说所有的盘子都没空着。那么在这种情况下 你想一下，放置方法的数目 跟什么东西没有关系啊？有一个东西又可以减掉了。哪个东西啊？ 每只盘子里至少放着的那只苹果。因为在这种情况下所有的盘子里头 都至少要放一只苹果。所以说 至少放置的那一只苹果如果把它剪掉的话 那么对于放置方法的数目，也没有 任何影响。于是呢我们就又得到另外一个等式。 如果没有盘子空着，那么 f(m,n) 实际上就等于 f，m-n,然后n。 那么说到这儿有的同学可能又发现了，哎，当每个盘子里都减掉这个 苹果以后啊,我们又碰到了刚才我们讨论过的那种情况。也就是说 盘子的数目其实远远大于苹果的数目。 对不对？那这个时候呢我们又可以减掉 所有多余的盘子。啊，那么在减掉所有多余盘子的基础上呢， 我们又得到了一种新的情况就是盘子数目跟苹果数目是相等的。 那么在这种情况下呢所有的放置方法又可以被分成 两类：一类是有盘子空着，一类是没盘子空着。 啊，那这个时候呢，我们又可以按照刚才的那种方法，再进行分析。 所以说啊，按照这个思路，我们可以一直分析下去。 比方说对于这种情况，那么如果有一个盘子空着其实它就等价于把这个盘子减掉。 然后如果所有的盘子都放着苹果呢，又可以等价于把每个苹果都减掉的这种情况。 那接下来呢，又会出现盘子的数目多于苹果的情况，所以又把多余的盘子再减掉。最后只剩下 一个盘子或者是一个苹果。 这个时候呢，就不用再分析了，对不对？啊，那按照这样的 一个规律其实我们就把所有可能出现的情况全部都分类， 分析了一遍。而我们要获得的那个结果呢，无非是把所有这些情况下的结果 加起来，就可以了。对不对？ 就是这样的一种分析方法。 那么把刚才这个分析的思路啊，给它写下来，我们就 获得了这样一个函数。这个函数呢，非常非常的简明。 别看这个题很复杂，啊，但是写出来的函数都非常的简明。函数的名字呢，叫做count。 它表示，当把m个苹果放到n个盘子上的时候，一共 有多少种的放法。那么，跟我们刚才讨论的一样， 那么这个程序呢，分情况来探讨了不同情况下的处理。 如果盘子的数目大于苹果的数目，那么我就减掉多余的盘子。也就是说如果 m小于n，那我就return count（m,m)。如果苹果的数目大于或者等于盘子的数目， 那么我就区分清楚，如果有盘子空着，那么 count (m,n) 其实就等于 count (m,n-1)。如果没有盘子空着，那就相当于每个盘子上都减掉一个苹果 也就是说count(m,n)就相当于count (m-n,n)。同时呢，在这指明了边界条件， 也就是说如果m或者是n小于等于0的话，那我们就直接return 1。 那在这种情况下只有一个解决方案。那么在这个函数的基础上呢，把程序补充完整，就是这样的。
    ```C++
    #include <iostream>
    using namespace::std;
    void count(int m,int n)
    {
      if(m <= 1 || n <= 0)
        return 1;
      if(m < n)
        return count(m,m);
      else
        return count(m,n-1) + count(m-n,n);
    }
    int main()
    {
        int apples,plates;
        cin >> apples >> plates;
        cout << count(apples,plates);
        return 0;
    }
    ```   
  那么这个程序的运行结果呢，就是这样的。那在这儿呢，我做了这么一个测试， 把100个苹果放到100个盘子上一共有多少种的放法呢？ 经过统计，一共有这么些种的放法，那这个数字非常大。 啊，那需要说明的是呢，这个程序啊，在我的笔记本上，至少跑了有十几秒钟。 十几秒钟之后，才返回来结果。那大家呢，也可以把这个程序抄写下来，在自己的电脑上，去运行一下这个程序。 那么通过运行这些递归的程序啊，你就会发现其实递归的 程序它的运算量还是很大的。虽然程序非常的简短，但它 的运算量有可能是非常大的。Ok，这就是放苹果这道题目。 在这儿呢，我也想说明一下，其实呢，放苹果这道题目的难度，也是不小的。如果我们 也做一个星级评定的话，那么五星呢，我也可以给到四颗星了。所以说如果大家一时还不能明白， 不要着急，慢慢地琢磨一下，就可以了。
  
- Ok，那么通过以上这两个例子啊， 我们可以看到，其实递归函数啊，在某些场景中能够啊， 帮助我们来自动地分析一个问题。 就比方说我们遇到的逆波兰表达式和放苹果，其实我们的程序都非常非常的 简短。那，这么简短的程序怎么能够分析清楚这么多的情况呢？ 所以说啊，在这种场景中啊，递归其实在帮我们做自动的分析。也就是说我们的递归函数是具有一定的分析能力的。那当我们面临类似的问题的时候，我们如何去做才能 找到这个帮助我们自动进行分析的递归函数呢？我们可以啊，这样去做。 首先呢，我们可以先假设存在一个这样的函数。也就是说， 我先假设有这么一个函数，它呀能够帮我们进行分析并且给出答案。就比方说在刚才的例子里头，我们所定义的notation，和分苹果的程序里头我们定义的count,我们都先假设存在这么一个函数，它能够给出我们一个分析的结果。然后呢，在这个假设的前提下，我们再去分析，如何去解决这个问题。也就是说，我们假设存在这么一个函数了，然后我们再去分析在这个函数的辅助之下，这个问题是如何一层一层解决的。比方说我们在逆波兰表达式里头，我们知道任何一个notation函数它都具备这样一些功能。那么在分苹果的例子里呢，我们知道 原来对于每一个我们定义的这个递归函数啊，我们都可以去分情况的去讨论。每一种情况下，它是如何 变化的。所以通过这个分析呢，我们就 利用了notation 去表示 notation。 利用了count去表示count。从而呢， 我们也就搞清楚了这个递归函数到底是如何完成计算的。 那么在这个的基础上呢，我们还必须要搞清楚，最简单的情况下函数返回的结果会是什么。 比方说在逆波兰表达式的例子里头，那么最简单的情况就是我读到 的不是一个操作符，而是一个普通的字符。这个时候我就直接返回一个数， 就可以了。那么在分苹果的这个例子里头呢，最简单的情况无非也就是m或者n小于等于1的时候。那么这个时候呢， 只有一个解决方案。那么对于这一类的问题，当我们搞清楚了这三个问题以后， 那么就可以基于我们的分析，写出递归函数来了。Ok，这是关于这个场景下递归函数的讨论。好，那么在分析了这三个场景之后啊，我们稍微做一个总结。 那么在这节课里头呢，我们在三个比较常见的场景之下，讨论了递归函数的作用。这三个场景呢，分别是用递归来实现递推，用递归呢，来模拟连续发生的动作。第三个呢，就是用递归来进行所谓自动的分析。那Ok我们在这儿呢，稍微总结一下， 这三个场景之下，我们给出来的一些解决方案。 首先，在用递归来解决具有递推性质的问题的场景中， 我们是按照这种方法来寻找递归函数的。那么在 这种场景中呢，首先我们看问题的视角就要发生一个变化。 我们应该把我们的关注点啊，放到最终求解的那个目标上。比方说 切饼问题我就直接去考虑，第n刀切下去的时候，我会获得一个什么样的结果。 那么在这个基础上呢，我要寻找这个递归函数的第n次执行和第n-1次执行 之间的关系。并且呢要搞清楚第1次执行，也就是边界情况下， 递归函数的返回结果。那么有了这三个条件， 你就可以去书写那个递归函数了，这是这个场景。 那么在，用递归来模拟连续发生动作的这么一个场景中呢，为了找到递归 函数啊，我们应该这么来做。首先我们要搞清楚那个连续发生的动作到底是指的什么呀？ 因为通常啊，只有我们确定了哪些动作是我们要表达的 连续的动作，我们才能够给出递归函数来。比方说，在汉诺塔的问题上 如果你不能够搞清楚你需要连续执行的动作 其实就是把一些盘子经过一个柱子搬到另外一个柱子， 那么你就没办法给出那个move函数来。 啊，那个参数你都不知道该怎么去写，那么通常呢，在这一类的问题中， 这第一步啊，也是一个难点。其实在第一步的时候，你可能就需要确定 函数的参数有哪些。 那么在我们搞清楚连续发生的动作到底是什么的这个基础上，我们再去搞清楚不同次 动作之间的这种关系。你比方说，在进制转换的例子里头其实上一次动作啊， 求出来的那个商，就是下一次动作的输入。我们要搞清楚这个关系。 然后在这个基础上呢，再搞清楚那个边界条件是什么。那么有了这三个条件，你也就可以书写 用于这种场景的递归函数了。那么第三种情形，利用递归来进行自动的分析。 那么这个呢，是我们刚刚讲过的方法。那么在这种场景之下呢，我们往往会先 假设有一个函数能够给出这样一个答案。 然后呢，在这个前提下我们再去分析这个问题是如何被解决的。最后呢 我们再搞清楚最简单的情况下，也就是边界的情况，到底是什么。那么有了这三点， 你也就可以在这个场景之下，去利用递归了。我在这儿啊，还是想要 强调一点。那么其实啊，这三个场景之间啊， 并没有明确的界限。在很多情况下，由于看问题视角的不同，你 会觉得一个问题，应该属于这个场景。另一个同学觉得这个问题属于那一个场景。 Anyway，都不要紧。其实呀，这三个场景向我们给出来的这些方法，基本上都是 相通的。所以说呢，我就希望大家在学习使用递归的这个过程里头， 如果遇到问题，你就可以啊，回想一下这些典型的场景。想一下 在这样一些典型的场景之下，我们是如何去求解问题的。那么通过这样一种模仿的方法， 将会非常有助于你在这部分的这一个学习。那么今天的课程呢，我们就讨论到 这里。最后呢，我还是希望大家要好好地琢磨一下这些问题。如果碰到不明白的问题呢，即 时通过论坛，反馈给我们。最后谢谢大家。
## 6. 递归应用示例（逆波兰表达式）
- OK,那么在说完了这个之后啊，我们再来继续看一下第三种情况。也就是说，其实啊我们还**可以利用递归来做一些自动的分析**。什么叫做自动的分析呢？ 我们首先来看一个例子。 OK，我们来看这样一个例子，这个例子的名字呢，叫做逆波兰表达式。 什么叫逆波兰表达式呢？ 逆波兰表达式啊，是一种把运算符前置的算术表达式。 什么叫运算符前置呢？举个例子，比方说对于一个我们熟悉的算术表达式，2+3， 如果把它表达成逆波兰表达式的话，那么怎么去表示呢？应该表示为 + 2 3。也就是说把这个运算符啊，从中间提到前面来了。 那再看一个例子，对于这样一个算术表达式，（2 + 3）*4， 如果把它表示成逆波兰表达式的话呢， 那就对应成为× + 2 3 4。那这个式子怎么来的呢？ 因为，在这个式子里面我们要先算2 + 3，所以我们优先得到+ 2 3。 然后呢，因为2 + 3的结果× 4，所以呢， + 2 3的结果再× 4。 啊于是呢，这个表达式就可以得到了。那么通过这个例子啊， 我们就可以看到逆波兰表达式的几个特点。第一个，一个完整的逆波兰表达式， 如果它包含运算符的话，应该是以一个运算符号开头的。 那么从这个例子呢，我们还可以看到逆波兰表达式啊，还有一个优点，就是在逆波兰表达式中，我们不需要写括号。 因为只要我们写出逆波兰表达式，那么它的计算顺序就是确定的。 啊这也是逆波兰表达式的一个优点。那现在需要我们做什么呢？ 需要我们啊，编写一个程序，求解 任意一个包含了+ - * /这四个运算的一个逆波兰表达式的值。啊现在我们来看一下， 既然包含的是+ - * /这四个运算，那么这四个运算呢，都有一个共同的特点， 就是说，它们都是双目运算符。 也就是说，+ - * /啊，都是有两个数来进行运算的。 那么通过刚才逆波兰表达式的这个定义啊，我们就可以知道， 那么仅包含+ - * /四个运算符的逆波兰表达式，一定具有这样的特点。 首先， 如果它包含运算符的话，它肯定是以运算符 来开头的。其次呢，在任意一个运算符的后面， 都肯定包含着两个逆波兰表达式。 啊这是我们从逆波兰表达式的这个定义啊，可以得出来的。 啊什么意思呢？我们打个比方，比方说看底下这个逆波兰表达式， × + 11.0 12.0 + 24.0 35.0， 那么对于这样一个表达式我们来看一下刚才那个特征是不是都存在。 首先这是一个完整的逆波兰表达式，所以呢， 它一定是以一个运算符号开头的。而且呢， 由于这个×是一个双目运算符，所以在×的后面， 一定包含着两个独立的部分。也就是说啊，当我们看到这样一个表达式的时候， 其实我们立刻就可以写出来这样的一个结构。 啊这一定是跟这个逆波兰表达式等价的。那么我们接着再往下看， 接下来呢，我们读到一个+，OK，既然我们读到一个运算符号，那就意味着 它一定代表着一个独立的逆波兰表达式。 啊因为所有的逆波兰表达式都是以运算符号开头的。 那么既然+代表一个独立的逆波兰表达式， 而且+的后面没有其他运算符号了，所以说我们就知道， 那么+ 11.0 12.0这是一个独立的 逆波兰表达式。于是呢我们就可以把它写在这儿，那么11.0 + 12.0，那么在读过了11.0 12.0之后接着往后读，我们又读到一个 +，读到这个+之后呢，我又知道这又是一个独立的逆波兰表达式的开始。 而且呢，在这个运算符号的后面，又没有其它运算符号了。 那我们就知道，从这个+开始，到35.0，形成了一个独立的逆波兰表达式。 那于是呢，我们就可以得到24.0 + 35.0， 于是呢，上面的这个逆波兰表达式就被转换成了下面的这个普通的算术表达式。 啊那么这个算术表达式的值呢，就是1357.0。 OK，那么通过这个介绍啊，我相信大家能够理解 什么是逆波兰表达式了。那么在理解了逆波兰表达式之后呢，回到我们的任务， 啊我们需要做的事情啊，就是要编写一个 程序，求解任何一个包含了 + - * /四个运算符的逆波兰表达式的值。也就是说啊，程序的输入 是一串儿满足逆波兰表达式定义的一个字符串。 那么需要我们做的事情呢，就是把这样的一个字符串按照逆波兰表达式的这个定义，给它解析出来。 并且呢，给它计算出来，计算完了之后呢，输出这个表达式的值，这是要我们做的。 那么对于这个问题，我们应该怎么去解决呢? 我们应该怎么用递归去解决这样一个问题呢？ 我这么来解决这个问题。 当我们的面前啊，有这样一个逆波兰表达式的时候， 我假设，存在这样一个函数， 这个函数的名字呢，叫做notation（）， 它呢，能够帮助我们 读取并且返回一个逆波兰表达式的值。 我假设存在这么一个函数，啊我先假设这个函数 的存在。然后呢，我再去分析这个函数 应该如何去实现。 OK，我们来分析一下，那么既然呢，notation（） 这个函数能够读取并且返回一个逆波兰表达式的值， 于是呢，我就让notation()来解析我们面前的这个逆波兰表达式， 然后呢，我来分析notation（）是如何来完成这样一个过程的。 那么根据逆波兰表达式的定义， 当notation()来解析这个逆波兰表达式的时候， 它首先肯定要读取表达式中的第一个字符， 然后呢，它会判定这个字符是不是 + - * /，如果是+ - * /之一， 那么，就意味着我读到了一个操作符， 那么根据逆波兰表达式的定义，也同时意味着，在这个操作符的后面， 一定存在两个互相独立的部分， 而且这两个互相独立的部分，每一个都会是一个独立的逆波兰表达式。 所以呢，当notation()读到这个×的时候， notation()应该做什么呢？这个notation()就应该把 以×开始的那个逆波兰表达式解析为这样的一个结构，就是×在前面， 后面呢，有两个互相独立的部分。 那么这两个互相独立的部分，从哪开始到哪结束 我并不知道。但是，我却知道这两个独立的部分 分别都是一个合法的逆波兰表达式。 那么由于它们两个都分别是一个合法的逆波兰表达式，所以我完全可以分别指派一个新的notation()函数去分别对它们进行解析。也就是说，当前面的这个notation()函数读到一个×的时候，我就应该把以×开始的逆波兰表达式 解析成这样的一种格式。 这就是这个notation()函数的作用。 当然，如果进一步做解释的话， 这个表达式的含义是什么呢？根据逆波兰表达式的定义， 其实它的含义就相当于，这两个独立的部分 相乘在一起， 就是说这个×的含义就在于，表达它们两个相乘在一起。于是我们就可以得到一个结论，notation()函数的第一个功能，当它碰到一个×的时候， 它就应该把以×开始的那个逆波兰表达式 分解成notation() × notation()的这种形式。这是我们分析得到的第一个结论。 那么在这样的一个基础上，既然这个notation()函数已经读取了这个×， 并且呢，把整个的这个表达式分解成了这两 部分，那么接下来呢，就分别由这两个notation()函数对剩下的表达式再进行分析。当然根据求解的顺序， 第一个notation函数先来进行分析。于是， 第一个notation函数继续读取下一个字符， 于是这个notation表达式读到了第2个运算符，除号。那么根据 逆波兰表达式的定义，既然我读到的是一个除号，那就意味着在这个除号的后面也存在两个互相独立的部分。 也就是说，这个notation函数如果遇到 除号，它就应该把以除号开始的那个逆波兰表达式分解为这种形式。 除号，然后两个互相独立的部分。与前面的情况相同， 虽然我并不知道这两个互相独立的部分从哪儿开始到哪儿结束它们是什么，我不知道。 但是我却知道它们每一个都是一个独立的逆波兰表达式。 所以说，它们的每一个都可以用一个新的 notation函数分别对这两个部分进行解析。 与前面的情况相同，也就是说，那么我们可以看得出来，notation函数 的第2个作用就是，当我遇到一个除号的时候，我就把以除号开头的那个逆波兰表达式 分解成为两个notation相除的 这么一个结果。 也就是这样一个结论。如果遇到除号，我就把以除号开头的 逆波兰表达式分解成为notation除以notation。ok， 按照这种方式，我们继续进行分析。 那么接下来呢，就由这个notation函数继续去读取 前面的字符串，这个时候呢，因为乘号 和除号都已经被读走了，那么它读到加号。 于是呢，这个notation函数就把以加号开始的那个 逆波兰表达式解析成为这种格式。 加号notation，notation。那么这个式子的含义其实就等价于 notation加notation。也就是说notation函数的另外一个作用， 如果遇到加号，我就把以加号开头的那个逆波兰表达式分解成为notation加notation。 那么同理，如果遇到减号，我就把以减号开头的逆波兰表达式 分解成notation减去notation。那么除此之外呢， 如果notation函数读到的第一个字符并不是一个 操作符，而是一个普通字符，那它应该怎么做呢？ 它就应该把这个普通字符开头的字符串解释为相应的数，然后返回。 那么通过刚才的这个分析啊，我们就分析清楚了notation函数的 几个作用。如果它碰到加减乘除，它就应该把 以加减乘除开始的逆波兰表达式解析成这种格式。 如果它遇到的是其他字符，那就应该把读到的字符串解释为相应的 数，这就是notation函数的 作用。那么基于这样的一个分析， 我们就可以写出notation函数的基本的逻辑结构。 在这呢，我们就用了一个switch语句。 那么每一个notation函数在开始的时候先 从缓冲区读入一个字符串，并且检查这个字符串的 第一个字符。如果这个字符串的第一个字符是加减乘除， 那么notation函数就把以加减乘除开始的 那个逆波兰表达式解析成相应的这种格式。 那么如果开始的这个字符是一个 普通字符。那我就把以这个普通字符开始的那个字符串 转换成相应的 数字返回出去。那么在这呢，我们用了一个以前我们曾经 讲过的字符串函数，就是把一个字符串转换成相应的 float类型，也就是转换成相应的浮点型。 我们讲过这是一个很常用的一个函数。那么基于 这样的一个函数，我们就可以写出整个的求解逆波兰表达式的 一个程序。ok，接下来我们来看一下这个程序。 
```C++
#include <iostream>
using namespace::std;
double notation()
{
  char str[10];
  cin >> str;
  switch(str[0]){
    case '+':
      return notation() + notation();
      break;
    case '-':
      return notation() - notation();
      break;
    case '*':
      return notation() * notation();
      break;
    case '/':
      return notation() / notation();
      break;
    default:
      return atof(str);    
  }
}
int main()
{
    cout << notation();
    return 0;
}
```  
那么在这个程序里头呢，我们定义了一个notation函数。这就是刚才我们所定义的那个 能够帮助我们读取逆波兰表达式并且返回结果的那个函数。那么在 主程序里头呢，我就调用并且打印了这个函数的执行结果。 好，那么接下来呢，我们就结合刚才的例子来分析一下 这个程序的执行过程。那么在程序运行起来以后啊， 这样的一串逆波兰表达式就作为一个 字符串输入给了这个程序。那么我们注意到在这个 字符串里头啊，操作符和想要表达的数字之间都用空格来隔开了。 也就是说啊，由空格把这样的一个字符串分解成了很多个小的字符串。 于是呢，我们在这个函数里头啊，就定义了一个字符数组str【10】， 用它来存放每一个读入的小的字符串。 比方最开始的时候，我们用cin来读取一个字符，那这个时候我们读到的应该是 乘号。 那么根据逆波兰表达式定义，这个程序呢当读到一个 乘号的时候，我就把由这个乘号所开始的那个逆波兰表达式 等效的分解成两个notation函数相乘的这样一个结果。 也就是说，当我们读到一个这样的乘号，那么整个的 这个逆波兰表达式其实就可以被分解成这个样子。 也就是分解成两个相对独立的逆波兰表达式的乘积。 然后呢每一个逆波兰表达式我们都用notation函数继续再去分析。 ok那接下来由第一个notation函数继续对 剩下的乘号以后的剩下的逆波兰表达式继续进行分析， 那么当这个逆波兰表达式在运行的时候，它首先去读入一个字符，它会读到除号， 因为得到的是除号，所以呢根据逆波兰表达式的定义， 就可以把由除号开始的那个逆波兰表达式分解成 两个逆波兰表达式相除。也就是说， 当我们读取到这个除号的时候，我们就可以把由这个除号开始的逆波兰表达式 等效的分解成为这个样子。 两个notation相除。然后 再接下来呢，再由这个两个notation中的第一个 继续对剩下的字符串再去分析。那么当这个notation函数去读取这个字符串的时候，它读到了 加号。那么当我们读到一个加号的时候，那么就意味着由加号开始的这个逆波兰表达式就可以被分解成 这个样子。也就是说啊，由加号开始的那个逆波兰表达式被分解成了 两个逆波兰表达式相加，并且呢其中每一个都是由notation函数去分析的。 那么第一个notation函数再去读取的时候，我发现后面是一个 字符串了，不是一个操作符了。于是呢我们就把这个字符串 转换成相应的数字，于是把12填在这里。 同理，后面的这个notation函数去读取的时候也是读取到一个字符串，36. 于是呢，它就把它也转换成相应的一个数字。 12加36.于是呢，那么在12和36都获取了以后呢， 这个逆波兰表达式的值也就有了，等于48. 它的值有了以后呢。由这个逆波兰表达式接下来再进行分析， 它再去读取这个字符串的时候啊，将会读到一个新的加号。 既然读取到的是一个加号，所以由这个加号开始的逆波兰表达式就可以被分解成 这个样子。那么其中的每一个又是一个小的notation函数去执行。 那么当这个notation函数去执行的时候读到了这个字符1，于是呢，把它转换成数字1. 当这个notation函数执行的时候呢，读到了这个字符3，于是呢，把这个字符转换成相应的数字 3.当1和3被读取完毕之后，这个逆波兰表达式的值也有了。 正如刚才我们讲过的，前一个逆波兰表达式的值是48， 后面一个逆波兰表达式的值是4， 它们之间呢，是相除的关系。 那么48除以4的结果12，就被返回到这个notation函数。 那么这个notation函数的值有了以后呢， 后面的这个notation函数又开始执行。这个notation函数呢 继续去读取剩下的字符串，于是它读到了减号。 既然读到的是减号，于是由减号开始的逆波兰表达式就可以 分解成这个样子，其中的每一个又是一个独立的notation函数。 那这个notation函数读取的时候呢，把15读取进来。 那后面的notation函数呢，把8读取进来。于是15减8 的结果7又被返回到这个notation函数。 ok，那现在呢，两部分notation函数都有了。 于是，12乘以7的这样一个结果 就被返回到最初的notation函数。 于是呢，最后打印出结果是84. 也就是说啊，整个的这个逆波兰表达式其实就等效于 这样的一个表达式。而它的运算结果呢，应该是84. 我们来看一下这个程序的执行结果。输入这样的一个字符串，我们得到的结果是 84.ok，这是这样一个题目。 当然了，对于逆波兰表达式的求解，这样一道例题啊，还是具有相当的难度的。 那么如果呢，把我们这个课上准备的例题把它的难度做一个星级评定的话， 那我觉得这个逆波兰表达式的难度呢，可以达到4颗星或者4颗半星， 一个比较高的难度了。所以说呢，大家如果一时不能够完全理解，千万不要着急。 你可以运行一下这个程序，慢慢地琢磨一下。 把这个程序跑一下，你就能够明白了。 **那么通过这个题目啊，我们可以初步感受到， 要解决类似的这种题目，我们完全可以先去假设 存在这样的一个函数，这个函数呢能够帮助我们解决问题。 然后呢在这个基础上再去分析，这个函数的实现方法**。 那么通过这个题啊，我们就可以有这样的一个初步的感受。 为了进一步说明这个问题啊，我们下面再看一个例子。 
## 7. 枚举、模拟与递归
- 大家好，欢迎大家选修李戈老师在coursera上的计算概论A的课程。我是课程的助教- 郝益阳。 今天，我给大家带来一节习题课，然后我讲以下几道题。 首先是我们作业的四大湖和流感传染这两道题， 然后之后我再讲一讲递归，如果你还没有看过递归的话， 到时候请先看老师递归的视频，然后再回头看这堂习题课。 好的，我们先从四大湖开始。四大湖这道题是一个典型的，我管它叫做枚举。 一遇到枚举的题目。枚举的题目是什么特点呢？就是我们首先把所有的可能性全部给列出来。 比如说在这道题里面，我们有四大淡水湖，洞庭湖、 洪泽湖、潘阳湖和太湖，然后它们的大小顺序 一共有多少种可能性。其实就是一二三四的一个全排序。 这样的话A44就应该是四三二一，四六二十四，除二 等于十二种。十二种可能性，把这十二种可能性全部遍历一遍就可以了。 但是在实际情况中，我们一共只有四个淡水湖。所以它的排序 并不是很多。我们可以完全从一一一，一直排序到四四四四这样排序，这样的话就有四四， 十六乘以十六等于二百五十六种可能性。我们可以直接遍历这二百五十六种可能性。 首先筛一遍看看有没有把两湖排到同样大的情况下，因为我们题目中说明了四个湖的大小均不- 相等。然后第二是， 再筛一遍，看四个人是不是每个人只答对一个。 对于这道题来说，大家一般来说没有太大的问题，但是这是 一个非常好的解决问题的方法，就是我们把所有可能性的情况全部列出来。 然后用程序一一地去筛，看哪些情况最后是剩下来的。 这种题目的难处就是在于怎么样去把那个所有的可能性全部给列出来。 像这种四大湖的话，它就是四个湖的 大小一二三四排名的一个全排序。但是对于别的题来说可能就不是很一样。 但是这是一种非常有用的思想。这种思想在之前做点评赛车那道题的时候 也是使用过，也是关于几辆车的那个最后名次的一个问题。 也是用一个枚举的方式去做的。 四大湖这道题，我看了一下同学们主要错在两个地方。 第一个地方是大家没有理解四个人没人仅答对一个是什么意思，有人就直接 看成了四个人中仅答对了一个，就是ABCD只有一个人说对了。 其实不是的，是A说了三句话，其中是三句中有一句是对的，剩下两句是错的， 大概是这个意思。然后， 出错的第二个点就是，有些同学没有去比较就是 四个湖的大小均不相等这个条件，它直接 枚举了一二三四，一共二百五十六种可能性，但是没有筛去 比如说洞庭湖和洪泽湖一样大的情况，没有去把它筛掉，然后输出了错误的情况。 基本上错误就犯在这两个，因为之前有一道点评赛车的题目，所以这道题 在算法设计上并没有太多的问题。 这是一道枚举的题目。接下来我说一道模拟的题目， 所谓模拟的题目就是有个明确过程的，比如说流感传染这道题。 这道题就是说在一个N乘N的一个房间的矩阵内，然后里面有 几个人他第一天就得了流感，然后他就会往四周，上下左右四个方向 的房间，传播他的流感这个疾病，但如果旁边是个空房间的话就不会被影响。 然后我们要输出的是M天后 一共这个整个N乘N的房间内有多少个人患病了。对于这么一道题呢， 我们的思路也是非常清晰的，就是去模拟把这M天从第一天到第M天的整个过程 全部模拟出来，最后输出最后M天那一天的房间的情况就可以了。 但是在这么一个模拟的过程中，有些同学就会顺序的去处理这些房间， 比如说在这里第八个房间，处理到第八个房间的时候它就会把第九个房间给标记成一个@， 然后接下来再处理第九个房间的时候就会发现第九个房间已经是有一个 流感的人了。然后他就会把，尝试把上下左右再重新标记成@，这样下来的话，肯定会出错。 因为第九个房间在当天是没有一个传染能力的，只有在第二天 才有传染能力。对于这个问题呢，我看了下大家的解决方案。 但解决方案基本上都是把它先临时标记成一个什么 别的一个字符，或者一个什么数字。然后之后再去把那些数字 再全部更新成@，这是一种处理方式，然后还有一种方式呢就是直接在这里 去标记一个数字。就是比如这第一天的话我在这里标记一个1， 然后呢之后循环循环到第二天的时候就把所有标记成1的房间的 上下左右再更新一下，更新成2，如果他是个 健康的人的话，我就把它更新成2。如果第二天的话再把那个标记成2的 房间的上下左右更新成3，然后如此类推，这样的话也是一种 解决方案，但基本思想就是要把当天的和前一天的人给隔开。 在这个模拟过程中，我们可以看出来，所有的房间的处理其实是一种并发的， 它并不是一个顺序的处理，并不是某一个房间要比另一个房间要先处理，而是所有的房间 是要理论上是要并起，并发处理的。然后这次处理的结果不应该影响下一次处理的结果。 所以说，对于这样的一种模拟题，就需要去在 建模的时候，考虑一下这个模拟的过程。 而不是单单地从，程序设计的难易程度去考虑。 如果只仅仅从程序的设计上来说，我们对于这么一个N乘N的矩阵，肯定是从0开始， 一个一个枚举过去的，但是在逻辑上我们需要区分一下不同的阶段。 接下来我给大家带来四道递归的题目。 递归是对于新学者来说是一个非常难以掌握的一个思想。 但是在程序设计中，它对于一些有递归性质的问题， 是有非常好的解决效果的。我们首先看一道题，是叫做括号匹配的简化版。 我们的那个作业里面有一道题是括号匹配，原题是说 里面会有一些括号， 然后括号里面会有一些文字像这个样子。然后，我们要在底下 另一行去标出那些没有被匹配到的括号， 比如说后面这两个。然后我们是用一个问号还是用什么， 好像是问号来标记一下。这样的话， 可以标记出来这，右边有两个括号是没有被匹配上的， 是这样一个问题。但因为对于我们这个简化版来说是不要这个文字的。 而且我们输出也不要输出具体它的位置，就是 只用输出这个整个字符串，它是不是一个完美匹配的括号 的情况，就可以了。 当然你不可能只去数它的左括号数和右括号数是否相等，这样肯定是不行的。 因为我把右括号放到左边，左括号放到右边它肯定是不匹配的，虽然它的数目可能是相等。 那对于这道题我们怎么样递归地去考虑它呢？ 我们知道括号是分层的，我们有左括号和右括号。右括号是对左括号的一个匹配。 那么哪一个右括号会匹配这个左括号呢？是在同一层上， 离这个左括号最近的右括号，就会跟这个左括号去匹配。 首先，什么叫做层呢？我们可以看见， 这个括号它是一个括号，因为这个左括号，这个右括号是匹配的，然后后面这个左括号右括号- 也是匹配的。 那么我们就认为这四个括号，这个左括号包括后面这三个符号，这四个括号是在同一层上的。 而里面的这三个括号对也是在同一层上的，是在另一层上的。 那么一个匹配的括号对 就等于N个括号的连接，而每个括号呢， 里面又是一个匹配的括号。那么我们怎么处理 一个乘以N这么一个形式呢，我们知道如果我们定义A 等于N个B， 其中A和B都是一个特定的字符串。那么我们可以这么去定义，它就等价于 A=BA， 或者空串，我们用 iii 来表示一个空串， 它就是这样一个格式。 对于这道题一个匹配的括号， 就等于括号里的一个匹配的括号，后面 加上一个匹配的括号，是这样一个定义的格式。这样一个定义就显然是一个递归性的定义。 其实之前也是一个递归性的定义，但之前的乘以N，并不是很好被程序来处理，后面这个就很- 好处理了。 我们可以不断地去尝试读取在字符串左边的匹配的括号， 然后再进一步处理后面剩下的字符串。我们可以尝试匹配左边的括号对，并且 再继续处理剩下的字符串。那么剩下一个问题就是我们怎么样知道右边 这个括号它在哪里呢？右边这个括号是在同一层上的与左边括号最近的那个右括号。 那么我们怎么去知道它呢？计算它的方法我们可以很简单的这样去想， 既然每遇到一个左括号，我就进入了下一层，每遇到一个右括号，我就出一层。 那么我们就可以用一个变量去每遇到一个左括号我们就加一，遇到一个右括号就减一。 然后如果比如说我要再找跟这个括号对应的右括号，那么我们再往里面走，如果遇到一个左括- 号+1， 遇到一个右括号-1，然后一直找，找到最后遇到这么一个右括号的时候， 正好把那个值减回刚开始的那个值比如说是0的话， 那么你就知道现在找到的右括号一定是第一个跟左边括号匹配的右括号。 这是一种非常直接的寻找它的方式。但这样寻找它的方式好不好呢？ 显然是不好的。为什么呢？因为它速度太慢了。 我们在找这个右括号的过程中实际上已经把中间的这些括号 全部给找了一遍，然后遍历中间这些括号的时候并没有去处理我们 遍历它得到的数据，而直接扔掉它，之后我们再去尝试匹配中间的 左括号的时候我们又要在中间重新遍历一边。这样是非常低效的。 我们可以尝试在匹配外层的左括号的时候就把内层的左括号已经都匹配上，这样的话我们就会- 用到一个递归的一个算法 来匹配他。我们希望解决子问题的时候，获得一个 我们想利用解决子问题来解决我们的父问题。 在这道题里面，我们的父问题就是找到右边这个 右括号，然后我们的子问题是匹配中间的这些括号。 那么我们设定一个递归函数， 比如F，那么它就应该有一个返回值，这个返回值就是它上一层的那个右括号的位置， 因为我们只有在递归的去遍历完内部的子括号之后我们才能知道上一层的右括号在哪里。 那么我们这个函数就应该有一个返回值，比如说是E， 这个E的返回值就是对应的，就是它上一层的右括号的下标。 这个函数会有参数，一个是字符串的参数，然后还有一个是 它开始的位置。因为在某一层上我们必须要标明它是在哪个位置开始的。 然后这个函数还需要另一个返回值。那一个返回值就是它内部的 这个字符串到底是不是一个匹配的符号对。 如果里面呢它不是一个匹配的符号的话，那么外面一层呢肯定也不是匹配的符号。 这是一个基本思想。所以它应该还有一个返回值，是一个波尔类型的。 而上一层的右括号的位置是一个INT型的返回值， 那么我们有这两个返回值，这个函数就可以发挥我们的功能了。 好的，那么如果我们F这个函数可以解决在 STR这个字符串里面从S的位置开始， 进行匹配，直到它遇到上一层的右括号的位置， 并且，如果它在匹配的过程中失败了，那么它会返回一个false， 否则返回TRUE。如果我们有这么一个函数，那么它的上一层的代码应该怎么写呢？ 首先我们要判断这个字符串是否为空，如果 字符串是空的话， 当然我们在程序实现的时候并不能这么写我们要用字符串的长度来匹配， 如果它是个空的话，我们直接return true。 如果它不是空的话， 那么我们就首先要判断这个字符串第一个 是不是左括号。如果第一个是左括号的话 那么我们就会尝试匹配里面的这个小括号。 然后它的开始位置就是1，因为我们左边的这个括号是0。 然后再加一个位置， 然后我们用变量B和变量N接收这个函数的返回值，如果里面这个字符串并不是一个匹配的- 符号串， 那么我们就可以直接返回FALSE,否则我们就在 N+1的位置继续匹配。因为我们当前这个字符串已经匹配完了， 然后它返回了右边这个括号对的位置是N，那么我们就继续匹配右边的这一块。 我们继续调用这个F。这就是它匹配这上一层的括号时候所需要的代码。 我们把上一层的代码直接原封不动的拷贝到这个子函数的代码中，因为它的 解决的问题完全是一样的。然后我们把相应的位置进行一下修改。 比如说这个函数，这个字符串开始的位置应该是S， 我们是指的是当前这一层开始的位置。然后这个E应该是S+1，是 这个左括号右边的位置。然后再做一个判断。如果这个字符串并不是以左括号开头的， 那就是说它是以右括号开头的，那么它肯定不是真的，我们返回一个FALSE。在这里判断- 空串的时候我们 并不能直接判断整个字符串是否为空串，我们实际上判断的是 当前这一层是不是一个空串。也就是说这个S是不是已经到了这个 字符串的结尾处。如果到了结尾处那么我们认为已经完全匹配完了，我们返回一个TRUE。 然后要改的第二点是在这里。如果这个函数是以一个右括号开头的， 当然如果它是在最上层的话，那么它肯定是一个FALSE。 但是呢如果这个函数运行是在某一层里面的话， 它碰见后面的一个右括号实际上这是要返回到上一层的意思，所以我们并不能直接返回FA- LSE, 我们要返回TRUE。同时我们要返回后面那个右括号的位置，也就是 S。我们还差最后一步，那就是匹配这个右括号，我们写在这里。 如果里面的字符串的匹配结果返回的是一个右括号的话， 那么我们继续做后面的匹配，否则 我们RETURN一个FALSE。代表匹配失败了。 这样一来我们整个函数就完全写好了。 这个函数完全是按照这条公式来写出来的。 首先我们判断这个是不是一个左括号，然后呢如果它是左括号的话， 我们去匹配这个左括号里面的东西，匹配完了之后我们再匹配后面的右括号。 匹配完右括号之后我们再去匹配右括号后面的东西。 如果其中某一步出问题了我们都会返回一个FALSE, 否则都会返回TRUE。那么我们怎么在主函数中使用这个函数呢？ 首先我们假设我们输入的这个字符串就是STR，那么 我们调用F，STR 0，从第一个字符开始匹配， 我们的返回值分别是用B和 N来表示，那么， 如果匹配成功了， 我们输出YES， 否则，我们输出NO。这样写行不行呢？ 其实是不可以的。为什么呢？因为我们这个函数F实际上 表示的意思是从字符串STR的S位置开始 进行匹配看是否能够成功匹配一个 匹配的括号，并没有说这个STR本身它就是一个匹配的括号。 也就是说，我们必须得确保这个F确确实实的把整个字符串匹配到了。 那么我们就在这里需要判断一下返回的N。但是呢我们在代码中并没有写好这个N的返回值， 因为N在这里实际上对应的是在这一句话上，也就是说匹配到这一个字符串的末尾处了。 那么我们不仅要返回一个TRUE，我们还要返回一个特定的值，比如说-1， 于是我们在这里做判断，N==-1，我们输出YES。 利用全局变量来 实现多返回值的函数可以是这个样子，我已经实现了一下。我们可以在函数之前定义另一个全- 局变量， 保存另一个返回值，然后在返回的时候我们利用一个 括号表达式，在这里，这个括号表达式的意思是我们首先计算逗号前面的东西， 然后最后以逗号右边的值为整个表达式的值，比如说这个表达式的 值就是-1，但是在计算-1之前它先计算了B=TRUE，先把B赋值为TRUE。 在这里，底下也多次用到了这个表达式，它最终返回的是逗号右边的值，但它也做了前面的值， 这个逗号表达式也可以加多个逗号，然后加入多组表达式，这些表达式就会以从左往右的顺序- 依次执行， 最后返回最右边的值。接下来我给大家讲一个双递归的题， 什么叫双递归呢？双递归其实也是递归的一种，它跟递归 的不同就是对于一个普通的递归，我们是在一个函数F里面 它会等于它自己的一个状态， 比如说这是X+1=fx+1，像这么一个状态转移方程，这个是很明显的一个 单递归的一个，或者说普通的一个递归函数。那什么叫 双递归呢？双递归就是说在一个函数，它本身 它等于另一个函数，这个很正常，但是另一个函数呢 却等于这个原来这个函数。像这样一个问题， 我们加上一，这样一个双递归的函数 跟原来这个是完全一样的。当然你也可以用数学的方式直接把这个带入进去， 把这个G+1给带进去之后变成一个FX 减 1 加 2，这么一个结果，也是完全可以的，跟刚才那道题在计算 一些数的时候是等价的。那双递归它有什么用呢？ 比如说我们来做这么一道题啊。 是判断一个数是奇数还是偶数。我这个问题说出来 你们肯定就知道该怎么做了，我们直接取一个余数，对2取一个余数，看它余数是0还是1就- 可以解决问题了。 但是呢，我们这么去定义奇数和偶数啊。 我们对自然数进行定义，如果，首先0它是个偶数， 这是第一个定义，0是偶数。 第二个定义，如果x是偶数， 那么x+1是奇数。 如果x是奇数，那么 x+1是偶数。 这样看起来很多余的一个定义，但是我们就这么定义，然后我们怎么去 做这道题呢。然后我们这道题的输入，比如就输入一个x，然后输 出就是，就是 它一个true或者true or false吧。 好，那这道题我们的主函数怎么写呢？主函数很简单，就是 cin 一个x，这谁都会，然后呢，我们去 用一个函数，比如说f，我们还用f吧，f（x）， 它的返回还是iii，true或false，如果f（x）真， 输出true， 否则输出false。 这么一道题，跟刚才那个有异曲同工之妙，但这个f这个函数怎么写。 我们判断这个x是否是偶数吧。 好，那么这个，我们换个名字，不叫f了，我们叫做isEven， 如果x是偶数的话，isEven它就是返回为true，如果它是奇数的话， isEven就返回为false。然后我们再定义一个函数叫做isOdd， 这个函数呢也是输入一个x，如果它是奇数的话，那么就输出 true，返回true，如果它是偶数的话，那就返回false。 那么这个奇数这个东西怎么写呢？其实非常简单，return !is Even(x-1)，是不是很简单？ 因为就像我们刚才说的，如果 x是奇数的话，那意味着x， x是奇数，那么意味着x-1，在这里是x+1，这里应该是x-1，呃， x-1那么它就应该是一个偶数。然后我们再定义偶数。偶数怎么定义呢？非常简单。 如果它前面那个不是奇数的话，那么它就，呃，前面那个东西，哎，错了错了， 错了错了，应该是这个样子啊。 如果它前面那个是奇数的话，那么它现在这个就应该是偶数。 但是偶数还有个情况，就像我们刚才说的，0是偶数，那么， 我们这里应该加一个，x==0，或者， x-1是奇数。好的，这样我们一个奇数偶数的问题就用一个双递归的函数解决了。 是不是显得很多余呢？但是它确实是一种解决方式，而且我们管这种方式，这种，呃， 两个函数或者多个函数轮流互相调用的一种情况，就叫做多递归，多重递归。 这跟单递归在形式上有些区别，当然你也可以直接用一个函数了。 像是isEven的话，我们可以直接把isOdd这个函数给删掉，我们直接说 !，呃， isEven，也是可以的。因为这道题比较简单， 所以它是可以把它转化为一种单递归的解决方式的。 但是只跟大家说一下有这么一种解决方案叫做双递归。 双递归用的地方并不多，而且所有的双递归、多递归其实 都可以转化为单递归，只是说返回值有区别。 像刚才那个的话，我们只用判断它是true就行了，但是现在的话我们要判断它是个fa- lse。 就是要前面加一个！，或者说后面iii false。 这样的话，它对返回值的一个状态有一个要求。 仅此而已。 