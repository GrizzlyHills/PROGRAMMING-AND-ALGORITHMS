# [C程序中的函数](https://www.coursera.org/learn/c-chengxu-sheji/home/week/2)
> 本次课，我们讲授“函数”的基本概念、定义方式、调用方式、参数传递方式等基本知识。其间，我们还将讨论“变量的作用域”的问题。

> PS：我们这门课程一直处在不断地建设与优化当中，吸取了很多以往课程的经典视频，所以如果你看到视频中出现了不同课程的名字，也不要惊讶哦，因为你正在集百家所长：）
## 1. 函数的定义与声明
- 好，各位同学大家好。那么在讲完了 理性认识C++程序这个部分之后啊， 我们从这次课开始进入我们第三个迭代周期。 就是关于C程序中的函数。 函数这个部分啊对于C程序而言是一个非常重要的部分。 那么在这个部分呢，我们计划讲两次课。 今天呢是第一次。那么今天呢，我们先来介绍一下 关于C程序中函数的一些基本的知识。 那么我希望呢大家要重视这个基本知识的学习。那么把一些基本的概念 掌握好，那么这样呢，到了后面比较难的部分，啊我们才比较容易应付。OK，那么在 这个部分呢，我们将介绍这么几部分的内容。
  - 第一个关于函数的定义，也就是说怎么去定义一个函数。 
  - 第二个部分我们讲一下函数的执行过程。 那这个部分呢，我觉得还是比较重要的一个部分。
  - 第三个，那么 有了函数之后，我们讨论一下函数中的变量的作用范围。 
  - 第四个部分呢讨论一下数组与函数。啊其实， 重点就一个数组名作函数参数。最后呢，我们举一个简单的例子来说明一下函数的作用。
- 好，我们先来看第一个部分，函数的定义。 
  - 说到函数呀，一说到函数这个词儿， 啊基本上我们的脑子里头啊立刻就会浮现出来传统意义上数学里面的函数。 像y=f（x），啊这是我们脑子里面关于函数的 最普遍的一个认识了。这样的一个函数呢其实就描述了一个过程。 也就是说对于两个变量x和y，如果呢， 对于x的每一个确定的值，y呢都有唯一确定的值 与它对应，那么我们就说x和y形成了这样的一个函数关系。 而且呢在这里我们把x称作自变量，y呢称作 因变量。啊这是我们脑子里面最熟悉的函数 的那个样子。那么在C语言里头函数长成什么样子呢？ 那么在这儿啊，我就列出来了一些在C语言里头非常非常 常用的函数。这些函数呢都是在我们写程序的过程中非常非常常用的。 我们先来看一下它的样子。 比方说第一个，如果已知一个数的话，我们要求它的平方根， 那么我们就可以用sqrt，啊这是我们碰到过的。 输入写到这里头，然后呢，它就会返回一个平方根的值。第二个， 如果已知底数x，幂指数y，我们要求x的y次幂。 那我们可以用pow这样的一个函数pow。 它有两个输入参数x和y，那么把x，y写在这， 那么我就可以获得x的y次幂是多少。啊这两个呢都是一个 很常用的两个数学函数。那么下面呢，还有三个，这三个呢都是关于字符串的。第一个， 如果已经有一个字符串的话，我们要求它的长度，我们就可以用strlen这个函数， 它就会返回字符串的长度。那如果你想比较两个字符串的大小，就是看它们 字母的优先级的顺序以及长度，啊来比较大小。 那么如果比较大小的话，你就可以用strcmp这样一个函数。 它呢会返回一个值代表它们的大小关系。第三个，这个也非常非常的常用。 如果你已经有一个字符串，这个字符串里面呢都是一些字符形式的数字，比方说， 啊有一个字符串1，2，3，4，5，那这是一个字符串啦。 那么如果我想把这个字符串啊转换成它对应的数字，比方说 转换成12345，啊想转换成一个这样的数。 怎么办呢？你就可以用这样一个函数，atoi，就是area to int。 非常好用的一个函数。那这样呢你输入一个字符串，你就可以获得跟这个字符串相对应的一个整数了。 这是五个非常常用的这个函数。大家在写程序的过程中如果想用， 那你就随便用，没有问题，包括在我们的作业和考试里面，啊我绝对不会给你限制。 我们来观察一下这些函数。你看这些函数啊， 基本上它都满足这样的条件，给出一个输入，有一个输入的参数， 对于这个输入呢这个函数会返回一个与这个输入相对应的输出。 这个输入就相当于这个x，这个输出呢就相当于这个y。所以说你看， 其实在C程序里面的这些函数跟我们平常意义上我们认为的函数它其实是一样的。 正如我们在图灵机那个部分曾经讲过的， 任何一个计算机程序其实都可以被看作一个函数。因为 它都会处理一些输入的数据，并且给出来一个相应的输出。 所以说，我们才能够把程序表示为函数。 所以说在C语言里头，我们可以把所有的程序都组织成函数。这就是C程序中的函数之所以存在的道理。 OK，那么在C程序中我应该怎么去定义一个函数呢？也就是说我想定义一个 自己的函数，那么在C程序中我应该怎么去定义呢？我们来看一下函数如何去定义。先来看一个例子。 
    ```C++
    #include <iostream>
    using namespace::std;

    int absolute(int n)
    {
        if(n < 0)
          return (-n);
        else 
          return n;
    }
    int main()
    {
        int m = -123,result = 0;
        result = absolute(m);
        cout << result;
        return 0;
    }
    ```
    这是一个很简短的一个例子。但是在这个例子里头呢， 有些程序是我们所熟悉的，有些我们不太熟悉。比方说，啊这两行，这是我们熟悉的。 下面啊main函数的部分也是我们熟悉的。 那么除了这个熟悉的部分之外，中间的这个里这个部分其实就定义了一个 函数。这个就是定义了一个函数。这个函数的名字呢叫做absolute， 它的作用呢我可以先告诉大家，它是一个用来求一个数的绝对值。在这个函数的名字的后面， 啊有一个括号，括号里面呢会写入 输入参数，那么当你定义一个函数的时候呢， 就需要在这列出来所有参数的类型。那么同时呢你要指定一个函数的返回值， 就是说这个函数可能会返回什么类型的值。有的同学说，我为什么需要指定一个函数的返回值的类型啊，我干嘛要指定这个东西啊。那是因为你之所以定义这个函数，你的目的是希望别人在程序里头调用你这个函数。 那如果别人不知道你这个函数可能会返回一个什么类型的值，他就没办法去调用了，或者调用起来就变得非常困难。对这个程序而言，比方说我的主函数里头，我就调用了这个函数。啊有一个变量， 叫result，用来存放结果的。result里头存放什么结果呢？ absolute(m)，m呢是我定义的一个变量，它是-123，把它当做一个参数传递给这个 函数。我期望从这个函数呢获得一个返回值，给这个result。 那么既然我希望从这个函数获得一个值，那我就否则我连定义一个什么类型的变量去接纳这个返回值，我都不知道。 所以说一定要指定返回值的类型。 OK。那么在写完了这个函数的名字的部分之后呢， 我们就在底下用一个大括号写出来函数体。 把所有的函数的执行过程、执行语句全部都写在函数体里头。 那么需要注意的是呢，在这个函数体里头啊，首先你就可以用你刚才在 这个参数定义部分所定义的这些参数，你就可以引用它了。其次呢， 因为你在函数的定义部分指定了函数的返回值，所以说你一定要在函数里面返回一个相应类型的一个值。否则的话你就不满足函数的这个定义了。 那么通过这种方式，你就定义了一个函数。那么在这个程序里头啊， 我们把函数输入参数里面这个n称作形式参数， 啊简称形参。 也就说这个参数啊是一个形式上的参数，并不是真正让函数执行的时候 传给它的那个参数。这个参数啊只是用来辅助进行函数的 定义的。这叫形参。那么在函数运行的时候实际上传给 它的这个参数，也就是这个m被称作实际参数，简称实参。 也就说实际运行的时候传给它的这个参数。 这两个概念今后就是我们非常非常常用的两个概念。 那以后啊当我们提到形参的时候，我们指的就是函数定义里头定义的这个 输入参数。它是用来辅助定义这个函数的。那么当我们提到实参呢， 就是真正要运行这个函数的时候，我们传给这个函数的参数。 
    - 那我们来总结一下，如果要定义一个函数的话，你需要指定函数的名字，并且呢给出来一个输入参数的列表，并且指明 每一个输入参数的类型，然后呢要说明输出也就是返回值的类型， 在这个基础上给出相应的函数体，这样呢我们就完成了一个函数的定义， 
  - 当然在这定义的函数呢，它只有一个参数，当然你也可以定义具有多个参数的函数。 比方说这个函数，
      ```C++
      #include <iostream>
      using namespace::std;

      float max(float a,float b)
      {
          if(a > b)
            return a;
          else 
            return b;
      }
      int main()
      {
          int m = 3,n = 4;
          float result = 0;
          //result = max(n,n);
          //cout << result;
          cout << max(m,n);
          return 0;
      }
      ```  
      那么在这个程序里头呢，我们就定义了一个包含两个输入参数的一个函数， 这个函数的名字叫max，它的作用 就是返回两个输入参数中比较大的那个数， 比较大小，然后返回那个大的数，它的两个参数都是float型的， 而且它定义了那么返回值也是float 型的， 那么函数体也很明确，如果a大于b就return a，否则的话就return b。 当然无论a和b都是float型的，所以说满足返回值的这个条件。那么要调用这个函数的时候也极其简单， 我们就把相应的变量，比方说m和n是两个定义好的变量，传递给这个函数，然后呢我们就从这个函数获得了一个m和n里面比较大的一个值，作为一个返回值。有的同学可能发现了， 你这个程序写的太啰嗦了，你为了求3和4的值还定义了这么多的变量，其实不用定义，如果简化一下这个程序的话，我完全可以写成这个， 直接c out， c out max（3，4），有的同学说这行吗，能这样写吗？ 因为max是有返回值的呀，你在这呢你直接写出来它的值你往哪返回呀， 允许这样写吗？首先说这样写完全是允许的。那么函数的调用， 不一定我们非要搞一个变量去接纳它的这个返回值。函数的调用呢，是有多种形式可以选的。 
      - 根据函数在程序中出现的位置和形式，那么函数的调用呢可以分成以下三种， 也就是说任何一个函数我都可以以以下三种方式来调用它： 
        - 第一个就是作为**独立的语句**，就像刚才我们所看到的， c out 直接max （3，4） 没有任何问题，这是一种调用方式。`stringPrint()`
        - 第二种调用方式， 它可以**作为表达式的一个部分**，也就是说它可以写在一个式子里头，参与计算，比方说max（numA，numB） 然后呢，我直接把这个函数的调用写在一个表达式里然后除以2，没问题，这也是允许的。 `number = max(numA,numB)/2`
        - 第三种形式， 作为**实际参数出现在其他函数的调用中**，这也是可以的，比方说，我们想调用一个函数，叫min， 它有两个参数，第一个，第二个， 那它第一个参数呢，我们就可以直接写一个函数调用在它参数的这个位置， 也就相当于我们要拿这个参数函数调用返回的值， 当作min函数的这个输入参数之一，这个也是允许的， 这三种调用方式都可以。所以说刚才我们所讲到的这种调用方式是没有任何问题的。 那我们可以这样去调用。 好，这是具有两个参数的函数。`number = min(sum(-5,100),numC)`
      - 那能不能定义没有参数的函数呢？当然可以，我们看这个例子，
        ```C++
        #include <iostream>
        using namespace::std;

        int get_int()
        {
            int n = 0;
            cout << "Please input an integer:" << endl;
            cin >> n;
            return n;
        }
        int main()
        {
            int result = 0;
            result = get_int();
            cout << result;
            return 0;
        }
        ```     
        那么在这个例子里，我就定义了一个函数，它没有任何的输入参数，那这个函数的作用呢？ 其实就是帮助程序员用来完成输入的，首先它打印出一行please input an integer，输入一个整数， 然后它接着cin把这个数读进来，然后立刻返回读入的这个数， 把这个数当作返回值返回出去，它没有任何的输入参数，这也是没有问题的，这是可以的。 在主程序里，调用这个函数，就可以完成一个整数的输入了， 这也是没有问题的，没有任何的参数。
    - 不但是没有任何的参数是可以的， 没有返回值照样是可以的。再看这个程序，
        ```C++
        #include <iostream>
        using namespace::std;

        void delay(int n)
        {
            for(int i = 0;i < n*100000;i++);
            return;
        }
        int main()
        {
            for(int j = 0;j < 100;j++){
                cout << j << endl;
                delay(1000);
            }
            return 0;
        }
        ```     
      在这个程序里头我也定义了一个函数， 名字叫做delay，看到这个名字我们就可以想象这个函数的作用。 这个作用是干嘛呀？ 作为一个延迟的，有的时候在程序里头特别是输出的时候， 我们希望做一些延迟，它一个一个的来慢慢的输出， 那我们就可以构造一个类似的程序。当然这种方法并不是最好的，如果你真的想使用呢， 在C程序的库里有一些专门用来做延时的函数，你可以去使用。 在这呢，我们做一个例子来看一下。 既然是做延时，所以说这个函数啊我只需要它做事情，不需要它返回任何的值， 这个函数我们这样来定义，delay 它有一个输入参数n， 这个n来指定我循环多少多少次，当然为了取得延时我们给它乘了10万 用这个for循环来实现这个延时，当然这个方法很奢侈呀， 那么执行完这个延时以后，它也应该结束了， 那么结束的方式有两种，一个呢你可以写一个return， 因为我不需要它返回任何的值，所以return后面不需要写任何的数据，第二种方式你也可以不写， 不写也是可以的，既然这个函数没有任何的返回值， 我就需要告诉别人这个函数不会返回任何的东西， 于是我在定义这个函数的时候，我就指明它的返回值是void，也就是空返回值， 它不会返回任何的东西，你需要说明这一点。那么调用这样一个函数也是， 直接调用就可以啦，比方说我们在这，在for循环里头我们就可以调用这个delay， 也就是说函数不一定非要有一个确定的值返回，不返回值也可以， 
    - 还有一些函数呢，既不需要参数也不需要返回值， 比如说这个函数show， 
        ```C++
        #include <iostream>
        using namespace::std;

        void show()
        {
            cout << "**********************************************************" << endl;
            cout << "*            System error has occurred.                  *" << endl;
            cout << "*          Please contact  the administrator.            *" << endl;
            cout << "*          Sorry for the inconvenience.                  *" << endl;
            cout << "**********************************************************" << endl;
        }
        int main()
        {
            show();
            return 0;
        }
        ```     
      这个函数的作用呢，它就是为了在屏幕上打印这些字符， 这就是当系统碰到错误时我们经常用的一个输出，那么为了省事， 不用每次都写这个输出，于是我就干脆定义了一个函数，这个函数 不需要任何的输入参数，也不需要任何的返回值，那么调用的时候呢我就直接调用它就可以。 那么通过这个讨论我们就能感受到，我们可以根据自己的需要， 定义任何类型的函数，它可以有返回值，也可以没有返回值， 它可以有输入参数也可以没有输入参数，也可以有多个输入参数。anyway，根据你的需要去定义。 
    - 那么除了这些之外还有一个函数，是我们每次写程序都需要去定义的， 那就是main函数。大家还记得这个程序吗，这个程序呢是 在这个课上我展示给大家的最简单的第一个程序。 其实这个程序的目的就是为了定义这个main函数， 说到这我们终于能够掉回头来解释一下这个main函数了。 看看这个程序，在main的后面，也有一个括号， 那我们现在知道其实这个括号是用来放输入参数的， 那么我们之前写的程序里头呢，这个括号里头都是空的，其实啊， 这个括号里头是可以写东西的。main函数是可以带参数的，如果有时间的话，以后我们还会提到这个问题。 那main函数呢，还有一个返回值，约定呢是int类型的， 也正是因为main函数要求有一个int类型的返回值， 所以说无论这个程序执行什么东西，到最后啊我们都要 返回一个整数给它。如果我们没什么想要返回的， 那我们就写return 0，这个return 0就有两个作用，一个作用是结束当前的main函数， 另一个呢就是要满足函数返回值的这个要求。 那说到这我顺便来解释一个问题， 有的同学可能在一些资料上看到，说老师我看到它们的main函数是这样来定义的， void main， 然后呢，因为它是void，返回值是空， 所以说我也不需要写return 0， 那用这种方式来定义main函数可以吗？ 那这两种方式又有什么区别呢？稍微回答一下，那么这种定义方式是老的C标准允许的一种定义方式。 现在我们所使用的返回值为int 类型的这种定义方式呢， 是新的C语言标准所要求的一种方式。 当然在一些编程环境里头， 仍然兼容了老的这种方式，也就是说你仍然可以用这种方式。 它们两位有什么区别呢？ 老的这种方式因为返回值是空，也就是说它不会返回任何的东西， 所以呢调用这个main函数的程序体没办法获知， 这种类型的main函数它执行的结果到底如何，这就是它的一个小的弊端。 所以说新的编程环境往往都要求大家使用这种新的方式来定义。 那为什么要在程序里面一定要定义main函数呢？ 因为main函数是程序执行的入口，那么有了main函数， 我们就可以在这个基础上定义任何其他的函数。 那么在一个程序里头我可以定义多少个函数啊？多少个都可以。 啊，你可以定义多个函数。有的同学说，那一个文件我得写多长啊？ 
    - 其实啊，你可以在一个程序里头写多个文件。 啊，也就是说，一个程序啊，可以由多个源文件来组成。 那一个源文件里头呢，又可以包含多个函数。 啊这都是允许的。只要你有一个 main 函数，作为执行的入口，啊就可以。 比方说刚才的那个程序啊，我们就可以把它拆分到多个文件里头。 看这个例子。在这个例子里头啊，我就把一份程序， 拆分到两个文件里头。 其中的一个文件包含了 main 函数。 包含 main 函数的文件呢，我们把它命名作 compare.cpp ， 这是我们平常保存文件的那种格式。啊， cpp 文件。那么除了 main 函数之外呢， 比方说我还定义了这样的一个函数。那这个函数呢，我可以把它放在 max.h 这个文件里头。 然后呢我们把这两个文件都放在同一个目录之下。那怎么才能说明它们两个连起来呢？ 在包含 main 函数的这个文件里头我可以写这样一句，include max.h， 然后呢，用双引号把它引起来。通过这种方式，我就可以把这两个文件连成一个程序。 那么它的效果呢，就跟放到一个文件里头是完全一样的。在这儿呢，也做一个小的说明。 **有的同学可能要问了，在这儿为什么要用双引号？为什么不能用这个间括号呢？ 那么在微 C 的环境之下，这跟微 C 的变应切所默认的搜索入境是有关系的。 那么如果你使用这个间括号，那么它就会默认的去搜索那些系统函数库所在的目录。 如果你使用双引号，啊它就会优先去搜索当前的这个目录。 啊然后呢，再去搜索系统函数库。 所以说，使用双引号才能确保它能够找得着我们所定义的这个 max.h 这个文件**。 Ok ， 这就是关于函数的定义。那么在这儿呢，还想给大家介绍一个概念。就是说啊， 所有的函数，其实也是有类型的。 
- 那什么叫做函数的类型呢？ 其实很简单。**函数的类型啊，是指函数的返回值的数据类型**。 也就是说，一个函数，它会返回什么类型的数据， 那这个函数本身的类型，就是什么类型。 啊比方说 main 函数， 因为它会返回 int 类型的数，所以说我们说 main 函数的类型是 int 型。 那有的同学说，哎呀，为什么提这样一个概念，听上去怪怪的。 啊，没关系。 你呢，先记得这样一个概念。啊，有这样的一个印象。 以后啊，会用得着的。啊，也就是说，以后用得着的时候，你想起来， 啊，函数的类型指的却是它，就是它的返回值的类型就 Ok 了。 这是关于函数的定义。 那么，说完关于函数的定义啊，我相信大家就算是比着葫芦画瓢， 也能够定义自己的函数了。在一个程序里头，我可以定义很多个函数。 那这些函数我应该定义在哪呢？是不是我都必须把它定义在像 main 函数和预定义部分之间呢？ 啊，定义在这个地方呢？我能不能把函数定义在 main 函数的后面呢？ 可以吗？可以。 可以。但是，当你把一个函数定义在 main 函数的 后面的话，那么你就必须得在 main 函数的前面多写一句， 先声明一下，啊，有这样一个函数。 比方说，看右边这个程序。因为我把函数的定义挪到了 main 函数的后面， 所以说，我在 main 函数的前面多写了这样一句定义。 首先解释一下为什么要在前面写这一句。定义器啊，在解释你所写出来的这个程序的时候啊， 是按照从上往下的这样的一个顺序来解释的。 那么如果你把函数的定义写到了后面， 在前面呢，又没有进行说明。那么当定义器 读到 max 的这个东西的时候啊，它就不知道这个东西是什么。 那么就产生了一个疑问，这个东西是个什么呀？它到底是个变量呢， 还是一个标示符呢，还是一个什么东西？这就不知道了。 所以说啊，如果我们把函数体定义在 main 函数的后面，我们就需要在 main 函数的前面 写这样一句。在明白了这个原因的基础上，我们再来讨论一下我们写下来的这个东西。 这个东西是什么呢？我们所写出来的这个东西啊，被称为函数的原型。 
  - 那什么叫做原型呢？一个函数的原型啊，首先包含了这个函数的名字。 然后呢，包含了这个函数的所有的输入参数的类型。 需要强调的是，只需要给出来类型就可以。再一个呢，需要指定函数的返回值的类型。也就是说，所谓函数的原型，其实就是指 返回值的类型加上函数名再加上参数的类型。 对于任何一个函数而言， 只要你告诉了我，这一些东西。你看，我是不是 从形式上我就应该能够去调用这个函数。 比方对于这样一个函数， 啊，如果它的原型是 `float max (float, float)` ， 那我就可以知道，如果想调用这个函数，它有两个参数。这两个参数的类型都是 float 的类型的。而且呢，这个函数会返回一个 float 的型档结果。 从形式上我就可以去把握它了。 所以说啊，拿到一个函数的原型，我们就可以知道该怎么去调用这个函数了。 当然，仅凭这个函数的原型， 我们并不能确定这个函数做了些什么。 啊，但是呢，它的调用的形式，我们就已经可以掌握了。 啊，这就是函数的原型的作用。 
- Ok, 所有这儿稍微做一个总结，啊关于函数的原型和函数的声明。 
  - 所谓函数的原型，啊是指由函数的返回类型，函数名以及参数表所构成的一个符号串。 啊，其中呢，参数可以不写名字。啊，比方说 `bool checkPrime(int)` ， 我就可以知道，这个函数的名字，它的所有参数呢， 只有一个是 int 类型的。那它的返回值呢，是 bool 类型的。 正因为获得了一个函数的原型，我们就知道 如何去调用这个函数了。所以说我们又把函数的原型 充作这个函数的 `Signature` 。那么很多地方把这个 Signature 翻成`函数的签名`。Ok, 也行吧！啊，就是一个名字而已。 那么在软件工程里面呢，我们通常把这个东西称作`函数的基调`。 
  - Ok, 那么，如果一个函数它的定义不肯被写在 main 函数的后面， 我们就需要利用函数的原型来对函数做一个声明。啊，就是在使用函数前都要进行声明。 除非被调用的函数部分出现在主函数之前。 也就是说，在 C 语言中，啊，那么对**函数进行声明， 使用的就是函数的原型**。 这是刚才我们所讲过的。 
## 2. 函数的调用过程
- 那么在了解了函数的定义以后啊， 我们来看一下函数的执行过程。 那么函数的执行过程是这节课的一个重点。 那么只有了解了函数的执行过程，才能够 对函数的运行方式， 有一个比较深入的了解。我们先来看一个例子，这个例子刚才已经被引用过很多遍了。
    ```C++
    #include <iostream>
    using namespace::std;

    float max(float a,float b)
    {
        if(a > b)
        return a;
        else 
        return b;
    }
    int main()
    {
        int m = 3,n = 4;
        float result = 0;
        //result = max(n,n);
        //cout << result;
        cout << max(m,n);
        return 0;
    }
    ```  
   那么在这个程序里我定义了一个函数，他叫Max，它有两个输入参数。 那么在主程序里我定义了两个变量，m 和 n，然后调用了Max这个函数。 那么这个程序是怎么运行的呢？ 或者说我们应该按照一种什么样的方式去理解， 或想象这个程序的执行过程呢？ 那么为了让大家有一个比较直观的了解，我希望啊， 大家能够这样来想象这个函数的执行。比方说， 这片蓝色的区域就是我们的内存，我们要在蓝色的这片内存空间里面， 运行这个程序。 大家都知道Main函数是程序运行的入口，那么为了运行这个程序，系统 首先要在内存里面开辟一片空间， 把Main函数放进去，你可以这样来想象， 在内存里头，首先开辟了一片内存空间，把main函数放进去， 然后我就开始执行这个main函数，从第一句开始， 往下执行这个main函数。当我执行到result等于max这一句， 要去调用max这个函数了，那这个时候系统会怎么办呢？ 请你这样来想象，系统啊会在内存里面， 新开辟一片内存空间， 把max这个函数放进去。也就是说，把max函数 放到一片不同于main函数的内存空间的另一片内存空间里头。 放好以后，main函数把两个参数m和n传递到， 这片内存空间里头来。当max接收了m和n之后，就开始运行这个函数。 一直运行到函数结束。那么函数结束之后， 就会返回一个float类型的值，返回到main函数里头。 max在执行完函数体，并且把返回值返回给main函数之后， max所在的这片内存空间就被释放掉了。 这个时候呢，main函数已经拿到了max的返回值， 于是呢，继续往下执行， 直到程序执行结束。 这就是这个程序的执行过程。 好，下面我们来回顾一下这个程序的执行过程。 来看看我们学到了些什么。首先main函数是 程序执行的入口点，也就是说任何一个程序都是从main函数开始执行的。 那么在main函数执行过程中，如果遇到了新的函数调用的语句， 那么main函数的执行过程就会被打断， 然后呢，会转去执行这个被调用的函数， 那么等到这个被调用的函数执行完毕以后， main函数在继续往下执行，这是我们需要知道的第一点，这是一个基本的执行过程。 那有的同学就会问了main函数在执行的过程中被打断了，那等到这个函数执行完了， 为什么它又能够继续往下执行呢？ 那是因为main函数在转去执行其他的函数， 以及从其他的函数返回的时候都进行了一些操作。 
  - 比方说，当一个main函数准备去执行其他函数的时候， 它会做这么一些操作，首先初始化这个函数， 也就是说在内存里开辟一片空间，把这个函数放好，你可以这样理解。 
  - 第二个它要传递参数，比方说在这个main函数里，我需要把m和n传递给max，第三个需要保存当前现场， 那就是说，既然我要停下来先去执行max，max执行完了之后我还要继续， 所以说呢，在转去max之前，我首先要干一件事情，把当前的 我执行的这个状态先保存下来，等到以后我回来的时候我再回复，所以说它叫保存当前现场。 包括保存函数返回的地址， 也就是说你转去执行max了，等你执行完了之后回来，回到什么地方去都要保存下来。 ok，保存完这些信息以后，就可以放心大胆转去执行max了。 
  - 等到max运行完了以后在回到main函数， main函数首先我调用了你这个函数，我要接收函数的返回值， 我调用不能白调用啊，你把返回值给我。 
  - 第二个按照刚才的记录恢复现场。 把整个运行的现场再重新恢复起来，然后从这个断点处继续往下执行。 这是main函数在准备调用一个函数，以及调用完一个函数以后所做的一些操作。 这是我们想强调的第二点。第一点是一个流程，第二点是说main函数其实做了这两项工作。 
  - **我还想强调的一点，也是在这需要着重强调的一点， 当一个函数被调用结束以后， 那么它所占用的这一片内存空间就会被释放掉了。 也就是说这个函数在执行完以后，它的内存里头你就可以认为它已经不存在了。 也就是说在main函数执行过程中，只有调它的时候，它在存在，调完了之后这个函数就不存在了， 在内存里头。 那么，以后大家在碰到函数调用的这么一个场景，你就可以按照这样一种方式， 来想象函数调用的过程，这样的一种想象有利于帮助你理解一些复杂问题。 或者是关于调用的过程，除了我们需要了解这个调用的过程之外， 在这个调用过程中还有一点也是非常非常重要， 那就是关于函数参数的传递**。 
- 我们接下来把这个函数传递的过程单独拿出来讨论一下。 现在我们先来回顾一下程序运行的过程，如果我们想执行一个程序， 我们就先开辟一片内存空间，把它的main函数放入进来，放入进来以后，从main函数的开始往下执行， 一直执行到result 等于max （m，n）， 在这呢，m是我们定义的一个变量，它的值呢是3， n呢也是我们定义的一个变量，它的值是4， 那么现在呢，我就用这两个变量当作参数去调用max， 那么根据刚才我们所讲过的，要调用max，系统呢会首先在在内存里面新开辟一片存储空间， 然后把max放进去，这个时候main函数会把m和n这两个参数传递给max， max呢再去执行，执行完了后返回到main，main函数呢在继续往下执行， 这是整个程序的运行过程。那么在这个过程里头， 系统是怎么样把参数传递给max这个函数的呢， 系**统是把变量m的值copy了一份给这个形式参数a， copy，也同样把n的值copy了一份给形式参数b**， 在这啊，我用了一个词，叫copy， 什么叫做copy呀，copy就是复制， 就是你拿着原稿把它复印了一份。 有人说在这个地方m的值是3，于是呢它就把这个3复制了一份给了a， n的值呢是4， 它也就把这个4 copy了一份给了b。我打个比方， 我有一份材料，你拿了我的原稿去复印了一份放在你自己手里， 假设说你把你自己手里的这个给撕掉了，把它揉烂了，撕碎了， 点了，烧了，扔了，销毁了，对原稿有影响吗？没有影响。 无论你对复印以后的这个结果进行如何的处理， 对原稿都没有任何影响。 这就是copy的涵义。 也就是说当我们在一个函数里面调用另外一个函数的时候， 我们使用了这种方式来传递参数，那么是把要传递的参数复制了一份， 给要调用的这个函数， 是这样的一个道理，明白了这个道理之后， 后面有很多问题就会变得特别的简单。 那么为了强调，在这我们专门对这个事做一个总结， 比如说关于函数参数的传递，首先我们想要强调的是实参和形参， 实际上是分别放在不同的存储单元里的， 比方说在刚才这个图里头，这是实参， 这是形参，对不对，它们都在两片不同的存储区域里头， 这是第一件事情，**那么实参和形参之间变量的传递， 是属于值传递。什么叫值传递啊，很多书上也是用这个词， 但是难以理解，所以说我在这里给出了一个比较好理解的解释，这个解释就是copy， 在函数调用时，系统给形参分配存储单元， 并且将实参对应的值传递给形参， 当然实参和形参的类型必须是相同或者是可以兼容的， 否则的话就会出现函数调用的错误**， 好，这就是关于函数传递我们想说的。 
## 3. 函数调用示例
- 好，有了这个认识呢我们就可以来做几道题了。ok我们来看这样一道思考题。 第一道题，读一下这个程序，请你想象一下这个程序的执行结果。 我们来看一下这个程序。
    ```C++
    #include <iostream>
    using namespace::std;

    void change(int c,int d)
    {
        c = 30;
        d = 50;
    }
    int main()
    {
        int a = 3,b = 5;
        change(a,b);
        cout << a << " " << b;
        return 0;
    }
    ```  
  从主程序开始。 主程序里头呢定义了两个变量，a和b，分别赋值3和5。 然后调用了一个函数change。调用完这个函数之后呢把a和b的结果打印 出来。那就希望检测a和b到底有没有被改变。我们来看一下这个函数。这个函数是这样的。 它有两个形参，c和d，然后在函数 提议里头呢它对c赋值为30， d呢赋值为50。那现在问题很明确。我就是想问大家，在这儿a和b 打印出来到底会是多少呢？是3和5呢？还是30 和50呢？也就是说现在这个change的这个 函数到底有没有改变a和b的值？ 到底有没有改变？ 好这个程序我们运行我们就知道它没有改变。为什么没有改变呢？我们来 解释一下这个函数的执行过程大家就明白了。那么要执行这样一个程序我们首先还是把右边蓝色的 区域看作一片内存空间。 那么要执行的话呢，首先我开辟一片内存空间来放入 main函数。那么在main函数里头呢我定义了两个变量。 a和b。a的值呢是3，b的值呢是5。然后呢在main函数里头我 调用了change这个函数。只要我一调用，系统呢就会在内存空间里面 再开辟出一片区域来放入change。那么因为呢在change这个函数中 定义了两个形式参数，所以说呢就相当于在change的内存空间中 开辟了两个变量，一个是c，一个是d，而且呢由于main函数在 调用change的时候啊传递了两个参数，一个是a一个是b。 根据刚才我们所讲过的，把a的值传递给c就相当于把a的值 copy了一份给c。a的值是多少？是3。所以说copy了一份给c。 c的值也是3。然后呢b的值也一样，b的值呢也copy了一份给 d，所以d的值呢是5。然后呢这个change还是说开始执行。 在执行的过程呢，c和d被重新赋值了。c和d的值由原来的3和5变成了 30和50。 那么执行完这一句程序之后呢，change这个函数就执行完毕了。 change这个函数在定义的时候我们指定它的类型是void的类型。 所以说它不需要返回任何的值给main函数。于是 change这个函数在执行完，在把c和d换成了30和50以后 就执行完了。在执行完以后change这个函数就消失掉了。 就被释放掉了。 因为它没有返回任何的值，所以说对main函数没有任何的影响。main函数继续往下执行。执行到了 c out <<a和<<b。 那请问main函数呢它在a和b被修改过吗？当然没有。 a还是原来的a，b还是原来的b。 因为传递参数来说呢都是 copy了一份，都是复制了一份。所以说 a和b没有受到任何的影响。所以这个时候打印出来a和b的值仍然是3 和5。那么透过这个例子大家就可以进一步的理解这个参数的传递。什么叫做copy？ 那么之所以反复的强调呢是因为有它的书少，关于这个问题的解释太过于笼统。 那么很多时候呢一句直传递就结束了关于这个问题的解释了，那什么叫做值传递？ 在这儿我特别打这个比方。copy。 copy。ok这是第一道题目。 
- 那么接下来我对这个题目稍做修改。我们来看这个程序。 
    ```C++
    #include <iostream>
    using namespace::std;

    void change(int a,int b)
    {
        a = 30;
        b = 50;
    }
    int main()
    {
        int a = 3,b = 5;
        change(a,b);
        cout << a << " " << b;
        return 0;
    }
    ```  
  这个程序跟刚才那个程序有什么不同呢？不同处在这儿。 刚才那个程序的形式的参数的名字是c和d。 那么在这儿呢这个程序呢它的形式参数的名字被 改成了a和b，那么当然在这里头呢相应的 改成对a复制对b进行复制。ok那么对这样一个程序 请问在主函数里头把a和b的值打印出来的时候a和b的值会改变吗？ 我们也看一下这个程序的运行过程。 仍然假设蓝色的区域是内存。那么要运行这个程序我首先开辟一片内存空间 把main函数放进去。那么在main函数里头呢定义了两个 变量，分别叫做a和b，那么值呢分别是3和5。 然后呢接下来main函数开始执行，执行到了change a, b，既然呢要调用到change函数，所以 在内存里面再开辟一片内存空间 来放这个change函数，因为它定义了两个形参，所以在change这个函数里头 有两个变量a和b。在main函数里面调用change函数 的时候我给这个change函数赋的值是a和b，那么这个a的值呢是3 于是呢copy一份给a，于是a的值呢变成3。 那么然后呢copy一份给这个b，于是b的值呢变成5，那么接下来呢 change函数继续往下执行，对a和b进行重新复制，a变成了30，b呢变成了50。 那么执行完这个过程以后有没有返回任何的值啊？没有，因为change这个函数的 类型是void的类型，所以这个函数不会返回任何值给main，那么既然它已经执行完了 所以接下来它会被释放掉。被释放掉而且没有返回任何的值 那么main函数呢继续往下执行。c out <<a和<<b。那会打印出多少来？3和5。 因为在main函数空间里的这个a和b从来 没有被修改过，它传递给函数的这个 a和b呢都是copy了一份。 那么在这儿呢我们想说明的是这样的一个问题。虽然我们在定义函数的时候使用了跟 main函数里头名字看似一样的变量作为函数的形式参数 但实际上这个地方把cd改成ab 有影响吗？没有任何的影响，因为你所定义的这个ab是在哪里呀？ 它是在change这个函数的自己的内存空间里头。 那么这个ab在哪里呀？这个ab在main函数的内存空间里头。 你说虽然两个都是ab，但是它们却在完全不同的内存空间里。 也就是说这两个ab虽然都叫ab但它们互不干涉。 没有任何的互相干涉的地方。所以说呢在main函数里头的 ab不会被改变。也就是说最后的结果会是 3和5。这就是这个程序的一段执行过程。 
- 好下面我们再来看一道题。再来巩固一下，因为太重要了。 好这里又有一个程序，
    ```C++
    #include <iostream>
    using namespace::std;

    void change(int a,int b)
    {
        int p;
        if(a < b){
            p = a;
            a = b;
            b = p;
        }   
    }
    int main()
    {
        int a = 3,b = 5;
        exchange(a,b);
        cout << a << " " << b << endl;
        return 0;
    }
    ```  
  在主程序里头定义了两个变量a，b， 并且在主程序呢调用了一个函数，就是change a, b 最后呢再把a和b都打印出来，确认一下有没有变化。 那么这个函数是这样的。两个参数，一个参数是a，一个参数是b，如果 a小于b的话，我就做这么一个操作，大家一看就知道，是a b互换位置。 也就是说如果a小于b的话，我就把a和b的位置互换一下。 对于这样的一个程序它的运行结果应该是怎样的呢？ 好那我们来快速的分析一下。 我们想要运行这个程序的时候我们首先开辟一片内存空间把main函数放进去。 在main函数里头会有两变量，一个呢被初始化为3，一个被初始化为5，然后呢main函数开始 执行一条语句叫exchange (a, b)，把ab当作参数来调用exchange这个函数。 那么既然要调用exchange，于是在内存里面生出一片新的内存空间 然后呢把exchange放进去，在exchange的内存空间中呢有两个变量a和b。 那么又在调用的过程中呢main函数把a的值传给了这个a。 把b的值呢传给了这个b。这个怎么去传递的？我们是不是很清楚了？copy, copy, copy! 把a的值copy一份给a，所以说a的值是3，把b的值copy一份给b，所以b变成5。 然后接下来呢在exchange的内存空间中a和b 因为满足了a小于b这个条件，所以说a和b进行了一个 互换。然后呢exchange又执行完了，并且呢没有返回任何的东西给main函数。 于是exchange在执行完之后它就消失掉了。 消失掉了之后呢main函数在从exchange调用之后 继续往下执行c out打印出a和b来。所以最后的结果是3和5。 是不是一样的道理呀？这个程序跟刚才那个程序 完全一样的道理。在这儿之所以反复强调是因为 太重要了。 我希望大家能够彻底的理解这一点。 
## 4. 变量的作用域
- 好，我们接下来再来讨论一下变量的作用范围 那么我们先来熟悉两个概念，局部变量和全局变量 什么叫做局部变量全局变量呢？其实是根据变量在程序中作用范围的不同 来进行划分的。
  - 所谓局部变量呢，就是在函数内部或者某个代码块的内部 。所谓代码块就是用大括号括起来的那些代码，那么在函数内或者代码块内，定义的那些变量 那么这个变量呢，只在这个函数或者是代码块之内起作用 那么这样的变量就被称作局部变量 
  - 那么跟局部变量相对应的呢 有一些变量啊，它的作用范围呢更大，叫做全局变量 所谓全局变量就是在所有的函数外，定义的那些变量 那么它的作用域呢，是从定义变量的位置开始一直到这个程序文件的结束 也就是说无论这个程序里头有多少个函数，那么从这个变量定义的那个地方开始 它就会一直在起作用，直到这个文件的结束 
- 那么我们来看一个例子，对照一个例子呢来理解一下。看这个程序 
    ```C++
    #include <iostream>
    using namespace::std;

    int excel_number = 0;
    void excel_count(float score)
    {
        if(score > 85)
            excel_number++;   
    }
    int main()
    {
        float score = 0;
        for(int i = 0;i < 100;i++){
            cin >> score;
            excel_count(score);
        }
        cout << excel_count << endl;
        return 0;
    }
    ```  
  在这个程序里头，首先它有main函数。在main函数的前面呢，我还定义了一个自己的函数 那么在这个函数之前还有一行程序，这行程序呢定义了一个变量 像类似这样来定义的变量，以前我们还没有碰到过 我们以前从来没在函数的外面写过任何东西，那么这行程序呢就写到了函数的外面 它呢，就定义了一个全局变量。好，既然熟悉了这个程序的结构，我们就来看一下 这个程序里头所有变量的作用范围。我们首先来数一下 这个程序里头一共有多少变量。那么刚才我们提到的这个在程序外面进行的变量是第一个 excel number，这是第一个。第二个，实际上是 在excel count 这个函数里头定义的这个score，这是第二个变量 第三个变量呢，是在main函数里头定义的这个score 这是第三个变量，除了这个变量之外还有其他变量没有啊？ 还有一个，那就是在for循环里面所定义的这个i，这是第四个变量 那我们分别来看一下这些变量的作用范围 我们先来看这个score。这是我们最熟悉的一种变量了 我们以前写程序的时候总在mian函数里面定义变量。那么这种变量的作用范围也很明确。首先它定义在 main函数的内部，所以说它是一种局部变量 按照刚才的定义的话，它属于一种局部的变量。那它的作用范围呢，应该是这样的 在main函数的里面，从这个变量的定义，一直到main函数的结束 这就是score的一个作用范围 那么跟这个变量相类似的，我们在excel count这个函数里头 也定义了一个形参，形参的作用范围啊就在这个函数的里头 所以说它也属于一种局部变量，所以这个绿色的score，它的作用范围呢 是在excel count这个函数的内部 由此我们看到，虽然两个变量的名字是一样的 但是，他们发挥作用的范围，完全不同 而且他们两个的范围没有任何的交集，也就是说这两个变量 独立起作用，互不干涉。我们再来看最外面定义的这个变量 刚才我们说呢这个变量是属于一个全局变量，那它的作用范围应该是什么呢？既然是全局变量 那就是应该从变量的定义的这一行起一直到文件的结束 所以说它的作用范围是最大的，是excel number作用范围。非常非常大 从它的定义开始一直到这个文件的结束 还有一个变量就是这个小i，这个小i是什么类型的变量呢?根据我们刚才的定义， 那么由于这个i是定义在程序块里头的 所以说这个i也是一个局部变量，那它起作用的范围是什么呢？ 就是在这个for循环的范围之内 也就是说，这个i出了这个for循环，它就不起作用了 当然我们以前讨论过，那么关于这个i的作用范围的理解 不同的编译器可能有不同的理解结果，有的编译器会认为这个i是从定义一直到main函数的结束 但是vc2008以后的版本里头，那这个i的作用范围呢都是被局限在for循环的内部 也就是说如果你接下来再想使用一个临时变量i的话，你就必须重新再去定义一个 
- 好，我们稍微做一个总结 从这个图上我们可以看得出来，
  - 全局变量的范围实际上是最大的。是从这个变量定义的这行起，一直到整个文件的结束 这是我们知道的第一条。
  - 第二条在函数里面定义的局部变量 是从这个变量的定义开始一直到函数的结束，这是第二条。
  - 第三条 有一些变量被定义在代码块里头，比方说这个i，被定义在代码块里头 那么这些变量的作用范围就被限定在这个代码块中 这是第三条。
  - 第四条 其实在函数里面我们所定义的形式参数也是一种局部变量 它的作用范围呢就是在这个函数的范围之内，出了这个函数，那么这个变量也不能起作用了 这是关于变量的作用范围 
- 那么作用范围的不同对变量的使用有什么影响呢？ 对程序的运行有什么影响呢？ 我们下面通过一个例子再来看一下。看这个例子，
    ```C++
    #include <iostream>
    using namespace::std;

    int a = 0,b = 0;
    void exchange()
    {
        int p;
        if(a < b){
            p = a;
            a = b;
            b = p;
        }   
    }
    int main()
    {
        cin >> a >> b;
        exchange();
        cout << a << " " << b << endl;
        return 0;
    }
    ```  
  这是main函数。那么在main函数的外头呢 又定义了一个函数叫做exchange，在所有的函数前面定义了两个变量a和b 我们通过刚才的定义可以知道a和b都是全局变量 然后呢，那么在主函数里头呢，我从键盘上读入了a和b，然后呢我调用函数exchange，在exchange里头呢 检查一下a和b的大小关系，如果a小于b的话我就交换a和b的位置 最后呢在主函数里头我再把a和b都打印出来，这就是这个程序的一个基本的结构 那我请问，你觉得，这个程序的执行结果会是怎样的呢? 那么如果我输入3和5分别给a和b的话，他们会被交换吗？ 好，我们来分析一下这个程序的执行过程 假设这是我们的内存空间，那么在程序执行的开始呢 定义了两个全局变量a和b 全部变量被定义在了函数的外面，并且呢，它在这个文件里头 都会起作用，那么，我们应该怎么来想象这个全局变量呢？ 我们可以这样来想象一下，它被定义在这个地方，不在任何函数的里头 那么程序执行的时候呢系统给main函数开辟一片内存空间，然后main函数就开始运行 首先呢它运行第一句cin，a和b，这个地方我想请问一下 main函数运行到cin，a和b的时候这个a和b指的是谁啊？ 这个时候a和b是不是指的上面的a和b啊，是不是指的它呀 对的，因为上面这个a和b的作用范围是从他们的定义开始一直到文件的结束 所以说在这，这个a和b指的就是全局变量，a和b。那么现在要在main函数的里面 给main函数外面的这个a和b进行赋值。也就是说 在main函数的里头我要伸出一只手来 去改变这个main函数之外的这个a和b 在这我画了一只手，画的不好大家别介意 之所以要画这只手，我就是想给大家一个强烈的概念 就是说当在main函数的里面执行cin，a和b的时候 那么就相当于main函数伸出了一只手，伸到函数的外面 去改变外面的a和b。比方说这个时候呢，我们cin的结果是输入了一个3和5 那么把3给了a，把5给了b，接下来呢main函数继续执行，执行到了exchange a，b 既然它要调用exchange这个函数，正如我们前面讲过的，要在内存空间里面开辟一片区域给这个函数 然后呢这个函数开始执行。首先呢，它要判定一下a和b的大小 请问，这个a和b是指的哪个a和b啊？ 是不是也是指的全局变量啊？所以说它要判定一下。一看呢 这个时候a等于3，b等于5，满足a小于b的条件吗？ 满足。于是呢，它执行a和b要交换的这个操作 这个时候是对谁去执行这个操作啊？ 是不是像刚才一样啊？Exchange 这个函数也伸出了一只手， 对定义在函数之外的这个 a 和 b 去进行了操作啊。 这个时候呢， a 和 b 就被进行了一个互换。啊，a 变成了 5, b 变成了 3 。在完成这个互换之后呢，Exchange 函数就要执行完毕了。 那执行完毕之后呢，它就从内存中消失掉了。 Exchange 这函数消失掉之后，在 exchange 这函数之外的 a 和 b 会不会受影响啊 ？ 不会受影响。啊，所以说这个 a 和 b 就被保留下来。当 main 函数里头再去打印 a 和 b 的时候， 它会去打印哪个？是不是又去访问函数之外的这个 a 和 b 啊？ 啊，所以说它会打印出来 a=5, b=3。 啊，所以整个程序的执行结果应该是这样的。 啊，输入了 3 和 5，那么打印出来呢， 5 和 3 。啊，这就是整个出来的程序执行结果。 **所以说我们可以看到全局变量的作用范围是从全局变量的定义 一直持续到整个文件的结束。啊，在整个的这个范围里头， 任何一个函数都可以去访问这个全局变量。啊，这就是全局变量的含义**。 
- 那说到这儿，可能有的同学就想到了一个问题。那万一我定义了一个全局变量 a 和 b ，然后呢，我又想呢，在某个函数里头也定义一个 a 和 b ， 那会怎样呢？Ok, 我们就来看一个这样的程序。 看这个程序。
    ```C++
    #include <iostream>
    using namespace::std;

    int a = 0,b = 0;
    void exchange(int a,int b)
    {
        int p;
        if(a < b){
            p = a;
            a = b;
            b = p;
        }   
    }
    int main()
    {
        cin >> a >> b;
        exchange(a,b);
        cout << a << " " << b << endl;
        return 0;
    }
    ``` 
  这个程序的结构跟刚才的那个程序啊，几乎一模一样。 都是在 main 函数之前定义了一个名字为 exchange 的函数。 那么在这个函数之前呢，我也定义了两个全局变量， a 和 b。啊，a b 呢，都等于0。 所不同的是，在这个 exchange 这个函数里头啊， 我也定义了两个形式参数。啊，我们讲过形式参数就相当于局部变量。 这两个局部变量的名字呢，也叫 a 和 b 。跟外面的全局变量的名字是一样的。 这个时候，可以吗？可以。啊，允许你这样来做。 那允许这样做的时候， 当在 exchange 这函数里头， 我访问到 a 和 b 的时候，我指的到底是 里面的这个 a 和 b 呢, 还是外面的这个 a 和 b 呢？ 那当然关于这件事情，作为一个编程语言，必须明确的定义下来。啊，我们来看一下， 编程语言是怎么去定义的。首先，因为在这里定义的 a 和 b 是全局变量， 所以说，这个 a 和 b 的作用范围是从它的定义开始一直持续到整个文件的结束。 那么又由于在这个全局变量 a 和 b 的作用范围之内，你又定义了两个局部变量 a 和 b 。**因为这两个 a 和 b 是局部变量，所以说它们两个的作用范围将是 在这个函数的里面。比如说这是它的作用范围， 那现在就有了冲突。外面有一个全局变量， 里面又有两个同名的局部变量。那这种情况怎么处理呢？ 很清楚，编程语言清晰的规定， 当全局变量与局部变量同名的时候，那么局部变量将在自己的作用域内有效。 它将屏蔽同名的全局变量。也就是说，虽然在外面定义的 a 和 b ， 它的作用范围很大，但是，在局部变量定义的这个范围里面， 局部变量说了算**。 抱歉，今天这个，今天这个课程录的真是很艰难啊。 因为我现在在车里面来录，那么刚才两个印度的老兄在车外面 discuss, 一直都 discuss 。那现在呢又有一个冰淇淋车过来。 啊，今天比较热闹。那么， 因为受到条件的限制呢，我也是尽可能的找一些比较安静的地方去录课。 首先不能打扰别人，其实呢我们要保证录课的这个质量。那有的时候啊， 这两者之间还真是鱼与熊掌，难以得兼呢。Ok ，我们等它走过去。 还好，今天没有很多小朋友在。 Ok, 这就是全局变量和局部变量之间的关系。 好，那么在明确了这一点之后啊，我们就来看一下这个程序的执行过程。 这个程序的执行呢，跟刚才的程序，啊，基本雷同，我们来看一下。 当程序运行的时候呢，首先在存储中间里面定义了两个全局变量 a 和 b， 存储值是 0。 然后呢， main 函数开始执行。 在 main 函数的里面首先我们来执行 cin ， a 和 b。 那刚才我们讲过，这个 a 和 b ， main 函数里头 cin 的时候这个 a 和 b 它只能是指外面的这个 a 和 b。 啊，全局变量。所以说，相当于 main 函数伸出了一只手， 要对外面的 a 和 b 进行操作。这个时候呢，假设我的输入是 3 和 5 。啊，一个 3， 一个 5 。那么接下来呢， main 函数 调用了 exchange 这个函数。 那么它要调用这个函数的话， 立刻在内存里面开辟一片空间给 exchange 函数， 然后由于 exchange 函数里面定义了两个形参 a 和 b ，所以说 就相当于在exchange 的函数里面形成了一个 a 和 b。 而且呢，由于 main 函数在调用的时候啊，向 exchange 函数传递了参数， 也就是说啊，相当于这个 a 的值被 copy 到这里。 这个 b 的值呢， 被 copy 到这里。 Copy 的含义我们刚才已经讲过了。所以说在 exchange 函数里头， a 和 b 的值分别是 3 和 5 。啊，这个时候呢，那 exchange 函数继续往下执行， 因为 3 小於 5， 所以说它们两个要互换位置。 啊，也就是说在 exchange 函数里头， a 和 b 进行了一个互换。 互换完了以后，是不是 exchange 函数就结束啦？啊，就执行完了。 执行完了以后，exchange 函数所在的内存空间就被释放掉了。 烟消云散。 那么在 exchange 执行完了之后呢，那么 main 函数回来继续执行。 执行到 cout ， a 和 b。 那这个 a 和 b 指的是哪个 a 和 b 啊？ 仍然是外面的这个 a 和 b。 所以说这个时候 main 函数又伸出一只手去拿了 外面的 a 和 b 来把它打印出来。所以整个的这个程序的执行结果是 输入 3 和 5 ，输出也是 3 和 5， 没有任何的改变。 那么通过这个过程啊，我们就可以感受到 全局变量和局部变量之间的关系。大家如果碰到这样的问题的时候呢，啊，可以这样来想象一下， 我相信这个问题就迎刃而解。好，这是关于全局变量和局部变量。 
## 5. 数组做函数参数
- 那么接下来呢我们再讨论第四个话题： 数组与函数。其实关于这个 问题之前就一直有同学写信给我来问 说虽然看了好多书但是也仍然不清楚。ok那接下来我们就来分析一下。我们首先看一个例子。看这个例子。 
    ```C++
    #include <iostream>
    using namespace::std;

    int a = 0,b = 0;
    void change(int a,int b)
    {
        a = 30;
        b = 50; 
    }
    int main()
    {
        int a[2] = {3,5};
        change(a[0],a[1]);
        cout << a[0] << " " << a[1] << endl;
        return 0;
    }
    ``` 
  先看一下这一个例子的结构，有一个主函数，主函数的前面定义了一个 名字为change的函数。这个函数有两个形式参数，a和b。 int型的。我们来看一下主函数。 在主函数里头我首先定义了一个数组，a[2]两个元素，分别是3和5。 然后我利用数组的两个元素a[0]和 a[1]，用这两个元素作为参数去调用了函数 change，调用完了以后我再把a[0]和a[1]打印出来。那请问你觉得 这个程序的执行结果会是怎样的呢？很多同学一看就知道了，哎呀这个程序没什么奇怪的。 这个程序跟之前我们所给出的那个程序很接近，以前的程序我在这边定义了 两个变量a和b，而在这儿我只不过把这两个变量变成了数组元素a和b。 一点都没错，这个程序跟我们以前讲过的在 main函数里头传递变量a和b给change的函数的这个程序一模一样，没什么区别。为了说明这个情况，我们也来简单的过一下这个程序的执行过程。 从main函数开始，在main函数里面我定义了一个数组， 这个数组有两个元素a[0]a[1]被赋值为3和5。 然后我就调用了这个函数change。一调用这个函数在内存里面生成change函数，并且在change函数的里面定义了两个局部变量a和b。 那么由于main函数在调用change函数的时候把a[0]和a[1]传递给了change函数，所以说a[0]的值就被copy给了a，a[1]的值就被copy给了b。既然是copy，那么a[0] 等于3，a[1]也就等于3，a[1]等于5，b也就等于5。 没什么稀奇的。然后change的函数继续往 下执行，执行到a等于30，b等于50。于是a和b的值变为30和50。 执行完这一句之后怎样啊？change函数就执行完毕了。 而且因为它是void的类型，所以说它不需要返回任何的东西给main函数。 于是change函数在执行完毕之后就消失掉了。 那么消失掉了之后main函数继续往下执行去打印a[0]和a[1]。那a[0]和a[1] 发生变化了吗？没有，a[0]还是原来的a[0]，a[1]还是原来的a[1]。 所以说整个这个程序执行完毕之后会打印出来3和5。这就是整个这个程序的执行过程。**那么透过这个程序 我们就能看到当我们把数组元素 当作参数传递给某个函数的时候 这个数组元素是不是跟普通的变量没什么区别啊？ 没有任何的区别。在这儿这个数组元素就相当于两个变量，那a[0]就相当于某个变量比方说a 那a[1]就相当于某个变量比方说b，没有任何的区别**。那么这是数组元素 做函数参数的时候所遇到的情况。 当然这并不是我们讨论的重点。
- 我们接下来讨论一下 数组名做函数参数的时候会怎样？看这个程序。 
    ```C++
    #include <iostream>
    using namespace::std;

    int a = 0,b = 0;
    void change(int a[])
    {
        a[0] = 30;
        b[1] = 50; 
    }
    int main()
    {
        int a[2] = {3,5};
        change(a);
        cout << a[0] << " " << a[1] << endl;
        return 0;
    }
    ``` 
  这个程序跟刚才的程序非常的接近。 那么也是在有一个main函数。main函数前面定义了一个change函数。那么所不同的是change函数的参数从原来的两个变量变成了这样的一个参数，长成这样子。可以吗？可以。这个定义是完全符合语法的。 **就是说当你想把一个数组传递给某一个函数的时候， 就请你按照如此的方式来定义这个函数的形式参数。这样的话 它就可以接受一个数组了**。
  ok所以说在这儿我就定义了一个int a，后面两个方括号。 方括号里面可以不写东西。ok我们来看一下这个程序。从main函数开始，在main函数里头 我定义了一个数组a[2]，赋初值3和5。然后 我利用数组a调用了函数change。 作为这个形式。你看你在这儿定义的是int a，然后方括号。 然后在这儿我去调用这个函数的时候我给这个函数传 参数，也是直接用了一个数组的名字 a，这个a是在这儿定义的。 通过这种方式调用函数change。调用结束之后我再把a[0]和a[1]的值打印出来。 那么这个程序在你看来它的执行结果会是怎样的呢？ 好那我们就先来看一下这个程序的 执行结果。这个程序的执行结果是这样的。 30 50，也就是说原来a[0]和a[1]的值是 3和5 ，但打印出来之后变成了30和50。 也就是说数组元素的值被改变了。 为什么数组元素的值被改变了呢？ 这跟我们以前碰到的情况不太一样。 那下面我们就来分析一下。那我首先来分析一下 当函数调用的时候参数传递的情况。 假设说这个蓝色的区域是一片内存空间。当函数开始执行的时候首先开辟一片内存区域 给main函数，main函数里面定义了一个数组a，包含两个元素。 然后main函数用数组a做参数，调用了函数change。 它一调用这个函数那么在内存里面再开辟一片空间把change的函数放进去。 那在这个函数的里面我定义了一个变量来接纳一个数组。 当然我们在这儿讲过很多遍了，虽然它的名字也是a，但是这个a跟这个a的 作用范围完全不同对不对？这个灰色的a的作用范围只是在函数的里面。 这个a[2]的作用范围是在main函数里面。好它两个完全不同。 那么这个时候main函数要把这个参数a传递给这个函数。 那这个传递的过程是怎么去进行的呢？仍然是 copy。仍然是copy。 只是所不同的是在这儿我要特别强调，我们要看一下 它copy的是一个什么东西呀？也就是说这个a是个什么东西？ 我们可以看到这个a是数组的名字。 是数组的一个名字。我在这儿需要特别特别强调。 特别特别强调。**数组的名字它不是一个变量。 数组的名字不是变量，它是一个常量**。 也就是所有数组的名字跟你写出来的3写出来的5这样的数字一样，它是一个常量。 而不是一个变量。 所以说你在这写一个a不相当于比方你在这里写了一个3或者写了一个5。 那当你去调用一个函数写了一个3和5的时候你都很清楚，它是把这个3的值直接copy给了这个变量对不对？ 把这个3的值直接给了这个变量。写5的话就把5的值直接给这个变量。那你现在写的是个a，这个a 跟3和5一样它是个常量，所以说它是直接把这个a的值直接就给了这个a。 **ok总结一下，当我们把一个数组 的名字当作实际参数传递给另外一个函数的时候 实际上因为这个数组的名字是一个常量 而不是一个变量， 所以说这种情况跟传个3传个5传任何一个这种数 是一样的**。这是我们需要特别清楚的第一点。 那有的同学可能就要问了。那这个数 到底是个什么样的数呢？它代表一个什么含义呢？ 那么在这儿我需要强调的第二点其实这件事情 在我们讲数组的时候我们就曾经讲到过 数组的名字其实代表着数组的地址。 什么叫做数组的地址啊？那当然关于地址这个概念我们讲到指针那部分的那个时候 我们还会给出明确的定义。那在这儿你怎么理解呢？ 数组的地址就代表着这个数组所在的那个地方。 ok理解不了没关系，我们下面看一下这个例子的运行过程你就清楚了。 这个呢，是刚才我们看到的这个程序。 那么要运行这个程序的话，那么首先在内存空间中开辟 一片区域。啊，把main函数放进去。那么在main函数的里面， 我定义了一个数组。那么想像一下的话，就因该在main 函数 的里面有一片小的空间。啊，这个空间里面呢，定义了一个数组。 然后呢，main函数以数组名作为参数，调用了change 这个函数。那么一调用呢， 就在内存空间中开辟一片新的区域，把change函数放 进去。那么在change函数里头呢，也有一个形式参数， 用来接纳main函数传进来的这个数组的名字。 **那刚才我们讲过，数组的名字应该是什么呢？ 是代表着数组的地址。也就是说，实际上main函数把这个 数组所在的这片内存空间的地址告诉了 change函数。那么接下来呢，change函数再去对这片地址空间中的 a[0] 和 a[1] 去访问。那就相当于change函 数伸出了一只手，到 main函数的里面 去修改了main函数里面的这个数组里面的值。 啊，又把这个数组的值从3和5,修改成了30和50**。 那么执行完这个操作以后呢，change函数就执行完毕了。 执行完毕以后，change函数就消失掉了。 然后呢，main函数接着往下执行，会去打印a[0] 和 a[1]的值。 这个时候a[0] 和 a[1]的值等于多少啊？是30和50。所以程序运行的结果是 30和50。啊，这是这个程序运 行的结果。ok，下面我们来总结一下， **那么当数组的名字被当作函数的 参数，传递给另外一个函数的时候啊， 这个时候啊，就相当于把这个数组在内存中的地址 直接传递给了这个函数**。那这是一件非常非常严重的事情。我打个比方， 比方说啊，我有一批金币，相当 值钱的金币，我把它埋在了一个地方了。 这批金币呢，就相当于我所定义的这个数组。那么埋藏金币的这个地点呢， 就相当于这个数组在内存中的那个空间。那现在呢，main函数把这个地址呀， 给了change这个函数。比方说，我是main函数，你是change函数的话， 我呢，把埋藏金币的这个地址告诉了你。啊，比方说我告诉你我就 埋在未名湖边上离翻尾石鱼最近的那一棵树的 下面了。我只要把这个地址告诉了你， 是不是你就可以直接去取那些金币了？ 如果到明天我去看，哎哟，那金币全没了，也没问题，因为我告 诉了你了地址。你知道了这个地址之后，你就可以去 访问这片地址里面的东西了。所以说，传递 地址啊，是一件非常严重的事情。那这个事情呢，也就解释了 当main函数把数组a的地址传递给了change函数的时候， change函数就可以伸出一只手到main函数 的里面去修改这片地址空间里面的 东西了。这就是当你把数组名当作参数，传递给另外一个 函数的时候，你，这个是一个等级相当高的一个授权。 所以说在这种情况下，change函数的任何操作，都是对这个数组实际 存储空间的操作。啊，所以说它才会改变这个数组的值。 这就是数组名做函数参数的时候，我们特别要小心的。在这儿我特别 特别想要申明一下，刚才我们讲的数组名做函数参数的这个过程你听不懂，完全没问题。 因为等到指针的部分，我们还会翻过来，从新地在另外一个高度上 再去解释这个问题。到那个时候你把它学会，就ok了。啊，不要着急。 就是说在这儿听不懂的话，不要着急，没关系。ok，这是关于 数组做函数参数的情况。
## 6. 函数应用示例
- 那在这一节的最后呢，我们再举一个小的例子来看一下函数的一个基本的作用。当然作为C程序的基本组成单位，函数的作用非常的巨大。那么再这儿我们只给出了一个简单的例子，来展示一下函数的最基本的一个作用，就是来组织程序。噢，也就是说啊，利用函数，我们可以把一个挺大的程序啊，切成一块一块的小程序。那么同时在这个例子里头呢，我们也展示一下全局变量对整个程序的影响。 Okay，我们来看一个例子。这个题目是这样的。
  - 给定从公元 2000年1月1日开始逝去的天数，啊，就是过去的天数。给你一个。然后呢，请你编写程序给出 当前的这一天，比方说，当时你已经过去多少多少天了，那么过去了这些天之后的那一天， 是哪年哪月哪日星期几。假设说我告诉你，从 2000年1月1号开始，过了3000天，那么3000天过去以后的那天，是哪年哪月哪日星期几呢？那么这个题如果放 在理想状况下，它就非常的好解。比方说我们认为每年都有365天，然后每个月都有30天。 那这个题就特别好办了。 
    - 但是现在不同，这个题目给了两点提示。
      - 第一，你要注意闰年。 
      - 第二，注意每个月的天数也不一样！而且闰年里的4月份跟平年的4月份的天数又不同。 
- 那这就跟实际的情况完全一样了，对不对？那现在让你来解决一下这个问题，你想应该怎么 办呢？那有些同学可能觉得，哎哟，那是如果是按实际的算，那这个算法就复杂咯！ 哦，也不复杂。哦，无非就是让我们体会一般现实和理想的差距而已。 好，我们再来看一下它对输入输出数据的要求。要求啊， 输入多组数据，每一组呢，一个正整数。 这个正整数呢，表示从2000年1月1号开始已经过去的天数。 对于输入的每个天数呢，要求你都 数出一行，这一行里头包含了对应的 日期和星期几。它的格式呢，是年-月-日， 然后星期几。啊，星期几呢，用英文来 表示。输入的最后一行是-1，那表示输入结束，不须要再特殊处理。 而且呢，你可以假设年数一定不会超过9999。 那大家思考一下，对于这样一个问题我们应该怎么去解它呢？ 首先啊，有了我们前面关于输入输出的讨论， 那么虽然这个程序呢，是输入多组的数据，并且输出多组的数据。那我相信这个输入输出啊， 应该不是什么太大的困难了。 呵，所以说呢，我们可以集中力量来考虑如何来计算这个日期。 在这个程序里头啊，实际上须要我们计算出来的信息啊，有4个。 一个是年，一个是月，一个是日， 一个是星期几。那在这4个信息中呢， 有一个信息是最容易计算的。它不受其他信息的影响， 那就是星期几。 所以说，计算这个程序的一个基本的思路，我们，我们可不可以这样？ 首先呢，我们定义一个变量，用来存放这个输入的天数。 然后呢，基于这样一个天数啊，我就开始一路的计算。 因为关于星期几的计算，不牵扯任何其他的问题。所以说呢， 我先基于这个日期啊，算出来。哦，那么当前这一天应该是星期几？那当然呢，需要我们查一下， 2000的1月1日，啊，它应该是个星期六。那么基于这个星期呢，我们就可以算出来 星期几。那么有了星期几以后啊，接下来我再计算年。 计算年的办法也不难。 我们就从总的天数里面减掉2000年的天数， 再减掉2001年的天数，再减掉2002年的天数，一直减下去。 也就是说要减掉每年的天数。那么， 直到减到剩下的天数不够一年， 噢，我们就得到了关于年的信息了。那么在这计数上呢，我们在减掉 每个月的天数，直到减到剩下的天数，不够一个月，余数我们就得出来 月的信息。那么最后剩下的那个天数就应该是日的信息。Okay, 这就是我们 解决这个问题的思路。那么当然在这个过程中，要减掉每年的 天数也不是一个特别简单的事情。这须要我们去计算要减掉的那一年 是不是闰年。啊，我们先要计算一下它是不是闰年，然后再减掉相应的天数。那减掉每 月的天数呢，也不是一个容易的事情。因为每个月的天数不同。噢，我们怎么样去减掉 每个月的天数呢？那么在这个地方啊，我们可以利用一个数组， 来枚举出每个月的天数。那无论如何，这个 题啊，我们可以分成这三步去解决。第一步，计算出星期几。 第二步，计算出年的信息。第三步，计算出月 的信息。最后呢，得到day的信息。啊，这是整个的这个程序。 哎呀，看上去还真的挺罗嗦的。啊，如果写到一个程序里头，这个程序毕竟是比较长的。 那么在这儿呢，我们就可以用一个函数来做一个组织。比方说我们先来看它的主程序。 这个主程序可以长成这样子。在这个主程序里头呢，首先我定义了 一个全局的变量，days。但是因为啊， 这个days在所有的函数里头啊，可能都要用到。然后呢，我定义了三个函数。 第一个函数呢，是get_dayofweek()， 啊，用来计算星期几。第二个函数就是get_year(), 我获得年的信息。 第三个函数是get_month（）, 我获得月的信息。 那么整个程序的架构呢，也非常简单。看这儿！ 对于输入的每一天，那么只要这一天不等于-1。当然等于-1的话整个程序就结束了。 呵，我先求出星期几，然后呢，再求出 年的信息。然后呢，我计算一下最后的 那一年是不是一个闰年。 然后把这个信息呢，告诉接下来的这个函数去获得月的信息。 这leap_year做一个输入参数，输入给get_month（）。哦，然后呢，求出月的信息。 啊，这是整个程序的组织。
- 从这个主程序我们就可以看出来，由于 使用了这一些函数，它使主程序变得特别的简明。 好，我们看到这个主程序我们就可以知道它每一部在做什么。 不仅如此，通过使用这些函数， 我们还把一个大的程序拆分成了好多小的程序。这将有利于啊，我们 把一个程序分给多个人去协同 完成。比方说我们现在把写这个程序的任务 交给了一个小组。那这个小组里头呢，一共有 4个人。那这4个人就可以做一个分工。 有一个人呢，来写main函数。然后呢，把这三个函数get_dayofweek(), get_year(), get_month(), 分别分给另外三个不同的同学。这样的话，这4个人呢， 就可以协同完成这一个大的程序了。这是函数的另一个作用。 所以说利用函数啊，我们可以把一个大的程序拆分成多个小的。 我们可以把一个总的任务分给多个人去完成。 其实呢，有种倒分本身就是一个结构化程序设计的重要思想之一。 那么有了这个思路之后啊，我们再去组织这个程序，就会变得简单了。 那么关于这个程序的细节呢，我们在这儿就不详细的去讨论了。 那么大家呢，可以参考PPT中给出来的程序。哦，自己呢，试着去写一下。 那么同时呢，在这个程序里头啊，还有一点事情想跟大家分享。 在这个程序里头啊，我们定义了一个全局变量，就是days。 这个全局变量呢，根据刚才我们的思路，在get_dayofweek()这个函数中， 我们会用了它。在get_year()这个函数里头， 我们也会用到它。并且在这个里头还会改变它。 因为我们要从这个days里面减掉每年的天数。那么在get_month（）的这个函数里头呢，也会用到这个days。也就是说啊，这个全局变量在接下来的三个函数以及主函数里头都要用到这个全局变量。
  - 那么这样做会不会有什么问题呢？ 的确会带来一些问题。 
    - 第一个问题，因为days在三个函数里面都会用到， 而且呢，有的函数还会改变它。所以万一在get_year()里面，啊，你不要说程序我没写好，写错了，这个错误就会直接的传递到 get_month()这个函数中去。比如说，无论get_month() 这个函数做得对不对，它的计算基础都是错误的。 也就是说因为days是一个贯穿三个函数的一个全局变量从而使得围绕着days所番的错误都会在这些函数里面有所体现， 这是第一个麻烦。
    - 第二个麻烦，就如刚才我们所设想的那个场景。 假设说我们把整个的那个程序分给4个同学去完成。然后呢，这4个同学必须都 记得有一个days这样的全局变量。 而且呢，关于这个全局变量的使用我们必须严格的 限定下来，来联合开发这个程序的4位同学之间多了很多交流上的麻烦。 也就增加了犯错误的概率。这就是这个全局变量带给我们的 麻烦。在这儿呢，关于全局变量和函数的关系，我们做一个总结。 通过这个题目，我们就可以看到，全局变量的使用啊，有的时候确实会给我们提供一定的便利。 但是呢， 因为引入了全局变量，往往就破坏了函数的相对独立性。 哦，像刚才我们的这个程序，那么几个函数呢，就被串在了一起。那像羊肉串一样把它给串在一起了。 每个函数都没办法独立的发挥作用。 而且呢，它增加了函数之间的耦合性。也就是说当 某一个函数里头，对这个全局变量进行了一些操作以后，很有可能 会通过这个全局变量而影响到其他的函数，这也是一个非常不好的一点。 同时呢，函数之间的这种交互啊，也变得不够清晰了。 也比方说关于年的计算。哦，其实在年的计算这个函数里面有两个返回的结果。 一个呢，是返回了当前的年数。另一个呢，实际上是体现在全局变量上面。在全局变量中减掉了以往年的天数。但是呢，由于这个全局变量的存在使得这两个结果并没有明显的体现在函数的返回值上。所以说啊，由于这些问题的存在就提醒我们必须要谨慎的使用全局变量。所以说呢，我们给出的建议是不在非常必要的情况下， 请你不要使用全局变量。噢，我们要尽量保持函数的相对独立性，降低函数之间的耦合性。并且呢，要尽可能的提高函数之间进行交互的清晰度。 
- Okay,那么关于这样一个例子讨论呢，我们就进行到这里。当然关于函数更多的内容我们会在后续的课程里头啊，做更多的介绍。Okay, 那么今天的课呢，我们就进行到这里。谢谢大家！ 