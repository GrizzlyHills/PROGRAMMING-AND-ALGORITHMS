# 指针与二维数组及字符串
> 这次课是上次课的延续，我们将为大家讲解“指针与字符串”之间的关系，“二维数组名的含义”（这也是一个小难点，不过，只要大家谨记上次课中的结论，一切将会变得简单：）），以及“指针与函数参数”之间的关系（这种情况很常见哦：））。
## 1. 字符串与指针
- 各位同学大家好，接下来我们开始讲指针的第二个部分。 那么在这个部分里头呢，我们将讨论这样一些问题。 首先我们讨论一下指针与字符串的关系。 那么上节课呢我们讨论了指针和一维数组的关系。 那么这次课呢，我们首先来讨论一下字符串与指针之间的这种关系。 跟一维数组稍有不同。那接下来我们 再来讨论一下今天的重点，就是指向二维数组的指针。 当然指向二维数组的指针跟指向多维数组的指针具有很大的相似之处啦。 ok，下面我们先来看一下字符串与指针。 
- 字符串啊跟数组是很接近的东西。 关于数组的指针，我们上次课曾经讨论过。 那么，在这我首先解释一个概念，这个概念叫做指向数组的指针。 那么，在此之前呢，我们并没有特别的来解释这个概念。 因为啊这个说法并不是特别的准确，但是呢却非常非常的常用。 人们经常用这个词，叫指向数组的指针。 那么什么叫指向数组的指针呢？实际上人们说的是这么一回事，我定义一个数组a[10]， 它里面的元素呢，都是int 型的，然后呢我定义一个指针p， p的基类型呢，也是int 型。 然后这个时候我就可以做一个动作，就是把这个数组的名字呀付给p， 那么在这种情况下，人们就把p称作， 指向数组a的指针。 这是一个很常用的一个称呼，没有什么特别的，大家如果碰到这个称谓呢， 就是说某个变量是一个指向数组的指针，我们知道是说的这么一回事就可以了。 
- 那有了指向数组的指针，那我们就可以定义指向字符串的指针。 因为数组和字符串太接近了，对不对。 那怎么样去定义指向字符串的指针呢？也很简单， 我首先定义一个字符数组，它就是用来存放字符串的。 我们以前讲过字符串和字符数组其实区别就在于有没有最后的反斜杠零， 本质上都是字符数组。 定义一个字符数组，然后我又定义了一个指向char元素的一个指针。我把数组名a付给p，跟上面是非常的对等的， 那么，在这种情况下，我们就称做p是指向字符串a的指针。先解释这么一个概念，这个概念也没有什么特别的用处。 只是大家看到或者听到的话，知道说的是这么一回事就ok了。 好，接下来我们先通过一个例子来稍微预热一下， 我们看看这个程序，你觉得这个程序完成了什么功能啊？ 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        char a[] = "How are you?",b[20];
        char *p1,*p2;
        for(p1 = a,p2 = b;*p1 != '\0';p1++,p2++)
            *p2 = *p1;
        *p2 = '\0';
        cout << "string a is:" << a << endl;
        cout << "string b is:" << b << endl;    
        return 0;
    }
    ```
  ok，我们来讨论一下，程序的开始我定义了一个字符串a， 并且付了一个初值 how are you，定义了另外一个字符串b， 接下来定义了两个指针，p1和p2，我把a 数组名a付给p1，也就是p1是指向字符串a的指针，把b呢付给p2，p2就指向字符串b了， 然后呢循环，那么循环的终止条件是只要* p1不等于反斜杠零， 那么我们就 p1++，p2++， 就是这两个指针都往后走，并且做一个动作，就是把p1的值付给p2， 只要p1没读到反斜杠零，我就把p1的值付给p2， 这是干嘛呀？这是做了一个copy呀，对不对，字符串的复制啊， 复制完了以后呢，我让p2 的结尾也等于反斜杠零，这样的话p1和p2就一样了， 对不对，所以说这个程序很简单。它完成的功能呢， 就是把a copy 给b，比方说字符串a是how are you， 那执行完了之后b 的结果也是 how are you。
- ok，一样的，好， 结束了这个预热啊，我们就来讨论一点小问题。我们先来看一个程序， 看这个程序，看一下这个程序， 你觉得它会输出什么样的结果？ 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a = 5;
        int *pa = &a;

        int b[6] = {1,2,3,4,5,6};
        int *pb = b;

        char c[6] = {'h','e','l','l','o','\0'};
        char *pc = c;

        cout << a << endl;              //5
        cout << pa << endl << endl;     //0x..........

        cout << b << endl;              //0x..........(地址)
        cout << pb << endl << endl;     //0x..........(地址)

        cout << c << endl;              //hello
        cout << pc << endl;             //hello

        cout << static_cast<void*>(c) << endl;      //0x..........(地址)
        cout << static_cast<void*>(pc) << endl;     //0x..........(地址)

        return 0;
    }
    ```
  ok，我们来分析一下这个程序，定义一个变量a， 然后呢定义了一个指针pa，让它指向变量a， 然后呢，定义了一个指针pb，让它指向数组b， 定义了一个字符数组c，并且定义了一个指针pc， 让它指向这个字符数组。 然后呢我就一串的打印，先打印a cout a，如果这个你还不知道什么结果，那我就打算从我的楼上跳下去了。 然后呢，打印一个pa， 这个也应该知道，然后在看第二组，打印一个b b是一个数组名，数组的起始地址，所以说在这仍然会打印一个地址， pb呢也会打印一个地址，因为指针变量里存放的是一个地址， 所以说会打印地址，那么接下来我们重点讨论这一组， cout c和cout pc， 那么cout c呢是直接把字符串的名字放在这了， 那么这一句会打印出什么来？有的同学就开始觉得有矛盾啦， 说，哎，李老师你以前讲字符串的输入输出那部分的时候啊，曾经说过， 象这样的形式应该打印字符串的内容，也就是说会把hello 打印出来，这是我们以前讲过的，那么现在你又说如果你 把字符串的名字打印出来的话，它应该是一个地址，你比方说这个b打印的时候， 它就是一个地址，那c打印的时候岂不是也应该是一个地址吗？，可能有的同学有这个问题， 然后呢，我cout pc，因为pc是我所定义的一个指针的变量， 如果是这样打印的话，应该打印这个变量的值，也就是会把地址打出来，这是我们前面曾经讲过的。 也就是说根据我们前面讲过的内容，在这一句程序上好像存在一点矛盾， 那么对这一句节程序而言呢，没有什么矛盾，它会打印地址， 那么这是根据我们以前学过的东西，做出来的推论，那实际的结果会是怎样呢？ ok，实际的结果是这样的，也就是说在这，也就是cout ， 无论是输字符串的名字，还是输出指向字符串的指针， 都会打印出字符串的内容来，因为cout对字符串做了处理。 好，我这是想告诉大家它有这个区别，就是在输出的时候 知道就ok啦。那有的同学可能还要问，如果呀在这个地方我不想打印字符串的内容， 我就想把那个字符串的地址给打印出来，那应该怎么办呢？ 很简单，看这个程序，你只要这么来写就可以了，你看它打印的都是地址啦， 你只要记住这个结果就可以啦，那以后接触的多了，你很快就会明白啦， ok，这是关于字符串和指针。
- **用指针来操作字符串， 有很多的好处**。我们下面举一个例子， 举一个小例子，来看一下到底有什么好处。 看这个例子，
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        char buffer[10] = "ABC";
        char *pc;
        pc = "hello";
        cout << pc << endl;     //hello
        pc++;
        cout << pc << endl;     //ello
        cout << *pc << endl;    //e
        pc = buffer;
        cout << pc;             //ABC
        return 0;
    }
    ```
  首先定义了一个字符串数组buffer， 它的初始值呢就等于abc，然后呢我定义了一个指针变量，它是指向char型元素的， 然后呢，底下我做了一个动作，这个动作真是看上去真是让我们 羡慕不已啊，**pc等于hello。 以前我们没这么付过值吧？对不对？ 以前对于字符串，我们是不能够直接这样赋值的。 除了定义的初始化部分以外， 我们从来不能直接把一个字符串付给某个数组，这是不允许的。 但是在这呢，如果用指针的话，你就可以这样去做。 用hello直接付给pc，这是可以的， 这是可以的。那么，在这需要特别说明的是， 虽然呢，我们可以把hello这样一个字符串付给一个指针pc， 但是你不能通过这个指针pc去修改 hello这个字符串的值，为什么呢？ 原因很简单，因为hello这个字符串啦，它是一个常量。 虽然你用指针指向了这个常量，但是呢，你却不能去修改它， 为什么，因为在程序运行的时候啊，所有的常量 都被放在一片特殊的存储区域里头，这一片存储区域是不允许你去修改它的。 所以说即便你用指针指向了hello，你也只能去访问， hello这个字符串中的值，而不能够对这个字符串进行任何的修改， 这是我们特别需要说明的一点**。 接下来呢我进行了一系列输出的操作，首先我cout pc，根据我们讲过的cout pc肯定会打印出来 hello，会把内容全都打印出来，这个字符串的内容，然后呢，我对pc 做了一个++的操作，也就是说指针沿着这个字符串往后移动了一位， 原来是hello，现在会打印出什么来，没有h 啦，把ello打印出来。 我还做了一个小动作，* pc，* pc， 也就是说啊，最开始的时候，pc指向h ，指向数组的第一个元素， 那么我们做了一个++以后呢，指针就会指向e， 所以说， 如果我们去cout pc的时候，这个时候我们得到的是ello， 那现在呢，我要去打印* pc， 这个时候要小心，既然pc是指向e的， 那么如果我去cout *pc的话，会打印出什么来？ 一定会打印出e来，这个是毫无疑问的， 我会打印出当前这个元素的内容，这是上次课我们曾经讲过的。 那接下来呢又做了这样一个操作，把buffer付给了pc， 这允许吗？以前我们反复讲如果是对于一个字符串的话， 绝对不能在两个字符串之间互相付值， 那这个付值允许吗？那我想问你为什么不允许？ 你看，buffer它的类型是什么啊？ 字符数组buffer 10的数组名， 它也是指向数组首元素的指针，所以说我把一个指向数组首元素的指针， 付给一个具有相同的基类型的指针变量， 有什么不可以啊？完全可以。 而且当完成这个付值以后，我们再去看，我去直接去打印他， cout pc，那当然会打印出什么来，ABC 因为这个时候pc它指向了哪啦？ 它是不是指向了A呀，因为 buffer本来就是指向A的，buffer付给了pc后，pc也指向A， 那根据刚才我们讲过的，如果我们使用cout去打印一个指向 字符数组指针的时候，它会把字符数组的内容打印出来。 所以打印出ABC。这是整个这个程序的涵义。 

- ok，那么从这我们可以看的出来，用指针来操作字符串是有很大的便利的。 我们可以把一个字符串付给一个指针，也可以 把一个定义好的数组付给一个指针，我们也可以把数组中的某一个元素， 付给这个指针，这也是可以的。 ok，这是指向字符串的指针。那需要说明的是，在c程序里头啊， 对字符串进行操作的时候，指针用的非常非常多。 当然你如果不用指针也可以去实现， 但是很多情况下用指针可以使得程序变得简单一些。 当然那么由于指针本身本身所存在的复杂性， 所以有可能会使得程序的易读性稍微变得难一些， 啊，这是需要说明的，所以说我们在写字符串处理的程序的时候， 你就可以权衡一下，到底要不要使用指针，你自己来选择， ok，这是指向字符串的指针。那么接下里呢我们进入今天的一个重要的内容， 指向二维数组的指针。 
## 2. 取地址与指针运算
- 那接下来呢，我们进入今天一个主要的内容，指向二维数组的指针。 那么在开始讲这部分之前呢，我首先说明一下。那么，指向二维数组的指针啊， 对同学们来说可能是一个难点。比方说在我们这个课上， 有些同学啊，可能践足于一些参考教材，往前学了一些。 他的进度比我们课程稍微快了一点。 当他看到这个部分的时候呢，他就产生了很多的问题。于是呢，就写邮件给我，来询问这些问题。 我很理解这个状况。首先呢，这部分啊稍微有一点点的麻烦。 而且呢，我也确实看到，在很多的教材上解释得不是很清楚。 啊，所以说呢，给同学们的理解造成了麻烦。 其实啊在这一部分很关键是一个理解的问题。 Ok ，那接下来啊，在介绍指向二维数组的指针之前，我们首先啊，先再来谈一下一维数组的 地址的问题。Ok ，大家还记得这一页 PPT 吗? 哪，在这一页 PPT 上啊，我解释了一个问题。 如果你定义了一个指针变量 p2。 它呢，指向了一个普通的整型的变量 a。 啊，因为 a 是一个整型的变量，int 型的变量，所以说， a 在内存空间中占了1，2，3，4 ，4 个字节。 这个时候呢，如果我们对指向 a 的指针变量 p2 进行 ++ 操作的话， 那么，得到的结果并不是对 p2 的这个地址进行了 +1 的操作， 而是进行了地址 + 4 的一个操作。所以经过 ++ 以后呢，p2 移到了这里。 啊，也就是说，一下跨越了 4 个字节。这是我们曾经讲过的。 总结一下的话就是说，当我们对一个指向整型的指针变量进行 ++ 操作的话，那么指针变量的值一下子增加了 4。 啊，这是上次课我们曾经讲过的。我们还说，这个东西呢，它体现了基类型的作用。啊，就因为定义了这样一个基类型，所以才会出现 这样的一个结果。Ok ，那么回顾完这次讲的知识点以后啊， 我们就来看一段程序。我们来看这个程序，读一下这个程序。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int b[4] = {1,3,5,7};

        cout << a << endl;              //0x..........(地址) 指向数组第一个元素的指针
        cout << a + 1 << endl;          //0x.......... + 4 (地址)

        cout << &a << endl;             //0x..........(地址) 指向整个数组的指针
        cout << &a + 1 << endl;         //0x.......... + 16 (地址)

        cout << *(&a) << endl;          //0x..........(地址) 相当于 a
        cout << *(&a) + 1 << endl;      //0x.......... + 4 (地址)

        return 0;
    }
    ```
  想一下，这个程序的输出啊，会是什么样子的? 在这个程序里头啊，首先呢，我们定义了一个数组，int a[4] = 1,3,5,7 数值。 那么当我定义完这样的一个数组的时候啊，那么肯定在内存里头 就开辟出一片存储空间，并且呢，把这个数组放进去。 比方说，啊内存的状况是这样的，4个数组元素摆在这里。 a[0], a[1], a[2], a[3]。 这一边呢，都代表内存地址，啊这都是内存的地址。 当然，内存的地址是一个字节一个字节的来标定的。 啊，比方说这是一个字节，那么这就是由一个字节相对应的内存地址。 Ok ，那我们就来分析一下底下程序的运行过程。首先啊，我在这里打印数组名 a 的值。 毫无疑问，因为数组名是数组首元素的指针，也就是数组首元素的地址 也是数组首元素的起始地址。所以说在这儿毫无疑问会打印这个值 0028F7C4。 会打印这样一个值。这是毫无疑问的。Ok, 再往下，我们去打印 a+1 的值。 这个时候啊，可能有的同学就有不同的建议了。那 a+1 的值应该是多少呢? 到底是在 0028F7C4 的这个基础上 +1 得到 0028F7C5 呢，还是要打印一个其它的值呢 ？ 要分析清楚啊，也不难。我们只要搞清楚这个 a 是什么含义就可以了。 对不对？a 的含义我们再清楚不过了。 a 是数组的名字，也就是 指向数组首元素的那个指针。数组的首元素，第一个元素是什么类型的啊？ 是 int 类型的元素。我们刚刚讲过，当一个指针变量指向一个 int 型的元素，而我们对这个指针变量进行 +1 的操作的时候，它会跨过 几个字节啊？会跨过 4 个字节。 也就是说，当对 a 进行 +1 的时候，它会直接跨过 4 个字节到哪儿啊? 到这里。 到这里。也就是说， a+1 的值会打印哪一个值啊？会打印这个值。 0028F7C8 ，一下跨过了 4 个字节。 啊，我相信呢，这个，大家也不难理解。Ok, 这是这两个。 继续往下看。接下来呢，我要打印的东西叫做 &a。 &a 。有的同学在这儿可能就产生疑问了。 a 呢，它是一个常量，它不是一个变量。 那么在 a 的前面再加一个 & 的取地址符号，这个怎么解释呢？ 这个程序能正确运行吗 ？ 啊，可能很多同学都会有这样的疑问。 Ok, 那其实关于这个问题呢，在上一节课被更新以后的 视频中，我已经给出来解释了。那么在这儿呢，我再解释一下。 这是上次课，我们去解释数组的名字相当于指向数组第一个 元素的指针的时候，我们用的一张 PPT 。那么在这个 PPT 上呢， 我列出来了 3 个从 C 语言的规范中截起来的文字的片段。 那么，在中间的这一段，关于数组类型的表达式，比方说数组名， 它的类型的解释中，明确的指出来了这样的一个问题。 就是说，如果这个数组名啊，except when it is operand of 它，它和 & operator 。如果它不是这个 & 的操作符的一个操作数的时候， 也就是说，如果一个数组的名字 不出现在这个取地址符号的后面的时候， 那么，它的类型将被转换成 an expression with type pointer to type。 也就是说，它就会被转换成为指针类型。 而且这个指针类型是指向哪的呢？指向数组的第一个元素的。 那么这一段呢，就解释得非常的清楚了。就是说，一个数组名， 如果不出现在取地址符号后面的话，那么它呢，就相当于 指向数组首元素的指针。那么如果出现在这个取地址符号后面 会怎样呢？那么根据 C 语言的规范， 当一个数组名出现在 & 的符号以后的话， 它会返回一个指向这个数组的一个指针。 什么意思呢？根据 C 语言的规范，当你把一个有 E 的表达式写在 取地址符号后面的时候，比方说，&E, 那么，根据 C 语言的规范呢，整个这个式子 返回的将是指向这个 E 的一个指针。 那么在这个程序里头，出现在取地址符号后面的是数组的名字 a。 那么根据取地址符号的这个运算规则，在这个时候，整个这个 &a 返回的结果将是指向数组 a 的一个指针。也就是说，这个指针的类型 不再是指向数组的第一个元素的了，而是指向整个数组的 一个指针。Ok ，那么下面我们回到这个例子，再跟大家说明一下。 也就是说，原来呢我们只打印 a 的时候，那么这个程序呢，将会打印这个地址。 对吧？那么现在呢，当我们打印 &a 的时候， 它依然会打印这个地址。 但是，&a 跟 a 有什么不同呢？ a 呢，是相当于指向数组首元素的那个指针。 而 &a 也就是取地址符号加上 a ，相当于什么呢？ 相当于指向整个数组的一个指针。 啊，也就是说啊，这两个 a 啊， 虽然打印出的地址是同一个地址， 但是它们的管辖范围不同。 那么这个 a 呢，它的管辖范围只是数组的首元素。但是 &a 这个表达式所返回的那个指针， 它的管辖范围是哪呢？是整个数组。是整个数组。 虽然他们打印出的地址是一样的，但是它们的 管辖范围完全不同。啊也就是说， 如果在数组名字前面加上一个 & 的符号的话， 就相当于把这个数组名字的管辖范围 上升了一级，给它升官了。明白这个意思了吗？ 啊，这就是 &a 的含义。好！ 我们呢清理一下屏幕，接着往下看， 通过刚才我们这个介绍啊，大家都知道， &a实际上是一个指向整个数组的一个指针。 那么在打印完&a以后，我再去打印 &a+1，请问它会打印哪个地址呢？ 那根据我们前面讲过的，如果对一个指针进行+1的话， 它会跨过它的基类型所占用的全部内存单元。 对不对，如果对a进行+1，我们得到了这个地址， 得到了这个结果；如果对&a+1的时候，我们应该得到哪个结果啊？是不是从这 将跨越整个数组啊， 对不对，将会跨越这个数组a+1。所以说 &a+1会指向哪里？会打印哪个地址啊，会打印这个地址。 这是&a+1的这个涵义。 它会跨越整个数组。好，说到这呢，我们不妨先来看一下 这个程序的执行结果。这是这个程序的执行结果，我们来核实一下。 当我去打印数组名a的时候， 我得到的是0028F7C4，也就是这个地址， 这毫无疑问是正确的。当我去打印a+1的时候，我所得到的是， 0028F7C8，是这个地址，这个也是正确的。 当我再去打印&a的时候，我们说这个时候， 虽然它跟a的结果应该是一样的，但它的权限范围不同。 我们先来看打出来的结果是不是一样的，0028F7C4， 跟这个结果是一模一样的。 那我接下来再去打印&a+1，那么根据我们的分析它将打印这个地址。我们来看一眼， 是不是0028F7D4？没有错这是这个地址。通过这几次打印，我们就能搞清楚a和&a的涵义。 好再完成这个输出之后啊，我又打印了一个这样的表达式， *(&a),而且呢 先算&a 再去算*，那么对于这样的一个表达式我们应该怎么样去理解呢？ &a，a是数组名，&a是指向数组的 一个指针，它是指向整个数组的这么一个指针， 对它进行指针预算，求*（&a），那这个会返回一个什么样的结果呢？ 那么根据C语言的规范，出现在* 运算后面的这个表达式， 比方说这个E，如果这个表达式是一个指针的话， 那么*E这个表达式返回的结果将是， 这个表达式E，它不是个指针吗？它所指向的那个内容。 回到这个例子，比方说在这，我们在&a前面使用了*， 那根据刚刚我们所讲过的， 整个这个表达式，也就是*（&a） 这个表达式，返回的结果将是， &a这个式子所指向的那个东西，那&a指向的东西应该是什么啊， 我们刚刚讲过，&a指向的是数组， 所以说当我们去打印这个表达式*（&a）的时候，其实整个的打印结果就相当于我们去打印a 就是这样的一个结果。 所以说在这打印的时候，你看我们打印出来是0028F7C4， 是这个值。那有的同学说了，哎呀，你打印出来这个地址，我可不知道这个地址表示什么涵义， 因为在这，在这都会打印这个地址，那么 为了证明这个地址的涵义，很好办，我去打印一下*（&a）+1的值。 那么通过这个打印我们发现，它的值打印出来0028F7C8是哪个，是这个值， 说明我们在这打印*（&a）跟打印a的结果是一样的。 ok，这就是整个这个程序运行的结果。 那么鉴于这个程序运行结果的重要性，我们再来梳理一下它的输出结果。 我定义一个数组a，4个元素， 那么接下来当我去打印数组名a的时候，毫无疑问， 我会打印数组的起始地址，也就是这个地址。那么当我去打印数组名+1的时候， 因为数组名相当于指向数组第一个元素的指针， 因此对数组名进行+1的时候，将会跨过第一个元素，所以说这个值会打印这个地址。 接下来当我们去打印&a的时候，那么根据刚才我们所讲的， &a呢将会返回指向整个数组的一个指针。 当然当我们去打印&a的时候，仍然会打印这个地址，也就是说数组的起始地址。 但是呢我们知道这个时候，&a它的涵义已经不同了。 在a的前面加了一个&符号，那么就相当于把a的管辖范围给它上调了一级， 上升了一级。 原来a的管辖范围呢是第一个数组元素， 那么上调了一级之后呢，&a的管辖范围就变成了 整个数组了， 这是&a的涵义。所以说当我们再去打印&a+1的时候， 那么它会跨过整个数组的存储范围而去打印 这个地址。这是刚才我们所看到的。 ok，接下来再去打印*（&a），刚才我们也讲过， 这一句相当于打印a ，所以说， 我仍然会打印这一个地址，仍然会打印这个地址。 那么*（&a）的涵义呢完全就相当于a，也就是说啊当我们把一个*号 放在一个表达式的前面的是时候，就相当于把这个表达式的管辖范围， 又给它降了一级，对不对，原来&a的管辖范围是整个数组， 那么现在呢，我给它降了一级之后，*（&a）的管辖范围又变成了数组的第一个元素了。怎么去证明这一点呢，当我们打印*（&a）的时候，它又会跨过数组的 第一个元素而去打印这个地址啦， 对不对，这就是这个程序执行的所有的结果。 ok，通过这个程序啊， 我们啊就可以得到这样一些结论，关于一维数组的。 首先呢，我们知道，数组名呢相当于指向数组第一个元素的指针。 那比方说这个数组a呢是指向这个首元素的指针， 也就是说a相当于&a【0】，这是我们知道的， 
- 那么在这个前提下，通过刚才的例子，我们能得出来这样两个结论。
  - 第一个， **当我面写&a的时候，这个&符号用在a上面，就相当于把a的管辖范围， 做一个比方的话，上调了一级或者叫上升了一级， 也就是说原来a的管辖范围呢，只是a[0]，数组的第一个元素。 如果我们在前面增加一个&的符号的话，那么 &a的管辖范围就变大了，变成了整个数组了, 上升了一级**。
  - 那么跟这个结论相对的，**我们还可以得到 * 运算， 就是当我们在一个表达式的前面加一个 * 运算指针运算符的时候， 也就是相当于我们把这个表达式的管辖范围啊， 下降了一级，比方说对于这样一个例子，那么原来a是指向a【0】的一个 指针，那如果我们对它做 * a的运算，我们得到的 只是a【0】的值，也就是说如果我们打印a的时候，好歹我们得到的是一个地址， 那么如果我们去打印 * a的话，我们得到的只能是a[0]的值， 对不对。那么对比刚才的那个例子，对于数组a，我如果&a的话，相当于上升了一级， 那如果我对这个上升的结果再做一个 * 运算的话， 就把上升的那一级又给它降回来了，所以这个就相对于a**。
- ok，其实呢这一点都不复杂，总结起来就两句话， 也就是&号，就相当于把&后面的表达式，上调了一级，管辖 范围扩大了一级，* a呢就相当于管辖范围下降了一级。 如果这么理解的话，就非常非常的简单，也非常容易记住。 ok，有了这个概念，我们再去看二维数组，就容易的多了。 
## 3. 二维数组名的含义
- 好，刚刚在上一小节中啊，我们再次讨论了一下一维数组的地址。 那么在这一小节中呢，我们将讨论指向二维数组的指针。 那么通过上一小节的讨论啊，我们能得到这样一些结论。 首先我们知道数组名呢相当于指向数组第一个元素的指针。 啊这是我们解释过很多次的一个结论了。那么其次呢， 当在一个表达式的前面使用&符号的时候，那就相当于把这个表达式的 管辖范围上升了一级。那如果在一个表达式的前面使用了* 符号的时候，那就相当于啊把这个表达式的管辖范围 下降了一级。那么这是刚刚我们关于一维数组 总结出来的一些结论。那么对于二维数组呢？ 二维数组啊也一样。我们来看它怎么是一样的。
- 比方说对于这样一个二维数组， 它包含了三行四列，那么这是一个三行四列的二维数组a[3][4]。那么对于这样一个二维数组而言，那么既然我们说二维数组跟一维数组啊，它的规律也是一样的。那么我就想知道啦，在这样一个二维数组中，谁是我们所说的第一个元素呢？啊这就是我们所必须要讨论的一个问题啦。那么其实呀，在我们讲二维数组定义的时候，我们就曾经提到过。定义一个二维数组，比方说是a[3][4]这样的二维数组， 其实就相当于你定义了三个一维数组。这三个一维数组呢分别是a[0]， 它包含了四个整型元素， a[1]，它也包含了四个整型元素，和a[2]，也包含了四个 整型元素。也就是说一个二维数组就相当于有三个数组 名为a[0]、a[1]、a[2]的三个一维数组来组成。 好，那么有了这样一个解释之后，我们说二维数组中我们所说的第一个元素应该指的是谁啊？应该指的是 a[0]。啊，**它的第一个元素应该指的是a[0]。 a[0]是一个包含四个整型元素的一个一维小数组。啊就是这个数组。也就是说，二维数组中的第一个元素其实是一个包含了四个整型元素的一个小数组，这个小数组的名字叫做a[0]**。这是我们所做出来的结论。那OK，基于我们已经有的结论，一个数组的数组名相当于指向数组第一个元素的指针。 那么在这，第一个元素又是以a[0]为名的那个包含四个元素的这个小数组，所以说，a的含义其实是指向这个小数组的一个指针。也就是说，二维数组 a[3][4]的名字，这个a它的含义是指向， 是指向名字为a[0]的这第一个小数组的这么一个指针。 这就是二维数组的数组名的一个基本含义。 那么说到这儿啊，我想多问一句。那么请问， 对于这样一个一维数组， 这样一个名字为a[0]的一维小数组， 请问a[0]的含义是什么呢？OK。很多同学就反应过来了，既然它是个一维数组嘛， 所以在这a[0]的含义实际上是什么啊，指向数组的第一个元素的指针。 **也就是说，a[0]是指向第一个元素，也就是a[0][0]这个元素的一个指针。 它仍然是一个指针。 它就相当于数组元素a[0][0]的一个指针。啊这就是a[0]的 基本含义**。 
- OK，我们来总结一下。我们就来总结一下，对于我们所定义的一个a[3][4]这样的二维数组， 在这样的一个二维数组里头，刚刚我们所提到的那一系列表达式， 它们的管辖范围。啊我们来总结一下，我们来排个顺序。 我们根据它们的管辖范围啊，把它们的级别高低来排一个顺序。 首先我们写出二维数组的名字a。 这个二维数组的名字a其实是代表了指向第一个小数组的 这么一个指针。这是它的管辖范围。那么比它的管辖范围要小 一点的是a[0]。那么a[0]的管辖范围是什么呢？ **a[0]是第一个小数组的名字。也就是说， a[0]是指向数组第一个元素， 指向这个元素的一个指针**。也就是说，a[0]的管辖范围是第一个元素，对不对？那么除了a[0]之外，还有没有比a[0]级别更低的？ 有呀。a[0][0]。根据刚才我们这个分析，a[0]它好在还是一个指针呢，对不对。 a[0][0]它就不是一个指针了。 它是被指针指向的一个int型的量，它的值是1。 也就是说a[0][0]其实它的管辖范围只能是里边这个int型。 它就是a[0]所指向的这片空间里面的那个内容，对不对。啊这是一个级别高低的一个顺序。 那有的同学问，有没有比a更高级别的量啊。当然有啦。我们也曾经讲过啊，应该是 &a。我们知道&a就相当于给a又升了一级，对不对。 **那&a就是指向整个二维数组的这么一个指针**。 所以说&a的级别就相当高了，对不对。 这就是我们按照这四个元素它们的管辖范围的不同排出来的一个级别高低的顺序。 
- OK，那么基于这样一个顺序，我们就可以得到一系列的推论。 比方说，我们可以得到这样一些结论。 
  - 既然a比a[0]要高一级别，所以呢a与&a[0]的级别应该是相等的。
  - 那么同时呢，a[0]就相当于&a[0][0]，它两个是等价的。因为&a[0][0]就相当于，就相当于又给a[0][0]升了一级嘛，对不对。
  - 那么a[0]呢，又与 * a是等价的。也就是说，当我们使用* 给a降一级别的时候，给这个a降一级别的时候， 我们就会得到a[0]。啊这所以说它们两个是等价的。
  - 那么a[0][0]呢， 就与** a，也就是说给a降两级的时候，它就与 a[0][0]是等价的。
- 是否我们可以得到这样一些结论哪。 那讲到这呢，有同学说，哎呀，太复杂了。 二维数组里面就这么多的级别，那如果是三维数组的话， 是不是级别更多啦，那就太复杂了。其实呢，一点都不复杂。 啊我们来总结一下。 虽然我们讲了这么多，其间呢，各个量之间的关系变来变去，但无论它怎么变换，变不离其宗，都符合这三条规律。 也就是说，它其实都是按照这样三条规律来变来变去的。 只要我们晓得了这三条规律，我们就可以按照这样一个规律， 随便地去推理。这个规律就是，
  - 首先数组名相当于指向数组第一个元素的指针。
  - 其次，&E 就相当于把E的管辖范围上升了一个级别。 
  - 那如果是* E的话，也就是说在一个表达式前面加*的话， 就相当于把E的管辖范围下降了一个级别。 
- 也就是说，无非就是遵循这三条规律来变来变去的。 没有什么，一点都不难。只要了解了这三条规律啊， 那所有的事情都好办。那有的同学说，哎呀，我真想写个程序试试。OK，那么我们就写个程。 OK，那我们就来看几个程序。
## 4. 二维数组名引用示例
- Ok 我们来看这个程序。
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12},};

        cout << "      a = " << a << endl;                                  //0x0013FF50
        cout << "      &a[0] = " << &a[0] << endl << endl;                  //0x0013FF50

        cout << "      a + 1 = " << a + 1 << endl;                          //0x0013FF60
        cout << "      &a[0] + 1 = " << &a[0] + 1 << endl << endl;          //0x0013FF60

        cout << "      *a = " << *a << endl;                                //0x0013FF50
        cout << "      a[0] = " << a[0] << endl;                            //0x0013FF50
        cout << "      &a[0][0] = " << &a[0][0] << endl << endl;            //0x0013FF50

        cout << "      *a + 1 = " << *a + 1 << endl;                        //0x0013FF54
        cout << "      a[0] + 1 = " << a[0] + 1 << endl;                    //0x0013FF54
        cout << "      &a[0][0] + 1 = " << &a[0][0] + 1 << endl << endl;    //0x0013FF54              
        return 0;
    }
    ```
  在这个程序里头呢， 我定义了一个二维数组， a[3][4]。 啊，给它赋好初值。 然后呢，我们打印一系列的量。首先我们来打印 a 。a 呢 是二维数组的数组名，所以是指向二维数组的第一个小数组的指针。 所以说呢，你打印 a 的话，应该会打印第一个元素的地址。对不对？那么接下来， 如果我去打印 a+1 的话，它会跨过第一个小数组，而到这儿。所以说， 打印 a+1 的话会打印这个地址。然后呢，再看第二条，我打印 &a[0]， 因为 a[0] 呢，是第一个小数组的数组名， 所以 a[0] 是指向第一个元素这个 1 的这个元素的 一个指针。那么 &a[0] 就相当于给它升了一级。升了一级之后变成什么啦？ 变成这个，啊，变成指向第一个小数组的一个指针了。 所以我们打印 &a[0] 的时候，它会打印第一个元素的地址。 而当我们去打印 &a[0] +1 的时候，它会去打印 这一个元素的地址，对不对？那么再来看下面的一组， * a 。因为 a 呢 是指向小数组的这个指针，所以 * a 相当于给它降了一级。 应该是指向这个元素的指针。所以当我们打印 * a +1 的时候啊，它应该会打印这个元素的地址。 对不对？啊，我们再来看 a[0] ，当我们打印 a[0] 的时候， a[0] 是第一个数组的 名字，也就是指向第一个数组元素的指针。那如果 我们打印 a[0] +1 的时候，因为它指向第一个数组元素嘛，所以说也会打印这个值。 接下来我们再去打印 &a[0][0] ，那这个很好理解了。 a[0][0] 是二维数组中第一个小元素，对不对？ 那么，&a[0][0] 呢就是第一个小元素的地址，就是这个地址了。 如果对 &a[0][0] 进行 +1 的话，那么就相当于要打印这个地址。 对吧？我们来看一下这个程序的运行结果。 啊，我把这个运行结果排起来，我们可以看到 a 和 &a[0] 它两个的地址是一样的。 这符合我们所说的规律。那么， a+1 和 &a[0]+1 ， 它两个是一样的。啊，这也符合我们的规律。它们两个差了多少呢？刚才我们分析过， 那么这一组呢，会打印这个元素的地址。而这一组呢，会打印这个元素的地址。 所以说它们两个应该差了四个整形元， 也就是差了16个字节的内存空间才对。 我们看，是不是差了16个字节的内存空间啊。 由 50 变成了60 。有的同学说，50 变 60 不是差 10 吗？这是 16 进制的，啊， 所以说正好差了 16 个字节。我们再来看这一组。从这个结果上我们可以看到 * a 和 a[0] 和 &a[0][0] ，它们的地址完全是一样的。 啊，这个也符合我们的规律。那么对它们进行 +1 的话根据刚才我们的分析 都会打印 2 这个元素的地址。我们来看一下是不是。 啊，它的地址是50， 在这儿呢，打印了 54 。所以说，这个呢， 都比在没 +1 之前增加了4 个字节。啊，所以说我们的判断和程序的运行结果是一致的。 

- ok, 我们再来看一个例子。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};

        cout << "      a = " << a << endl;                                  //0x0013FF50
        cout << "      &a[0] = " << &a[0] << endl << endl;                  //0x0013FF50

        cout << "      a + 1 = " << a + 1 << endl;                          //0x0013FF60
        cout << "      &a[0] + 1 = " << &a[0] + 1 << endl << endl;          //0x0013FF60

        cout << "      a[1] = " << a[1] << endl;                            //0x0013FF60
        cout << "      &a[1] = " << &a[1] << endl;                          //0x0013FF60
        cout << "      *(a+1) = " << *(a+1) << endl << endl;                //0x0013FF60

        cout << "      *a + 1 = " << *a + 1 << endl;                        //0x0013FF54

        cout << "      &a = " << &a << endl;                                //0x0013FF50
        cout << "      &a + 1 = " << &a + 1 << endl << endl;                //0x0013FF80              
        return 0;
    }
    ```
  同样，在这个程序里头啊，我也是定义了一个二维数组 a[3][4]。 然后呢，接下来打印一系列的量。我们来看一下， 先打印 a ，然后再打印 &a[0] ，然后再打印 a+1 再打印 &a[0]+1。这都是我们在前一个例子都分析过的。 那么接下来呢，不太一样。首先呢，我来打印 a[1]。那有的同学说 a[1] 应该是什么呀？ a[1] 是整个二维数组中的第二个小数组的 名字。也就是这个小数组的名字。然后 &a[1]， 因为 a[1] 是这个小数组的名字，所以 a[1]是指向这个元素的一个指针。 在它的前面加了一个 & 的符号就相当于给它升了一级。所以说 &a[1] 是指向哪个指针啊？ 它是指向整个的这第二个小数组的一个指针。 啊，这是 &a[1] 的含义。指向这里， a[1] 呢，指向里面，指向它。 我们再来看。 * (a +1)，哇，这个我们就要分析一下了，对不对？我们先来看，(a+1) 表示什么意思？a 呢，是指向 二维数组中的第一个小数组的指针。对不对？ (a+1) 呢，它应该是指向二维数组第二个 小数组的指针。这是 (a+1) 的这个含义。对不对？然后 *(a+1)， 那么*(a+1) 就相当于把 (a+1) 降了一级，对不对？所以说 *(a+1)也应该是 指向二维数组中第二个小数组的第一个元素的指针。 啊，这就是整个这个*(a+1) 的这个含义。它也是指向二维数组的第一个元素的这么一个指针。 所以说如果对它进行打印的话应该打印这个地址的值。 我们再来看一下 * a+1， 啊没有括号了，这一次。 * a+1 应该是什么？a 是 指向二维数组第一个小数组的指针。 那 * a 呢，相当于降了一级。相当于指向二维数组第一个小数组中第一个 元素的指针。现在对 * a 再进行 +1，所以说这个地址应该指向哪儿啊？ 指向二维数组中第一个小数组的第二个元素。啊，所以说， * 1+1 实际上应该指向它。如果打印地址的话应该打印它的地址。 接下来我们再来看，打印 &a ，这个好办。这个刚刚我们讨论过。&a 的话就是指向 整个二维数组的一个指针。这是 &a 的含义。 那么 &a+1 ，按照这个道理，&a+1 就会从 这个二维数组的起始跨过整个的这个二维数组。 所以说 &a+1 应该是打印最后一个元素的下一个元素。 啊，应该是这样的一个关系。我们来看一下这个程序的运行结果。 a 反应出来 FF50。 啊，我们记住这个值。那么，&a[0] 呢，肯定也是 50 。啊，是这样一个值。 那么我们讲过，a+1 和 &a[0]+1， 它应该是一样的。 它们都会跨过16个元素。所以说都会打印 60 。啊，这是刚才我们讲过的了。 那么接下来我们再去打印 a[1] ，a[1] 呢是二维数组中第二个小数组的 名字，也就是指向二维数组中第二个小数组的第一个元素的指针。所以它会打印出来 a60 。因为起始地址是 50 。跨过第一个小数组之后，地址正好是 a60。 那么 &a[1] 呢，根据我们刚才的讨论，它应该是指向 整个这个二维数组的第二个小数组的这么一个指针。 所以说它也会打印这个地方的地址。啊，所以说也是 FF60 。那么，* (a+1)，根据刚才我们的讨论，* (a+1) 其实指向的是二维数组中第二个小数组第一个元素的地址，所以说，会打印这个地方。 还是会打印这个地址。啊，我们看到的，还是这个地址。再接下来，* a+1， 根据刚才我们的讨论，*a+1 应该是指向二维数组中 第一个小数组的第二个元素的指针。所以说，会打印这个值。 也就是比起始地址增加了 4 ，啊，54 。啊，这个没有错的。 那么接下来呢，我们再打印 &a ， 那么我们都知道，打印 &a 的话应该是数组的起始地址。不用再分析了。 那么再打印 &a+1，根据刚才我们的分析， &a+1 呢会跨过整个二维数组， 跨过整个二维数组之后打印二维数组之后的一个地址。 我们来看一下。二维数组的起始地址呢，是 50。 &a+1呢打印出来是 80 ，那这中间跨过了多少个 16 啊？ 跨过了 3 个 16 。啊，刚好是 3 行。所以说 通过这个地址我们可以看出它刚好把二维数组全部都 跨过去了。所以说这个程序的执行结果跟我们的分析也是一致的。 ok, 那么通过对这些程序的分析啊，就印证了刚才我们得出来的 这个结论。那么以后呢，大家在遇到二维数组甚至多维数组的情况的时候，都可以按照这个规律来进行分析。 所以说啊，在这个方面的理解，花点时间也是值得的。 