# 结构体与链表
> 这次课，我们将为大家讲解“结构体”的基本概念、定义方式和使用方式，结构体的使用将为某些程序的编写带来极大的便利：）在此基础上，我们还将介绍“链表”的基本概念和创建方法。需要说明的是，在我们的课程上，链表将不作为一个重点练习的内容，因为，在后续的课程中，它将被反复大量的讨论：）
## 1. 结构体与结构变量
- 各位同学大家好，下面呢我们开始今天的内容， 结构体与链表。那么根据我们的课程的安排呢， 那么这部分内容啊，属于需要大家了解的内容。也就是说我们对这部分的内容啊， 不会有太高的要求。那在这部分里头啊，我们将讨论这几方面的内容， 第一方面关于结构体，什么是结构体，如何去使用它。第二方面关于链表，如何去创建 和操作链表。在里边呢，我们也会提一下双向链表的问题。 第三部分作为我们课程的一个收尾，我们来轻扣一下面向对象之门。OK，下面我们先开始 第一部分，先来看一下什么是结构体。其实啊，在我们设计程序的过程中啊， 经常遇到这样的情况，也就说啊，我们想把一组变量啊定义在一起。 用这一组变量呢，来描述同一个事物。比方说， 我们可以定义这么一组变量来描述一个学生，
    ```C++
    int id;         //声明学号为int型
    char name[20];  //声明性别为字符数组
    char sex;       //声明性别为字符型 
    int age;        //声明年龄为整形
    float score;    //声明成绩为实型
    char addr[30];  //声明地址为字符数组
    ```
  在这儿呢，id表示学号。 name姓名，sex性别，age年龄，score成绩，addr地址。 其实这一组变量都是用来描述一个学生的。那么有的时候呢， 在写程序的时候我们就想把这、一组变量啊，给它捆绑在一起 使它们呢看起来像是一个整体，以强调呢它们是用来描述同一个事物的，从而使得这一组变量之间的关联变得更加的明显，它的意义呢也变得更加的直接。有的时候啊，我们很想这样来处理。 

- 那么在C语言里头有没有一个办法，可以支持我们一组变量捆绑起来定义在一起呢？ 有！那么今天我们要讲的这个结构体就是来支持我们做这样一件事情的。比方说对于这样一组变量，
    ```C++
    struct student  //名字为student的结构体类型
    {
    int id;         //声明学号为int型
    char name[20];  //声明性别为字符数组
    char sex;       //声明性别为字符型 
    int age;        //声明年龄为整形
    float score;    //声明成绩为实型
    char addr[30];  //声明地址为字符数组
    };              //注意大括号后的";"
    ```
  在这一组变量的前面和后面分别加一个大括号， 把它们括起来。然后呢，在这样一组变量前面加上一个struct student 这样一个描述，从而呢我们就定义了一种新的数据类型 这个新的数据类型就是结构体。
- 在这儿啊，我需要特别特别强调的， 我们在这儿啊定义的这个student，它啊不是一个变量， 它不是一个变量，而是一种数据类型。 什么意思啊？它跟int float, char等等等等这些数据类型一样，它是一种数据类型，是用来定义其他变量的东西。 那么这种数据类型跟我们以前遇到过的数据类型有什么不同呢？ 它属于组合数据类型，也就是说把这一组变量给它捆绑在一起，形成了一个新的数据类型。 那么这个数据类型呢，是用来定义其他类型的。OK，既然我们反复强调它是一个数据类型，所以如果我们要使用这个结构体的话，我们就必须利用这个结构体来定义变量，我们来看一下怎么利用这个结构体来定义变量。太简单了，就跟我们定义普通变量是一样的。 这个结构体的名字，student，就是我们刚刚所定义的那个结构体的名字，写在前面。 然后呢把变量名字写在后面，student1,student2 那么对比传统的变量的定义的话，你就会发现传统的变量的定义， 它的格式是完全相同的，语义也是相同的。 那么在这儿呢，需要稍微多加一点说明的，其实除了这种方式以外， 我们还有一种方式可以用来定义结构体类型的变量，那就是直接把它写在结构体定义的后面。比方说这是我们刚才所定义的那个结构体student，然后呢， 在它的后面，定义完这个结构体之后我接着两个变量的名字，lige_1,lige_2，定义成两个变量了。 OK，这就是结构体类型的定义和结构体变量的定义。
- 那么定义好了这样一个结构体我们怎么去使用它呢？ 我们来看一个简单的小例子，看这段程序。
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    int main()
    {
        student mike = {123,{'m','i','k','e','\0'}};
        mike.id_num = 20130000  + mike.id_num;
        for(int i = 0;mike.name[i] != '\0';i++)
            mike.name[i] = toupper(mike.name[i]);
        cout << mike.id_num << " " << mike.name << endl;
        return 0;
    }
    ```
  那么在这段程序里头啊，我就定义了一个 结构体的类型，student。那么为了展示的方便呢，我在这儿对这个类型啊做了个简化， 那包含两个部分，第一个部分是id number，表示学号。另一个部分呢，我们用一个字符号数组来表示学生的姓名。那么需要特别提示的是呢，在结构体类型定义的后面千万别忘了这个分号。如果忘了的话语法就错了。 那么定义完这个结构体类型以后啊，我们就可以利用这个类型来定义变量了。 比方说在主函数里头我们就定义了这么一个变量mike，然后呢，我们利用这样的方式 来对变量进行了一个初始化。大家可以注意到这样的一个初始化的方法， 跟我们对多维数组进行初始化的方法是非常非常的 接近的。那么其实啊，不仅是初始化的方法 与数组非常非常的接近。其实呢，结构体类型的变量， 在内存中的存储方式跟数组也是非常非常地接近。 比方说对于我们定义的这样一个变量mike，它的内存中的存放方式就是这样的。 那么前面的这个123是一个整型的变量，所以在内存中它占用了四个字节来存放这个123。然后呢，mike这个字符串在内存中 就占了五个字节，刚好是123之后的这五个字节。 那么由此我们就可以看到，结构体类型的变量它的存储方式 跟数组的存储方式是非常非常接近的。那么都是呢利用了 一片连续的内存空间来进行存储的。OK，那么在定义好这个结构体类型的变量以后呢， 我们就可以来引用并且操作这个变量了。 比方说，如果我们要修改mike的学号我们可以这样来引用mike.id_num，那么通过这样的一种形式我们就可以直接来引用结构体类型的变量中所包含的的那个自变量。通过这种方式， 我们就可以来引用它。那么在这个程序里头，我们把原始的这个数给它加了20130000，得到了一个新的学号。 然后呢我们再来修改mike的这个名字，我们要把所有的小写字母换成大写。 我们就可以用这样的一个循环，从0开始一直到\0。对于这个 结构体变量里面所包含的这个字符数组中的每一个元素， 我们都可以用这种方法来引用。 mike.name[i]那么这种方式呢，我们就可以引用到 这个结构体类型的变量所包含的这个数组里的每一个元素了。 然后呢，我们利用一个toupper这个函数，把这个字母变成大写字母。 那么最后呢，我们再去利用mike.id_num 把mike的新学号打印出来。然后呢，利用mike.name我们直接去cout mike的name的话，我们就可以把mike这个结构体变量里面所包含的字符数组给它直接打印出来。 OK，那么这是关于结构体类型的定义。那么接下来呢，我们再来看一下怎么去使用结构体类型的变量。
## 2. 结构体变量与函数
- Ok, 那么在了解了结构体变量的定义和应用之后啊，我们来看一下结构体变量的使用。 那么首先我们来看一下结构体变量的赋值。比如说，当我们把一个结构体赋值给另外各结构体的时候，会发生什么样的情况。我们来看这个例子。 
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    int main()
    {
        student mike1 = {123,{'m','i','k','e','\0'}};
        student mike2;
        mike2 = mmike1;           //结构体的直接赋值，相当于copy一份给对方
        mike2.id_num = 20130000 + mike2.id_num;
        for(int i = 0;mike2.name[i] != '\0';i++)
            mike2.name[i] = toupper(mike2.name[i]);
        cout << mike1.id_num << " " << mike1.name << endl;    //123 mike
        cout << mike2.id_num << " " << mike2.name << endl;    //20130123 MIKE
        return 0;
    }
    ```
  首先在这个例子里头呢，我仍然定义了一个结构体student。 那为了展示的方便，我们对student呢进行了一个简化， 保留了id number作为学号，保留了name这个数字作为学生的姓名。 然后在主函数里头我定义了一个结构体变量mike1，并且呢，对mike1进行了初始化， 学号123，姓名小写。然后紧接着，我定义了另一个变量mike2， 并且呢，没有对mike2进行初始化。那么在接下来的程序里头呢， 我直接把mike1赋给mike2。 嗯，把mike1赋给mike2。 首先，这个程序可以直接运行吗？Ok，这个程序是没有问题的。嗯，它是可以直接运行的。当我们把一个结构体变量 赋给另外个结构体变量的时候，实际上跟普通变量的赋值是完全一样的。 也就是说，系统会把这个结构体变量的值copy一份赋值给这个结构体变量。 也就是说，当这个程序执行完毕的时候，内存中的状况是这样的。啊，mike1呢占用一片 独立的内存空间，mike2也占用独立的一片空间，但它们两个的值是一样的。 那么接下来的动作，我们就容易理解了。那么接下来的动作里头呢，我对mike2的值进行了修改，我把mike2的学号呢 改成了20130123，然后把mike2的名字呢 改成了大写。于是我们分别去打印mike1和mike2的时候，我们得到的结果 应该是这样的。第一个会打印123，因为没有被修改过。那么第二个会打印20130123，大写mike。 Ok，那么通过这个程序啊，我们也证明了当我们把结构体的变量赋给个另外结构体变量的时候， 其实是copy了一份，创造了一个复本给了对方。那这是结构体赋值的 一个很重要的特点。 

- Ok，那接下来我们来看一下结构体变量做函数参数的情况。那么在这个，我们首先想要强调一点。当我们把一个结构体的变量传给一个函数的时候， 就相当于啊，我们把这个变量copy了一份，并且把这个副本传给了这个函数。那么这个情况跟数组名做变量是完全不同的。 那么现在我们通过一个例子来观察一下是不是这样的。
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    void renew(student one)                                 //把 mike copy 了一份给 one
    {
        one.id_num = 20130000 + one.id_num;
        for(int i = 0;one.name[i] != '\0';i++)
            one.name[i] = toupper(one.name[i]);
        cout << one.id_num << " " << one.name << endl;      //20130123 MIKE
    }
    int main()
    {
        student mike = {123,{'m','i','k','e','\0'}};
        renew(mike);
        cout << mike.id_num << " " << mike.name << endl;    //123 mike
        return 0;
    }
    ```
  在这例子里头，我仍然利用了结构体类型student。 在主环数里头呢定义了student类型的变量mike， 并且呢，对它进行了初始化。那么初始化的结构呢就是这样的。在主函数里头有这样的一个变量。 那么接下来呢，我把这个变量mike当作参数传送给一个函数renew。 在这个函数的里面呢，我定义了一个形式参数student one， 用这个形式参数来接纳传进来的这个mike，啊是这样的一个情况。 然后呢在这个函数里面，我对这个形式参数one进行了一个值的改变。 比方说我把学号变成了新的学号。mike的名字由小写改为了大写， 并且在这个函数的里面，我把变量one的值都给打印出来。打印完之后， 这个函数的功能就结束了。并且呢，由于这个函数是void的类型，所以它没有返回任何的值。 嗯，这个函数就结束了。 那么在调用完这个函数以后，在主函数里面我又把mike这个变量的值全部都打印出来。 我们先来看一下这个程序的运行结果，然后我们再来分析一下。 这个程序运行的结果是这样的。当我在函数里面第一次打印one的值的时候，我打印出来是这个值。 然后呢，当函数运行结束以后回到主函数里面去打印mike的时候啊，出来是这个值。 我们可以看到这两个值是完全不同的。也就是说，实际上这个数值传送的过程是这样的， 在主函数里面，我初始化完毕以后得到了这样的一个变量。 当我把它传递给变量数renew的时候，实际上 是把这个变量copy了一份给了renew里面的形式参数one。 啊，这个地方是一个copy。那么在renew里面呢，对one又进行了改变， 把它变成了这样的一个样子。也就是说，在这个过程中 由于main函数把mike给copy了一份 给renew里面的那个one，所以说在接下来的过程中，对one所做的 任何的修改，都不会影响到主函数里面的mike。 啊，因为它们两个是互相独立的变量。 所以最后打印的时候，one打印one的，mike打印mike的。 它们互相不会干扰。 Ok，那么这个程序就应征刚才我们给出的一个结论，就是说当我们把一个结构体的变量当作参数传递给一个函数的时候， 实际上我们是把这个变量copy了一份传递给这个函数。 也就是说这个函数拿到的是这个变量的一个赋本。无论这个结构体有多么的复杂， 全部都copy了一份给这个函数。 **这个跟我们以前说过的数组名参数的情况是完全不同的。因为数组名只是代表一个地址， 所以说当我们把数组名传给另一个函数做参数的时候， 实际上只是copy了一份地址给它**。对不对？ **但是当我们把一个结构体变量当作参数传递给一个函数的时候，实际上是把这个结构体变量所有的值全部都copy一份给这个函数。 那么结构体变量做参数的这种特点是我们特别需要注意的。 那这个特点也非常非常地好。其实我们在写程序的过程中呢，很多时候我们都可以利用 结构体变量作参数的这样的一个特点**。Ok，这是作参数的情况。
- 那么接下来呢，我们再看一下当结构体变量作函数返回值得时候，这是怎么样的情况。那么其实啊， 当我们把一个结构体的变量当作返回值从一个函数里面返回给它的调用者的时候啊，其实跟参数的传入一样。 那么这个函数呢也会copy一份赋本，然后把这个赋本返回给它的调用者。下面我们来分析一个程序，看是不是这样的。看这个程序，
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    student newone(student one)                                 //
    {
        student one = {20130123,{'M','I','K','E','\0'}};
        return one;                                             //会将 one 的副本传递给主函数
    }
    int main()
    {
        student mike = newone();
        cout << mike.id_num << " " << mike.name << endl;        //2013123 MIKE
        return 0;
    }
    ```
  仍然定义了一个结构体student。 在主函数里头呢，定义了一个结构体类型变量mike，但是没有对它进行初始化， 而是直接把函数newone调用的返回值，把它赋值给变量mike。 然后紧接着呢，我把变量mike的值打印出来，验证一下。 嗯，也就是说，如果这个newone能够返回一些实实在在的 值给这个mike的话，那么在这我就可以把这些值给打印出来，对不对？ 我们看一下这个函数newone。在函数newone的里面定义了一个局部变量one。 然后呢，我对这个one进行了初始化。需要特别强调的是one是一个局部变量。 所以说one这个变量这个作用仅限于函数内部。 比如说，当这个函数被调用完毕以后，one还存在吗? 它就不存在了。当完成这个初始化之后呢，函数直接return，把这个one return给它的调用者。根据刚才我们讲过的，系统在这个地方呢，会把one 再copy一份赋本，把这个赋本返回给它的调用者。 也就是说，这个程序的进行过程是这样的。首先，在一片内存区域里里面，main函数先开始执行， 调用了newone函数。在newone函数里面呢定义并且初始化了一个局部变量one。那么，在这个函数执行完毕的时候呢， 把这个变量当作返回值，返回给了main函数。那么在这个函数里头， 它会copy一个赋本，然后把这个赋本返回给main函数。 也就是说当main函数调用newone这个函数完毕的时候，main函数就获得了变量one的一个赋本，也就是说在main函数里面得到的一个赋本跟原来newone函数里面原本的那个局部变量one分别占用两片不同的存储空间。 那么在main函数里面这个赋本就被赋给了变量mike。 于是呢，当我们在打印mike的内容的时候，我们就得到了20130123。我们可以看到啊，在main函数里头，我们并没有对mike进行初始化，但是呢当调用完毕的时候，我们仍然打印出来了一个初始化好的mike。这就证明我们刚才给出的这个结论。 当我们把一个结构体变量从一个函数返回给它的调用者的时候， 实际上它是把变量的内容copy了一份给了它的调用者。 这个结构体变量作参数的情况一样。我们在写程序的时候啊，在很多时候，我们都可以利用结构体变量的特点。 
## 3. 结构体变量与指针
- Ok，那接下来呢，我们再来看一下，指向结构体变量的指针。 看这个例子，
  ```C++
  #include <iostream>
  using namespace::std;

  struct student
  {
      int id_num;
      char name[10];
  };

  int main()
  {
      student mike = {123,{'M','I','K','E','\0'}};
      student *one = &mike;
      cout << (*one).id_num << " " << (*one).name;
      cout << one->id_num << " " << one->name;          //指向运算符，效果同上
      return 0;
  }
  ```
  在这个例子里头仍然沿用了student 的定义， 在主函数里头呢，定义了一个结构体类型的变量mike并且对它进行了初始化。接下来呢，我定义了， 一个变量，one，它呢，是一个指针类型的变量。并且呢，它的基类型是student， 这个结构体。也就是说，one是一个可以指向student 类型的结构体变量的指针。并且呢, 接下来我把mike的地址赋给变量one。 这跟普通变量是一样的。 那么接下来呢，我写了这样一行程序。cout<<(*one).id_num， 然后cout<<(*one).name。好理解吗？ 非常好理解。这跟普通变量的引用方法是一样的。 one是一个指针，*one呢, 就应该是这个指针所指向的存储单元的内容。 也就是那一个 结构体。那么，在这个结构体的后面使用.id_num当然引用的就是结构体变量里面的 学号。同理，.name就是结构体变量里面的支付数组。 所以这个程序的执行结果也很容易想象。啊，它是这样的。打印出123 然后mike。 那么在这儿我需要特别说明的是, 在这个地方，也就是 引用 .id_num 和引用 .name的这个地方， 除了这种写法以外，我们还可以把它写成这个样子。 one，写一个 ‘-’ 号再写一个 ‘>’ 号，构成一个箭头，在后面呢，直接写出 id_num。这也是引用结构体变量mike里面的第一个元素的办法。 啊，也是可以的。那么跟刚才我们给出的那个写法呢，是完全等价的。由于用这一 种方法写起来更加的简便明了，所以人们更倾向于使用这样一种方法。 那么一个‘-’ 号再加一个‘>’ 号所构成的这个符号啊， 这是一个运算符，我们把它称作指向运算符， 指向运算符。那么在接下来的程序里头呢，当我们使用指针指向一个结构体变量的时候，我们就可以用这个符号，来对这个指针所指向的结构体，变量的，成员变量进行访问了。 Ok, 这是指向结构体变量的指针。 

- 那么做一个附加的讨论呢，我们稍微来讨论一下，当我们把一个指向结构体变量的指针用作函数参数的时候，是一种什么样的情况？ 看这个例子，
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    void renew(student *one)                                 //
    {
        one->id_num = 20130000 + one->id_num;
        for(int i = 0;one->name[i] != '\0';i++)
            one->name[i] = toupper(one->name[i]);
    }
    int main()
    {
        student mike = {123,{'M','I','K','E','\0'}};
        renew(&mike);
        cout << mike.id_num << " " << mike.name << endl;        //20130123 MIKE
        return 0;
    }
    ```
  在这个例子里头啊，仍然沿用了student。 主函数里头呢，定义了一个变量mike并且进行了初始化。 那么程序执行到这儿呢，我们得到的状况就是这样的。这主函数里面，有一个mike，并且呢，进行了初始化。 那么接下来呢，主函数里面调用了一个函数叫renew，并且呢, 把mike的地址当作参数传递给renew。 啊，我们定一个形式参数one来接纳这个指针。 当接收到这个指针之后呢，我就利用形式参数one，采用指向运算符 去修改这个指针one所指向的存储单元里面的内容。 那么main函数里面呢调用完renew以后啊，紧接着把变量mike的内容啊， 打印出来。那么这个程序的执行结果呢，是这样的。那么通过这个执行结果我们可以看得出来 renew这个函数有没有去修改主函数里面的mike这个变量啊？ 修改了没有啊？修改了，啊，修改了。也就是说在这个过程里头是这样的，当main函数调用 renew函数并且把mike这个变量的地址当作参数传递给renew的时候， 那么这个renew这个函数就拿到了这片存储区域的地址。 啊，于是呢我就可以对这片存储区域里面的内容，进行修改了。 也就是相当于renew这个函数要伸出一只手来 到main函数的里面去修改mike的值。所以说最后mike的值才会发生变化。 那么这种情况呢，跟当我们把指向普通变量的指针当做函数的参数传递给另外一个函数的时候，是完全一样的情况。 那么说到这儿，我们就可以看出结构体变量的很多特性跟普通变量的特性实际上是一样的。 
  
- 那么除了这一些关于结构体变量的使用，我们来看最后的一点，利用结构体来定义数组。看这个程序，
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char name[10];
    };

    int main()
    {
        student myclass[3] = {{123,{'M','I','K','E','\0'}},
                              {133,{'T','O','M','\0'}},
                              {143,{'J','A','C','K','\0'}}};
        student *one = myclass;
        cout << one->id_num << " " << one->name << endl;        //20130123 MIKE
        one++;
        cout << one->id_num << " " << one->name << endl;
        return 0;
    }
    ```
  在这个程序里头呢，我就利用结构体类型student来定义一个数组， myclass。在myclass里头呢，有3个数据成员， 分别是123 mike，133 tom，143 jack。接下来呢我定义了 一个指针，one，我利用数组的名字，myclass 对 one 进行赋值, 可以吗？当然可以。啊，因为这是一个普通的数组， 数组名就相当于指向数组首元素的指针，所以说这个赋值完全没有问题。 那么接下来呢，我就利用one这个指针去打印 它所指向的结构体变量的id_num 和 name。 打印完之后呢，我对one做一个＋＋的操作。 其实这个地方我们是想怎么你知道吗？我们是想印证一下这个＋＋会跨过多大的范围。对吧？ 那么＋＋以后呢我再去打印one所指向的结构体变量的id_num 和 name。我们来看一下这个程序的执行结果。 那么第一次呢，打印出了123 mike，这跟我们所想像的是完全一样的。那么第二次呢，在＋＋之后 打印出了133 tom，这说明什么问题啊？这说明在最开始的时候， one这个指针是指向了数组的第一个元素，也就是指向了这个元素。那么经过＋＋以后呢，one这个指针 指向了哪里啦？指向了这里了。这是数组的第二个元素。所以我们才得到刚才的结果。 也就是说总结一下的话，其实利用结构体类型来定义数组跟普通的变量来定义的数组是一样的。啊，数组名呢仍然是相当于指向数组第一个元素的指针。 而且呢，当我们对这个指针进行＋＋操作的时候，实际上是跨过了 一整个结构体。啊，这跟普通变量，也是一样的。 所以，那总结一下的话我们就可以得到，**结构体数据类型的特性实际上与普通数据类型的特性，是一致的**。 所以结构体这个东西对我们来说是既陌生，又熟悉。 
- 那么结构体数据类型具有那一些用途呢？其实啊，在写程序的过程中， 结构体数据类型还是用得非常非常多的。那只是呢我们这个课并不对结构体类型作出很高的要求，所以呢我们并没有设计很多的例题让大家去感受这一点。 那么接下来呢，我就举一个小例子，来说明一下结构体类型的作用。 看这个例子， 那这是一道OpenJudge上面的题目。 那我把这道题的所有信息呢，都copy过来了。这个题目是这样的，
  - 在一个有100 个人的大班级里头啊，存在多个人具有相同的生日。 啊，就是说月日相同，这个概率还是非常大的。 那么现在呢，系统会给你每个学生的学号，以及他的出生的月和日，要求你写个程序，列出所有生日相同的同学。
  - 啊，输入格式是这样的，先输入一个n代表学生的数量。那么接下来呢，是n行， 每一行呢，都先给出学生的学号，然后呢再给出出生的月 和日。啊，学号和月日之间呢都用一个空格隔开。需要特别注意的是，这道程序 所约定的输出。它要求啊，对每一组生日相同的同学都输出到一行里面。 其中呢，前两个数字表示月和日，后面呢，跟着所有在这一天出生的 所有同学的学号。那么学号之间呢都用空格来隔开，这是一个格式的要求。 还有一个顺序的要求，就是对所有的输出要求按日期从前到后的顺序 输出。也就是说，先排一月一号的，再排一月二号的，然后再排二月份的，再排三月份的等等等等。 而且呢，对于生日相同的那一些学号，要按照输入的这个顺序来进行输出。 其实作这样一个输出的约定啊，是为了让你有更多的办法可以来解这道题。 那么其实呢，解这道题目的方法非常非常地多。啊，当我们看到这道题目的时候 恐怕很多的同学都会想到，哎，这是一道统计题，所以说呢，那么我可以利用数组来作统计。 Ok，这是一个不错的想法，但是这道题呢，可能有点麻烦，因为需要判定相同的那个量啊，有两个， 一个是月份，一个是日期，所以说有可能你需要定义一个用来统计月份，一个用来统计日期。 有的同学说，哎呀，我不用这样啊，我可以把它们两个合在一起， 定义一个二维数组。哎，好办法。我以前呢，也见到过有的同学， 定义一个二维数组来解决这个问题。啊，也是一个办法，只不过啊，稍微麻烦了一点。其实啊，对于这样一道题目啊， 我们非常适合利用结构体类型来解决。我完全啊，可以定义这样一个数组， 啊，这是一个结构体数组。 它的每一个元素呢，都是这样一个结构体。比如说第一个成员是它的学号，第二个是月， 第三个是日。数组里的每一个成员都是一个这样的结构体。 于是呢， 我完全就可以利用这样一个数据结构把所有输入的数据啊，全部都读入进来。 然后呢，我再利用一个这样的结构体数组来进行统计。比方说，有的同学啊就 写出了这样一个程序。啊，这是我从历届有的同学题用的程序里面直接采用过来的。 它呢，就定义了一个这样的结构体，并且呢 利用这个结构体定义了一个数组，stu[100]。 然后呢，利用一个for循环把所有的数据啊读入到这样一个结构体数组里头来。 然后呢，再利用这个结构体进行统计分析，比方说它就可以穷举所有的 月和日，然后呢去检查有没有在这一天出生的同学。 如果有的话我就把这个同学的信息写入到count这个数组里面。 最后呢，我只要把count这个数组里面所存的学号信息全部都打印出来，就可以满足题目的要求了。 啊，这是一个不错的办法。那么感兴趣的同学呢，在听完以后啊，可以把这个程序copy下来，自己 运行一下。Ok，那么关于结构体的使用啊，我们暂时就先讲这么多。 
## 4. 链表的定义
- ok，在了解了结构体之后啊，下面我们来介绍一下链表，首先呀，作为一个对比，我们来回顾一下， 结构体数组，啊，刚才我们说过呢，结构体数组呢，是一种很常用的数据结构，但是啊，结构体数组有一个很明显的缺点，比方说，对于刚才我们所定义的这个结构体数组，那这个结构体数组里头呢，有三个元素， 那么，在内存中去存储这个结构体数组的时候呢，这三个元素啊，是依次排放在内存里面的，这种存放方式呢，就有一个缺点，比如说，当我们想在第一个元素和第二个元素之间， 插入一个元素的时候，比方说，又有一个 学生，他的学号呢，是125，他的名字呢，叫 Jenny，那么如果我们想把这个学生啊，插入到Mike和Tom之间的话，就很麻烦，为什么呢，因为为了保持这个排放的次序啊，我们必须把Tom和之后的Jack全部往后移动一下，才能给这个Jenny腾出足够的空间那么这样一个操作呢，实在是太费劲了，那么相比这种数据结构有一种数据结构来解决这样的问题，就非常的得心应手，比方说，我们来看，这样一个结构，这个结构啊，跟刚才的结构，有一点不同， 就是我们用指针呢，把原有的3个结构体变量啊，给它串联起来了也就是说，在第一个结构体的后面，加一个指针让它指向下一个结构体，然后，在第二个结构体的后面，再加一个指针，让它指向下一个结构体，依次连接， 那么通过这种方式，我们就可以把想要顺序保存的那些结构体，保存下来， 并且呢，它们之间的连接是灵活的，比方说，当我们想在MIke和Tom之间插入一个Jenny的话，我们完全可以这样去做， 让Mike呢，指向新人Jenny，然后，让Jenny呢，指向后面的这个人Tom，那么通过这种方式，我们就可以把Jenny插入到整个队列里 面来了，ok，我们可以看到，对于这种情况的处理，这样的一个数据结构，比结构体数组具有很大的优势，那么这样的一个数据结构就叫作链表， 

- ok，下面，我们就先来介绍一下什么是链表，每一个链表啊，都有这么几部分来构成，首先呢，是一个链表头，也就是这个head，它呢实际上，是一个指针， 它用来指向链表中的第一个元素，然后，接下来呢， 是一个一个的链表节点，链表节点里面啊，通常包含两个部分，第一个部分呢，是用来存储数据的，比方说，在这个链表里面， 123 Mike,都是用来存储数据的，啊，133 Tom，都是用来存储数据的，第二个部分呢，是指向下一个节点的一个指针， 也就是，下一个节点的地址，那么在链表的最后呢，我们用一个NULL 指针，用来表示这是一个链表 的结尾，那么通过这个介绍，我们就可以看出，其实链表其实是一个并不复杂的 数据结构，对不对，但是它却是一个非常常用的数据结构 那么其实呢，在我们这个课上，并没有着意的去介绍许多的数据结构，那么在这呢，在课程的最后一个部分，我们把链表拿出来，作为一个了解内容，介绍给大家，啊，如果大家想要在程序里面，去使用的话呢 可以随意的去用，

- ok，那么接下来，我们就分别来介绍一下链表的创建和操作 首先，我们来看一下，如何去创建链表，那 么我们可以看到，一个链表呢，其实是由很多很多个节点来构成的，而且呢，这些节点是可以根据我们的需要随时的去增加的，也就是说，链表 啊，其实可以去动态的创建，也就是说，我们可以根据我们的需要去创建一个具有相应节点数目的链表，为了能够动态的去创建链表，我们首先来了解 一下，如何去动态的申请内存空间，那么在这呢，我们介绍两个非常常用的运算符，一个呢，是new，一个呢是delete，new这个运算符啊，是用来开辟一片相应的存储空间，并且呢，返回这片存储空间的 起始地址，那么delete呢，则是释放掉一个指针所指向的一片存储空间，那么在new的后面呢，要给出来想要创建的这片内存空间，用来放什么类型的数据，而且呢，你可以在这个数据类型的后面，加一个小括号，写出这片数据空间所具有的初始值，当然，你也可以不写这个初始值，那么通过这种方式呢，你就创建了一片用来保存这种类型数据的存储空间，并且呢，这样的一个表达式，能够返回一个指向这片存储空间的地址，那比方说，在这呢，`int *pint = new int(1024);`,我们就利用new所返回的这个指针，对一个指针变量pint进行了初始化， 也就是说，pint就指向了刚刚生成的这片内存空间，这就是new的一个用法，它非常非常的简单，你只要在new的后面加一个类型符号，就可以了，当然，如果你想要释放掉这片内存空间的话，也非常的简单,`delete pint;`，只要是delete，把这个指针写到后面，就可以了，那么同理，我们也可以用new 啊，来申请一片用来存放具有4个整型元素的一个小数组的一片空间，那这个表达式呢,`int *pia = new int[4];`，同样也会返回一个地址，我们可以用这个地址呢，来初始化一个指针，当然，如果你想要释放掉这片内存空间的话，你就使用这样的一个表达式，`delete [] pia;`,来释放掉，delete后面有个[],表示后面要释放的这个指针指向的是一片 数组的区域，ok，这是用于动态的申请和释放内存空间的两个操作符，new和delete 的基本用法，

- 当然，毫无疑问，我们可以把，new和delete用来动态的申请和释放结构体类型的空间，那么就可以把它用到链表上了，比方说，对于我们前面所定义的结构体类型， student，ok，在这呢，为了给大家展示起来更加的简明，我把这个student结构体啊，做了进一步的 简化，只保留了一个id，那么第二部分呢，就是一个指向student类型的一个指针，那么有了这样的一个结构体，我们就可以通过这种方式，来申请 一片student类型的存储空间，比方说，我首先定义一个指向student类型的指针head， 然后呢，我就可以new student 通过这种方式，我就获得了一片用来存放一个student类型变量的 一片存储空间，并且呢，把这片存储空间的地址赋给了head，那么 通过这种方式，我们就可以啊，动态的创建链表 了，ok，那下面我们就来看一下，如何去逐步的创建链表，那么要创建一个链表的话呢，我们从第一节点开始，用new呢，申请一片 student类型的存储空间，并且赋值，然后呢，我们定义一个head指针指向它，那么相应的程序呢 就可以写成这样，head就=new student，同时呢，为了创建后续的节点，我们定义一个临时的指针temp 让它呢，指向新创建的节点，相应的程序呢，就是student *temp = head，那么接下来 呢，我们就需要做一个判定，判定一下是否要继续创建 新的节点，如果要创建新的节点的话，那么当然，我们首先要再申请一片相应的 存储区域，然后呢，我们就要利用刚刚所定义的这个指针， 让它的next指向下一个节点，那么也就是说，建立这个关联，那么相应的程序呢，就是，temp->next=new student, 那么同时呢，我们要对这个student的数据部分进行赋值 那么，创建完这个节点以后呢，为了能够继续创建 后续的节点，我们就需要把这个temp往前移动一个节点使得temp指向最新创建的这个节点，那么移动完毕之后呢，就变成这个样子，那么相应的程序呢， 就temp=temp->next，那么创建完这个之后呢，我们接下来，再回到第 二步，去做一个判定，要不要创建新的节点，那么如果要创建新的节点，那么我们再次运行这几句 程序，那么相应的呢，我们再去创建一个节点，并且呢，利用temp指针， 让前一个节点呢，指向它，那么之后呢，再把temp指针，往前 移动一次，那么移动完temp呢，再次指向新创建的节点，这 时候呢，再次回到temp2，去判定是否要创建 新的节点，假设说这个时候，我们不需要再创建新的节点，那我们就需要把最后这个节点的next指针 置为空，也就是说，temp->next=null,那么执行完毕之后呢，结果就是 这个样子的，那么到这步为止呢，一个链表我们就创建完成， 了，那么链表创建的这个过程呢，可以用这个程序来表示
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{
        int id_num;
        char neme[10];
        student *next;
    };

    student *creat()
    {
        student *head,*temp;
        int num,n = 0;
        char NAME[10];
        head = new student;
        temp = head;
        cin >> num >> NAME;
        while(num != -1){
            n++;
            temp->id_num = num;
            tep->name = NAME;
            temp->next = new student;
            temp = temp->next;
            cin >> num >> NAME;
        }
        if(n == 0)
            head = NULL;
        else 
            temp->next = NULL;                //这里有瑕疵，一个空节点，导致不能遍历
        return head;
    }

    int main()
    {
        student *stuLink = creat();
        return 0;
    }
    ```
，啊，在这呢，我写了一个函数，这个函数呢，叫create，它呢 会返回一个指针，啊，那么这个指针呢，其实就代表着链表的 头节点，那么在这，我给出的这个程序呢，跟刚刚我们所讲的这个过程是一致的，所以我们就不再赘述了。 
## 5. 链表的操作
- 在完成链表的创建之后呢，我们再来看一下，对链表的操作。 那么在使用链表的过程中啊，有一些操作是我们经常需要进行的。 那么我们分别来看一下。
- 首先呢，我们先来看一下链表的遍历。 所谓的遍历就是一个一个的去访问。啊，把这些值啊，都打印出来。比方说，在我们给出的左边的这个程序里头， 我们就使用了一个 while 循环。啊，也就是说呢，我们定义了一个临时的指针 pointer ， 让它指向链表的第一个元素。那么在访问完这个元素以后呢，用 pointer 的 next 给 pointer 赋值，这样的话， 就使得 pointer 往后移动了一个结点。啊，那么一个一个结点移下去， 如果 pointer next 不等于 NULL ，我就一直移下去。 那么通过这种方式呢，我就可以完成对链表的遍历。 
- 接下来呢，我们再来看一下，链表中结点的删除。那么要从一个链表中删除一个结点啊， 我们需要分不同的情况来讨论。首先我们来看一下这个情况。那么原来有一个完整的链表， 当我们想把链表中的第一个元素从链表中删除的时候， 我们应该怎么去操作？ 要删除第一个结点是非常容易的。首先呢，我们用一个 temp 指针，找到这个要被删除的结点。 然后呢，如果它是第一个结点的话，我们就直接让这个 head ， 指向它的下一个结点就可以了。那么相应的程序呢，我们可以写成这样 ： temp 就等于 head ，然后呢，我们直接把 head → next 赋给 head 就完成这个删除了。 当然，我们可以使用 delete 去释放掉这个结点所占用的内存空间。 这是删除第一个结点的情况。那如果我们要删除的是一个 中间结点呢？比方说，我们要删除第三个结点。 那在这种情况下，我们就需要两个辅助的指针来帮助我们完成这个删除。 那么既然我们要删除这个结点，那么删除的办法也很简单， 无非就是让它的前一个结点直接指向它的后一个结点。 那么要实现这个操作，就需要我们使用 temp 去寻找这个结点的同时， 找另外一个指针，跟在 temp 的后面， 因为我们要利用这一个指针对这个结点的 next 指针进行 赋值。那么相应的程序呢，可以写成这个样子。
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{                   //C++模式的链表节点构造，注意和C模式的区分
        int num;
        student *next;
    };

    /*在链表中将值为n的元素删掉*/
    linker *Delete(student *head,int n) //很明显，该链表为不带头结点的
    {
        student *temp,*follow;
        temp = head;
        if(head == NULL){             //head为空，空表的情况
            return head;
        }
        if(head->num == n){           //第一个节点是要删除的目标
            head = head->next;
            delete temp;
            return head;
        }
        while(temp != NULL && temp->num != n){    //寻找要删除的目标
            follow = temp;
            temp = temp->next;
        }
        if(temp == NULL)                          //没寻找到要删除的目标
            cout << "Not Found!";
        else{
            follow->next = temp->next;            //删除目标节点
            delete temp;
        }
        return head;
    }
    int main()
    {
        return 0;
    }
    ```
  就是说，把 temp 的 next 赋给 follow 的 next。 啊，通过这种方式，我们就把这个结点给删除掉了。当然我们也可以使用 delete 把它释放掉。 那么相应的程序呢，我们就可以写成这样一个函数。那么假设呢，存在一个头为 head 的一个链表。 而且呢，我们要删除它的数据区为 n 的这么一个结点。那么就需要分情况来讨论。 啊，如果链表为空，应该怎么办？如果删除的是第一个结点，应该怎么办？ 如果不是这两种情况呢，我们就寻找到要删除的这个结点。如果没有找到，应该怎么办？ 最后，除此之外，我们就可以利用 follow → next = temp → next ， 通过这种方式完成结点的删除。 那么这是在链表中删除结点的情况。 
  
- 那么接下来呢，我们再来讨论一下，如何在链表中插入一个结点。 跟删除的结点相类似，我们也需要分情况来讨论。比方说， 如果我们要在一个链表中所有结点的前面插入一个结点， 啊，那么我们应该怎么去操作呢？ 那么在这儿，我需要特别的提示大家，链表的插入啊， 要特别的小心，因为它的操作是有顺序的。 比方说对于这样一个链表，我们要在它所有的元素前面插入一个新的结点。 那么假设说呢，原来有一个指针将 unit 指向这个结点。那么现在呢，我们要把这个 unit 插入到第一个结点的最前面去。那么我们应该怎么去操作呢？ 我们第一步能不能先让 Head 指向这个新的结点啊？可不可以啊？ 不可以。为什么呢？因为如果第一步 我们就让 Head 指向这个新的结点， 那么就相当于我们切掉了 Head 这个结点跟任何后续结点的联系。 也就是说，我们再也没办法找到链表中剩下的这些结点了。 那么这些结点呢，就会被丢失掉了。 所以说当我们想在一个链表中插入一个结点的时候，我们的第一步一定是先让这个新插入的结点指向它的后续结点，从而保证后续的这些结点不会被丢失掉。所以说在这里插入一个结点的程序是这样的： 首先我们对要插入的这个结点 unit→next 的指针进行赋值， 然后呢，我们再让 Head 指向这个 unit。 啊，是这样的一个顺序。Ok ， 这是在所有的元素前面插入一个结点的情况。 Ok, 那么接下来我们再来讨论一下如何在一个链表的中间插入一个新的结点。啊，比方说这是一个原来的链表。 我们现在呢，需要在 2 和 3 之间插入一个 0。 啊，这样的一个结点。怎么去操作呢？ 那么跟刚才的操作相类似，要在一个链表的中间插入一个新的结点， 我们就需要两个辅助指针帮我们来做这个事情。 temp 在前面， follow 在后面。那么在这种情况下呢，就比刚才要灵活一些。 因为插入位置之前的这个结点由 follow 替你保存， 插入位置之后的这个结点呢，由 temp 帮你保存。啊，所以说在这个时候呢，赋值就会灵活一些。 那么我们可以用这样的程序来完成。 那么在这儿呢，我们首先也是先给 unit→next 的这些赋值。 也就是先建立这个指向关系。然后呢，我们再去给follow →next 的这些赋值，也是什么？ 建立这个指向关系。那么通过这两步就可以完成这个结点的插入了。 那么相应的呢，我们就可以把这个插入结点的程序再写成一个函数 insert。 那这个函数呢就能够帮助我们在一个以 head 为头的结点中 插入一个结点值为 n 的元素。 那么也是呢，需要分情况去讨论。
    ```C++
    #include <iostream>
    using namespace::std;

    struct student{                   //C++模式的链表节点构造，注意和C模式的区分
        int num;
        student *next;
    };

    /*在链表中将值为n的元素删掉*/
    linker *Insert(student *head,int n) //很明显，该链表为不带头结点的
    {
        student *temp,*follow,*follow;
        temp = head;
        unit = new student;
        unit->num = n;
        unit-> = NULL;
        if(head == NULL){               //如果链表为空，直接插入
          head = unit;
          return head;
        }
        while(temp->next != NULL && temp->num < n){   //寻找第一个不小于n或结尾的节点temp
            follow = temp;
            temp = temp->next;
        }
        if(temp == head){               //如果temp为第一个节点
            unit->next = head;
            head = unit;
        }else{
            if(temp->next == NULL)      //如果temp为最后一个节点
                temp->next = unit;
            else{                       //如果temp为一个中间节点
                follow->next = unit;
                unit->next = temp;
            }  
        }
        return head;
    }
    int main()
    {
        return 0;
    }
    ```
  那么感兴趣的同学啊，可以运行一下这个程序，试一下。 
  
- Ok, 那么到目前为止啊，我们前面讨论过的链表啊，都是单向链表。 也就是说在这样的链表中呢，每一个结点上只包含一个指向它的后继结点的指针。 那么除了这种链表之外呢，还有一种非常常用的链表，叫做双向链表。 那么在双向链表中呢，每一个结点上啊，除了数据区以外， 还包含了两个指针。一个呢，是指向这个结点的 后继结点的指针。还有一个呢，是指向这个结点的前区结点的指针。那也就是说啊， 在这一种链表中，从任意一个结点出发都 可以到达链表上的任意其他的结点。 因为每个结点都有指示它向前走的指针，也有指示它 向后退的指针。啊，所以说，这一种链表的使用啊，非常非常的 灵活。只是啊，在这种链表中，想要删除 或者添加一个结点，比单向链表啊，稍微有一点麻烦。 我们来看一下。 首先我们来看一下，如何在这样的一个链表中删除一个结点。那么比方说，在 这样的一个双向链表中啊，我们想删除这个结点。那么如果要删除这个结点的话，我们必须要修改 它的前驱结点中指向后方的一个指针。 并且呢，要修改它的后继结点中， 指向前方的这个指针。啊，这是必须要修改的两个指针。 那么要完成这个修改呢，首先我们定义一个临时的指针变量， temp ，用它呢来指向待删除的这个结点。然后呢，首先啊，我们来修改它的前驱结点中的 next 的指针。temp→ahead→next 就等于temp 的→ next 。那么通过这样一句程序啊， 我们就修改了 temp 结点的前驱结点中, next 它的指针，修改为指向 temp 的后继结点。那么接下来呢，再对这一个结点中的 ahead 的指针进行修改。 这个 ahead 的指针由原来指向 temp 修改成指向 temp 的前驱结点。 那么当这两句程序执行完毕以后呢， 这个 temp 结点就从双向链表中被删掉了。 那么通过这个分析啊，我们可以看到，虽然在双向链表中删除一个结点稍微有点复杂， 但是呢，思路是非常清楚的。Ok, 那么接下来呢我们再来看一下 如何在双向链表中啊插入一个新的结点。 那么现在呢我们要在这样的一个双向链表中插入一个新的结点， unit ，啊。 在这个位置。那么为了完成这个操作啊，我们仍然定义一个 临时的指针变量 temp ，让它指向待插入结点的前面一个结点。 那么接下来呢我们就来修改这个结点，这个结点和这个结点中指针的直向关系。 那这个过程呢可以描述成这样。首先呢我们来修改 unit 这个结点的 next 的指针。让 next 的指针呢， 等于 temp 的 next 的。于是呢， unit 的 next 的就指向呢，它的下一个结点。 再接下来呢，我们再对 unit 的 ahead 的结点， 也就是这个结点进行修改。那么它呢，就等于 temp 。于是呢，指向了它的前驱结点。 那接下来呢，我们再来修改后面这个结点中指向前面的这个 ahead 的指针，也就是说 temp→next →ahead， 那它等于 unit 。那么当执行完毕的时候呢，现在呢改为指向 unit。 那么最后呢，我们再对 temp→next 的指针进行修改。让 temp→ next 指向 unit。 啊，由此执行完毕之后呢， temp→next 就指向 unit 的结点。那么通过这样的一个修改，我们就完成了 unit 这个结点的插入。 那么通过这个分析我们可以看到，虽然这个过程看上去有点复杂，但是思路还是很清楚的。 其实啊，在很多的应用场景中，双向链表比单向链表啊更有用。 比方说，在这儿我们举一个小例子，约瑟夫问题。 约瑟夫问题啊，是一个非常经典的问题。这个问题是这样的。 编号为 1-N 的 N 个人围坐在一起形成一个圆圈， 啊，就像这样，N 个人围坐在一起形成一个圆圈。然后呢， 从第 P 个人开始，啊，比方说 P 等于 7 的话，我们从这儿开始， 依次按照顺时针的方向来报数。 那么数到第 M 的人出列，直到最后剩下一个人。那么这个游戏呢，就结束了。 那么现在希望你呢，写一个程序。对于给定的 N, P 和 M ， 计算并且打印出出列的人的序号。 当然，对于这样的一个问题啊，有非常非常多的解法。 那么在这儿啊，其实有一种非常直观的解法。那就是啊， 利用循环链表。 啊，那么在这儿呢，我就举出来一个程序的例子。在这个程序里头啊，我们定义了一个**双向循环链表**。 啊，利用一个双向循环链表来解决了 约瑟夫问题。那么在这个程序里头呢，我们定义了三个函数。 一个呢，是 create ，用来创建链表。一个呢，是 search ，用来在链表中啊寻找某一个确定的结点。 还有一个呢，是 release ，要把某一个特定的结点从链表中剔除掉。那么利用这三个函数， 我们就可以模拟约瑟夫问题的解的过程。那么限于时间的关系呢，在这儿我们就不做一一的介绍了。 那么有兴趣的同学呢，可以把这三个函数抄写下来运行一下。 