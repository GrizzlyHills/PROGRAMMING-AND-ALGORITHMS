# 指针与函数
> 这次课我们将紧跟上一节的脚步，继续为大家讲解“指针做函数参数”及“指针做函数返回值”的两种情况，到此为止，你应该对于指针在C程序设计里的应用有一个比较全面的了解啦，不妨在本次课末尾画个思维导图考考自己，是否弄清楚了这个重要的概念。
## 1. 指针做函数参数
- 各位同学大家好，那么接下来呢我们开始今天的课程。 那么今天我们来讲指针的最后一个部分，也就是指针的第三个部分。 那么在这一讲里头啊，我们主要来关注指针与函数的关系。 那么指针与函数呢主要是两部分的内容。第一个就是指针用做函数参数的时候， 会怎样？第二部分呢，就是指针用做函数返回值的时候， 会怎样？ 那么下面呢，我们先来了解下，如何把指针用作函数的参数。 那么下面呢，我们先来看一个程序。看这个程序： 
    ```C++
    #include <iostream>
    using namespace::std;

    void Rank(int *q1,int *q2)
    {
        int temp;
        if(*q1 < *q2){
            temp = *q1;
            *q1 = *q2;
            *q2 = temp;
        }
    }
    int main()
    {
        int a,b,*p1,*p2;
        cin >> a >> b;
        p1 = &a;
        p2 = &b;
        Rank(p1,p2);
        cout << a << " " << b << endl;
        return 0;
    }
    ```
  在这个程序里头呢，我定义了一个函数叫做Rank，那么Rank函数呢有两个参数， 都是指针，分别是去q1和q2。 那么在主函数里呢，我定义了两个变量a 和b， 然后读入a 和b。 然后定义了两个指针p1和p2， 让p1呢指向a，让p2呢指向b。 那么如果我们画一个图来表示一下现在的状况的话，就是这样的一个状况， 一个main 函数，一个Rank函数，然后在主函数里呢定义了两个变量 a 和b， 然后呢读入这两个变量。比方说我给a赋值为3，b赋值为5， 然后呢，我定义了两个指针，分别指向这两个变量p1和p2。 那么在接下来的操作里头呢， 我把p1 和p2 当作实际参数传递给函数Rank， 这相当于把指向了变量a 和变量b的两个指针， 传递给了Rank。 我们以前曾经特别强调过， 函数在传递的时候是怎么样去传递的。 是把这个要传递的参数的值， 把他们两个的值直接copy给函数， 是把他们两个的值直接copy过去。也就是说， 当我们把p1和p2的值传给Rank的时候， 实际上就相当于让Rank里面的 q1和q2指向了main函数里头的a和b，对不对， 因为我们把地址传过去了。这就象以前我打的一个比方一样， 我呢在北大的未名湖边上，埋藏了一些宝藏， 然后我把地址给了你，你呢，就可以直接去那， 随意的处置那些宝藏了。那么在这呢， 因为p1和p2是指向a和b的指针， 也就是说p1和p2里面存放的是a和b的地址， 所以说当我们把p1和p2当作实际 参数传递给函数Rank的时候， 也就相当于让Rank里面的q1和q2这两个形式参数 直接指向了main函数里面的a和b。 那么接下来，通过q1和q2， 对a和b的任何操作其实也就是对变量a和b的操作。我们来看它进行了一个什么操作？ 那么Rank函数里面，说当q1所指向的 变量的值小于q2所指向变量值的时候， 我就交换， q1所指向的变量的值和q2所指向的变量的值。 所以说在这个程序里头当我们所入3和5给a和b的时候， 在Rank函数里头就会把3和5进行交换，变成5和3， 毫无疑问，这个程序的输出结果是5和3。 这就是指针用做函数参数的情况。 那么基于前面我们所学习到的知识呢，相信大家是不难理解这个过程的。 这是最典型的一种把指针用作函数参数的情况。 

- 那么除了这种情况以外呢，其实我们在以前例子里还接触过另一种类型的把指针用作函数参数的情况。 我们来看这个例子，那么首先需要说明的是，这是同一个程序， 这是写在一个文件里的，我是为了让大家看的更加清楚，我把它分别写到两个框里头，这是主程序，这是可以调用的一个函数。 当然如果你自己呢想要运行这个程序的话，你需要首先把这个主程序先copy到你的编译环境中， 然后呢把这个函数也copy到你的编译环境中。 放在哪里呀，那么这个函数的位置呢应该放在主函数之前，预定义部分之后，放在这个位置。 那这个程序就可以去运行了。我是为了让大家看的更清楚，我把主函数和被调用的函数分开来写了。 ok，下面我们就来看一下这个程序，
    ```C++
    #include <iostream>
    using namespace::std;

    void sum(int *p,int n)
    {
        int total = 0;
        for(int i = 0;i < n;;i++)
            total += *p++;
        cout << total << endl;
    }
    int main()
    {
        int a[10] = {1,2,3,4,5,6,7,8,9,10};
        sum(a,10);
        return 0;
    }
    ```  
  那么在这个例子里头，我想实现这么一种情况，定义一个函数，这个函数有一个参数是一个指针。我想把一个数组的名字当做函数的实际参数传递给这个函数。说简单一点就是把数组名当作实参，付给指针类型的形参。这样可以吗？我们曾经讲过这样当然是可以的。 毫无疑问，为什么可以啊？因为数组名就相当于指向数组第一个元素的指针。 比方说对这个数组而言，数组名a就相当于 指向一个整形元素的指针。而在这个函数里头呢， 指针p它的涵义也是指向整形元素的指针。所以说， 这个形参p的涵义，跟实参a的涵义是完全等价的。 所以我们完全可以把一个数组的名字当作实参去赋给一个指针。 当然前提是你所定义的这个指针跟数组名字它的涵义必须是等价的。
  
- 那有的同学可能立刻就想问，如果是多维数组可以吗？ 我们来看这样一道题目，
    ```C++
    #include <iostream>
    using namespace::std;

    int maxValue(int (*p)[4])         //注意传递二维数组指针的形参
    {
        int max = p[0][0];
        for(int i = 0;i < 3;i++)
            for(int j = 0;j < 4;j++)
                if(p[i][j] > max)
                    max = p[i][j];
        return max;
    }
    int main()
    {
        int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
        cout << "The Max value is " << maxValue(a);
        return 0;
    }
    ```  
  在这个题目里头啊，主函数里头啊定义了一个三行四列的二维数组， 并且呢对这个二维数组进行了初始化。 然后呢我把这个二维数组的名字a 当作函数的实参传递给一个函数maxvalue, 让maxvalue这个函数啊，从这个3乘4的矩阵里头找到所有元素的最大值， 这就是这个程序的基本涵义。 那么现在呢，二维数组的参数空出来，让我们填一个参数的定义进去。 我们来看一下，应该怎么去填这个定义。 首先在主函数里头传进来的实际参数是二维数组的名字a， 所以说在函数的定义里面，我们一定会定义一个函数的参数来接纳这个a， 这个参数的名字呢，应该是p。因为这个程序里面除了p之外，其他都是被定义过的。 而且呢我们所要定义的这个变量p呀， 它必须能够通过pij， 这种方式来访问二维数组里的元素。 也就是说p它的类型必须与二维数组的名字a类型是一样的。 那么说到这可能有的同学就已经反应过来了，既然 它与二维数组的名字a具有相同的类型，那a的类型是什么呢？ 我们上次课刚刚讲过。a呢是指向二维数组中第一个小数组的指针。那怎么去定义一个指针，使得它成为一个指向二维数组中第一个小数组的指针呢？ 我们上次课刚刚讲过，在这可以这样来定义这个p， int（* p）[4]，那么通过这样一种方式我们就定义了一个变量p， 于是呢p和a的涵义就等价了。 那么，在这呢，我们就可以用这样一个p来接纳这个a了。 ok，这是多维数组的数组名做函数参数的情况。 那有的同学可能问了，哎呀，这个定义也太复杂了点啦。 每次要定义这样一个形参还真是挺费劲的。 
  
- 我能不能在这直接去定义一个数组呢？ 也就是说我能不能直接在这用一个数组的名字当作形参来接纳一个 数组名类型的实参呢？有同学可能还没听明白是怎么回事，我们来看一个程序。
    ```C++
    #include <iostream>
    using namespace::std;

    void sum(int array[],int n)
    {
        for(int i = 0;i < n - 1;i++){
            *(array + 1) = *array + *(array + 1)
            array++;
        }
        return *array;
    }
    int main()
    {
        int a[10] = {1,2,3,4,5,6,7,8,9,10};
        cout << sum(a,10);
        return 0;
    }
    ```  
  这个程序就是这种情况，在主函数里我们定义了一个数组名字为a。 然后呢，我把这个数组名啊，当做实参传递给了一个函数 sum，然而呢，在这个函数里头，接纳这个数组的名字的时候，我没有去定义一个指针 而是啊，直接通过这种方式，定义了一个数组，int array[] 也就是说啊，把一个数组名，当做形参来处理，而且呢，在这个函数里头啊，我直接把这个array当做变量来使用，那么甚至呢，我还可以对这个array进行加 加减减的操作，那当我明年看到这样一个程序的时候，有的同学觉得可能就很诧异了，array不是数组名嘛？ 那么数组名是不能当做变量来使用的，你在这还对它进行加加减减， 这是以前我们讲过，完全不可以的， 那么这样一个程序，能正确的运行吗？ 其实啊，这样的一个程序是可以正确运行的，为什么呢？**因为C++的编译器啊，会把 形参定义在形式参数里面的这个数组 名，当做指针变量来处理，它就相当于我们定义了一个，指向int类型的指针变量，所以说，当我们把数组名a当做实参来传递给这个形参array的时候，完全没有问题**，那么这个呢，是需要我们特别注意的一种情况，啊，这种情况是完全合理的，它是可以运行的 那我们来看一下，这个程序做了一个什么 事情，在主函数里头呢，定义了一个数组a，然后呢，给它赋了10个值，1,2，3,4,5,6,7,8,9 10，然后呢，把数组的名字，当做实参传递给sum这个函数， 在这个函数里头啊，进行了这么一系列的操作， 啊，for从i=0到i<10-1啊，<10-1它是有目的的，我们来看一下，它什么目的* (array+1) 就等于* array + *(array+1) 这是什么 意思啊，是说，从数组的第二个元素开始， 每个数都等于当前的这个元素和前一个元素的和 而且呢，我一直累加到数组的最后一 个元素，也就是说sum这个函数做了这么一件事情，它 把数组里所有元素的和求了出来， 并且呢，把这个最终的和存放在数组的最后一个元素里头，并且呢，把这个和 返回出来，啊，这就是sum这个函数的作用， 那么通过这种方式求和，可以吗？ 啊，也可以，但是，在这个程序里头啊，sum这个 函数，除了完成求和这个功能以外 啊，它还做了一些多余的 事情，什么多余的事情啊，它其实在不断的修改着这数组 里从第2个元素开始，往后所有元素的值， 那这样一个函数啊，可能用起来，我们就有顾虑了，对不对，啊，我本来把一个，在主函数里面呢，我定义了一个数组，我本来把这个数组交给你啊，是想让你，读一读数组里面的这些元素，并且呢，把这些元素的， 和求出来，本来是这样一个意图，结果呢，你在求和的过程中，却把我每个元素的值都给我修改了，这是我所不希望的，所以说啊，当我们在程序里头，把一个变量或者是数组的名字，传递给一个函数的时候，还是挺危险的，对不对？因为这个函数拿到的，是这个变量或者是数组的地址， 它拿到了地址，它就可以直接对这个地址里面所埋藏的这些宝藏，也就是地址里面存放的这些值，进行肆意的修改，这就是当我们把指针用作函数参数的时候，所带来的一个很大的问题，对不对，那有没有一种办法，可以呢使我既能够把这个地址传递给某个函数，又能够确保不让这个函数随意的修改这片地址里面的值呢？ 有没有一个这样的办法呢？啊，是有这样一个办法的。那么接下来呢，我们就来看一下，如何，来限制指针的功能。
## 2. 限制指针实参的功能
- OK，在刚刚的一小节里头呀，我们提到过，当我们把指针当作实参传递给一个函数的时候，这个函数就可以利用这指针肆意地去操作这个指针所指向的那片存储单元的内容。这个有的时候会给我们的程序带来一些麻烦。 比方说，在我们刚才举的这个例子里头，当我们在主函数中，把数组的名字传递给一个函数的时候，实际上，这个函数就拿到了整个这个数组的操控权，它可以肆意地去操作这个数组，去修改这个数组。 那么有没有一个办法可以去限制函数所拿到的指针的操做权限呢？有办法，我们来看一个这样的程序。 
    ```C++
    #include <iostream>
    using namespace::std;

    void sum(const int array[],int n)
    {
        for(int i = 0;i < n - 1;i++){
            *(array + 1) = *array + *(array + 1)
            array++;
        }
        return *array;
    }
    int main()
    {
        int a[10] = {1,2,3,4,5,6,7,8,9,10};
        cout << sum(a,10);
        return 0;
    }
    ```  
  这个程序就是对刚才的程序做了一个非常小的改动。 大家能看得出来这个改动在哪里吗？ 这个改动在这里，也就是说，我在参数array定义的前面加了一个关键字，这个关键字叫const。加这个关键字的作用是什么呢？ 那大家注意到在这句的程序里头有一个小的红色波浪线了吗？ 这就意味着这句程序是有错误的。 那这个错误是什么呢？ 当我们把鼠标放在这里的时候，我们就会发现系统将提示我们， 禁止我们修改*（array+1）的值。也就是说，当我们去运行这个程序的时候， 你会发现它就会报这样一个错误，不能给常量赋值。 也就是说，你不能通过array这个指针去修改所它所指向的存储单元的内容。 为什么是这样的呢？ 加一个const这样的关键字就有这样大的效果呀！ 其实**当我们在int的前面加了一个const以后啊， 我们就把array变成了一个指向符号常量的指针， 所以，它就不能去修改这个array所指向的存储单元的内容了**。 那什么叫指向符号常量的指针呢？ 接下来我们就来分析一下。 
  
- 那么，在讨论指向符号常量的指针的概念之前呀，我们先回顾一下符号常量的概念。 其实我们在很久以前，在我们去介绍C语言的数据成分的时候， 我们就曾经介绍过符号常量。在程序里头，我们可以定义一些标识符， 它们表示一些常量。比方说，我们当时曾经举过一个例子， 比方说，我定义一个符号常量PI，它就等于3.14159f。由于我们指定它是一个const类型， 所以它是个常量，是一个值不能被修改的量。 当然根据符号常量定义方式，这个const既可以写到float之前，也可以在float之后。 通过这种方式，我们就定义了一个符号常量。 那如何去定义一个指向符号常量的指针呢？ 那么也很简单， 根据指针的定义，我就可以这样来定义，比方说， 我在这儿就定义了一个p，它的类型呢，首先就是一个指针，而且呢，是一个指向int 型的指针，而且呢，是一个指向const int 型的指针。 什么意思啊？就是指向一个符号常量的指针。 那什么叫做指向符号常量的指针呢？ 我们来对比一下它跟普通指针变量的不同， 你就能够感觉到了。比方说我们来看这两个程序。
    ```C++
    #include <iostream>
    using namespace::std;

    int main()
    {
        int a = 256;
        int *p = &a;
        *p = 257;
        cout << *p << endl;
        return 0;
    }
    ```  
    ```C++
    #include <iostream>
    using namespace::std;

    int main()
    {
        int a = 256;
        const int *p = &a;    //指向符号常量的指针
        *p = 257;             //错误
        cout << *p << endl;
        return 0;
    }
    ``` 
  在左边这个程序里头啊，定义了一个普通变量变a， 它的值呢，是256，右边也定义了一个普通变量a，值也是256。 接下来呢，我定义了一个普通的指针变量p，让它指向变量a。 在这边呢，我也定义了一个p，但是，我却把这个p定义成指向符号常量的一个指针， 然后也让这个p指向a。 接下来，在左边的程序里头，利用* p，对p所指向的这个变量a 进行重新赋值。原来不等于256吗？现在我让它等于257。 那右边呢，我也利用这种方式进行重新赋值。然后呢，我再把* p再打印出来。 那么当你去运行这个程序的时候，你就会发现左边的这个程序呀，可以顺利地运行，没有问题。 而右边的程序呢，将会在运行到这句程序的时候，报出一个错误。 它会告诉你这个* p 是不允许被修改的。 那么通过这个程序，我们就能够感受到， 当我们把p定义成一个指向符号常量的指针的时侯， 然后再让这个p指向什么东西， 它所指向的那个东西就不能被修改了。我们就不能通过p再去修改 它所指向的那个东西了。 这个就是指向符号常量的指针的含义。 那么有了这个东西之后，我们就好办了。 当我们再去定义一个函数并且想传递一个指针给这个函数的时候， 我们就可以利用const来对指针实参的功能进行一个限制。 比方说，在这个程序里头，
    ```C++
    #include <iostream>
    using namespace::std;

    void mystrcpy(char *dest,const char *src)
    {......}

    int main()
    {
        char a[20] = "How are you!";
        char b[20];
        mystrcpy(b,a);
        cout << b << endl;
        return 0;
    }
    ```   
  主函数里头，我定义了一个字符串a， 然后又定义了一个字符串b，我希望 通过一个函数叫mystrcpy 通过这样一个函数把 a copy 给b。 同时呢，在这个过程中，我又 不希望这个函数mystrcpy ，这个函数，我又不希望它对a的值做任何的修改。 我不希望它去修改字符串a的值。 于是，我去定义mystrcpy这个函数的时候，我就可以把 与a所对应的那个形参，定义成一个指向符号常量的指针。 那么通过这种方式，在函数体里头，无论你怎么写， 在这个mystrcpy的函数体里头，你无论怎么去写， 你都不可能对传递到这里的实际参数的那个值进行修改。 通过这种方式，很好地保护了这个指针所指向的那片存储单元的内容。 这就是指向符号常量的指针最常见的一个用途。 
  
- 那么再回顾以下我们刚才所举的这个例子。 在第一个程序里，由于我没有把array 定义成一个指向符号常量的指针， 所以，当主函数把数组a的名字当作实际参数传递给sum这个函数的时候， sum就对数组a里面的值进行了修改，那是我们不希望看到的。 当我们把array定义成一个指向符号常量的指针时候， 如果函数再去对数组里面的内容进行修改，那么系统就会报出错误， 去禁止它修改，这就是指向符号常量的指针的作用。 那么说到这儿，同学们可能意识到，这个东西还挺有用的，对不对？ 那么我希望呢，大家如果在写程序的过程中，真的定义了一个函数，它的形式参数是一个指针， 那么如果你不想让这个函数对传进来的那个指针所指向的内容进行修改的话，那么请你把这个函数的参数直接定义成指向符号常量的指针。 那么些通过这种方式我们可以避免很多不经意作出的修改， 特别是当我们把一个数组名当作实际参数来传递给一个函数的时候。 那么既然这个东西这么常用， 那么，关于指向符号常量的指针，我们还有一点需要附加说明一下。 我们来看一个例子。
    ```C++
    #include <iostream>
    using namespace::std;

    int main()
    {
        const int a = 78;
        const int b = 28;
        int c = 18;
        const int *pi = &a;
        *pi  58;            //error,*p不能被赋值
        pi = &b;            //可以给pi重新赋值
        *pi = 68;           //error,*p不能被赋值
        pi = &c;            //可以给pi重新赋值
        *pi = 88;           //error,*p不能被赋值
        return 0;
    }
    ``` 
  这个例子是这样的，在这个程序里头，我定义了三个量。 第一个呢，是一个符号常量a， 它的值是78。第二个呢，是一个符号常量b，值是28。 第三个呢，是一个普通变量c， 它的值是18。接下来呢，我定义了一个指向符号常量的指针 pi。首先呢，我让这个pi指向a， 接下来，我要这个pi进行一系列的操作。我们来看一下，哪些操作是可以的，哪些操作是不允许的。首先第一个操作呢， 我是利用* pi 对pi 所指向的值进行修改。 原来它指向a吗，a是78，我现在让它等于58。 这个可以吗？这个显然是不允许的。 因为我们刚刚定义了pi 是指向符号常量的指针， 所以说，我们绝对不可能也不可以通过* pi 去修改pi所指向的那个存储内容。 这是我们刚刚讲过的，这是不允许的。 那接下来，我能不能做这么一个操作？对pi呀，进行重新赋值。 你原来这个pi不是指向变量a的吗？ 我对pi进行重新赋值，让它指向变量b。 那么，请问这样做可以吗？也就是说，虽然pi所指向的存储 单元的内容不能修改，我能不能修改pi本身的值呢？ 它本来指向a，我现在让它指向b。可以吗？ 那么，根据C语言的规范，这是可以的。可以 对pi进行重新赋值，这个是没有问题的。 那么pi原来指向a，现在让它指向b。 那么接下来，程序再通过* pi去修改所b所指向的内容，行不行呀？ 当然是不可以的，这个我们已经重复过很多次了。 那么接下来的这个程序，我再对pi进行修改，让它指向c，可以吗？ c和b有什么不同呢？c是一个普通的变量，而 b是一个符号常量。那么既然c是一个普通变量，我不能通过* pi修改c值呀？ 当然是不可以的，这个刚才我们已经介绍过了。 OK。那么通过这个小程序呀，我们就可以了解到，那么指向符号常量的指针具备这么几个特性： 
    - 第一个，当我们定义了一个指向符号常量的指针的时候， 我们就不能够通过* pi的这种方式去修改它所指向的那片存储单元的内容。 这是第一点，这是不可以的。 
    - 第二点，当我们定义了一个指向符号常量的指针的时候， 其实我们可以修改这个指向符号常量指针本身的值，它原来指向变量a，我可以让它指向变量b。 这个是可以修改的。
    - 第三个，我们完全可以用指向符号常量的指针指向一个普通的变量， 对不对？其实，之前我们都是这么做的。 那么当它指向普通变量的时候，仍然我们不可以通过*pi去修改它的值。OK，这是当我们在使用指向符号常量的指针的时候，需要注意的三点。 
## 3. 指针做函数返回值
- OK，那么在了解完了如何用指针作函数参数的情况以后啊， 我们再来看一下指针用作函数返回值的情况。 毫无疑问，啊我们可以从函数里头啊返回一个指针。 那比方说以前呢，我们定义一个返回整型的一个函数，啊我们可以这么来定义。 那么当我们去定义一个返回指向整数类型的指针的函数的时候，我们就可以这样来定义。非常的简单，也容易理解。 那么在函数名之前呢，写一个指针符号。 然后呢，在这个指针符号前面写清楚所返回的指针类型的基类型。 我想呢，大家都比较容易理解。我们来看一个例子。 
    ```C++
    #include <iostream>
    using namespace::std;

    int *get(int arr[][4],int n,int m)             //或者 int *get(int (*arr)[4],int n,int m) 也可以
    {
        int *pt;
        pt = *(arr + n - 1) + m - 1;
        return pt;
    }
    int main()
    {
        int a[4][4] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};
        int *p;
        p = get(a,2,3);
        cout << *p << endl;
        return 0;
    }
    ```  
  在这个例子里头啊，我们定义了一个函数。 这个函数呢就能够返回一个指针，并且呢是指向int型类型的一个指针。 它的作用是这样的，当主程序里头定义一个二维数组的时候， 那我们就可以把这个数组的数组名当作参数传递给这个函数。 那么这个函数呢就能够把其他的两个参数 所指定的相应的行和列上的地址返回出来。 那么比方说，我们在这传进去的是2和3，那么这个函数呢就能够把 数组a的第二行第三个元素的地址返回出来。 这就是get函数的含义。那么我们来观察一下这个程序。首先呢，我们传给函数的 参数是一个数组名，而且是一个二维数组的数组名。 那么函数的形参呢，就必须是与之相对应的 变量。那这个变量呢，在这个程序里头啊是这样来定义的， int arr [][4]。那这样定义可以吗？首先根据我们前面所讲过的当我们在函数的形参里面去定义的是一个数组的时候，就相当于我们定义了一个指针变量。 这是我们刚刚讲过的。除此以外，由于我们传入函数的参数，啊是一个a， 这个a呢，是一个指向包含4个整型元素的一维小数组的指针， 对不对。所以说，在这儿的这个arr也必须符合这个含义。那么这样的一种定义方式也能够满足程序的要求，当然除了这种定义方式之外我们曾经说过，我们照样可以这样来定义， int然后arr然后4，那么这两种定义方式都是可以的。 这是刚刚我们讲过的。 那么get这个函数呢，在进行完相应的操作以后， 获取到第n行第m列的 指针以后，它呢，就要返回这个指针，当然在这 我们借助一个临时的指针变量pt做一个过渡了， 直接返回这个指针，那么主函数呢，获取到这个指针以后， 我就可以直接通过* 操作，把相应的内容给打印出来。 啊这是这个程序。那么通过这个程序我们就可以看到， 那么定义一个返回指针的函数还真没那么难，对不对。 

- 嗯但是，有一些事情啊我们必须要注意。 比方说我们来看这么一个程序，那么请你呢，阅读一下这个程序， 看看这个程序的输出结果将会是怎样的。 OK，我们来分析一下。 
    ```C++
    #include <iostream>
    using namespace::std;

    int *getInt1()
    {
        int value1 = 20;             //局部变量
        return &value1;
    }
    int main()
    {
        int *p;
        p = getInt1();
        cout << *p << endl;          //当函数被调用完毕， 函数的存储空间被从内存中释放掉的时候， 这个变量还存在吗？也不存在了。 
                                     //所以说这个时候你再去打印* p的值，你知道会打印出什么结果吗。 我                              
                                     //也不知道会打印出什么样的结果
        return 0;
    }
    ```  
  在这个程序里头呢定义了一个函数，getInt1[]，它呢， 会返回一个指针，这个指针的类型呢，是指向Int型的。 这是定义了一个具有指针类型返回值的这么一个函数， 然后在主函数里头呢，我定义了一个普通指针变量p， 它呢也指向整数类型。然后呢，调用getInt1,并且呢，利用 getInt1的返回结果，对p进行赋值。 赋完值以后呢。我就用* p， 把p所指向的那个存储单元的内容给它打印出来。 那现在我们的问题是，这个p会打印出什么来呢？ 当然，p打印出什么内容来，我们要看一下getInt1将会返回一个什么样的指针， 对不对，啊我们先来分析一下，看它会返回一个什么样类型的指针。那么在 getInt1里头呢，我定义了一个变量，叫value1，并且呢，赋初值为20。 当然，在函数里面所定义的一个变量，这属于局部变量， 然后呢我把这个value1的地址直接返回出来，作为函数的返回值。 也就是说啊，main函数里边这个指针变量p， 所得到的这个指针，指向谁的呀它是？ 指向value1的。啊是一个value1的指针。 那么在这儿，当我们去打印这个p的时候，会打印出什么来呢？ 那有的同学说，那应该会打印20啊。是这样的么？ 那有的同学说为什么不是这样的呢？ 那是因为啊，在这儿所定义的这个value1，它是一个局部变量。 那么根据以前我们所讲过的，局部变量作用范围的知识，我们就知道value1的有效范围是从哪儿到哪儿啊，value1的有效范围实际上是从定义开始一直到这个函数的结束。嗯，是这样的一个作用范围。也就是说，当这个函数存在的时候， value1呢是存在的。当函数被调用完毕，函数的存储空间被从内存中释放掉的时候，这个变量还存在吗？也不存在了。所以说这个时候你再去打印* p的值，你知道会打印出什么结果吗。我也不知道会打印出什么样的结果。OK，我们再来回顾一下这个程序的运行过程。首先呢我们定义了两个函数，一个main函数， 一个getInt1的函数。在main函数的里面呢，我们又定义了一个指针变量p， 然后呢我们调用getInt1这个函数给p赋值， 那么当我们调用getInt1这个函数的时候， 那么就在内存里头生成一片内存空间，把getInt1 load进来，对不对。这是我们以前讲过的。 然后呢，getInt1就开始运行。 当getInt1运行的时候呢，在它的里面定义了一个 临时的指针变量value1，并且呢，赋初值为20。 并且呢函数getInt1的运行结果是把value1的地址 传递给了指针变量p，也就是说p指向了 value1，对吧，这是这句程序执行完毕以后，得到的一个状态。 那么当这句程序执行完毕以后， 那么getvalue1就被释放掉了，啊这片内存空间就被释放掉了。 那么释放掉以后，程序继续往下执行，执行到哪一句啊， 执行到这一句，cout* p， 这个时候p所指向的这片内存空间已经被释放掉了。这个时候我们再来打印* p, 会打印出什么结果来呢，那谁也不知道可能会打印出什么样的结果来。 那打印的这个结果就严重取决于p所指向的这片内存空间里面现在是一个什么样的值。 对不对，那么如果刚才的赋值20没有被新的内容给覆盖掉，那么仍然会打印出来20。如果它已经被覆盖掉了， 那么就会打印出新的内容来。至于新的内容是什么， 谁也不知道。这取决于系统使用的状态了。所以说， 这个程序的返回结果是无法完全预测的。 也就是说这个程序所返回的值，是一个非常不稳定的值。 因为这个p指向了一片已经被释放掉的存储空间。 那有的同学说，李老师我怎么去运行这个程序的时候啊， 我总能够得到20呢，无论我运行多少遍，它总得到的都是20。 那你真的是比较幸运，
  
- 那么接下来呢我就构造一个新的程序，你看这个程序， 
    ```C++
    #include <iostream>
    using namespace::std;

    int *getInt1()
    {
        int value1 = 20;             //局部变量
        return &value1;
    }
    int *getInt2()
    {
        int value2 = 30;
        return &value2;
    }
    int main()
    {
        int *p,*q;
        p = getInt1();
        q = getInt2();
        cout << *p << endl;          
        return 0;
    }
    ```    
  那么你在去运行这个程序的时候，你看看你的结果应该是怎样的。 那么在我的机器上呢，那么这个程序运行的结果呢是30。 呃我们来看一下它应该不应该等于30。 主程序里头定义了两个指针变量,p和q，我们分别用 getInt1和getInt2的返回值，对p和q进行赋值。 最后输出的时候呢，我只输出* p的值，也就是说第一次调用的时候， 啊调用的getInt1的返回的那个指针所指向的存储单元的内容。 嗯我们来看一下getInt1和getInt2都做了些什么。在getInt1里头我定义了一个 临时变量value1，它的值呢是20。啊这跟刚才我们的 程序里头是一样的，那么在getInt2里头呢 我定义了一个临时的指针变量Value2，它的值呢是30， 然后呢，这两个函数分别返回value1和value2的 地址，当然，这value1和value2都是 局部变量，对不对，它们都是局部变量，也就是说， 它们返回的值，都跟刚才我们程序里面介绍的情况是一样的 然后呢，我在这打印的时候，打印的是* p，也就是getInt1, 所返回的值，那么按照刚才的那个程序，这个时候呢，可能大多数情况下，会打印出来 20，对不对？啊，那么实际你去运行 这个程序的时候，你会发现，很多时候，你得到的结果是30， 也就是说啊，当调用完，getInt1， 以后，那么getInt1的这片空间就被释放 掉了，那么系统呢，又利用了这片已经被释放掉的空间存储了 getInt2，所以呢，当你调用完getInt1，又调用完getInt2 然后返回头来，要去打印指向getInt1里面的这个Value1的指针的时候 实际上，你打印出来的值是第2个函数， 里面value2的值，在大多数情况下得到的是这样的 一个值，也就是说，它已经被覆盖掉了，当然，在这需要强调的是，就是你得到的是30，也不是一个稳定的值，因为 getInt2在被调用之后，也被释放掉了 对不对，所以说，在这个地方啊，打印出来的这个值仍然 是不能够确定的，仍然是一个危险的值，那么通过这两个例子，我们就可以看得出来，当我们从一个函数里面返回一个指针，并且呢，这个指针是指 向这个函数里面的一个临时变量的时候，这个时候是非常非常危险的，啊，实际上，你返回的这个值是一个指向已经被释放掉的内存空间的一个值，啊，它是非常非常的不稳定的，所以说啊，这就告诉我们，当我们要从函数里面返回一个指针的时候请你务必确保这个指针是有意义的，也就是说，它必须指向一片没有被释放掉的，有意义的，仍然活着的内存空间。
  
- 啊，比方说，这个例子，我们再来看这个例子，
    ```C++
    #include <iostream>
    using namespace::std;

    int value1 = 20;         //全局变量
    int value2 = 30;
    int *getInt1()
    {
        return &value1;
    }
    int *getInt2()
    {
        return &value2;
    }
    int main()
    {
        int *p,*q;
        p = getInt1();
        q = getInt2();
        cout << *p << endl;          
        return 0;
    }
    ```   
  那么这个例子呢，就不同了我们来分析一下，仍然呢，是定义了两个函数，一个叫getInt1， getInt2，它们都会返回两个指针，那么getInt1呢返回的是Value1的地址，getInt2呢，返回的是 value2的地址，跟前面的程序所不同的是，在这个程序里头，value1和value2 是全局变量，全局变量，也就是说，它们两个的 生存周期啊，是从这个变量的定义开 始，一直持续到整个文件的 结束，也就是说，value1和value2的作用范围， 是从它们定义开始一直持续到整个 文件的结束，也就是说，就算，当getInt1和getInt2被 调用结束之后，value1和value2的存储空间仍然不会 被释放 掉，所以在调用完getInt1和getInt2之后，我们再 去打印p里面所指向的那片内存空间的时候，p所指向的内存空间有没有意义啊？ 有意义，因为p指向value1，而value1呢，是一个 全局变量，它的作用范围是从它的定义开始，一直到整个 文件的结束，所以说，当我们在这里再去打印*p的时候，它仍然是有 意义的，啊，所以说，在这个程序里头 啊，getInt1的这个做法，返回的value1的这个 值，是正确的，所以程序的运行结果呢，也是， 稳定的，那么在这种情况下，我们就可以说，getint1 和getint2返回的都是处于生命周期中的 变量的地址，啊，而不是一个死的地址，不是一个被释放掉的地址。
- 那，可能有的同学可能问了 那，那，为了确保我返回的是一个有意义的地址 是不是，我必须得使用全局变量啊，那你老师曾，以前可是讲过，使用全局变量要非常非常的慎重， 啊，因为，全局变量会破坏程序的结构性， **那有没有什么其他的办法，可以让我返回一个有意义的值呢？有，那么除了全局变量之外，你还可以在函数里面定义一些静态局部变量，比方说，在刚才的这个程序里头，那么如果我们不把value1和value2定义成全局变量，但是呢，我们又想确保它们返回的value1和value2的这个值是有意义的， 是没有被 释放掉的，那么我们就可以把value1和value2定义成static啊，也就是静态局部变量**，什么叫静态局部变量 啊，ok，接下来呢，我们就来了解一下什么是静态局部变量。 
## 4. 静态局部变量
- OK，接下来呢，我们就来了解一下什么是静态局部变量。 **所谓静态局部变量啊，指的就是在函数中所定义的一些局部变量。 那么与普通的局部变量不同，静态局部变量它的值呢， 在函数调用结束后啊，不会消失。 它不会像普通的局部变量那样被释放掉， 而是会保留原来的值， 一直存在在那里。也就是说， 它所占用的存储空间是不被释放的。 如果还有下一次函数调用的时候，仍然可以继续使用 这样的一些局部变量，那这样的变量就被称作静态局部变量**。 那怎么去定义一个静态局部变量呢？非常地简单，那么 只要在原来普通变量定义的前面加一个static，就可以完成一个静态局部变量的定义了。 OK，那么为了让大家更好地理解什么是静态局部变量，我们来看一个例子。看这个例子， 
    ```C++
    #include <iostream>
    using namespace::std;

    void function()
    {
        int a = 0;
        static int b = 0;            //再次调用子函数时，不会再生成新的b并赋初始值了
        a++;
        b++;
        cout << "a= " << a << endl;
        cout << "b= " << b << endl;
    }
    int main()
    {
        for(int i = 0;i < 5;i++){
            function();
            cout << "Call Again!" << endl;
        }         
        return 0;
    }
    ```   
  在这个程序里头啊，定义了一个函数，function， 在function里头呢，我定义了两个变量，一个变量是普通的局部变量a， 第二个变量呢，是一个静态局部变量b，然后接下来呢在这个函数中分别对 a和b进行加1的操作。也就是说如果这个函数调用一次的话，我就对a 加一次1，然后如果调用一次的话就对b加一次1，然后我分别打印a和b的值。 那么在主函数里头呢，我就用一个for循环，连续五次去调用这个function函数。那明白这个程序的作用了吧？ 那么在主函数里头啊，我反复地去调用function这个函数。反复调用五次，然后这个function这个函数里头呢有一个普通的局部变量a和一个静态局部变量b， 它所做的事情呢就是对a和b进行加1的操作，然后打印输出a和b。 OK，那么通过运行这个程序，我们就来比较一下静态局部变量和普通局部变量的不同。我们来看一下这个程序的运行结果，这个运行结果是这样的。 毫无疑问，那么第一次调用的时候，a等于0，b等于0，然后呢 a等于a+1，b等于b+1，那么最后输出的结果当然是a等于1， b等于1，这是毫无疑问的。打印完之后呢，主函数第二次 再来调用function这个函数。那么第二次再来调用这个函数的时候， 对于普通变量a而言，第一次调用的结果将被释放掉，那么当第二次我们调用function函数的时候， 对于普通变量a而言，需要重新在内存里面开辟一片内存空间给a，然后重新给a赋值为0。 然后呢，对a进行加1的操作，然后再把a打印出来。 所以第二次当我们再去打印a的时候会打印什么结果啊？ a等于1仍然打印a等于1。 因为实际上这个a和这个a是不同的，那么第一个a呢，已经被释放掉了，对不对？这是第二个全新的a。 但对于变量b就不同了， 因为b是一个静态局部变量。那就意味着 b的生存周期是从定义这个变量开始一直到整个文件的 结束。所以，当我们第二次再去调用function这个函数的时候， 还需要再生成一个新的b吗？ 不需要了，那function函数里面的这句程序， 只被执行一次，当你再调用function这个函数的时候， 它就不会再去生成一个新的b了， 而是在原来这个b的基础上继续进行加1的操作。 于是呢，b将被打印出来b等于2。 也就是说啊，虽然function这个函数 被反复调用了多次。 但是static int b，定义 静态局部变量b的这句程序只会被执行 一次。当你第二次再来调用function这个函数的时候，b已经存在了，所以不需要 再去执行这句程序。所以呢，b就在上一次执行结果的基础上继续进行加1的操作。 于是，当我们第三次再去调用function的时候，那么系统呢又会重新生成一个 变量a。但是对于b呢，又会在原来b的基础上再进行加1，于是打印出 a等于1，b等于3.第四次调用的时候呢，也是一样，于是打印出a等于1，b等于4。 第五次调用的时候仍然一样，a等于1，b等于5。 那么通过这个例子，我们就能看的出来， 什么叫静态局部变量。那**么跟静态局部变量b相对应的，我们把a这种普通类型的变量称作动态局部变量， 也就是普通的局部变量。那么它们两者之间的区别呢，我们就可以用这样一张图 来表示。也就是说，对于我们所定义的普通局部变量， 比方说a，它的作用范围是从这个变量的定义开始，到函数的结尾。 也就是说，当函数调用结束以后，函数相对应的内存空间被释放掉以后， 那么这个变量呢，也就被释放掉了。 这就是普通的动态局部变量。对于我们所定义的静态局部变量，比方说 static int b，它的有效范围呢，就是从变量的定义开始一直持续到整个程序的 结束**。所以说当我们去反复调用function的时候， 每次调用过程中都会新生成一个a， 然而对于b呢，每次我们都要基于上一次的结果， 再继续对b进行操作。这就是静态和动态局部变量的不同。

- 那么在这儿呢，我需要稍微多说一点， 在以前的c++的版本中啊， 所有的普通的动态局部变量，比方说我们所定义的int a等于0，这是一个普通的 动态局部变量。那么对于所有的普通的动态局部变量定义的时候啊，其实在它的前面可以加一个关键字叫auto。 那么加这个关键字跟不加这个关键字呢，它的含义是一样的。也就是说，在以前的C++的版本中， 对于动态局部变量我就可以加auto，而且呢这个auto是可以省略不写的。 也就是说，当我们去定义一个普通的局部变量用int a 等于0这种形式的时候其实就相当于我们用的是 auto int a等于0，只不过auto被省略不写。 这是在以前的C++的版本中，它的含义是这样的。 但是根据新的，2011版的C++规范， 由于呢，老的版本中这个auto它的作用呢实在是太小， 所以在新的C++的规范中， 重新定义了auto这个关键字的含义。 它的新的含义跟老的含义完全不同了， 那么由于这是一个C++规范的新的变动，所以如果有的同学在有些参考资料上面看到关于auto的介绍的话，请你注意这一点。 那么有的同学可能要问了，那关于新的这个auto它的含义到底是什么呢？ OK，等到同学们再去学C++的部分的时候，面向对象的部分的时候， 我们再去讲述auto的含义。OK，那么这次课呢，我们就讲到这儿。 
- 总结一下这次课的内容，在这次课里头啊，其实我们就讲了两个要点。
  - 第一个要点 就是当指针用做函数参数的时候，我们需要注意的情况。 
    - 第一个需要注意的就是，当函数获取的一个指针类型的实参的时候，它其实就相当于拿到了指向某个内容的地址。从而呢，它就可以对这个内容啊，进行修改。所以说，当我们向某个函数传递一个指针的时候，我们要格外的小心。因为拿到了指针， 就可以对指针所指向的内容进行修改。
    - 那么为了防止这个函数对指针所指向的内容进行不必要的修改， 我们可以使用const来限制指针的功能。这是这次课我们讲过的第一个要点
  - 第二个要点我们讲的是，当函数返回一个指针的时候， 所应该注意的情况。
    - 首先，从函数里面返回一个指针的值，是一个常见的应用。 但是呢，这种情况下我们必须要确保函数返回的这个地址啊，是有意义的。它是一个出于生存周期中的内存单元。它不能指向一片已经被释放掉的内存单元。 
    - 那么如何才能保证它指向一个有意义的内存单元呢？ 那么两种可以选择的途径就是，你可以返回指向全局变量的指针，或者是返回一个指向局部变量的指针。所以呢，在这儿我们就介绍了静态局部变量和普通局部变量的区别。
- OK，那么这次课的内容呢，我们就先介绍这么多。 那么由于我的出差呢，我就被迫推迟了这个课的发布时间。所以呢，我们相对 安排少一些的内容给大家。那么下一次课呢，是我们这个课程的最后一次课， 我们将给大家介绍结构体和链表相关的内容。 那么在下一次课之后呢，我们将安排期末考试，到时候呢请大家关注。 那么在期末考试的过程中呢，我会根据大家的反馈再酌情地增加一些相应内容的介绍。最后，谢谢大家。