# [C语言中的运算成分](https://www.coursera.org/learn/jisuanji-biancheng/home/week/8)
 > 本节我们将介绍C语言中的“运算成分”。重点在于：掌握各种运算符的基本含义，特别需要掌握“由各种运算符引起的数据类型转换规律”。
 ## 1. 说在前面的话
 - 好，同学们大家好，下面我们开始今天的这个课程的学习。 那么今天呢，我们学习C语言的构成成分的第二个部分，运算成分。 
 - 在前面呢我们学习完了第一个部分，数据成分。 通过这次课呀，大家可能有这么一个感受， 觉得这部分呢有点琐碎。而且呢， 这部分也没什么意思，好像有点枯燥。其实啊，从我自己的感受来讲，我也最不喜欢讲这部分。 因为这部分呢，没有什么好讲的。 都是一些非常平时的需要大家接触的知识。 但是呢没有还不行。特别是数据成分和运用成分，这两部分。 那么这两部分呢，在后面用的特别的多。不讲还不行， 讲呢又有一点枯燥。没关系，我想告诉大家的是， 也就顶多这两部分了。等我们稍微过了这部分之后，其他部分就好办啦。 而且呢，有了上一次的，数据成分的这个基础，那么我们这次再来介绍运算成分， 那就会容易得多。 所以说呢，首先大家不要紧张，我们不会不是接下来都是这样枯燥的知识。 Ok，那我们介绍运算成分。
 - 在C语言中有很多的运算符。这是 以前我们跟大家提过的。以前我们也给大家展示过，C语言里面有很多很多的运算符。 在这儿呢，我还想多说几句。其实跟其他的语言相比，C 语言 中的运算成分，的确已经算比较多的了。不但多，而且功能强大。 这是C语言的这个运算符。
 - 那么C++ 语言里头，其实比C语言，还要强大。 因为，在C++ 里头，有一种运算符重载的 机制，可以赋予一个运算符更多更多的含义和功能。 从而使得运算符的功能变得异常的强大。甚至有的人觉得C++ 这么搞的话，会把运算符的功能变得太过于强大了。使得这个程序啊，不太易于控制， 有一些反对的声音出来。所以说，在后续产生的很多语言里头，人们甚至有意识的去 淡化运算符的这种作用。比如说C++的运算符啊，非常非常 的强大。
 - 那么在这儿呢，我们先不去管C++，我们先来了解一下 C的运算符。我相信，在学完了C的运算符之后，你再去看其他语言的运算符呢，就变得容易了。 那么C语言中的运算符呢，都列在这里。一共就是这么多的运算符。
    ```C++
    C的运算符有以下几类：
    1.算术运算符：* - + / %
    2.关系运算符： > < == != >= <=
    3.逻辑运算符：! && ||
    4.位运算符：<< >> ~ | ^ &
    5.赋值运算符：=及扩展赋值运算符
    6.条件运算符：?:
    7.逗号运算符：,
    8.指针运算符：*和&
    9.求字节数运算符：sizeof
    10.强制类型转换运算符：(类型)
    11.分量运算符：. ->
    12.下标运算符：[ ]
    13.其他：如函数调用运算符:()
    注意：条件运算符是C语言中惟一一个三目(三元)运算符

    优先级
    优先级【高到低】：
    第一级：
    圆括号【（）】、下标运算符【[]】、分量运算符的指向结构体成员运算符【->】、结构体成员运算符【.】
    第二级：
    逻辑非运算符【!】、按位取反运算符【~】、自增自减运算符【++ --】、负号运算符【-】、类型转换运算符【(类型)】、指针运算符和取地址运算符【*和&】、长度运算符【sizeof】
    第三级：乘法运算符【*】、除法运算符【/】、取余运算符【%】
    第四级：加法运算符【+】、减法运算符【-】
    第五级：左移动运算符【<<】、右移动运算符【>>】
    第六级：关系运算符【< > <= >= 】
    第七级：等于运算符【==】、不等于运算符【!=】
    第八级：按位与运算符【&】
    第九级：按位异或运算符【^】
    第十级：按位或运算符【|】
    第十一级：逻辑与运算符【&&】
    第十二级：逻辑或运算符【||】
    第十三级：条件运算符【?:】
    第十四级：赋值运算符【= += -= *= /= %= >>= <<.= &= |= ^=】
    第十五级：逗号运算符【,】
    说明：
    ①G1不要求运算对象的个数，G2是单目运算符,G13条件运算符是三目运算符，其他都是双目运算符。
    ②G2、G13条件运算符、G14赋值运算符是自右向左的【也就是右结合性】，其他都是自左向右【左结合性】
    归纳各类运算符【高到低】：
    初等运算符【（）、->、.】 G1
    单目运算符G2
    算术运算符(先乘除【取余】，后加减) G3,4
    位运算符【<< >>】 G5
    关系运算符G6,7
    位运算符【递减& ^ |】 G8,9,10
    逻辑运算符(不包括！) G11,12
    条件运算符 G13
    赋值运算符 G14
    逗号运算符 G15
    左结合性和右结合性
    C语言中各运算符的结合性分为两种：左结合性和右结合性
    例如：算术运算符的结合性是自左至右，即先左后右。
    如有表达式x-y+z则y应先与“-”号结合，执行x-y运算，然后再执行+z的运算。这种自左至右的结合方向就称为“左结合性”。
    而自右至左的结合方向称为“右结合性”。 最典型的右结合性运算符是赋值运算符。如x=y=z，由于“=”的右结合性，应先执行y=z再执行x=(y=z)运算。
    C语言运算符中有不少为右结合性，应注意区别，以避免理解错误。（上文的优先级有分辨左右结合性）。
    ```
 - 有一些，其实是我们已经讲过了， 那么在今天的课上呢，我们就不再去作仔细的叙述了。比方说 size of，这是以前我们提到过的。 这就是下标运算符。那么在讲数组的时候，我们曾经用到过，在这儿呢，我们也不再去详细的叙述它了。 那么今天重点要讲的，包括哪几个呢？包括 这么几个，第一个，赋值运算符。第二个，算数运算符。第三个，关系运算符。 第四个，逻辑运算符。这四种运算符是我们今天要着重去讲的四种运算符。 除此之外，还有一些其他的运算符，在今天的课上呢，也会提到，会介 绍它的基本功能。比方说，条件运算符，逗号运算符，强制类型转换运算符，等等。 还有一类运算符呢，那么今天我们也会去讲一讲。但是，在我们那个课上呢，我们并不要求大家一定去掌握 这个运算符，就是位运算符。ok，那么其他的运算符，比方说，指针运算符， 以及分量运算符，这个呢，以后在相关的章节里头，我们再 介绍。今天呢，我们暂且不介绍它。 Ok，那下面我们就从赋值运算符。 
## 2. 赋值运算符
- ok，那下面我们就从赋值运算符开始。 那么说到赋值运算符，有的同学就开始觉得， 赋值运算符还有什么好讲的，不就是把一个值赋过去么？ok，你说的呀， 这是赋值运算符的基本功能。那么要用好赋值运算符， 那么除了了解它的基本功能之外，还需要再了解一些其他的要点。 我们就先来看一下它的基本功能，然后我们逐一看一下使用运算符 的要点。赋值运算符最基本的功能就是给赋值负号左边的这个变量 赋予一个值，这最基本的一个功能。除了最常用的这个功能之外，我们赋值运算符还出现在 变量定义里头。比方说，int a等于3，这其实相当于两句话。 第一句话，定义了一个变量a，第二句话，用赋值运算符给变量a赋值。 相当于两句话，那么需要说明的是呢，当然除了这种写法之外，我们也可以写成这样，int a 逗号，b，逗号，c，逗号，等于5，什么意思呢？我连续一下子定义3个变量，并且给变量c 赋值为5，这是这句话含义，所以说这个，就是说，大家千万不要写出来这种方式。 int a等于b等于c等于5，那么在定义， 变量定义的环节里头，变量之间是不能够连等的。 这种方式是错误的，这一定要小心。这是赋值运算符的基本功能。 那么，要用好赋值运算符，还需要知道一些什么呢？下面我们介绍一些使用赋值运算符的 要点。先看第一个，
- 要点一， 当两边的类型不同的时候，会怎样呢？ 也就是说啊，比方说有个赋值语句，a等于b，当 a和b的数据的类型不同的时候， 能赋值吗？如果赋值的话，会发生些什么呢？这是我们讨论的第一个要点。 我们先来看一个程序。
    ```c++
    int main()
    {
        int int_i = 64.12345;
        char char_i = int_i;
        float float_i = char_i;
        bool bool_i = float_i;
        cout<<showpoint<<int_i<<" "
            <<char_i<<" "<<float_i
            <<" "<<bool_i<<endl;
        return 0;
    }
    ```
- 首先在这个程序里头啊，我定义了好几个变量。比方说，int型的变量， char型的变量，float型的变量，bool型的变量。 定义了好几个类型的变量，并且呢，它们互相赋值。 那这个时候会发生些什么呢？ 我们先把结论告诉大家，然后我们再来验证一下，**如果等号两边的类型不一致的话，进行赋值，这个时候啊，就要发生类型转换。那怎么转换呢？这么来转换。不管等号右边这个操作数是什么类型， 统统转换为等号左边的 类型。不管右边是什么，统统转换成左边的类型。**我们借着下边的例子，对着这个例子的实验结果，我们来分析一下。 先看第一步，我定义了一个int型的变量， int i，并且呢给它赋值为，64.12345， 64.12345这是个小数，对吧，也就是个实型 的数。我们上次课曾经讲过，如果我们把一个小数直接写出来， 而不去说明它属于什么类型的数据的时候，系统将 把它默认为是什么类型啊？还记得吗？是double型。这个是一个double型的数，也就是说它是一个双精度浮点数。现在呢，要把一个双精度浮点数赋给一个整型的变量，可以吗？ 可以。 一定会发生类型转换，怎么转呢？就是要把这个双精度的，右边这个双精度的数据，转换成左边的整数。 那到底怎么去转呢？很好办。 既然它是一个小数，要转换成整数，那我就把小数部分整个一刀全部砍掉， 完事。然后把剩下的整数部分，赋到，赋到左边来。 也就是说，当右边是个小数的时候，要赋给一个整， 要赋给一个整数，我就把它拦腰砍断，把整数部分赋过去。 第一步里头，我们打印int i的时候，打出来64，这是对的。再看第二步， 现在int i里头是64，我要把它赋给一个char型的数。 既然64是一个位于0到255之间的数，所以可以直接去查一下测码表， 这个我们非常熟悉了，我们已经打印过很多遍了，是这个字符，@， @这个字符。所以说char打印出来是这个字符。 再看第三部，第三部里头啊，我们把char型的这个i， 赋给了一个float型的数，char i里头放的是64， 要把它赋给一个float型的数，float型的数是个小数， 那这个时候，无疑我们要补充小数位。 补充什么小数位呢，补0就行了，看第三个输出，就64.0000。 那么有的同学可能问了，嗳，这个地方为什么是64.0000，4个0啊？ 这上次课我们讲过，因为cout打印的时候默认打印6位精度。再往下看，float型的i，我们要 把它赋给一个bool型的i，可以吗？ 可以。怎么转换呢？float型的数要转换成 bool型的数。那以前我们讲过，bool型的数啊有这样一个 特点，它里面就放两个值，要么0，要么1。 0代表false，1代表true。 如果你赋给它一个非0的值，里面的值就是1；如果赋给它一个 0的值，里面的值就是0.那么在这，float i显然是一个非0的数， 所以说，赋过来以后，bool i里面放的是1. 所以最后打印出来是1.所以说，我们看到要点1， 完全成立。就是两边类型不同的时候，通通转变成左边的类型。 
- 好，在我们再来看一下赋值运算的第二个要点。 也就说，当我们把一个长的数赋给一个短的数的时候， 会发生些什么呢？我们先来看一段程序。 
    ```c++
    int main()
    {
        char char_a = ' ';
        int int_i = 0x361;
        cout<<hex<<int_i<<endl;
        char_a = int_i;
        cout<<char_a<<endl;
        return 0;
    }
    ```
- 在这个程序里头啊，我定义了两个变量。一个呢， 是字符型变量，char a，给它赋初值呢，是一个空格。 一个呢，是一个整型的变量， int i，然后呢，给它赋初值，0x，16进制的，361. 有了这个赋值以后呢，大家可以想象一下在内存中的状况，我在这呢，画一张图。 上面的这个数，就对应着0x361， 底下的这个呢，就是1个字节，它对应着呢，这个字符数。 这个是这个，对应关系。那么，在这个程序中呢， 首先我们把int i以16进制的方式打印出来，确认一下。 然后呢，我们做了一个赋值，就是把这个 int i啊，赋给了，char a。 int i呢，是一个32位的数。 赋给了char a，char a呢，是一个8位的数。 一个32位的数给了一个8位的数，会发生什么呢？不知道。 但是呢，我们把结果打印一下。char a，我们先来看一下这个程序的运行结果。 实际上是这样的，361，然后a。 我们来分析一下这个结果，这个结果是这样的。 上面的这个数呢，跟361是匹配的，也就是说，它的第4位，是1. 再往上数4位，应该是6。这个对应着6，这个对应着1。 再往上数4位，对应着3。那么，前面呢，全都是0。 那么在赋值的过程中，其实做的事情是这样的。既然我打算要把一个32位的数， 赋给一个8位的数， 那我怎么做呢？我就把这个32位的数最后面的8位， 最低的8位，直接砍下来，然后呢，赋给这个8位的数。 这就是刚才所发生的事情。那么赋过来以后， 我们计算一下这个数。这个数的大小呢，刚好是 97。也就是说，它的运行结果，刚好是打印字符a。 这就是当把一个长数，赋给一个短数的时候，所发生的事情。 所做的事情呢，就是截取长数的第n位，直接送给这个短数。 这就是刚刚所发生的事情。 那么为了更清楚呢，我们来举一个例子。
    ```c++
    int main()
    {
        long int long_i = 0x2AAAAAAA;
        cout<<long_i<<endl;
        short short_j = long_i;
        cout<<hex<<short_j<<endl;
        cout<<dec<<short_j<<endl;
        return 0;
    }
    ```
- 在这个例子里头呢，我们把一个 long型的数，赋给了一个short型的数，比方说，这两个数 之间的赋值。上面是一个long型的数据， 那么它占了呢，32个bit。下面呢，是一个short型的数据，它占了 16个bit。现在呢，我们要把一个long型的数据赋给这个16字节的short型的数据。 我们看一段相应的，相对应的程序。在这个程序里头啊，我们首先定义了 一个long型的变量，long i，然后呢给它赋初值， 0x2AAAAAAA，这个16进制的数，对应着上面这个数，跟这个数是等价的。 利用我们前面学过的知识，大家可以推算一下，它的二进制表示就是这样的。接下来把它打印一下， 用10进制的这种方式。然后呢，我们把这样一个long i， 赋给一个short 型的数short j，然后呢把这个short j先按16进制打印。 一下，然后再按十进制打印一下。啊，这个结果呢是这样的。有的同学看到这个结果，哎呀， 会不会是错了呀？你看，首先呢，我们用十进制的方式打印了这个数， 也就是说，这句输出啊，程序的这句输出对应着这儿。 先把这个long int型的数打印出来。这是一个正数，好大的一个正数啊。 然后呢，我们把它赋给了一个短整型的数。 然后呢，再把这个短整型的数以十六进制打出来。哎，也没什么错。aaaa，最后把它以十进制的形式打出来。 怎么变成负的了呀，为什么变成负的了呀？很简单， 在赋值的过程中，当我们把一个长的数，例如上面这个长的数， 赋给底下这个短的数的时候，怎么办来着，把上面这个长的数 拦腰砍断，砍下相应的字节，直接把这个字节赋给 底下短的数。赋完了以后呢，我们再来观察这个短的数，它是一个 short型的数。这个时候程序发现它的第一位，系统发现它的第一位是一个1， 那足以证明它是一个什么类型的数啊? 是一个负数，啊它一点错都没有。 然后呢，把后面的这些求它的补码。然后算出来之后，它恰好等于 -21846，就等于这个数。透过这个例子，我们可以看出来很多问题。**第一个问题，当我们把一个长数赋给一个短数的时候，很好办，把这个长数后面相应的n位直接 拦腰砍下，砍下来以后直接赋给短数，这是第一个结论。第二个结论， 当我们把一个数赋给一个短数的时候，这个短数只管去接纳这个数， 等到程序对这个短数进行解释的时候，它发现这个短数的第一位是一个 1，它才不去管这个短数是怎么来的呢。按照整数的默存方式， 它被解释出来是多少就是多少**。
- 这是当我们把一个长数赋给一个短数的时候， 发生的情况。那有的同学可能问，那反过来呢？当把一个短数赋给 一个长数的时候呢？我们说啊，这是最好处理的一种情况。 也就是说原来是什么数，现在还是什么数。比方说， 我们定义了一个短整型的一个数，a=-1。现在呢我们把它赋给 一个int型的数b，啊，这就从十六位直接赋到32位了。 那这个结果会是什么呢？结果就是b=-1，也就是说原来a是什么数， 赋完了以后b还是什么数。那这个过程是怎么处理的呢？我们现在 举个例子来说明一下计算机的处理过程。比方说我们要把一个 short型的数赋给一个long型的数，这个时候怎么处理呢，计算机？ 计算机这样来处理。
  - 如果short型的数为无符号数，那么， 那么先把short型的16位放到long型的低16位去，那么是long型的最高16位呢， 全部补0。啊是对无符号数。
  - 如果short型的数是一个有符号数， 那么，首先把short型的低16位放到long型的高16位。 然后去看符号位，如果short型的最高位，也就是说它的符号位是0， 那么long型的最高16位全部补0。 如果short型的最高位为1，则long型的高16位全部补1。
- 啊这就是它的处理情况。下面我们通过一个例子来印证一下。 这例子是这样的。啊，直接看这个例子。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        short short_i = -123;
        cout<<hex<<short_i<<endl;
        int int_i = short_i;
        cout<<hex<<int_i<<endl;
        cout<<dec<<int_i<<endl;
        return 0;
    }
    ```
- 在这个例子里头，我我定义了一个短整型的数，short i=-123，然后呢我把它打印出来，确认一下。 然后，接下来呢，我把这个数赋给一个int型的数j。赋完了值以后呢， 先把这个 int j按照十六进制先打印一下，我看看，它到底发生了什么变化。 然后呢，再按十进制的这种方式把它打印出来，看它是不是没有，真的没有变。 那程序的运行结果呢就是这样的。首先，short int型的 -123打印，按十六进制打印完是ff 85。然后呢，我们把这个short int型的数赋给一个int型的数j。 然后把这个j按照十六进制再打印一下，打印的结果是fff85。 看到这个结果是不是跟刚才我们讲过的是一样啊。因为short型的数的最高位是1， 全是f嘛，f全是1嘛。所以前面全都补1， 所以前面补的全都是f，没有错。然后呢，最后我们把这个， 最后呢，我们把这个int j，把它的十进制数打印出来，一看，-123， 的确没有变化。这就是当把一个短数赋给一个长数的时候，会发生些什么。 OK，这是要点之三。那么再看 要点之四。
- 要点四呢是符号位的处理。 也就是说，当把一个有符号的数跟一个无符号的数进行互相赋值的时候，将会怎么办呢？ 我们说啊这种情况也非常好处理。比方说， 这儿有一个有符号型的数，最高位是一个表示符号位。 那么这是一个无符号型的数，它的最高位呢表示数字位。那当它两个之间互相赋值的时候怎么办呢？很好办， 也是非常好处理的情况。**直接搬运，直接赋值，我才不管最高位 是数字位还是符号位呢。比方说，当我们把一个有符号的数赋给一个无符号的数的时候， 系统怎么做呢？就把这个有符号的数原封不动地搬给这个无符号的数。 然后原来有符号数的最高位由符号位变成了一个数字位。 毫无疑问这个数会变得大。那么当把一个无符号的数赋给一个有符号数的时候呢， 相反，这个最高位就由原来的数字位变成了一个符号位。** 下面我们通过一个例子来看一下。在这个程序里头我们看一下。 首先我们定义了一个无符号的数， unsigned int i，给它赋出值呢，0xAAAAAA。其实这个数呢就完全等价于 我们下面画的这个数，无符号的数。先把它打印一下，按照十进制的方式把这个数打印出来，先看一下。 那么我们看一下结果，结果就是这样一个数，这是一个无符号的数。 然后呢，我们把这个数赋给了一个有符号的数，signed int j， 把它赋给它。 赋给它以后呢，先用十六进制的方式把这个数打印出来。打印出来之后一看，全部都是A。 所以说赋值是没有问题的，是什么就是什么，直接搬过来。 然后呢，我们再把它按照十进制再打印一下。打印出来之后一看，是变成了一个负数，因为 这个数呢跟它是对应的，这就是一个负数，因为最高位呢是1。原来的最高位也是1，但是原来是一个数字位， 到这呢，变成了一个符号位。啊所以说这个数变成了一个负数。 这就是有符号数和无符号数之间的赋值处理。非常的简单，是什么就是什么。 那么我们对以上的几种情况啊做一个总结。
  - 第一个， 当赋值运算符两边的类型不同的时候， 要发生自动地类型转换。
  - 在类型转换的过程中，如果你把一个长数赋给了一个短数，那计算机会怎么做呢。它会截取长数的低位给这个短数。
  - 当把一个短数赋给一个长数的时候，这是最好处理的情况，计算机会自动地保证原来是什么数，赋值完之后还是什么数。 
  - 第4种情况，符号位的处理，就是把一个有符号的数跟一个无符号的数进行互相赋值的时候，怎么处理呢， 直接赋值，我才不管最高位是数字位，还是符号位。 那么先赋完值，赋完值之后，重新按照新的数据类型进行 解析和判断。
- 这是四种赋值的这个情况。 明确了这四种情况之后，我相信大家对赋值语句 应该会有一个大概的一个认识了。 
## 3. 赋值运算附加说明之表达式
- 那么关于赋值运算呢，我们还有几个附加说明。 那么第一项附加说明呢是关于表达式。 那么大家在之前呢已经碰到过很多个表达式了。
  - 那么什么是表达式呢？ 
    - 其实啊，表达式就是指程序中由 运算符、操作数和括号等等等等 所组成的这种计算式。我们平常见的计算式都属于表达式。 那么表达式呢是计算求值的一个基本的单位。 
        ```c++
        我们举几个例子，大家就明白了。
        比方说，那么a,b,c如果都是变量的话，a*b +c，那这就是一个典型的表达式。
        123<10， 这是由字面常量所组成的一个表达式。
        再看这个，字符a’ *3.14 f，这就表明了字符a是一个字符型的数，那么3.14f呢是一个float型的数。 
        啊然后呢，我们后面加了一个判例等于等于，这个大家在写f语句的时候碰到了，这个呢也是一个表达式。
        最后一个，a=b，这是一个 赋值语句。
        ```
    - **我们特别想要强调的就是这个，赋值语句也是一个表达式。在这儿，我需要特别说明一下，因为在好多语言里头啊，这个赋值语句并不算是一种运算符，但是在C语言里面， 赋值语句被算作了一种运算符。啊，所以说a=b 更毫无疑问的就是一个表达式了。那么这还需要强调的一点呢就是说， 所有的表达式都是有值的。因为表达式 就是用来计算求值的基本单位，所以说它肯定是要有值的。 我们需要强调的是呢，赋值语句其实也是有值的。**什么意思呢？看个例子我们就明白了。看这个程序。
    ```C++
    int mian()
    {
        int i = 0;
        cout << (i = 10) << endl;
        cout << (i = i + i) << endl;
        return 0;
    }
    ```
    - 在这个程序里头呢，有两个cout的语句。 每一句cout的语句都打印一个表达式，这个表达式是一个赋值表达式。 i是一个变量，啊，i=10，这是一个表达式。**我把它括起来，如果不括起来的话会发生语法错误。 我们把它括起来，以表示这是一个统一的一个表达式。** 那么，我们就要把这个表达式的值给它打印出来。那么第二行呢， i=i+i，也是一个表达式，我们把它的值打印出来 啊，那么计算的结果就是这样的。我们可以看到，i=10，这个表达式 所对应的值呢，就是10。那么i+i这个表达式所对应的值呢 就是20.由这个例子我们可以看出来两点，
      - 第一点 赋值语句所组成的表达式，也是有值的。那么赋值语句 所组成的表达式的值是什么呢。这值是多少呢 通过这个赋值符号所传送的这个值 表达式的这个值。比方说，i=10，那么通过赋值符号 那么，所以说整个表达式的值就是10 那么在这儿呢，i=i+i 最后这个表达式的值就是20 这是我们想强调的第一点。赋值语句 也是一种表达式。赋值语句也是有 返回值的。这是第一点。
      - 那么第二点，赋值表达式啊，不仅仅写成我们习惯看的样子。我们很习惯看这种 a=a+3。那么像这种的赋值 语句，还有另一种写法。就是可以把它写成这样子，a+=3是一种什么写法呢 这被称为复合赋值运算。什么叫复合赋值运算呢 就是指在赋值符号前面加上其他的运算符号，跟其他的运算符号一起，就组成了这样的一个语句。 这就是一个复合的赋值运算。 有同学可能问了，那这两种运算方式有什么不同啊， 啊，没什么不同。只是呢，左边的这一种是对右边的这一种的简写。那么同样，我们可以看到其它一些复合赋值运算，比如说 x*=y+8,那么这个表达式呢，实际上就相当于x= x*(y+8)。x%=3,实际上呢就相当于x =x%3。在我们这个课上呢，如果同学们愿意使用这个方式那也没有什么问题。你可以去用 不愿意使用这种方式呢，那完全可以使用这种方式。不对它的区别进行讨论 OK，这是关于复合表达式。这是第二点需要附加说明的 
      - 第三点需要附加说明的，关于连续的赋值运算。我们都知道在C程序里头 我们可以连续进行赋值运算，比方说，a=b=5 a=b=c=5都是连续的 赋值运算。在这儿呢我们需要强调一下，对于有多个运算符号包括赋值符号 所组成的这种长长的表达式而言。它既然包含了多个运算符号 那么就存在一个运算符号 优先级的问题。什么叫运算符号优先级啊 就像我们在写加减乘除的四则运算的时候 如果把加减乘除写在同一个四则运算 式子里头。我们会先算乘除再算加减 这就叫运算符优先级。就证明乘除的运算符优先级要高于加减 那么，对于同一个运算符，比方说在这个式子里头我们都是用的赋值运算 那么按照什么顺序去呢。对于赋值运算来言，采用右向左的 什么意思呢，就是优先算右边的， 然后再算左边的。 **比方说，对于这个式子，a=b=c=5 先去给c赋值附完值以后 因为c=5也是一个表达式， 这个表达式的值就等于5 然后呢再把这个5附给b。给b赋值以后，同样b等于5这又是一个表达式 再把这个表达式的值附给a。这就是这个的一个运算过程。需要注意的是 int a=b=c=5是会编译出错的** 所以说， 优先算右边的，从右边往左算。啊，所以说我们要由右而左的结合顺序。 那么在这儿还是要强调。那么在，嗯，定义变量的时候啊，我们不能采用这种方式， 这是不允许的，编译呢就出错了。这个大家要记得。 那么作为一个例子。我们来看一下这个表达式， 对于这个表达式而言呢，它其实同时出现了多种的运算符号。比方说， 赋值运算，加号，然后呢，括号。同时出现了好几种运算符号。 那么既然出现了多种运算符号，我们就必须要考虑运算符优先级的问题。 那我怎么知道这些运算符哪个优先级高呢。没关系， 几乎在任何一本C++语言或者C语言的书上， 它都会有一个运算符优先级的列表， 在里面清晰的列出了运算符的优先级。那么如果我们查一下的话我们就会发现其实 赋值运算的优先级是非常非常低的。所以在这个表达式里头，肯定我们要先算右边的这一系列的东西。如果对于这个表达式呢 按照我们的习惯我们都知道，要先算括号。因为括号的优先级比加号要高。 先算b=4，执行完之后b=4。再算c=6，执行完之后c=6。 那因为b=4这个表达式值是4。c=6这个表达式的值是6， 所以最后a呢，就等于4+6，a就变成了10。这就是这个表达式的一个 计算。在这还想说明的一点呢，就是说，有的时候啊，有一些程序里面 会把复合赋值运算和其他的运算符号啊写在一起，从而使情况变得比较复杂。 稍微举个例子 比方说对这个表达式，a+=a-=a * a，假设现在当前a的值是12，那么对于这样一个表达式，我们应该怎么去计算呢。 这个时候就要耐下心来慢慢来算。 不要着急。那既然对于这样一个表达式，我们都知道连续的赋值运算 是按照从右而左的结合顺序，也就是说我们要先算右边的 表达式。a-=a * a。这个我们就可以做一个转换。我们就知道它可以转换成a=a-a * a， 啊因为这时候a=12 所以呢，这个表达式呢实际上是12-12*12那么最后的结果呢 是负的132。有了这个132之后呢我们再去算右边的 这个复合赋值运算。那么a+=-132 其实就相当于a=a+(-132) 啊因为这个时候，a已经等于-132了。 所以说最终，这个表达式实行完毕以后，a呢，等于-264。这就是整个这个表达式的值。 啊我们是不是，是不是这样的表达式算起来非常的麻烦啊。 对不对，读起来也是很麻烦。所以，在这我要强调一点， 在我们的程序里，至少在这个课上面， 请你不要故意写这么复杂的表达式。为什么呢，因为它会影响程序的可读性， 像这样的表达式我们不如，明明白白把它写出来。这样对程序的可读性，有很好的提升。 在这儿稍微多说一句。有的同学在论坛里面讨论，为什么这么重视程序的可读性啊。这个很简单。 容易被别人读懂的程序，才能被长久的维护下去。你写出来的程序才具有生命力。 为了让你写的程序更具有生命力，请你把它写的易于被别人读懂。 OK。这是关于赋值运算，我们就将这么多。 
## 4. 算术运算符和算术表达式
- 赋值运算符之后呢我们再来看一下算术运算符。 算术运算符呢大概是我们最熟悉的一种运算符了。 那么，加，减，乘，除，啊唯一多了一个呢，就是一个百分号。 百分号呢，是一个模运算。这个我们已接触过了。 模运算就是求余运算。当然，它参与运算的个位呢必需是整数。 这是一个规则。比方说，7 % 4 = 3, 那么算术运算符呢我们不需要多说。啊，有几条需要注意的， 跟大家说一下。
  - 第一条需要注意的呢就是说， 整数运算，凡是有整数参与的运算， 那么我们的计算结果呢，仍然为整数。啊，这是一条非常非常常用， 但是很容易被忽略的计算规则。比方说，5 除於 3 ， 5 除以 3 的结果是多少呢，很多同学可能觉得都是 1.6666666，实际上不是。 在这儿，5 除以 3 的结果呢，就是 1 。啊它的小数部分就被忽略了 。 那，为什么呢? 因为啊， 在这个运算式里头只出现了整数。 整数跟整数进行运算，结果仍然是整数。 这是第一条，整数的运算，结果仍为整数。 
  - 再来第二条，实数的运算。结果呢，都是double 型。也就是说，在一个运算式里面， 只要出现了实数，比方说，5.3 除以 3 ， 或者是 5 除以 3.0 ，只要出现了浮点数或者是实数， 那么运算结果就一定是 double 型的。为什么呢? 不为什么，这是规则。 同时呢，我还要在这儿强调一点。那么既然 5 除以 3 ， 它结果呢，是一个 double 型的数。 double 型的数呢，它的表示精度就是有一个范围的。 啊，它不可能无限制的表示下去。ii, 5 除以 3 结果是 1.66666， 是一个无限循环小数，一个 double 型是 15 位精度， 到达了15 位精度的时候，那个 6 到底要舍7呢，还是要进位进上去， 乘以 1.6666666模位7 呢? 在这儿呢，需要强调一下。 舍入的这个方向啊，随编译器的不同，将会出现不同。 有可能出现 4 舍 5 入，有可能出现 5 舍 6 入， 都是有可能出现的。 那最好的办法就是你写一个式子，试一下。算术运算符的基本含义就是这样的。 
  - 那么关于算术运算符以及我们后面要讲到的关系运算符和逻辑运算符， 有一个非常非常非常重要的特性，是需要大家一定要清楚，并且要掌握的。 那就是关于运算符的优先级。
    ```C++
    优先级      操作符 
    1          () [] -> . :: ! ~ ++ -- 
    2          -(unary) *(dereference) &(address of) sizeof 
    3          ->* .*   
    4          * (multiply) / % 
    5          + - 
    6          << >> 
    7          < <= > >= 
    8          == != 
    9          &(bitwise AND) 
    10         ^ 
    11         | 
    12         && 
    13         || 
    14         ? :  
    15         = += -= etc. 
    16         , 
    ```
  - 比方说，算术运算符的优先级。 这个我们从小就知道了，先乘除，再加减。这就是指的优先级。 这当乘除或加减出现在一个表达式里的时候，肯定的我们 要先算乘除再算加减。啊，什么叫优先级，这个就叫优先级。 当然了，在这儿我们需要说乘除的优先级啊不如括号高，啊。 这个不需要我们说了，从小学我们就知道了。需要说的就是模运算。 模运算的优先级呢，跟乘除的优先级是平级的。 对于平级的运算符而言，计算顺序又是怎么样的呢? 啊先左，后右。啊，就是我们，跟我们小学学过的东西是一样的。 同一级别中，采取由左至右的结合方向。比方说，对于 a - b + c 那就相当于 a - b 括起来再加 c ，对于 a 模 b 乘 c 除 d ， 那就相当于先算 a 模 b, 然后再算 a 模 b 的结果乘以 c ， 最后把整个的结果除以 d ，这样的一个运算顺序。 从左至右的结合方向，先算左边，然后再算右边。 那看上去呢，好像是运算符的优先级是一件挺易解的事情，对嘛呵。 并不难。但是，当多个运算混合在一起的时候， 有的时候，运算符的优先级顺序啊，还真的不是那么好办。 如果这件事情再加上跟刚才我们讲到的， 不同数据类型的值混合在一起的时候，可能情况就会变得稍微复杂一些。 那么，我们来看一个例子。看这个表达式。 
    ```C++
    short    s;
    int      i;
    float    f;
    double   d;
    unsigned u;
    123%s + (i+'@') + i*u - f/d;
    ```
  - 123 模 s + i + @ 再 + i 乘以 u 减去 f 除以 d。 啊，这个表达式呢比较长一点。里面出现的类型呢， 也比较丰富。那就变量而言呢，其中，s 是 short 型， i 是 int 型， 那么 u 呢， 是 unsigned int 型， f 呢，是 float 型， d 是 double 型，类型都比较多了。 那对于这样的一个表达式，我们应该怎么去计算它呢? 啊，没关系。 在这儿呢，我借着这个例子，介绍给大家一种来求解表达式的值，和处理表达式中， 数据类型的转换关系的方法。 那么我把这种方法呢，取了一个名字，叫做剪刀法。什么意思呢? 就是说啊， 那么当你要求解一个表达式的时候啊，也就想象一下，啊， 在你的口袋里，装了一把剪刀，或者砍刀也行啦。那么当你面临一个表达式的时候呢， 就拿出这把剪刀，从整个表达式中， 运算符优先级最低的地方先剪断。 啊，比方说对于这个表达式，那谁的运算符的优先级最低啊 ？我们来分析一下。那么根据我们刚才 对算术运算符优先级的一个描述，括号最高，乘除，模次之， 那么加减是最低了。所以说我们要优先 从这些加减符号里面去选。然后呢，又有一条规则说， 当运算符优先级别是相同的时候，那么按照从左到右的方式来进行运算。 那么所以最左边的这个减号，它的运算符优先级是最低的。 于是我们第一刀从这儿把它砍断。 啊，基本说来，这是第一刀。第一刀砍完了之后呢， 这个式就断为了两节。第一节是这个，啊, 第二节是这个。 那么我们再去看，分别再去看这两节。那么当然我们先去分析前面这一节。前面这一节里头， 谁的优先级又是最低的呢 ？无疑这个 + 号又是最低的。于是第二刀在这里砍断。 我们接着砍下了这个第二刀。那么，又把这个式子断成了两节。这是一节，这是一节。 那么对于左边的这个表达式，无疑第三刀我们从这儿把它砍断。这是第三刀。砍到这个份上， 那么剩下的，就是只包含一个运算符的了。 那么到现在为止呢，我们就用三刀把这个长长的表达式砍成了一，二，三，四段。 把它砍成了四段。 那这四段怎么去计算呢? 很简单。 最后被砍下来的表达式要先进行运算。 比方说，这两个表达式，是最后被砍下来的。那么这两个表达式呢， 是最后被砍下来的，所以要先进行计算。我们来先分析一下。第一个表达式，123 模 s, 123 呢，如果没有特别注释的话，它应该是 int 型的。s 呢， 是 short 类型的。 int 类型的和 short 类型的进行计算。那么计算结果是什么呢 ？ 在这儿我先告诉你，如果一个表达式里面出现了short 类型， 那么所有的 short 类型必需要先转换成 int 类型，然后再去进行运算。 所以说 123 模 s 的计算结果一定是 int 型的。 我们再来看右边，i + @, @ 号呢是一个字符号。我们都知道字符的 存储方式跟整数是一样的，所以它们两个是可以进行混合运算的。 那么当字符跟一个整数进行运算的时候，那这个时候， 我也可以告诉你，那要把字符型转换成 int 型，然后才能进行运算。 所以说，它们两个的计算结果也是 int 型的。 啊，这是第二。当它们两个计算完毕以后呢，啊我们再考虑第二刀 砍下来的表达式，啊，要进行计算。也就是它们两个，是第二刀砍下来的。 这儿还有一个，也是第二刀砍下来的。我们先来看它们的运算结果。 int 型跟 int 型进行运算，毫无疑问，结果是 int 型。我们再来看， i 乘於 u ， 因为 u 呢， 是 unsigned 的型，i 是 int 型， 那么我也告诉你， 如果一个 int 型的数跟一个 unsigned 型的数进行运算的话，那么无论这个 int 型的数 是正数还是负数，都要先转换成 unsigned 的类型， 然后再进行运算。 所以说它们的运算结果也是 unsigned 的类型， 啊也是这个类型。 那么现在呢，那如果把这个表达式 跟它放在一起进行运算的话，那它们两个的运算结果是什么类型呢 ？ 那么我们刚刚介绍过，它的结果应该是 unsigned 的类型。 Ok, 那么第二刀砍下来的表达式我们又计算完毕了。 再看第一刀砍下来的两个表达式， 那么第一刀砍下来的两个表达式现在呢就剩了一个了。啊就剩这个了。因为左边已经计算完毕了。 那么右边的这个表达式，一个 float 的型的数跟 一个 double 型的数进行运算，这个时候我也告诉你，那么这个结果呢，应该是 double 型, double 型。 Ok, 那现在呢，要把第一刀砍下来的两个数值合起来再进行计算。 也就是这个 unsigned 的型要跟这个 double 型进行计算了。 那么这个计算结果呢，我也可以告诉你，它的计算结果只能是double型。 OK，那么整个这个式子呢就计算完毕了。这就是 这个式子的计算过程。那么通过这个例子呀， 我们可以看到，当我们碰到一个长长的表达式的时候， 我们可以用这个剪刀法把它剪成一段一段的。 然后呢，按照剪下来的逆序，把这一段 一段的全部都计算好。最后再去获得整个表达式的值。 那么我希望呢，大家能掌握这种方法。 那有的同学可能说了，掌握这个方法呀没有问题，
  - 但是呢，关于在一个表达式里头进行计算的时候， 数据类型的转换方式，我仍然是不清楚呀。 那怎么办呢？别担心，我这给一个图。这个图呢就表示了 计算过程中那么各种数据类型之间的转换方向。 这个图这么来看，那么在这个图上呢，有一些箭头 是纵向的，那么有一些箭头呢是横向的。 有什么区别呢？它的含义是这样的。 我们先来解释一下横向的箭头。看这，那么char型和short型都有一个箭头指向了int型。 它表示什么含义呢？它的含义是这样的。 **在一个表达式中，只要出现了 一个char型或者是short型的量， 无论是变量还是常量， 那么不管char型或者short型的这个量 要跟什么样的其他的量进行运算， 那么我们都先把这个量啊转换成一个int型的量， 然后再参与其他的运算**。这就是横向箭头的 意思，也就是说，只要是在一个表达式里面出现了char型或者short型， 那么要进行运算的话，就要先把这个char型或者short型的数 转换成int型，然后再进行运算。 也就。这个转换是必定要进行的。比方说，在我们刚才举的这个 例子里头，那么出现了short型，也出现了char型。 那么无论这个short型的数要跟一个什么样的数进行计算， 我都先把这个short型的数转换成一个int型的数。 啊也无论这个char型的数要跟什么类型的数进行计算，我都先把这个char型的数转换成int型。 然后再跟其他的类型进行计算。**那么相同的情况呢， 还有float型。也就是说只要一个表达式里面出现了float型， 不管这个float型要跟什么其他的类型进行计算，我都先把这个float型转换成double型**。然后我们再说别的。这是一定要进行这个转换。 这是横向箭头的意思。再看纵向的这个箭头。**比方说int型到 unsigned型，它的含义是这样的，如果一个int型的数 跟一个unsigned型的数进行运算的话，那么 先把这个int型的数转换成unsigned型的数。 然后再进行运算。当然结果也是一个unsigned型的数。 啊这是它们的含义。那么第二个，当unsigned型的数跟一个unsigned long型的数 进行运算的话，那么先要把unsigned型的数转换成unsigned long int型的数。然后再进行运算。 这是这个含义。那有的同学要问了，为什么不在这直接写unsigned long int型呢？ 因为这个式子里面还有一层含义，那就是说当int型的数跟long型的数 啊一起运算的话，它们两个的类型都是signed的类型，都是 有符号的数，那么就把int型的数转换成long int型的数， 那么再进行运算**。也就是说啊，这个箭头只表示一个级别。 也就是说，上面的数的级别要更高一些，底下的数呢级别要稍微低一些。 **那么最高的级别就是double型。我们可以看到在 整整个这个式子里边所有的箭头都指向了double型。 那么由此我们就可以断定，只要一个表达式里头出现了 double型，那么整个这个表达式计算的值一定是一个double型的数**。这就是数据类型转换的方向。那么， 这个转换的方向呢也是非常重要的一点，要求呢大家掌握，而且呢， 在我们接下来的课里头啊我们会反复地提到这个，也会反复地跟大家一起来进行训练的。 所以说呢，一时半会听不懂没关系，我们还会反复提到的。OK，那么 关于算术运算符啊，我们讲差不多了，只剩下最后一点点。 这一点点呢还挺麻烦，这一点点就是加加 
## 5. 算数运算符之自增、自减运算
- ok，那么关于算数运算符啊，我们讲差不多了。 只剩下最后一点点。这一点点呢还挺麻烦。 这一点点就是加加减减运算， 也就是自增自减运算。那当然对这个运算呢， 并不陌生。比方说，i加加这个词， 经常出现在哪里啊？ 出现在for循环里面，对吧。我们用它来对i进行i自加的运算， 这个运算我们讲过，i加加就等于i加1.这两个， 这两个的意思是一样的。那么，除了i加加， 运算之外啊，在c语言里面还有一种运算叫加加i。 加加i，也是对i进行加1的运算. 那有同学就问了，它也是对i进行加1的运算，它也是对i进行加1的运算， 那两者之间有什么区别呢？区别在这里，加加i 加加号如果写在前面的话，那么表示 在使用i之前，先把i的值， 加一下， 加1或者是减1，如果是减减的话那就是减1. i加加的意思呢，是说在使用i之后， 再把i的值再加1或者减1。 有同学可能听不懂，什么叫使用之前，什么叫使用之后啊？ 我给你举个例子你就明白了。比方说啊，我们把这个i比作一本书， 这本书呢，是我们从图书馆给它借来的。所谓加加i， 也就是在使用i之前进行加1是指的什么意思呢？ 在你借出这本书之前，你还没看呢，你先给这本书 包一个书皮，给它加上一页，这是加加i的 一个运算。那么i加加的运算是什么意思呢？ 是说当你把这本书借出来，并且你读完了以后， 你准备要把它还回图书馆去之前，你给它包了一个 书皮。这就是i加加的一个运算。 这是，这两个不同的运算。 那有的同学说，这样说啊，我还是不明白，听不懂。ok，没关系，我们来举个例子， 你就清楚了。例如，i的值啊，现在是3。在i是3的情况下， 我们呢，做四个运算。 我们看看，分别做完这四个运算，i的值，j的值，以及打印出来的值分别是多少。 比方说，当i等于3的时候，我现在做一个运算， j等于加加i。 那么当i等于3的时候，做完这个运算，请问j的值等于多少？i的值等于多少？ 毫无疑问，在这个式子里头啊，我们做了一次加加i，所以说做完 这个式子以后，i的值等于多少？i的值一定等于4.那么j的值等于多少呢？ 想想我们刚才说的话。加加i，加加i相当于 你把i借出来，先给它加1，先包书皮， 然后再去用，再去读这本书，再去用这个i。 所谓用这个i，就是用i给j进行赋值，也就是是说，当j 获得这个值的时候，是i加加以后得到的那个结果。也就是说，包了书皮的那个i。 也就是说，这个时候j必定等于4。那么我们相反再看一个结果， 如果i等于3，现在我们做的运算是j等于i加加，加加跑到后面去了。 也就意味着，我们拿出i了以后，我们先要去读它，先要去做事情， 先拿着这个i给j， 先把i给j，然后我们再给i包书皮加1， 对不对？所以说，运算完了之后i等于多少啊？ i等于4。j等于多少呢？j等于3。因为i在没包书皮的时候，就已经 给了j了。 我们再往下看，当i等于 3的时候，我打印一个值，叫做cout加加i， 我相信这次，大家应该是比较明确的了。 我先拿出i来，一借出这本书来，我就先给它包一个书皮，然后 再去用这本书，所以说这个地方应该打印等于多少啊？3加1先等于4，先把它打出来。 一定是这样的。那再看后面这个，当i 等于3的时候，如果执行cout i加加，它会打印出多少来呢？ 先把i拿过来先用，用完了以后再去包书皮。用， 所谓的用就是把它打印出来，所以这个地方会打印出3来。打印完了之后，这个i等于多少啊？ i等于4，这就是i加加和加加i的区别。 那么这个例子呢还是比较，相对比较简单的。 我们再来看一个稍微难一点的例子。当然，我先说明， 对于i加加和加加i，我们在考试里面，绝对不难为，拿这个东西 去难为大家。我们没有针对这个东西的考题，但是 这个事情大家应该掌握。 可是呢，又不需要彻底的掌握。为什么呢？后面我再去解释。 那么，这几个例子，还是需要大家掌握的。我们再来看一个例子，看这个例子。还是 i当前的值假设是3，请问 下面的几个执行结果。现在呢，稍微加了一点难度。 第一句，叫cout 减i加加，打印这句话。看到这句话的时候啊，我们立刻要有一个警惕性， 在这句话里面，虽然非常非常短， 但是出现了两个运算符。一个是负号， 符号运算符；一个是加加号，加加运算符。为了搞清楚 到最后这个结果到底是什么，我们必须要首先清楚的一件事情就是， 这两个运算符好，哪个运算符号是先进行计算， 也就是说，先解决运算符优先级的问题。 当看到这个式子的话，大家第一反应最好是 找一本书，先去查一下运算符优先级， 到底这个它的优先级哪个是高的，哪个是低的。 查一下c加加的运算符我们就知道，对于放在后面 的，也就是说所谓的后置的加加号， 它的运算符优先级，它要高于负号。 所以说，别看这个符，这个表达式非常的简单，它包含了 两个运算符号，而且这两个运算符号优先级不同， 这就像有两个指挥官一样，有两个指挥官在这，谁的优先级高我们先听谁的。 有一个指挥官叫做加加号，另一个指挥官叫做负号，毫无疑问我们要先听加加号的。 先听加加号，于是呢，加加号这个指挥官就下命令了，说 你们使用完i的话，你再对i进行加1， 这就是加加号这个指挥官所下达的命令。他说你先去用，用完了 给我加1，ok。我们拿了这个命令之后， 再去找负号。负号呢说ok，那我现在 就是要对它进行，原来是正的，变成负的，原来是3，我把它变成 负3.然后打印输出。打印输出用完了没？用完了。 这个时候，最开始加加号给我们的那个命令，我们应该去执行了。 等用完了以后，把这个i再进行加加运算，所以说整个这个式子会打印出来多少？会打印出来负3. 同时，i的值会变成4.有的同学说，啊呀李老师不对呀，人家是i加加呀。 i加加是，优先级是高的， 你怎么先，按照负号先算。算完了之后再给它加加呀。 没错，它的优先级的确是高了，但是 它是我们的大领导啊，我们的大领导给的命令是什么呢？ 先拿去用，用完之后回来再加。那我们听不听他的？ 当然要听。这就是整个这个式子的含义。 那么再看一下，当i等于3的情况下，如果我们打印的是负号，然后加加i， 如果是这样的话，应该怎么办呢？我们迅速的再去查一下 运算符优先级。经查，我们可以看到 减号和加加号，实际上它们的运算符是 同级的，优先级是相同的。但是，类似于这样 同级的运算符来说，是遵循右结合，也就是说 要先算右边，然后再算减号。 是这样的一个计算顺序，所以说对于式子而言，我们仍然要先算 加加号，然后再算这个负号。那么ok了，这个比较容易。 i等于3的时候，我先算加加号，那，那意味着什么啊？我一拿出i来， 我就先对i进行加1的运算。对吧，一借出i来，我先给它包书皮， ok，那我就，i就变成了4， 对不对？所以说，如果这个式子打印出来的话，将打印负4，最终i的结果呢，也等于4. 这是这个结果。ok，我们继续往下看。 第三个式子。第三个式子啊，是我们在， 在跟大家讨论的过程中，同学们赠给我的一个例子。 说，李老师你不是说，那这个里头，是先t加加的吗？ 我现在就非要让它这么来做一下， 先把负i 给它括起来，然后再算加加， 可以吗？我的回答是，不可以。为什么呢，编译错误。 为什么会编译错误呢？因为加加号只能 用于变量，不能用于表达式。什么意思呢？对于一个变量， 比方说i，我们写i加加，或者是加加i， 是可以的。这就意味着这个加加号啊，我们给它用的变量i身上，这是没有任何问题的。 但是，不能把这个加加号， 或者前置，或者后置，任何一个加加号都不能用到表达式身上。 你比方说我们来写这样一个表达式，i加j，括起来，加加， 这个呢，编译就是错的，为什么编译错的？因为加加号 不能用于表达式，i加j是一个表达式。 同理同理，在这，用符号括起来的这个负i， 仍然是一个表达式，我们不能把这个加加号用在一个表达式身上， 这就错了。ok，所以说第三个，编译错误。 那有的又有人问，第四个呢？我如果这么写呢，加加i加加。 ok，这个式，这个式子，在某些语言里头， 是成立的。首先说，这个式子，cout加加i加加，在某些语言里头成立。 but在c语言里头，它不成立。 原因是什么呢？原因跟上面一样，加加号不能用于表达式。 我们来分析一下这个句子，加加i加加这里头，别看它简单， 也是两个运算符，一个运算符是前置的加加号，一个运算符是后置的加加号。 那么你去查一下运算符的优先及顺序，我们就会发现 后置的加加号要先于，优先级要高于前置的加加号。 所以对于这样一个表达式而言，要先算i加加，然后再把这个结果， 再进行加加运算。如果能计算的话，因为按照这种顺序去算，但是 算i加加没问题，但是如果你想对i加加进行 加加的运算，那就错了，因为加加号不能用于 后面是一个表达式，不能用于后面的表达式。 这就是所谓的原因。 那么说到这呢，我觉得可能我们对于加加号啊，理解就更深入了一层。 那么我们做一个总结，其实在这，没有太多的东西，做一个总结。 加加，或者是减减， 只能用于变量，而不能用于表达式。接下来呢我们再做一点 说明。关于加加i或者是i加加啊，我们可以写出非常非常复杂的表达式来， 甚至于呢，对于某些表达式而言，在不同的编译系底下，会有不同的计算结果，所以说我们没办法一概而论。 但是呢，有一些常用的情况，我们必须cover到。 必须覆盖了，我们再举一个例子，也是一个稍微常用一些的 情况。ok，那么关于自增自减运算，我们 再多介绍一点，那就是，当把自增自减的运算，跟输出放在 一起的时候，那么这种情况呢，是大家需要特别注意的，所以说呢，在这呢，我们再 讲解一下。
    ```C++
    int main()
    {
        int a=0,b=0,c=2,d=0,e=2,f=2;
        cout << a << " " << a++ << " " << endl;
        cout << ++b <<" " << b++ << " " << endl;
        cout << c << " " << (c++) + (++c) << " " << endl;
        cout << (d=f++) + (e=f) << endl;
        cout << f << " " << d << " " << e << endl;
        return 0;
    }
    ```
- 我们可以看这个程序，在这个程序里头啊，我定义了6个变量，分别是a， b，c，d，e，f，然后呢，底下 我以不同的方式，那这几个变量啊，打印出来，看看打印的结果 会是怎样的，我们来分析一下。第一个我先打印a， 先打印a，然后空格， a加加，空格。我们先来想象一下第一句输出的结果会是怎样的。 那么很多同学就说，因为a的初始值是0嘛，而且，这里写的是a加加，那就意味着要 用完了a之后，再加1。那所以说，在这个地方，打印出来的结果应该是00。 然后打印完了之后，a的值应该是1，应该是这样的一个结果。 是吗？我们来看一下它的输出结果。 并不是这样的，它的输出结果是10。 为什么是这样的一个结果呢？ 那么我们来分析一下这条语句，看它的结果为什么是 10呢？其实有一条规则特别要告诉大家。 那么在告诉大家之前呢，我先要强调一下，可能在不同的编译系底下，会有不同的输出。 那么在visual c加加底下，是这样的。对于一条输出语句，如果这条输出语句 里面包含了多个表达式，那么程序，在打印这些表达式的值的时候， 它是最优先计算最右侧表达式的值， 然后再计算左侧表达式的值。也就是说， 它是按照一条从右往左的顺序， 来分别计算这些表达式的值的。 在一个输出里头，从右往左的顺序， 这是在VC下面，大家一定一定要注意这件事情。 那么既然知道了这个，我们就好计算了。我们看一下， 既然是从右往左，那么一开始a的值是0，所以在这，应该打印输出0. 然后打印完了以后， 立刻a的值就进行加加的处理， 所以说，a的值等到再去打印这个表达式的值的时候， 那么a的值是多少啊？a的值是1. 所以呢，会在这打印1，会在这打印0. 所以会出现这样的结果。 ok知道了这个之后啊，我们也就好办了，再去看第二个。b的值一开始也等于0， 然后呢我们先去计算它，b加加，那么在这毫无疑问，也会打印0. 打印完了0以后呢，b加加起作用了，因为是先用再加加。 加加完了之后，b变成1，也就是说，b到这的时候先变成1，因为呢， 在这又出现了一个加加，而且是先加加。那就意味着， 我在用之前就要对这个b进行加加。于是，这个地方，b就变成了2. 2，所以说，第二行会打印输出20. 我们再来看第三行。第三行，它会首先计算这个表达式的值，这个表达式稍微有点复杂， 在这个表达式里头呢，既出现了c加加，又出现了加加c，还出现了一个加号。 那这个怎么计算呢？那么，在vc底下，它是 这样来计算的。既然这个表达式里面出现了加加c， 那么我首先把c取出来的时候，我就首先完成这个加加c的运算。 因为这是一整个表达式，在这个表达式里头只要出现了c，加加c， 出现了几个，我就先给c加几次，也就是说，c一开始 是2，那么我就先对这个c进行一个加加的运算， 然后呢，把这个3，代入到这个表达式里头，让它进行 计算。c加加，因为这个加加出现在后面，所以要等到用完了 才能进行加加。所以整个表达式是这样来进行计算的。3，这个地方也是3. 3加3等于6，这个地方输出6。 输出完了以后，c的值后再加1，c的值会变成4. 所以说，c会在这输出4. 所以整个这条语句的输出是4， 6，这是在visual c加加下面的输出。是这样的，这是第三条语句。 我们再看第四条语句。 那么在这个表达式里头呢，既出现了负值，又出现了加号。我们来分析一下。 那么面对这样一个表达式呢，我们会先计算这部分的值，然后呢我们计算 后面这部分的值，最后我们计算这个加号加起来的值。这是这个 计算顺序。那么在计算开始的时候呢， f等于2，d等于f加加。那既然这个加号是在后面， 所以说，先赋值，再加加，那么d呢，就被赋值为2，d被赋值为2。 那么接下来，这个f是要等到，这个加号算完了以后再加加呢， 还是计算完这个小括号里面的， 赋完值以后就加加呢？ 在vc里面，它要等到这个加号算完以后，统一再进行 后置的加加的运算。所以说在这， 所以在这，那个f呢，赋值的时候，这个f仍然是2， 仍然是2，给e赋的值呢，也是2， 也是2.所以说，整个这个表达式的值是多少啊？ 既然赋的值都是2，所以整个这个表达式的值是4. 那么在这打印4.那么再往下看，打印完4以后呢，我们再把f打印出来。 当然毫无疑问，因为在这f呢，原来是2，经过了一次加加，这个地方会打印出3. 然后呢，d的值，刚才我们分析过，它依然是等于2的。 e的值呢，也等于2. 这就是最终的一个结果，它会打印出10，20， 46，4，322.我们来看一下这个结果是不是这样的。 它确实是这样的。10，20，46，4，322. 这就是当把加加，减减，也就是自增自减运算跟输出放在一起的时候， 所遇到的这个情况。 当然我们还可以构造更复杂的 加加或者减减的运算。但是呢，在这我们就不再作探讨了。 那么，如果有的同学对这个问题非常的 感兴趣，那怎么办呢？我还真的需要提示你一点。 为什么呢？因为关于加加减减的运算， 资料不是特别好找。网上呢，众说纷纭。 **其实有一个非常非常好的办法去判定， 这个运算到底是怎么进行的。 那么就是，你把你想要检测的加加 或者减减的运算，写成一个表达式，放在程序里面， 然后对这个程序插入一个断点，进行debug， 在debug的过程中，你可以看到这个程序反编译的结果。 那么在程序反编译的这个结果里面， 那么用汇编语言清清楚楚的写出了 每一个表达式的计算顺序。通过这种方式， 你就可以清楚的了解，你所使用的编译器， 到底是如何处理加加，或者减减运算的了**。 当然，我绝对不鼓励所有的同学都去这么做。只是对 那些有兴趣又有一定基础的同学，你可以采取这个办法。 ok，关于算术运算符，我们就讲这么多。 
## 6. 关系运算符
- 那么在说完算数运算以后啊，我们再来看 一下，另一种很常用的运算，啊，就是关系运算符 那么对于关系运算符呢，大家并不陌生，啊，我们一直 在用，其实，啊，比方说，最常见的关系运算符，小于，大于，小于等于，大于等于， 等于和不等于，这都是非常，非常常用的一些，啊，运算符，那么在这呢，想强调两点，第一点， 关系运算符的优先级，啊，虽然都是关系 运算符，但它们的优先级是不同的，那么，小于，小于等于，大于和大于 等于，它的运算符的优先级要高于等于和不等于，所以当它们出现在同一个表达式里头的时候， 啊，我们一定要注意，运算符优先级的顺序，啊，这个是一个特别特别容易犯错误的 一点，那么第二点呢，我们还是特别 要强调笔误的问题，对于等于等于， 啊，这是一个双=，它是用来做相等判定的，千万 千万不要把它写成赋值语句，每年无论在考试里头，还是在实际编写程序的过程中， 我都会发现，有些同学不经意犯这种错误，而且，像这样的错误 非常的难以调试，啊，因为，程序不会报任何的错，你只是看到你的结果 是不对的，这样的错误，非常非常难以检查，所以说，当 我们在使用判等符号的时候，一定要注意不要写错， 啊，这是需要注意的两点，那么关系运算 呢，跟，啊，其他的运算符号一样，也可以组成关系运算， 表达式，关系运算表达式啊，都是有确切的值的，而且，关系运算表达式的 值，只能有两个，要么真要么假，啊，比方说，有两个变量 A=3，B=4，A>B,就是一个关系运算表达式，那么它的值呢，自然就是0 啊，因为A不可能大于4，A不等于B， 啊，那么它的值呢，就是1，啊，因为它确实是成立的，A不等 于B，A等于等于B，那这就是一个判等 了，啊，那它的值呢，啊，就是0，啊，就表示假，因为它 不成立，那么，每一个关系运算表达式，它的值都是，或真或假，只有 两个值，成立的时候为真，啊，不成立的时候为假，也就是说，成立的时候返回1，不会，不成立的 时候，返回0，这是关于关系运算表达式 的值，那么还有一个想说明的就是，当我们把 关系运算跟其他的运算放在一起的 时候，那么关系运算符跟其他的运算符之间，又有一个优先级的 关系，那么关系运算符同我们刚刚所讲过的那两种运算 符的优先级顺序就是这样的，**算数运算符要高于关系运算符，同时呢，它们要高于赋值运算符**，啊，既然有这样的一个关系，所以当他们一起运算的时候，我们就要小心，啊，比方说 举几个例子，啊，我们来看几个表达式 第一个表达式，A+2%3 * 4>5/6-7 那对于这样一个表达式，我们应该怎么去计算， 还记得，我教给大家的那个办法吗？ 剪刀法，啊，或者是砍刀法，啊，对于这样的一个表达式 你是，你腰里面一定有 一把宝刀，拿出这把刀来，冲着运算符优先级最低的 运算符号先砍去，比方，在这个里面，考察一下，运算符优先级别最低 那就是，大于号，所以说，我们先在这，把这个式子断开，那么先去求解左边的值 然后再去求解右边的值，那它左边呢，是一个四则 运算，右边也是一个四则运算，我们就不再继续计算了，ok，再看第三个， X=1+2%3*4>5/6-7==8， 这是一个好长好长的表达式， 对不对，啊，那么对于这样一个表达式，我们应该怎么去算？一样的算法 我们抽出我们的宝刀，先从哪砍啊，从运算符最低的， 哪啊？赋值运算，在这砍断，那么，根据赋值运算的运算规则，我们要先求解这边的式子， 对吧，那么，要求解这个式子，我们第二刀从哪砍啊？根据刚才 我们讲过的，那么等号等号，这儿的优先级是最低的，在这砍断， 砍断以后呢，先求解这边，那么对于这个表达式呢，我们再在哪砍断？在这砍断， 啊，砍断以后呢，先求解这边，啊，这又是一四则运算的，我们就不再去算了，啊，算完它 算完它，再算它，算完 它以后，再算它，算完它以后，再把这个值赋给X， 这就是整个这个式子的运算过程，我们再来看一下最后一个表达式 啊，对于这样一个表达式，请问，这个表达式的值是多少啊？ 千万千万要小心，对于这样一个表达式，我们第一刀在哪 砍，在中间砍，在中间砍，砍开以后呢， 1大于2,1大于2吗？不大于2，所以返回值是0， 那么3>4,也不成立，所以返回值也是0，到最后，两个0求出来以后 再去判等，相等吗？相等，所以最终这个表达式的值是1， 之所以算一下这个表达式，就是很容易犯错误，所以说，我们在这算一下 ok，那么关于关系运算符啊，我们就讲这么多， 啊，因为这个呢，大家都比较熟悉，只要注意运算符优先级的问题 啊，就没有什么其他的大问题了，这是关系运算符， 那么说完了关系运算符呢，我们再来看一下，逻辑运算符 
## 7. 逻辑运算符
- 那么说了关系运算符呢，我们来看一下逻辑运算符。 逻辑运算符呢，我们既陌生，又熟悉。 之所以陌生，是因为真的我们以前没用过。在程序里头我们也没去使用它。 那之所以它熟悉呢，是因为我们在讲计算机基本原理， 也就是我们这一课的第一讲的时候，其实我们已经提到了。 照我们讲的布尔运算的时候。其实呢，这里的 逻辑运算符跟那里的布尔运算，它的意义是相同的。 那么在 C 里面拥有三种最基本的逻辑运算。 哪三种啊 ？ 与，或， 非。它的基本含义，我们其实已经讲过了。如果是与的话，就相当于两个开关给串联起来。 必须它们都闭合以及两个值都为真，那么， A 与 B 的值才有可能是真，那这个灯才有可能亮起来。 如果是 ‘或‘ 运算呢，那 A 与 B 的值只要有一个是真的， 那么这个灯就亮了，那么最后这个表达式的值也就为真了。 如果是 ‘非‘ 运算呢那更好办了，如果 A 是假，那么 非A 就是真。 如果 A 是真， 非 A 就是假。那么这个是基本的逻辑运算的含义。 好我们不需要再作更多的解释了。 那么当然了，由逻辑运算就可以组成逻辑运算表达式。 那个逻辑运算表达式也是有值的。而且呢，逻辑运算表达式的值也是只有两个。 要么是真，要么是假。啊，我们来看几个例子。 比方说，如果 a = 4， 我们来计算逻辑运算表达式 非 a 的值。 那非 a 式的话， 因为 a = 4 ， 这是一个非 0 的值。 那非 0 呢，就是真。所以 a 是真，所以非 a 那是假。也就是非 a 的值应该是 0。 啊这样特别小心。 那如果，第二个，如果 a = 4， b = 5 ， 那么 a 与 b 的值是多少呢? 啊，因为 a 和 b 都是非 0 的， 所以说都是真。所以说 a 与 b 的值应该是 1。 那么，第3个， 若 a = 4. b = 5, 那么 a 或 b 的值应该是多少呢 ？ 因为 a 和 b 都是非 0, 所以 a 或 b 的值也是 1。 a = 4, b = 5, 那么， 非 a 或 b 的值应该是多少呢? 当然， 非 a 应该是 0， 但是 b 的值应该是 1。 所以， 非 a 或 b 的值应该是 1。那有的同学可能问了， 啊，那么在这里头也出现了两个运算符啊。那么，一个运算符是非 a, 是这个非， 另一个运算符是 ‘或’ ， 那你这个算法就是先算了非a， 然后再算 ‘或‘， Ok, 是这样的，待会儿我们再说。再看底下这个表达式。 4 与 0 或 2， 啊它的值， 这个值呢， 你看也是 1。为什么呢， 由或运算， 然后呢，或运算后面， 2 是个非0 的值， 所以说那值一定是 1。 为什么要这么算呢，我们往后看，就知道了。 看一下，逻辑运算符的优先级。 首先我们看一下几个逻辑运算符本身的优先级。 其实，别看逻辑运算符只有 3 个，但它们之间仍然有很强的优先级顺序。 那么，逻辑运算符之间是 ‘非‘ 运算优先级最高， 其次是 ‘与‘ 运算， 再次是 ‘或‘ 运算。 所以啊，它们三个有着不同的运算符优先级。而且呢， ‘非‘ 的运算优先级是最高的。 Ok, 我们看几个例子,我们来体验一下。 第一个例子， 非 a 与 b 或 c, 那这个式呢应该怎么算 ？ 那当然先算 非 a, 啊然后再算 非 a 与 b, 然后再算 ‘或’ c。应该这么算。 这是最后一个式子，最后一个式子啊，比较复杂。 那么出现的运算符非常非常多。除了逻辑运算之外， 还有关系运算，还有算术运算。那这怎么办? 这样的话，我们就必须要搞清楚 逻辑运算，和算术运算，关系运算，以及赋值运算， 它们之间的运算符优先， 优先级的关系。 我这儿呢有张图，它表示它们之间的关系。 啊，由高到低，排序是这样的。 那最高是 ‘非‘，然后呢，是算术运算符，然后呢，是关系运算符， 然后，是 ‘与‘ 和 ‘或‘， 而且‘与‘ 和 ‘或‘ 的优先级 还是不同的。最后才是赋值语句。 看上去稍微有点乱。但是，其实在用的时候你会发现， 它呀，非常符合我们日常的思维的逻辑判断的方式。 我们先看一个简单的例子。啊，比方说， a > b 与上 x > y ， 这个怎么算 ？ 是不它就相当于 a > b 与上 xy， 因为我们要先算关系运算。 最后再算这个 ‘与‘ 运算。 再看下面，也一样的， a = = b, x = = y, 那么也是相当于 a = b 括起来，或上 x = = y, 第三个， 非 a 或 a > b, 那这个也是一样， 非 a 是一边，a > b 是一边,然后再计算。 通过这个我们就可以感受出来，在我们 对运算符优先级还掌握得不是特别好的情况下，我们有一个很好的办法, 来确保我们写的不会错。那怎么办 ？ 加括号呀。那么在你不是特别确定的情况下， 就可以通过加括号的方法来解决这个问题。 Ok, 那么，看完了简单的呢，我们再看一道稍微难一点的。看这个情形。 那在这个情形里头呢，首先第一呢，两个变量，a = 0, b = 0, 然后呢，给出来了一个 长长的表达式。 啊这个表达式可是够长的。对于这样的一个表达式， 我们先来看应该怎么去计算，然后我们再来分析它的结果。 去看这样的一个表达式，这个表达式应该怎么去计算啊 ?
```C++
#include <iostream>
using namespace::std;
int main()
{
    int a=0,b=0;
    a=5>3&&2||8<4-(b=!0);
    cout<<a<<" "<<b;
    return 0;
}
```
根据我教给大家的这个砍刀法， 再长的表达式我们都不怕。我们只要搞清楚了运算符的优先级顺序，就好办了。 啊，对这样的一个表达式，应该怎么算 ？很简单，第一刀，肯定是要在赋值语句那儿砍，砍开， 然后呢，先算右边。 那么第二刀，啊要，砍了赋值语句了我们就要砍逻辑运算符了。 那么逻辑运算符自身又有它的运算符优先顺序，我们知道， ‘或‘ 运算的运算符优先顺序是最低的，所以说第二刀砍在这里。 又砍成了两边，那先算这一边。 算这一边呢，又是一个子的表达式，那这个表达式呢， 当然毫无疑问，从这儿，从与运算砍开。 然后呢，再去算先算这边，这边就不用砍了。5 > 3 ， 得 1，然后呢，与 2，1与2 的结果肯定是 1， 对不对? 所以说，我们知道，那么这个或运算， 这一边，或运算的整个这一边的结果都是 1。 当两个数作 ‘或‘ 运算，并且其中有一个的已经是 1 了，对不对？ 那我们还用再继续算后面的吗 ？还需要算这边的吗 ？ 不需要了，我们一下子就可以知道这个值了。 所以说，整个这个表达式的值，算下来是 1。那 a 的值也是 1。 那么在这儿需要特别搞清楚的是 b 的值。 在刚才的计算过程中，我们仍没去算的时候啊， 啊，是这样的，因为 ‘或‘ 运算这边的值已经是 1 了，这儿呢，又是一个 ‘或‘ 运算，所以说，整个这边的值我们是不需要再去算的，那是不需要再去算的。 那么程序会去算吗 ？啊， 那我可以告诉你，这个地方，程序也不会去算。 啊，那么 b 呢，打印出来的结果 b = 0, 不会去赋这个值的。 啊，在这儿呢，我们就特别来说一下，强调一下， 逻辑运算符的取舍。**在 C语言里头啊，其实有这样一个规定， 运算逻辑表达式求解的过程中， 并不总是执行所有的运算的。 只有在必需执行下一个逻辑运算才能求出表达式的解的时候， 才会去执行这些运算符。 否则的话，这些运算符我根本就不需要再去做求解**。 我们看几个例子。啊，比方说，对于 本来是 a 与 b 与 c, 啊因为它们之间是 ‘与‘ 的关系， 所以说，如果有一个， 比方说 a 的值，如果有一个出现了 0, 那么这个表达式肯定后面就不需要再算了 也就是说只有a为非零的时候，a为真的时候 才需要再继续判别b的值，只有a和b的值都是真的 情况下，才有需要再去判别c的值，其他情况下不需要在判别了 同理，对于底下的表达式a或b或c，那么只要a是非零 也就是真啊，a已经是真了 那么就不需要再去判别b和c了，只有a为假的时候才判别b 只有a和b都判别为假的时候才回去判别c，也就是说 只有a和b都是假的情况下才回去计算 才会去运行c这个地方所给出的表达式 所以在刚才我们给出的这个例子里头，看这个表达式 因为我们已经计算出来这边的值是一，啊而且呢 这儿又是一个或运算,所以说后面的这个表达式根本就不会再被去 运算了，啊，程序根本就不会去算它了 不回去执行了，所以说根本就没有机会对 b进行赋值，虽然在这儿非零，是一，按道理 来讲应该给b赋一个1的值，但实际上不会去进行 因为整个右边的表达式程序连理都不会理它，这就是运算的结果 那么，OK，类似的呢，
- 啊，我们再看一个小例子 看这个例子，这个例子呢可能体现的更加明显一点啊，
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int i=0,a=1,b=2,c=3;
        i = ++a || ++b || c++;
        cout << i << " " << a << " " << b << " " << c << endl;
        return 0;
    }
    ```
- 我们第一呢 四个变量，i,a,b,c,啊，abc分别等于123 然后呢i就等于++a，或++b 或++c，啊其实这个式子大家一看其实就明白了，因为a已经是1，大家一看++a的值是 2，它已经是一个非零的值了，所以后面的++ 后面这个++和这个++会被执行吗？不会被 执行，所以最后打出来的结果一定是i等于多少啊？因为，因为这已经 是2了，所以说i等于1，a呢，是2，b呢，仍然是2，c呢，仍然是3 啊这是这样一个执行结果，这是关于逻辑运算符的取舍 
- 那么关于逻辑运算符呢我们还有一点想要说明的 就是在一个逻辑运算符的表达式里头啊 它的运算符的成员啊，可以是多种类型，它的运算对象可以是多种 什么意思呢？每一个逻辑运算符的两边，两侧不都是有两个值的吗？啊这两个值呢 其实是可以是任意类型 啊什么字符型啊，实型啊甚至指针型啊等等等等 都可以，系统呢只去看这个数是不是零 如果是零，那我就认为它是假，如果是非零 那我就认为它是真，比方说啊，这两，这个表达式里头 字符a与字符d，可以吗？当然可以，去查ascii码表，c和dascii码的值 都不是零，所以都按真来处理，所以最后这个表达式的值是真还是假？ 当然是真，这就是运算符的扩展，所以说我们可以啊在 逻辑运算表达式里面写很多数据类型进去，啊，再看一个例子
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a=0,b=1;
        a = 8>4 - (b=!'c') && 5>3 + 'a'%6 == 'b';
        cout << a << " " << b;
        return 0;
    }
    ```
-  OK，这有一个长长长长的表达式，啊再长都没有关系，因为我们有砍刀法 啊第一刀在哪砍啊？第一刀在这砍，啊，把这个赋值语句砍开，然后呢，我们去计算 右边的这个式子，那么第二刀在哪砍啊？ 一看我们这儿有逻辑运算符，逻辑运算符的运行级是最低的，所以说第二刀在这砍 砍开以后先计算这边，那这边在哪砍啊？ 一看有关系运算符，关系运算符比算术运算符要低，所以说在这砍 那么砍开以后呢，啊左边是八，右边是四减去b等于 非c，那么c，字符c本身是一个非零的数，所以说这个值应该是零 所以b等于零，然后呢整个这个表达式的值应该是 零，所以这个值是四减零，那么四减零呢等于 四，所以八大于四，返回值是一 既然它的返回值是一，中间又是一个与运算，后面还要不要算？ 当然要算，那么这个运算符呢我们也要把它砍开 怎么砍呀？第一刀运算符级别最低的地方砍开，在哪儿啊？应该在这儿 判等，因为等号，我们说过 比大于号的运行级还要低，等号判完了以后呢，再去计算这个表达式的值 这个表达式应该怎么砍啊？在这儿砍开，啊因为它是关系运算符，那么关系运算符砍开之后 5不需要再算了，3加a，字符a，磨6，既然有加有模，所以说我们先算这边 啊，a模6，a的值呢，我们去查下ascii码表就知道，a的值 等于97,97模6呢得到1，所以说这边 这个小表达式算出来结果等于1，然后呢，3加1等于4,5大于4吗？大于4 所以最终这个表达式的运行的结果等于1，那么1等于字符b吗？ 很显然，1不等于字符b，所以这边运行的结果是零 所以整个右边这个表达式的值等于零 那么既然中间是个与运算 那么1和0与运算在一起，它的结果是0 所以最终a的值是0 那么因为最终在这个过程里头呢啊，b进行了运算，b等于非字符c 所以说b的值也是零，所以最终这个程序打印出来的结果，是两个零，00 这个虽然画的比较乱，但我还是希望把这些笔记保留下来 以方便大家参考，啊，如果大家想参考原始的式子呢 可以去查我们上传到网站的ppt，讲到这啊，我们已经讲过了好多的运算符了 比方说赋值运算符，算术运算符，关系运算符，逻辑运算符，那这些东西有什么用呢 C，其实啊，C语言的运算符功能是非常非常强大的 那么经常啊我们在程序里头利用表达式来做一些逻辑上的判定 
- 比方说在这我们举一个例子，这个例子啊很简单 就是要你啊判别某一年是不是闰年 啊在这呢我们给出闰年的判定条件，两个条件只要符合其中之一就是闰年 第一个条件，能被四整除，但不能被一百整除的 都是闰年，第二个条件能被一百整除 又能被四百整除的啊也是闰年 当然了，在这儿我们不考虑年数特别大的情况，有的同学可能对闰年的事情非常的了解，啊，他知道 光这么计算是不行的，啊没关系啊，我们在这我们就按这个条件来计算 那么按照这样一个条件的话我们怎样去判定闰年呢 OK，我们去看底下两个表达式就可以了 可以用如下的表达逻辑判别式来判别某一年是否 是闰年，比方说我们定义了一个变量year 啊我们已经把这个，要判定的年数呢，放在这个变量里头了 于是我们可以通过去验证这个表达式是否成立来 来判定啊这个year里头所记录的年份啊是不是闰年 我们来看一下这个表达式 其实这个表达式的含义啊，非常非常的清楚 虽然它很长，但我们按运算符的优先级别来看，这有一个或运算 所以说我们先分成两边来读，左边 左边呢，中间又有一个与运算，与运算的这边呢，这是一个表达式，这个表达式是说 如果这一年磨四，也就是说除以四它的余数是零，也就是说能被四整除，中间是一个与 也就表示并且，并且呢，年份又不能被一百整除 这就满足了第一条，或者，这个年份呢 能被四百整除，能被四百整除当然就能被一百整除了 那么对于这样一个表达式，如果它的判定结果等于零，就表示这一年 不是闰年，如果它的判定结果不等于零，等于一，那就表示这一年是闰年 同理，按照上面的逻辑我们也可以写出其他类型的表达式来，啊，我们去 自己去做习题我们就可以知道同样的判别条件 不同的人可以写出不同的表达式来，啊我们在这呢就不再去重复了，OK 关于逻辑运算符我们就讲这么多 
## 8. 逗号，条件，强制转换运算符
- ok，那么在这儿呢，我们再提一下，其他的几种运算符。 
  - 首先来看第一种，逗号运算符。 这儿，特别，特别有意思，也特别想跟大家说明一下， 那么在C语言里头，逗号，也是一个运算符。 那这个运算符怎么用呢？是这样来用的。逗号这个运算符啊，是用来连接表达式的。 它把表达式连接起来。那，怎么连呢？很简单，就是把几个表达式用逗号给它 分隔开，就可以了。比方说表达式一，逗号，表达式二，逗号，表达式三，逗号， 那么把它串起来，这就形成了一个所谓的 逗号表达式。 这就形成了一个所谓的逗号表达式。那这个表达式的含 义是什么呢？既然逗号是个运算符，那它总要进行计算啊。 那么它的含义呢，就是这样的。先求表达式一，再求表达式二， 再求表达式三，点点点点点，一直求到表达式n。 逗号运算符的作用是什么呢？ 因为这是一个，整个是一个 逗号表达式。所以，这一整个表达式，也有一个 值。这个值，就是最后这一个表达式计算出来的值。 这就是逗号表达式的含义。举个例子，比方说，有这样一个表达式`a=3*5,a*4`。a等于3乘于5，逗号， a乘于4.那么在这个表达式里头啊，出现了很多的运算符号。比方说，赋值号、 乘号、逗号。当然，要计算这个表达式， 我们就必须要搞清楚它们之间的优先级。 查一下运算符优先级列表，你就会发现， 整个列表的最底端，就是逗号。 也就是逗号，在C语言里头，所有的运算符里头，运算符的优先级别是 最低的。既然它的运算符的优先级别是最低的，甚至低于 赋值运算，所以说我们第一刀在这儿砍开。 先去计算左边，左边很好计算， a等于3乘于5，所以说，a的值等于15， 然后呢，计算完了左边以后，a的值等于15了，那么再去计算右边， 15乘以4，所以最终这个表达式返回的值是 60。是60。 那么计算完了以后呢，a的值等于，就是这个表达式的含义。 啊。 那么，好，既然获知了这么一点以后啊，我们再作一个小的思考， 那么如果这两个式子计算完毕的话，x的值是一样的吗？ 一样不一样？好我们来看一下。x的值啊，明显地是不一样。我们先来看第二个， 第二个x值等于多少啊？ 既然逗号表达式是最低的，所以说第一刀在这砍开，x值等于多少啊？三。第二个式子，x值等于三。 那么第一个式子，因为这个逗号表达式出现在 括号里面，所以，第一刀在这儿砍开。 先计算括号里，这个大括号的值。 这个大括号的值，a 等于三。这个值是三，但是中间有一个逗号，那么最后这个表达式的值， 3乘以6，所以说最后这个表达式的值是18。 于是x值，也等于18。所以第一个值 x等于18，第二个，x等于3，这两个是不同的。 Ok，这是关于逗号表达式。 所以啊，我们在写程序的时候，一定要小心，别把分号写成了逗号，因为逗号也是一种运算。 Ok，这是逗号运算符。 
  - 那么，我们下面再看一种运算符。好，那下面呢，我们再来看一下， 条件运算符，跟前面我们讲过的运算符不同啊。 条件运算符啊，是由多个运算符号组合而成的。 什么意思呢？看这个形式，看这，这是条件运算符的形式。 一个条件运算符啊，可以包含多个表达式，比方说表达式一，表达式二， 表达式三，那么在表达式一的后面呢，跟有一个问号。 在表达式二和表达式三之间呢，放有一个冒号。那么这样一个形式， 就形成了一个条件运算符的表达式。那它的含义是什么呢？ 它的含义是这样的。 先求解表达式一的值，如果表达式一的值为真的话， 那么，我就把表达式二的值，作为整个 条件运算符表达式的值，返回出来。如果表达式一的值， 不为真，那么，我就把表达式三的 值，作为整个表达式的结果，给它返回出来。 也就是说，两者必局其一。要么， 整个表达式的值， 就是表达式二的值，要么，整个表达式的值， 就是表达式三的值。 啊这就是直条件运算符的基本含义。 如果还不太清楚，我们看下面的这个例子， 这就是一个，由条件运算符所组成的一个表达式。 max，max 是一个变量了。它等于 (a>b)？然后a:b 什么意思呢？这是表达一，这是表达式二， 这是表达式三。根据我们刚才所讲的， 如果表达式一的值是真的话， 那么把就把a，把这个表达式的值 当作整个表达式的值，返回给max。 也就是说，如果a>b是真的，那我就把a 的值，返回给max。相反，如果a>b 不是真的， 是假，那我就把b的值，返回给max。 啊，看上去有意思了啊。那么，大家就可以知道，这个式子的含义实际上概念什么事儿？ 求a和b中间的最大值。 于是呢，这句话，这一句话，就相当于我们 以前写过的这两行程序。如果 a大于b 的话，max 就等于 a。else， max 就等于 b。这就是 条件运算符的基本含义。那有些同学就说了，既然 我完全能够写if 语句去解决这个问题，我干嘛还要用这个条件表达式呢？ 没有问题。你在程序里头啊，完全可以写 if 语句来代替条件运算符。 而且，我非常赞同你这么去做。为什么呢？啊，因为 如果我们写成if语句的话，程序的可读性，将会得到提升。 所以说，我赞同你这么去做。但是，之所以讲条件运算符，意思就是说当我们碰到这个运算符的时候啊， 我们要知道它的含义。虽然我们可以自己可以不用，但是呢，看到别人写了，我们得明白。 这是条件运算符。 
  - 那么最后，还有一个运算符也要跟大家介绍一下，就是强制类型转换运算符。 强制类型转换，望文生义，我们就知道， 所谓强制类型转换就是把一个变量或者表达式的值 强制地转换成我所指定的 某种类型。那就是强制类型转换。举个例子， 来看，对于变量a， 我在变量a的前面写一个小括号，然后再里面 写上double，double 是一种类型。那么在这呢，一定 这里面一定写的是某种数据类型。 double。那么，整个这个表达式它的含义是什么呢？就是要 把a的值，强制转换成 double 类型。 注意，注意，这儿是把a的值转换成 double类型， 并且返回出去。这是一个表达式吗？这个表达式就有一个值吗? 整个这个表达式的值，就是等于把a的值强制类型转换成double 类型。 这就是整个这个表达式的含义。我们再看一个， 如果我想把a+b的值，强制类型转换成 int 型，那么我就可以把a+b 括起来，然后在前面加上一个小括号，写上 int。 这样的一个表达式，它的含义就是要把a+b的值，啊还是值，转换成一个int 类型的值， 然后把它返回出去。作为整个表达式的返回值。那这就是它的含义。再看一个， 5/3，括起来，啊，这是一个表达式了。 那么把它的值强制类型转换成float型，然后返回出来。 Ok。那么，请问，整个这个表达式的值，是多少呢？ 是1.666. ... 一直6， 还是1呢？稍微思考一下我们就知道，它的表达式的值是1。 因为5除以3，它的值是多少？是1。因为5 和3 都是整数，啊，得到1. 那么1呢，强制类型转换成 float 型之后，也是1。当然，如果打印浮 点数的话，那么它的浮点值因该是1.000000。 。 。 啊，是这样的一个量。**Ok，那么在这儿呢，还是要强调，就是说， 强制类型转换以后啊，那么被转换的量，它自身的类型是不发生变化的**。 比方说，第一个，a是一个变量，假设说它的类型是int 型，那么，在这个表达式 里头，那么通过强制类型转换，我们把a的 值，强制类型转换成了double型，作为整个表达式的 返回值。啊，这是没有问题的。 但是就算做完了这个，那么a这个变量，它原始的类型，就是int型，仍然是不会变化的。 它原来是int型，现在也是int型。也就是说，强制类型转 换的，都是后面这个表达式或者变量的值， 值，值。它本身的类型是不会改变的。Ok，这就是关于强制 类型转换。那么介绍到这呢，我们基本上 就把C语言里面，所有的运算符都跟大家介绍过了。 那么，那么希望啊，大家看了以后啊，好好地思考一下，看看自己有没有什么 问题。 因为这一部分呢，确实比较地琐碎。如果想不出问题呢，也没 关系，我们完全可以等到我们用到的时候我们再去查，就ok 了。 所以说，放轻松，不要紧张。能获取多少，算多少。Ok，谢谢大家。 
## 9. 位运算
- 好， 那么， 接下来呢， 做一个选讲内容。我们再跟大家介绍一下位运算。 说好了是选讲内容， 既然讲都是选讲了， 所以肯定不要求大家去掌握。 那么在今后写程序的过程当中呢， 能用到， 你就来看一眼。 如果用不到， 你可以不理它, 没关系。 
- 什么叫位运算？ 所谓位运算就是指， 就是对 内存里面， 每一个字节上的二进制位所进行的运算。 这就是位运算。那么当然我们以前讲到过。 其实呢， 在内存里面 字节是程序对内存进行操控的基本单位。 那么这儿的位运算， 虽然我们说是对二进制位进行的运算， 但实际上这种运算也是通过对字节为单位的控制来实现的。我们做一个解释。 
- 那么C语言或者C++语言中的位运算符呢包含了这么些。 有与运算，或运算， 异或运算， 取反运算，左移运算， 和右移运算。有这么6种。 其中呢，前三种都， 都是双目运算符 所谓的双目运算符就是有两个操作数参与的。 后三种呢， 都是单目运算符。也就是说， 只有一个操作数参与。我们分别做一个介绍。 先来看与运算。所谓的与运算，其实就是说， 把参与运算的两个数据， 这两个数据肯定是可以表示成二进制的字符串， 对吧，一位一位的。那么它每一位， 它个位均独立进行“与”运算。那么得到的结果就是位运算的结果。 我们举一个例子。 当然我们这儿举的例子为了方便我们没有把所有的字节全部都画出来。
  - 比方说对于表达式a=3 & 5, 什么意思呢？ 这是3所定的二进制的字符串， 这是5所定的二进制的字符串 那么3与5, 它要做什么呢？ 结果就是每一位都做与运算， 每一位都做与运算，每一位都做与运算。 最后得到的整体的结果就是位运算的结果。 位运算， 3与5， 我们可以看一看做完了之后， 它的运算的结果是0000000， 三十一个零， 加上一个一。 这个值的大小其实就是数字1。 整数1。所以说呢， 3与5的值是1。 这就是与运算的基本含意。那么这个与运算呢， 又叫 ”按位与“。 
  - 那么说完了与运算我们再来说一下或运算。 所谓的或运算， 也就是指"按位或" 这个运算是指什么呢？是指参加运算的两个数据 它的每一位， 各位均独立进行"或"运算。 比方说刚才那个例子。 3和5。 3和5的最后一个字节拿出来。 全都拿出来。 写出来是这样的。 当然我们也可以把其它的字节全都写上。也进行或运算。 每一位都进行或运算， 每一位都进行或运算。最后得到的结果是， 00000111。 那这个值数是多少，是7。 所以说3和5进行“按位或"的结果是7。 这是或运算。
  - 第三种运算呢，叫做"异或"运算。 按位异或运算。它的表示符号呢是向上的箭头。 在我们的键盘上有这个符号。 它所表示的含意呢，就是参加运算的两个数，各位均独立进行异或运算。 什么叫异或运算？我们以前也提到过。所谓异或运算就是参与 运算这两个数，如果是一样的，那么结果就是零。 那么你看，如果要是一样的，结果就是零。 如果参与运算的这两个数是不一样的，是相异的， 结果就是1。 这就是异或运算的基本含意。 那么我们来看一个例子。比方说有两个数，第一个数是这个数， 00111001。第二个数是00101010。 这两个数进行 异按位异或运算，那么得到的结果就是这个数。 那么这个数呢，换算成八进制结果是071. 这个数换算成八进制结果是052。是零开头的。所以 071 按位异或052 所得到的结果，就是这个结果。这个结果其实是对八进制的 023。这就是按位异或的含意。 
  - 再往后看， 取反，这是波浪键。那么这也是我们键盘上的一个符号。这是一个单目运算符。它用来表示什么呢？ 对一个二进制数进行按位取反。所谓按位取反就是原来是 零的全部变1，原来是１的全部变0。 比方说对这个数。如果它按位取反的结果，就是说，原来是0的变1。 原来是1的变0。变成这个数了。 所以如果我们对025, 这个8进制的数，进行按位取反运算的话，我们得到的就是这样一个数。 这是一个8进制的数。我们注意一下。这是取反运算的基本含意。 
  - 再往后看，左移运算。 所谓左移运算，就是把一个数的各个二进制位 全部左移若干位。这样的运算就叫 左移运算。当然一个数的二进制位如果左移的话就会有两个问题。 第一个问题是高位就会移到外面去。 其次呢，第一位就会空出来。那怎么解决这两个问题呢？ 高位左移后溢出。溢出的部分就舍弃了。 不再起作用了。那么第一位呢，新空出来的呢，我们就补零。 比方说，对一个数，a=15 也就是这样的一个二进制数。转换成一个8位的二进制数是这样的。 如果对这个数进行左移2位的运算， 可以写成这样子，a = a<<2 左移两位。那么左移两位之后的结果是什么呢？ 溢出来的两个零我就不要了。那么右边呢，新产生了位补零。这个数呢算下来就等于60。 所以说a左移两位，它的结果就变成了60。 15左移两位变成了60。 其实呀，细心的同学可能已经发现了， 每左移一位，如果这个数不溢出的话， 就相当于对这个数乘以了2。 是不是这个意思啊？左移两位呢，就相当于乘以了2的两次幂，就是4. 所以说，15左移两位因为它不会溢出，所以呢相当于乘了4 15乘以4, a 就变成了60。所以说，在一些乘以2的一些场景中，为了计算的快速 我们可以采用左移这样的运算来完成， 这是左移。
  - 我们再来看一下右移。 一样的，也就是将一个数的各个二进制位全部右移若干位。那么既然是右移的话， 那么也存在两个问题。 那么右端移出来的数就被舍弃了。那么左端呢， 空出来的数就要补零。也是一样的处理。比方15, 还是这个数。 那么所定的二进制数后8位是00001111, 那么右移两位，我们得到的结果是这样的。 那么右端多移出来的那两个1呢，我们就把它舍弃掉了。 它表示呢，就是这样的。 a = a>>2 右移两位。 那么当然一样的道理，既然是左移 是乘以二，那么右移呢，在不溢出的情况下 不溢出的情况下，就相当于除以2。那么对这个数呢，就不行了。因为它有溢出了。 它溢出了两个1。所以说就不能相当于除以2了。
- 那么关于位运算呢，我们还需要解释几个问题。 
  - 那么，第一个问题，关于右移运算的符号位的处理。 当把一个有符号的数进行右移运算时候，那个符号位应该怎么处理。 通常，它是这么来处理的。对于无符号的数，没有符号的数，右移的时候左端 左边因为空出来一些位嘛， 那肯定要放入一些0。那么对于有符号的数， 它是怎么处理的呢？如果原来的符号位是0，则左边放入0。 **如果原来的符号位是1，也就是负数，那么左边呢，是放入1还是0 这个事儿呢，取决于你所用的计算机系统**。 不同的系统会有不同的处理方式。那么可能的处理方式呢无非两种，**第一种就是移入0。 那么我们管这种情况呢叫做逻辑右移**。 大家在看到这个词的时候你就明白，OK，它右移的时候， 左边补的是0，就可以了。或者叫简单右移。 **如果移入的是1呢，我们就称为算术右移**。比方说在VC的环境底下， 那么它所采取的方式呢就是算术右移。 OK，这是关于位运算的第一个问题。
  - 那么第二个问题， 不同长度的数进行位运算的时候应该怎么处理呢？啊。 那么很好办。当有两个不同长度的数进行位运算的时候，系统呢 就会把这两个数啊按右端对齐，按右端对齐 来进行运算。 那么比方说a&b，a呢 是int型，b是short型，那么它们可以进行与运算吗？ 按位与运算吗？可以。那么他们就按右端对齐，也就是说 这个short型贴着int型的低16位排好。 那么既然是按右端对齐，左端呢， 可能就有空出来的东西，对吧。因为short型它短嘛。 那如何进行补位呢？这个补位是这样的。如果b，这个b啊int型 short型啊是无符号的数，那么左端呢，就添0。如果它是有符号的数， 那么如果是正数的话，左端左边16位就补0。啊右边。如果它是负数的话呢， 左边16位就补1，是这样来处理的。
  - 第三个， 位运算呢还经常跟赋值运算放在一起组成复合赋值运算。 因为位运算通常要跟赋值运算放在一起使用，所以说这种情况经常发生。 那么当我们碰到这种情况的时候呢，我们就要知道它的含义就可以了。这个跟复合赋值运算的 基本的道理是一样的。你比方说a&=b，它就相当于a=a&b。 a|=b，那就相当于a=a|b。a>>=2，那就相当于a=a>>2。 同样左移也是一样的。同样异或a^=b，就相当于a=a^b。 如果碰到这种情况，我们知道就可以了。这是第三个需要说明的问题。 
  - 第四个，关于位运算的优先级。那么在这呢，我们给出来一个参考，就是跟其他的运算符 优先级呢做一个对比。那么位运算的优先级呢，取反运算最高， 啊它比算术运算符的优先级还要高一些。 然后呢是左移或者右移的运算，它比关系运算符要稍微高一些。然后呢 是按位与或者按位异或或者按位或运算，最后呢是逻辑运算符。 大概是这样一个由高到低的一个顺序，那么 当然标准的答案呢，请大家参考运算符优先级列表。 
- 那么最后呢，我们介绍一下位运算的 作用，啊位运算的作用。其实在程序里头啊， 位运算有各种各样的应用，可以写出来不同的应用。但是呢有一些应用啊还真是 非常的常见。
  - 比方说第一种，按位与运算的用途，通常啊 是用来取一个数中的某些指定的位。 比方说对于一个整数a，假设说啊它是这样来表示的，当然这是用了16位了， 比方说我们想取它的低8位，那么我就可以把这样的一个a 跟这样的一个b做一个与运算。 因为这个b的最低位全都是1，最高位全都是0。 那么做完与运算之后，我们得到的这个c恰好是只包含了 a的最低位的那些二进制位。这是与运算的一个功效。 那么或运算呢也是，对一个数据的某些位我想把它 置为1，那我就用，我就让它跟某个数去做或运算。 这个相信呢，大家都能理解。 这是与运算和或运算。那么异或运算呢， 它的用法也是这样的。
  - 通常你比方说，我们可以可以做的是， 使某些特定的位呀，使一个数某些特定的位进行 翻转。比方说我们想使这个数它的低4位进行个翻转， 那么应该怎么办呢？我们就可以与，把这个数跟这个数 进行一个异或的按位异或的运算。 我们看一下这个结果，啊如果这个数跟它做一个 按位异或的运算，我们看得到的结果恰好是把 所有这里是1的这些位全部都做了一个翻转。 啊你看，这个值它的低4位 全部是对这个值的低4位的一个翻转。那么除了这个之外呢， 按位异或还有一个很重要的用途，啊是这样的。 这个呢经常在一些 面试啊什么等等这样的场合会看到这样一个题。有两个变量，比方说a和b， a=3，b=4。现在我想要把a 和b的值进行一个互换。a和b进行互换呢， 并不难。以前我们在讲程序的时候都碰到过，比方说我们可以找一个临时的量，比方说c吧，我就可以让， 把a呢先给先赋给c，然后呢再把b呢赋给a， 然后呢再把c呢给b。 这样的话，a和b就做了一个互换。但是在这儿呢， 我要求不能使用第三个量， 只能使用a，b。 只能使用a，b，而不借助于第三个量就要实现它们的互换，那怎么办呢？ 很好办，这个时候正好用到按位异或运算。它的计算过程是这样的。先把a和b做一个异或运算， 它的值呢赋给a。 然后呢再利用这个赋完值的a同b再做一次异或的运算， 结果呢赋给b。然后呢，再利用a和b的结果呢再做一次异或的运算， 结果赋给a。那么经历过这个过程以后，a和b的值就得到了一个互换。 而且在这个过程中，我们没有借助到第三个变量。OK，这就是异或运算的一个 在数据交换过程中的一个常用的方式。 OK，那么关于位运算呢，我们就介绍这么多。需要强调的是，位运算这部分 我们是不做要求的，大家如果有兴趣，可以了解一下。好，谢谢。 