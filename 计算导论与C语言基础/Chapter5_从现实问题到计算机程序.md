# [从现实问题到计算机程序](https://www.coursera.org/learn/jisuanji-biancheng/lecture/Aj6nt/mei-you-jie-jue-fang-an-jiu-mei-you-cheng-xu)
## 1. 没有解决方案就没有程序
- 各位同学大家好，我们开始今天的课程。今天的主题叫做：从现实问题到计算机程序。那么，首先咱们明确一下咱们所处的学习阶段， 我们现在还处在感性认识C++程序的这个阶段。 也就是说在这个阶段，我仍然不要求大家，自己能够独立的写出正确的C++程序来，仍然不要求。我只希望你对C++程序有一个比较好的感性认识就可以了。 那么这一次课，我们来讨论这么一个话题，就是当你面临一个现实问题的时候，比方说，我给你出了一道题， 那怎么从这个现实问题找到相应的计算机程序呢？今天我们来讨论一下这个问题。**上次课我们讲述了这样一件事情，程序是你告诉计算机的话。也就说如果你想让计算机做什么， 那你就要把要做的事情表达成程序告诉计算机，然后呢让它去执行**。那么这次课我想说什么呢？我想说计算机能起到的作用也就这么多了。什么意思呢？ 
  - 计算机其实是一个很笨的执行者。**如果你把要做的事情明明白白的告诉它， 它的确可以按照你的话去执行。 但是如果面对一个问题的时候，你还没有想好怎么去解决这个问题，它是不可能帮你想到解决问题的这个办法的。也就是说写程序其实是这样一个过程，当你面临一个问题的时候，比方说我给你出了一道题，你首先要找到解决这个问题的办法，也就是说那个解决方案。 然后才有可能把这个解决方案写成程序让计算机去执行。 也就是说当你面对一个问题的时候，你必须要先找到解决这个问题的办法， 然后才有可能写出相应的程序来。 如果你找不到这个办法，你是别指望计算机帮你去找这个办法的。** 
  - 为了让大家有一个直接的感受， 我们来举一个例子说明一下这个问题。这个例子的名字叫做切饼。 那么我们先来看一下这个题目给我们出的问题是什么? 
    - 他说假设有一张很大很大的饼， 然后呢给你一把足够长的刀， 要求每次在这个饼上切一刀。问题就是问N刀， 如果你切N刀的话，最多能切出多少块饼？ 这就是这个问题。我们来看一下，比方说N等于3， 也就是说问你3刀最多能切出多少块饼？ 那我们第一刀横着切，第二刀竖着切， 第三刀呢，为了保证我们能切出更多的块数， 我们需要保证切的第三刀跟前两刀有两个不同的交点， 这样的话我们才能切出更多的块数来。 所以人家的问题是如果切N刀的话能切出多少块饼？ 这是这个题的涵义。那请你来想一下怎么去计算呢？ 我能不能上来就写个程序说，唉呀,我让计算机帮我来算一下。 我就把这个题目告诉计算机，让计算机去帮我算一下。 我能不能上来就开始写程序呀？ 当然不行，因为我还不知道该怎么算呢。 三块的话，我可以数一数一、二、三、四、五、六、七、七块。 那么再多了呢，我就不知道了。 我必须要想到这个解决的办法，然后交给计算机， 它才有可能帮我去计算出来。是不是这个意思呀？ 所以说当面临一个问题的时候，我们一定要先去思考它的解决方案。 在这一点上计算机帮不了我们，我们必须要自己去做。 那好我们就来分析一下这道题目， 那怎么分析呢，先看一下，先总结规律，比方说 这是第一刀，我们横着切。 第一刀切完了，我们得到了两块， 第二刀呢，我竖着切。第二刀切完了很明显我们得到了四块。 再看第三刀，刚才说啦，第三刀斜着切， 保证跟前两刀有更多的交点，这样我们才能得到更多的块数。 那第三到切完了有几块呢，我们来数一下，第三刀切完了有 一、二、三、四、五、六、七， 有七块。这似乎有个规律。 你看，第一刀切完了有两块。第二刀切完了有四块。 2+2=4， 第三刀切完了有七块，4+3=7。 按照这个规律的话，如果第四刀切完了，我们应该有11块。 我们来看一下是不是这个规律， 第四刀为了保证有更多的块数，要跟前三刀有不同的交点。 这一刀我们这么切，它跟前三刀确实有不同的交点。我们来数一下是不是11块，一、二、三、四、 五，六、七、八、九、十、十一，的确是11块，也就是说 的确是7+4=11， 这的确是一个规律。利用这个规律我们的确能够计算出来，如果切N刀的话， 能切到多少块？ 但是这个规律成立吗？我们必须得想一个办法来证明这个规律。 好，那接下来我们就来证明一下这个问题。 那么,你看，当我们切第三刀的时候，第三刀跟前两刀有两个不同的交点， 这两个不同的交点就把第三刀在这个饼上的这段线段分成了三段， 你看是不是这样啊，分成了三段。 然后呢，每一段线段都把 原来的某一块小饼分成了两块。 比方说这一段把这个小饼分成了两块， 1、2两块， 那么这一小线段呢，把这个分成了两块， 这个也分成了两块。 于是现在的块数就比原来多了这个线段的数目，有几个线段就多了几块。 我们在来看切四刀的时候，切四刀的时候， 这第四刀切下去跟前三刀有三个交点， 然后呢它把这个线段切成了四段，1、2、3、4，这四段呢， 新切出来4块小饼。 也就是说,那么第几刀切下去，这条新的线就被原来的线分成了几块。 然后呢这个饼的块数也就增加了几块。 这完全符合刚才我们所给出来的这个规律。 如果把这个规律写出来就应该是这样的， q表示当前的块数，括号里面的这个值表示当前的刀数， 也就是说如果我们不切的话，那么当然就是一块大饼。 那么如果切一刀，我们得到了两块，切两刀就在原来的块数上增加了2块得到四块。 那么如果切三刀呢， 就在原来的块数上增加了三， 切四刀的话就在原来的块数上增加了4， 得到11。 如果切第N刀的时候，那么我就在N-1刀的基础上增加了N块， 这就是我们得到的那个解决方案， 这就是那个解决方案。 那么这个解决方案是不可能靠计算机帮我们想出来的。
- 讲到这我特别想跟大家分享这样一个感受， 什么感受呢，当你面临一个问题的时候，比方说一道题目， 如果你还没有想出来解决这个题目的这个解决方案， 请你千万不要着急动手去写这个程序。 那为什么不要这样做呢？ 在这我列举三点原因。
  - **第一点，很明显， 如果你还没有想到这个解决方案，你是不可能写出程序来的**。 
  - **第二点，急着去写程序很有可能会限制你的思维， 从而使你找不到带有创新性的解决方案**。 
  - **第三，如果没有想好这个解决方案就去写程序， 那么势必你会对这个程序改来改去，改来改去， 这个改来改去的写程序很容易造成程序结构的混乱， 很容易引入更多的错误。这一点是在软件工程领域被充分的证明过的。 也就是说啊，当你在面对一个问题的时候，如果你还没有想到一个相应的解决方案， 你千万不要着急动手去写那个程序。 请你把那个写程序的事先搁到一边， 先放开手脚去寻找那个解决方案。 这就是特别想跟大家分享的**。 
## 2. 先有构想再写程序
- 那，接下来一个问题。 那是不是有了这个解决方案，我就有程序了啊？ 啊，这是不是很容易就做成的一件事情啊？当然不是。 对一个问题而言，想到了解决方案，只是完成了第一步。 有了这个解决方案以后啊，还必须把这解决方案描述成程序。 
- 这是一个两步走的过程。
  - 前一步呢，重在实考。 
  - 那后一步呢，重在描述。 
- 这是两个不同的步骤。 但有些同学说，哎呀，描述，那容易。那，是不是描述问题就不用再实考了啊？ 在这，我想告诉大家，其实啊，像要描述一个问题，是一件不容易的事情。 那，比方说啊，MIT在筛选博士生的时候啊，曾经出过这样一道题目。 啊，请你写一段文字，向一个5岁的小男孩描述一下 如何系鞋带。可见，他们对描述是非常非常的重视。 而且呢，这个描述一个问题其实是一件非常有难度的事情。
- 那么，当你已经拥有一个解决方案的时候，你怎么样 才能把这个解决方案描述为计算机能够理解的程序呢？ 其实啊，这才是我们在这个课上重点要讨论的问题。 当然，把一个解决方案描述成程序啊， 有很多的办法。那么，我们现在所学的，是利用一个结构化程序设计语言来描述这个解决方案。 那么也就是说，我们应该按照结构化 程序设计的思想来描述这个解决方案，当然应该是这么去做。 但是在现阶段，因为我们是感性认识的阶段，我先不去探讨这个结构化程序设计的 一些深奥的道理，我们先从感兴的层面给大家一些提示。 所以啊，在这里，我写了这样一段话。
   - 在结构化程序设计中啊， 总是按照**先粗后细，先抽象后具体**的 这样一种方式。**对所要描述的解决方案，进行穷尽式的 分解，穷尽到什么程度呢？直到能够使用顺序，分支，循环， 这三种结构来描述你的解决方案。**
   - 那，什么叫做先粗后细，先抽象后具体啊？ 为了让大家有个感兴的认识，我呢，在这个做一个类比。看这幅图。 那这幅图里头呢，包含了6幅小的图象。这6幅图画 其实描述了一个绘画的过程。你看第一幅图画。
     - 第一幅图画里头，它是先用很粗的线条去勾了出来要画哪些东西。 那这个画大致的结构会是什么？ 它先不去管那些细节，然后在后来的过程里头 慢慢的再去增加细节。啊，对局部进行处理。 那，你看，这个体现了一个一样的过程。 先抽象再具体，先粗线条再 考虑细节，啊，一步一步的完成。
     - 我们再看一幅。 对这幅画更是如此。我们要画一幅图像， 我们先用粗线条勾了出来大致的轮廓， 啊，它的结构是什么。然后呢，对每个部分再进行不断的细化，不断的细化， 一步一步地完成整幅画。 那，这是在绘画的领域。其实啊，在自然语言这样的写作里头也有这样的规律。 
    - 啊，比方说Babara Minto，就曾经啊，提出了一个金字塔原理。 那，Baraba Minto 曾经在McKinsey工作过。她呢，写的报告非常的出色。 后来她写了一本书，提出了一个广为人知的写作方面的道理。 那就是如何去构建一个文章的结构。她把这个道理呢，称为金字塔原理。 在金字塔原理里头啊，她也提出了建立一个文章的金字塔结构。 那么你想像别人清楚地表达一个问题的时候啊，那你说缩写的那个文章 应该符合一个金字塔的结构，那就是说由种到分，由粗到细， 这样呢，才更便于被别人所理解。 那么在这啊，我不想讨论艺术和科学之间的相同与不同， 也不想讨论中西方绘画之间存在的一些差异。有些同学可能在思考这些问题了啊， 我不想讨论这些。我只想告诉大家，你看，**由粗到细，由抽象到具体， 这样来描述一个问题，它符合人们描述事物的规律。 啊，对绘画是如此，对写作是如此，对编程序 也是如此。**那，回到刚才的我们这个问题， 你看，我们已经找到了一个解决方案。 那么，该如何把这个解决方案描述为一个程序呢？ 嗯，在这啊，按照刚才我们告诉大家的规律， 先不要考虑那些编程序的细节。不要一上来就定义变量， 有时候我在上课的时候啊，提问问题，比如说谈论某个问题的时候，我就问一个同学。 我说，你是怎么解决的啊？有些同学站起来就开始说，啊，现定义了变量，后呢给变量附值，然后呢，For循环， 从0，嗒嗒嗒嗒嗒。他俨然背他心里的程序啊。虽然我非常佩服他的记忆力和这个 出口出程序的这种能力，啊，但是，我仍然不能够同意他的这种做法。 因为对于小的问题，你可以直接说出一个程序来，那对于大的问题呢？ 难道你也从第一行程序开始，用程序来描述你的解决方案？退一万步讲，你真的是这样的天才， 你也许可以这样去做，但未必别人能听得明白啊。 如果只有你明白，而无法跟别人进行交流， 那你就没办法进行团队协作了啊。 嗯，再说了，如果你真的是天才，我们也不用来讨论这些方法了，你可以直接去写程序了。 嗯，所以说在这啊，我们先要去描述我们要写的这个程序的轮廓。 啊，大致的轮廓。 用最简单的方式去想象这个轮廓。甚至去勾画这个轮廓。 你可以把这个轮廓给它画出来。那，比方说，我就画出了这样的一个轮廓。 你看，那，这样的轮廓啊，它不是用来给计算机看的。 它只是用来帮助自己或者别人理解我要怎样去 写这个程序的。当然你也可以不用这种方式，而用你自己的方式， 也不一定是图，也可以用文字。啊，怎么样都可以。我想要你做的就是 一定要在脑子里面形成一个轮廓，一个结构，嗯， 你要写的程序，它就长成这样，啊，你心里非常非常的有数。 因为对这样一个问题而言，我已经知道怎么去解决这个问题了。 那，怎么把它写成程序啊?我就可以这样来画。你看，输入刀数N， 然后呢，先设置好初数值，第1刀的时候两块， 啊，有的同学从0开始，也可以啊，0刀的时候，是一大块， 嗯，1块。然后接下来就是一个累加， 啊，这个累加就是一个循环，那这个循环，怎么去做的，细节，我先不去想。 啊，然后呢，我就把这个块数输出出来。你看这个程序的结构，先由一个输入， 再有个初数值的设定，然后一大块循环，循环里面而解决累加的问题。 循环完了之后输出一个块数。程序的结构如非如此。 我希望你在写程序之前，就能够形成这样的一个轮廓。 在你的心里有这样一个结构存在， 在去动手写程序，你就汹涌成除了。 那我们来看一下这个，这个例子的程序是不是这样的。你看这个程序的结构是不是这样的。 先输入一个数据，把这个N输入进来，然后呢，输入一个 初数值，然后呢，有一个循环，啊，这个循环不断的去进行。 啊，反正在循环里头完成累加。最后呢，有一个输出。 啊，把这个块数输出出来。 是不是这样一个结构啊?所以说，在你写程序之前啊，你心里头就有这样一个结构 存在。我要先输入，然后再输入一个初数值，然后呢是一个循环， 最后呢，有一个输出。那，如果有这个结构的话，你在写程序 非常非常的顺利。你要有这样一个， 有这样一个概念。先让自己形成这样的认识， 再去动手写程序。那么，写程序完全是可以不从变量定义先开始的。 你可以先把这个主干想办法给它描述出来。 然后呢，缺什么变量，再回头定义什么变量。 甚至于在这个过程中，可能有些许的语法错误，啊，也没关系。 你可以边写边改，也可以先把整个程序 写得差不多，然后再来调试，再来Debug。 这就是写程序的基本的一个过程。
    - Ok，那么， 通过了这个例子，我们还学了不少的东西。我们就来总结一下，看我们学到了些什么。 
      - 首先，我们可以知道啊，写程序是这样一个过程，当你面临一个问题的时候，啊，比方说，一道题目， 你必须要先找到一个相应的解决方案。 先去思考这个解决方案，
      - 然后呢，再想办法把这个解决方案变成程序。 那么，其实写程序是一个这样的过程，对吧。 因此呢，如果面对一个问题的时候，你还没有想好解决方案， 千万不要急着就去动手写程序。危害我已经讲过了。 这是第1点。第2点，
      - 有了解决方案以后，怎么写成程序呢？ 可以按照先粗后细，先抽象再具体的这个办法。 先建立起这个程序的轮廓。 当然在这个过程里头啊，如果有必要的话，你可以借助一些 建模工具。啊，所谓建模工具，就是一些用来画图的工具。 在软件建模领域里头啊，有很多类似的这样的工具。 那么我在北大呢，还讲出了一些研究生的课程。那么，跟这个部分是有点关系的。 如何去建模这个软件。当然呢，那个是主要面向对象方面的。 那么，用那些工具呢，可以帮助你来画一些图。 嗯，有了这些图后啊，然后再动手写程序。其实这过程，它的目的 仍然是帮助你先建立一个程序的基本的轮廓， 基本的结构，啊，然后再动手去写程序。 
      - 第3点，在写程序的过程中啊，可以先写出程序的轮廓， 而不是从定义变量开始的。而不是先去定义各种的变量， 啊，可以先写出程序的轮廓。那么写出这个轮廓以后再回头来补上所需要的定量的定义。嗯，这样去写程序。 可以保证让我们既有效率，又能够写出正确的程序来。 
## 3. [先有构想再写程序--示例](https://www.coursera.org/learn/jisuanji-biancheng/lecture/IwYzz/xian-you-gou-xiang-zai-xie-cheng-xu-shi-li)
- 那么接下来呢就让我们通过一些简单的例子来感受一下这个过程 来感受一下这个过程。 第一个例子，鸡兔同笼，首先说这些例子都非常简单 我们希望大家感受的是这样的一个过程。所以说我们尽量用一些简单的例子。 这是一个很有意思的问题，这个问题是这样的。在一个笼子里头关了一些鸡和兔子， 当然我不知道他们会不会打架啊。这个题目是这样的。鸡呢，当然of course有两只脚， 没有例外的情况。兔子呢，有四只脚，特别强调没有例外。 现在呢，已经知道了笼子里面脚的总数，就是说一共有多少只脚，我是知道的。 问笼子里至少有多少只动物，至多有多少只动物？ 当然这个问题非常非常的简单啦，大家一想就知道，对吧，应该怎么去解决。 无论如何，你首先脑子里边应该先有一个，想一个解决方案。 其实这个问题的训练重点不在于找到这个方案，它在于让你训练输入输出。 看输入样例。对这个问题而言呢，先要输入一个整数。 这个整数表示什么含义呢？它表示接下来的测试数据的 组数，就是一共有多少组测试数据。 然后呢，这是第一组，这是第二组，那么接下来呢， 每给出一个输入的测试数据，就要求你在输出里头给出一个， 一行相应的输出。 那比方说如果输入的脚数是3，那就要求，输出的时候 就是00，因为3是不合理的，奇数；如果输入的脚数是20， 那么我们可以给出答案，最少5个动物，全都是兔子。最多呢，10个动物，全都是鸡。 是这样的一个结果。这个是，输入输出。 其实啊，在这儿我想跟大家说明一下。正如刚才我们所讲过的， 其实描述一个问题是一件困难的事情。对于我们这个，outline的编程平台也是这样。 要在outline的编程平台上跟大家描述清楚，我要你计算一个什么样的问题， 也是一件不容易的事情。所以，很多时候啊，我们是要借助于输入输出数据，来 辅助我们描述这个问题。所以说当大家没有读懂题的时候，可以去好好研究一下这些输入 和输出数据。并且呢，你在做测试的时候也可以拿这些输入和输出数据当成测试数据来使用。 好，那么对于这个题，问题我们搞清楚了。解决方案呢，我相信每个同学都能够想得出来。 那么现在呢，我希望你去思考一下，如果我把这个解决方案写成程序的话，那个程序会长成什么样？ 你要先想一下，想象一下。 我是这样去思考的。 你看在这个题目里头啊，有很多组的输入数据，我可以意识到 哎呀，这个题目的输入可能还不是一个特别简单，一下子就可以解决的问题。 但是呢，我先把这个问题啊，给它剥离出来，我先不考虑这个输入， 先考虑如果我获得了每一组的一个输入的时候，我应该怎么去处理？ 先考虑这个问题。在这个题里头呢，一共有两问。那我们就是分情况讨论。 所以，这个程序会有很多的分支。 那在我们脑子里大概会长成这样子。首先我拿到一个脚数， 啊，那如果这个数是一个奇数的话，那就是错了，我就按错误来输出。 如果是个偶数的话，那就对了，那我接下来再去分析。那么最多有多少只脚啊？最多就是，脚数除以2。 那最少有多少个？如果数目最少的话，那就要意味着，就是兔子， 也就是说脚数除以4，或者是最多的兔子加上1只鸡。 其实这个考虑已经非常非常的详细了，因为这个问题比较简单。其实我们只要想到是一些， 分支，啊，我靠分支可以解决，那这个问题就可以了，你不需要想太详细。 那么搞清楚了输入每一个脚数应该如何计算了， 我回过头来再去想，每一组输入数据，然后我就可以画这样一个圆， 反正这里头是一堆的分支， 然后外头呢，就是一个循环输入， 用来解决不同输入数据组数的这个问题。 大致的程序结构无非就是如此，甚至于你可以把这个图画的更简单一点， 那么读入数据之后，外层就是一个循环。 然后内层呢，是一些分支。就是这样的一个结构。 那么有了这样一个结构之后我再去写程序，它就会变得容易了。我们来看一下这个，这个例子的程序。 比方说，cin先输入测试数据的组数，然后呢，根据这个组数建立一个循环。 对于每一个特定的脚数， 就是这个脚的数目，那么去考察，是不是，偶数啊， 那如果不是，就按错误来输出；那如果是的话，问能不能，%4能不能等于0啊？ 如果是，怎样，如果不是，怎样。 这个程序就写完了.所以说，你看，只要我们先明白了一个程序的结构， 然后我们再去写这个程序。这个事情就变得容易多了，这是这样的一个例子。 
```c++
#include <iostream>
using namespace::std;

int main(void)
{
    int nCases, i, nFeet; //nCase表示输入测试数据的组数，nFeet表示输入的脚数
    cin >> nCase;
    for(i = 0; i < nCase; i++) {
        cin >> nFeet;
        if(nFeet % 2 != 0) //如果有奇数只脚，则输入不正确；因为不论2还是4只，都是偶数
            cout << "0 0" << endl;
        else if(nFeet % 4 != 0) //若要动物数目最少，使动物尽量有4只脚；若最多，尽量2只脚
            cout << nFeet / 4 + 1 << " " << nFeet / 2 << endl;
        else
            cout << nFeet / 4 << " " << nFeet / 2 << endl;
    }
    return 0;
}
```
- 接下来呢，我们再来看一个例子。 那么这个例子呢，叫做百元买百鸡问题。这个问题是这样的，假设说啊， 我们要到农贸市场上啊，去购买一些鸡，那么假定呢，小鸡每只0.5元， 公鸡呢，每只2块钱，母鸡呢，每只3块钱。 当然这个物价水平跟现在的物价水平相去甚远，哈，现在给你呢，100块钱， 要求呢，买100只鸡。 需要你呢，写一个程序，来列出来所有可能的购鸡方案。 什么意思呢？就是说，这100只鸡里头，有多少只 小鸡，有多少只公鸡，多少只母鸡。 你要把所有可能的购买方案，都列出来。 这个题非常像我们小的时候做的应用题，对吧？哈。 那么看到这个题呢，凭我们对数学应用题的这种直感，我们很容易，就可以列出这样两个等式。 假设说我们要买的母鸡的只数是x只， 公鸡的只数是y只，小鸡的只数呢，是z只。 那么，首先x加y加z，一定要等于100。这是满足的第一个条件。 第二个呢，3x加2y加0.5z，所有的钱数加起来，也要等于100。 两个等式，三个未知数，我们可以知道，解决方案肯定是，不唯一的。 那，怎么才能找到所有可能的解决方案呢？ 这个时候啊，就要求我们啊，熟悉计算机解决问题的方式。 计算机解决问题跟我们不太一样。你比方说这个题，如果真的放到现实里头，让我们去解的话， 还真是有点不容易。因为我们总不能一个一个的去尝试吧？ 把x和y和z所有潜在的可能性全都试一遍？ 这个在现实里头是不可能的。但是，在计算机里头， 完全可以这样去做。这个方法叫做，穷举法，就是把所有可能出现的情况， 全部都一一测试，判断哪些是满足条件的，哪些是不满足条件的。 也就是说，我把潜在的所有的xyz它可能等于 的数，全部都试一遍，看看哪些是满足条件的。 这是完全可以的一个办法。ok，解决方案我们找到了。 那如果是针对这样一个解决方案，你想象一下，那个程序会写成什么样子， 稍微做一个思考。 既然我要尝试各种情况，所以，我要构造 一个循环。至于这个循环长成什么样我先不去想，反正它是有一个循环， 可以让我尝遍xyz所有的可能性。然后在这个循环的里面，我要去判定， x加y加z是不是等于100？3x加2y加0.5z是不是也等于100？ 是不是那个程序整体的结构就是这样啊？ 对，所以，这个程序整体的结构我们完全可以用这样一张图来表示。 首先我有一个循环。有同学说，啊呀，我还没想好，这个循环怎么才能 分别试遍xyz所有的可能性，这个没关系，待会儿我们再去想。 但是我们想出来，它至少是xyz所有的可能性，要试一遍。然后呢， 在每一次循环里头我要检查，是不是xyz加起来等于100。 是不是3x加2y加0.5z等于100。 如果是的话，打印输出，因为如果是的话，就一定是我们想要的方案之一。 所以说，整个的这个程序这样来写就可以了。有这样一个印象，就ok了，非常好。 那么接下来，我们再稍微详细一点，再去考虑这个问题。怎么才能试遍所有不同的xyz呢？ 那稍微做一个思考我们就可以知道，我们完全可以针对x，y 和z分别构造一个循环，然后把这三个循环给它套起来。 也就是说我们完全可以这样来做，尝试不同的xyz，我们针对x呢， 构造一个循环；针对y呢，再构造一个循环；针对z呢，再构造一个循环。 把它嵌套起来，这样的话，我就可以靠这三个循环把xyz 全部都列举一遍，然后呢每次做这样一个检查，符合条件我就输出。 那这样的话，这个程序的结构就变得非常清楚了，我们就可以直接来看这个程序了。 那么在这个程序里头，首先我们看到的3个for循环。这3个for循环啊， 就把xyz全部都罗列了一遍。先对 x进行循环，那么在这个循环里头呢，x从0到33， 有些同学说为什么要到33啊？因为从这个条件我们就可以看得出来，x最大也只能是33了。 那么，y呢从0到50，z呢，从0到100，因为从这个条件我们知道z不可能大于100. 有同学，啊呀，这个，这个算，太费劲了，没关系，你如果再嫌费劲的话，你这个地方完全可以写成100。 完全可以写成100，没关系的，让它多跑几遍，计算机跑得飞快，没有，没有任何问题。那么， 在每一次的循环里头呢，我去尝试这两个条件，看是不是同时成立。有同学说， 哎呀，我不知道会怎么去表达它同时成立。很好办啊，把两个if给它连起来，就可以了。 判断两次，if这个条件成立的情况下，这个条件也成立，那我就输出。 这就这个程序。 一旦我们清楚了程序的结构，我们就，很容易，来 写出这个程序来了。
```c++
/*百鸡问题一*/
#include <iostream>
using namespace::std;

int main(void)
{
    int x, y, z;
    cout << "\t母鸡\t\t公鸡\t\t小鸡" << endl;
    for(x = 0; x <= 33; x++)
        for(y = 0; y <= 50; y++)
            for(z = 0; z <= 100; z++) {
                if((x + y + z) == 100)
                    if((3 * x + 2 * y + 0.5 * z) == 100)
                        cout << "\t" << x << "\t\t"
                             << y << "\t\t" << z << endl;
            }
    return 0;
}
```
有的同学说，这个程序啊，太罗嗦，我想简化一下，也可以。 简化也可以，不简化也可以，比方说怎么简化呀？可以这样来简化，那么 for x从0循环到33，y从0循环到50，z呢，就不用循环了。 因为xyz满足加起来等于100的这个条件，所以说我们z就不用再循环了。 z呢，直接被计算出来，然后去检查，这个条件是不是满足。如果满足的话，输出。 那么写出这样一个程序，也可以，那么在这儿呢，我想提示大家的就是， 我们不在乎大家写出来的程序是不是最优的， 是不是得到了这样一个程序，或者一个更好的程序，我们不在乎这个。 那我们在乎哪些呢？前次课的时候我们已经讲过了，我们在乎你的程序 结构是不是清楚，你的程序是不是容易被别人看得懂。 这是我们所在乎的。 ok，这是这道题目。从这道题目我们可以看出啊哈 我们再次感受到，结构有了，那么写程序就会变得容易。 其次，有一些解决问题的方法，比方说，穷举法，在以往的，我们解决问题的这个， 过程中呢我们都不会采用的。但是呢，对于计算机而言，完全可以这样做，让它去穷举，这是可以。 
```c++
/*百鸡问题二*/
#include <iostream>
using namespace::std;

int main(void)
{
    int x, y, z;
    cout << "\t母鸡\t\t公鸡\t\t小鸡" << endl;
    for(x = 0; x <= 33; x++)
        for(y = 0; y <= 50; y++){  
          z = 100 -x - y;       //相对上版本的一点优化，少用了一次循环
              if((3 * x + 2 * y + 0.5 * z) == 100)
                  cout << "\t" << x << "\t\t"
                               << y << "\t\t" << z << endl;
        }
    return 0;
}
```
## 4. 体验结构化的程序--示例
- 我觉得这个程序写的非常的好。 有的同学说，啊呀，这个程序太罗嗦了，比第二个程序长了那么多，我们还以为你给的反例呢。 不是的，我是想要表扬这个程序。 那我的理由是什么的，待会我会告诉你，我们先来看这个题目，我们回顾一下这个题目，说输入10个1到100之间不同的整数， 他们彼此呢以空格分隔开， 要求你重新排序以后输出出来，按照什么要求去排序呢？ 第一：先输出其中的奇数，并且按照从大到小的方式把它排列起来 第二：输出其中的偶数， 并按照从小到大的方式给它排列起来。 说到这儿，可能有的同学已经注意到了，我给的这个例题，还跟作业题不是完全雷同的。 作业题呢是说，都是从大到小的方式。 我在这儿做了一个小的变化，奇数呢从大到小排，偶数呢从小到大排。 大家想像一下这个题目应该怎么做呢？ 如果不是让你来抄写这个程序，而是让你设计一个程序，你应该怎么做呢，在这儿我特别想 阐明一点，我现在虽然不要求你一下子能写出一个正确的程序来， 但是我真的希望你啊能够想象一下这个程序会是什么样的。 也许一些细节我还太会写， 但是整个的这个程序我能想像的出来是怎么让它去做的。 比方说对于这个题，我们不需要搞什么特殊的算法， 我们就用最平实的办法去解决就可以了。 首先，给了我们十个数，我们必须要把这个十个数先读进来，放到一个数组里头， 肯定是我们要做的第一步。 放好了以后，接下来刚好用上刚才我们给大家讲过的那道题， 把奇数和偶数给它区分开。 奇数呢放到一个数组里头，偶数呢再放到另外一个数组里头，放好两个数组， 那么接下来就更明确了，既然奇数和偶数都拆分开了。那我就分别对奇数的数组和偶数的数组再进行排序。排完序以后， 我再按照你所要求的方式去把所有的数打印出来。 是不是这么一个过程啊。那如果我们用刚才的那种方式把 我们的这个思路给它表达下来，那个思路就长成这样子。 一路的箭头。第一步，输入待排序的数据； 第二步，把奇数和偶数拆分开；第三步，对奇数组进行从大到小的排序； 第四步，对偶数组进行从小到大的排序；第五步 输出奇数组；那么第六步，输出偶数组。是不是这么来进行的？
```c++
/*奇偶输出问题*/
#include <iostream>
#include <iomanip>
using namespace::std;

int main(void)
{
    int all[10], odd[10], even[10]; //odd记录奇数，even记录偶数
    int i = 0, j = 0; //i,j为循环计数变量
    for(; i < 10; i++)
        cin >> all[i];
    int numOdd = 0;
    int numEven = 0; //numOdd,numEve分别记录奇数和偶数的个数
    for(i = 0; i < 10; i++)
        if(all[i] % 2 != 0) { //当前数为奇数情况
            odd[numOdd] = all[i];
            numOdd++;
        } else { //当前数为偶数情况
            even[numEven] = all[i];
            numEven++;
        }
    for(i = 0; i < numOdd; i++) //输出奇数
        cout << setw(10) << odd[i];
    cout << endl;
    for(i = 0; i < numEven; i++) //输出偶数
        cout << setw(10) << even[i];
    system("pause");
    return 0;
}
```
- 所以说呢，整个的这个步骤，在我们脑子里边非常的清楚。有的同学说哎呀我也知道是这么做， 但是这些细节我写不了， 我现在这个阶段我写不了什么奇偶分组，什么从大到小的排序。我写不了。 没关系，现在这个阶段你写不了没关系。你能想得到这样第一个结构， 我就已经非常高兴了，具体的程序写不了，我们可以，可以去抄程序。 所以在现阶段我们设计的作业呢，都是给大家去抄写程序， 没有一定要求你一定要把这个程序独立的正确的把它写出来。 关键的，是一定要养成这种思维的这种方式。 这是一个抽象程度比较高的思路， 其中的每一小步，都有可能是刚才我们做过的一个题目。比方说，奇偶数分组。 
```c++
/*选择排序法*/
#include <iostream>
#include <iomanip>
using namespace::std;

int main(void)
{
    int a[10];//用于存放输入的数据
    int i = 0, j = 0; //用于循环计数
    int temp = 0; //临时变量，用于暂存要交换的数据
    for(i = 0; i < 10; i++) //依次输入10个待排序的数据
        cin >> a[i];
    for(i = 0; i < 9; i++) //依次为数组的第i个元素选择最大的数
        for(j = i + 1; j < 10; j++) { //从第i+1个元素开始寻找比a[i]更大的数
            if(a[j] > a[i]) {//如果找到比a[i]更大的数，就将它与a[i]交换
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    for(i = 0; i < 10; i++)
        cout << a[i] << "    ";
    system("pause");
    return 0;
}
```
- 那么奇偶数分组呢我们刚才也给了一个这样的算法。 然后再说这个排序，你看，这个小的步骤里头， 就包含了这么一些小的程序， 这个小的步骤里头包含了这样一些程序。 你看我们去思考这个题目的解决方案的时候，我们总是先从一个抽象程度比较高的地方开始去想， 我们先不去管这些细节，甚至于我们可以把这个题目交给好几个人去做， 有一个人负责总体设计，我就设计一二三四五六，六步。 然后呢，第二部，交给一个同学去做， 第三步和第四步交给另外一个同学去做。我就可以把它组合成一个 大的程序。有了这样一个构想以后， 我们就来看一下这个题目具体的程序。这个程序写的非常的有特点。 虽然这个程序非常长，但是刚才啊我跟大家说过， 我说这是一个优秀的程序，我为什么这么讲呢，我们来观察一下。 我们来看一下这个程序是怎么做的。首先， 先把数据输入进来，这是刚才我们说的第一步。 然后呢，对奇数和偶数进行一个分组，这是刚才我们说的第二步； 再往下，先对奇数进行排序， 这是我们说的第三步；再对偶数进行排序， 这是第四步；然后呢，输出奇数组， 这是第五步；最后输出偶数组这是第六步。 看到这个程序了吗，这个程序非常的清楚。这是第一点我喜欢它的地方。它的结构 非常非常的清楚，我喜欢它的第二点， 更重要，这个程序有一个非常非常好的特性。 什么样的特性呢？他把每一步的操作， 都写到一个独立的部分里头完成了。 你比方说输入，从这开始，到这结束。这段里头就解决完了输入的事情。在这段程序里头我不做其他的事情。 再看第二段，从这开始，到这结束。我就解决完了 奇偶数分组的事情。在这样一段程序里头，除了奇偶数分组的事情，其他的事情我也不做， 专注做好这一件事情，我们再往后看第三个。 第三个呢，这部分里头我只负责对奇数组进行由大到小的排序， 只做这一件事情，其他的事情不做。这个范围是从这到这。再看第四， 从这到这，这个范围里头，我只做，对偶数数组进行排序的事情，其他的事情也不做。 那么第五第六段也是，在这只输出奇数组， 在这只输出偶数组，其他的事情一概不做。 这样做有什么好处呢？大家看这个程序。 在写程序的时候，我们总担心程序会出错。 我们看，观察一下这个程序。要想验证这个程序里头有没有错误， 或者是说我想确认，哪一步出现了错误，对于这个程序而言，非常好确认。 比方说，输入。在输入完了之后我就可以在这加一个断点， 或者插入一行程序，把当前的数组里面这个结果打印出来，看看我输入有没有错误。 这是第一个。第二个，在完成了奇偶分组以后， 我也可以插入一段代码或者是插入一个断点，把奇数组和偶数组 分别打印出来，看看我分组有没有问题。 如果分组没有问题,OK，接着往下再进行。 在奇数组排序结束以后，我照样可以看一下，到底是这个过程有没有错。 偶数组排序完了，再看一下有没有错。 也就是说，也就是说整个这个程序可以被拆分成一块一块一块的。 块与块之间没有过多的联系， 每一块都完成一个独立的任务。 所以说，这个程序是一个结构性非常好的程序。 我们非常乐于见到这样的程序。 通过这个程序我们可以感受到 结构化设计所带来的好处。 好，那么借着这个程序呢，我们来总结一下， 通过这个程序我们可以感受一些怎么样的思想。 
```c++
/*整数奇偶排序输出*/
#include <iostream>
#include <iomanip>
using namespace::std;

int main(void)
{
    int all[10], odd[10], even[10]; //odd记录奇数，even记录偶数
    int i = 0, j = 0; //i,j为循环计数变量
    for(; i < 10; i++)
        cin >> all[i];
    int numOdd = 0;
    int numEven = 0; //numOdd,numEve分别记录奇数和偶数的个数
    for(i = 0; i < 10; i++)
        if(all[i] % 2 != 0) { //当前数为奇数情况
            odd[numOdd] = all[i];
            numOdd++;
        } else { //当前数为偶数情况
            even[numEven] = all[i];
            numEven++;
        }
    //对odd选择排序
    for(i = 0; i < numOdd; i++) {
        for(j = i; j < numOdd; j++) {
            if(odd[j] > odd[i]){//设定排序方式
                //tmp为临时变量
                int tmp = odd[i];
                odd[i] = odd[j];
                odd[j] = tmp;
            }
        }
    }
    //对even选择排序
    for(i = 0; i < numEven; i++) {
        for(j = i; j < numEven; j++) {
            if(even[j] < even[i]){//设定排序方式
                //tmp为临时变量
                int tmp = even[i];
                even[i] = even[j];
                even[j] = tmp;
            }
        }
    }
    //输出奇数
    for(i = 0; i < numOdd; i++) {
        cout << setw(10) << odd[i];
    }
    cout << endl;
    //输出偶数
    for(i = 0; i < numEven; i++) {
        cout << setw(10) << even[i];
    }
    system("pause");
    return 0;
}
```
- **首先啊，我们能够体会到，写程序， 是一个由大到小由粗到精由抽象到具体的 这么一个过程。就是说，从你分析问题到写出程序， 是按照这样一个过程来进行的。其次，对于程序的结构而言，我们可以 感受到，好的程序是由若干个模块来构成的。 也就是说你写的程序最好能够被清晰的拆分成 很多个模块，而且呢这些模块之间应该满足这样一种关系。 就是说，模块之内，应该是高内聚的；模块之间应该是低耦合的。 什么叫做高内聚呢？刚才这个程序就是一个最好的例子。 所谓高内聚就是这个模块我只干这个事情，不干别的， 功能单一，这是关于高内聚的一个非常好的例子。 那么模块之间应该低耦合。什么叫低耦合呢？ 就是说当一个模块被改动的时候， 它只会影响它自己，而不会影响其他的模块。 像刚才我们的这个程序，也是这样的。当一个模块被改动的时候，不会因为这个模块错了下面的程序也接着错， 不会造成这个结果。 这就是高内聚低耦合。 其实啊，我们在这里讲的，就是结构化程序设计的基本思想。** 这就是我们希望向大家传达的这种思想， 也是我们让大家去抄写这个程序的原因。OK，那么这个例子呢我们就 讲到这。我们希望啊， 同学们能在课下，勤加练习，还是那句话，多做简单的题。 大家通过刚才这个例子就可以看得到了，其实复杂的题目 都是由简单的题目来构成的，所以说做好了简单题你才有可能 去做复杂的题。如果简单的题做不好，等到接触到了复杂问题，你就没有 办法处理了。所以说一定要多做简单题。
## 5. 课后作业
```c++
/* 给定一个十进制整数N，求其对应2进制数中1的个数*/
//这道题的解法就是反复地除以2，看最低位是1还是0。有些知道位运算的同学喜欢用位运算，但其实没必要，因为编译器优化之后的程序其实效率是一样的。
# include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; 
    for (int i = 0; i < n; i++) {
        int x, ans = 0;
        cin >> x;
        while (x > 0) {
            ans += x % 2;
            x /= 2;
        }
        cout << ans << endl;
    }
    system("pause");
    return 0;
}
```