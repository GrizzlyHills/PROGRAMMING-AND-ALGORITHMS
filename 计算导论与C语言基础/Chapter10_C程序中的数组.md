# [C程序中的数组](https://www.coursera.org/learn/jisuanji-biancheng/home/week/10)
> 在学习了C程序语言的几种重要的构成成分之后，为了帮助大家能够更好地使用已经学到的C语言成分编写程序，我们再介绍一种非常重要的数据结构——数组。 本部分的重点在于：掌握数组的定义、引用方法，并掌握数组的基本作用。特别的，需要大家掌握利用数组的下标来解决问题的“技巧”。
## 1. 再谈一维数组
- 好，各位同学，在我们理性认识C程序这一部分的最后 我们专门拿出一段时间来专门说一下数组。会有同学可能要问了。 为什么单单拿出数组来讲一讲呢？原因非常的简单，那是因为数组是我们最常用的一种数据结构，也是到目前为止我们所学过的最复杂的一种数据结构。那么关于数组的使用呢 还有一些事情想要告诉大家。所以说我们专门拿出一段时间来说一下数组。首先我们来回顾一下数组 的定义。关于数组的定义大家都已经非常的熟悉了。 那么写一个变量名在前头给数组起个名字，然后在这写一个常量表达式 好那就定义了一个数组了。拿这儿需要说明的就是数组的名字也是跟我们以前讲过的标识符，它的定义方式是一样的。 就是必须以下划线或者是字母开头，其它的都不行。 这儿再啰嗦一句，无论我们在什么时候定义数组我们都一定要注意下标的问题。比方说我们定义10个元素的一个数组，那么它的下标 是从0开始，一直到9，那就是一个任何时刻都必须要注意的事情。 因为在写成这个过程中非常容易犯错误。ok这就是数组的定义。
- 那么关于数组的定义呢，我们补充几点说明。 
  - 我们首先来看一个例子。在写程序的时候 我们时常碰到这样的情况，在我们定义一个数组的时候 我们并不一定能确切的知道这个数组应该有多大，当然最合适的大小是既不浪费又不能产生不够用，但是我们很多时候都不知道一个数组该多大。所以在这种情况下我们通常的做法是定义一个足够大的一个数组，对吧？有的同学觉得这有点浪费，那我能不能定义一个长度可变的一个数组呢？比方说在这个程序里头我就先定义了一个变量N然后呢我把数组的大小只定义成变量N。那么这样做在C++里头允许不允许呢？**非常明确这种情况是不允许的，在C++里头。 因为在数组的定义里头这个地方必须要出现一个常量表达式，必须是一个常量表达式**。但是有的同学说我还是 很想把数组的大小约定下来，比方说我在写一个程序的时候，一开始我就定义了一个数组的大小，我底下for循环语句我都是按那个大小去写的，如果这个数组的大小后面又发生改变的话 那么所有的语句我都需要改，至少让我改一个地方就能把数组的大小给改了在这个程序里头。 OK有这个需求很好，我们提供两个办法，第一个办法，你可以写一个这样的程序。 看一下现在这一个程序跟刚才那个程序有什么不同。在这儿呢我仍然定义了一个 看上去好似变量的一个标识符I，那有些同学这样做行不行呢？ 标识符i在这儿定义的是一个什么？我们以前讲过，这个叫做符号常量。 Constant int，i，它是一个符号常量。这样呢定义一个i，然后把这一个i写在这里。 那么在以后的所有的程序里头只要提到数组的大小的我都可以使用这个i来代替。 如果我发现我的程序写着写着这个数组的大小应该变一下啦，都不够用了，那怎么办呢?我只需要改 这一个数字就可以了。const i 后面所赋的这一个数值就可以了。当然首先要说明的是 这种方式不是说定义了一个可变长段数组，那么在我们这个课上所学的这个C语言里头 是不支持变长数组的，那么通过这种方式呢我们可以指程序的修改变得简单一些。 出了这种方式之外还有一种方式，就是说如果我不想在这里定义一个符号常量 那么你可以使用这种方式。看这个程序，这个程序看上去有点跟以前的不一样了。它的改变出现在这，以井号（#）开始写了一个define N 4，那么这句话呢出现在 main函数的前头，并且以井号（#）开头，这属于程序的预定义部分。 预定义部分。那么在这个部分呢我们可以定义一个标识符 N，这句话的含义就是这样的，就是在这个程序里头我定义了一个N。 在程序的任何一个地方只要碰到N我就可以把它当作4来看待。 这就是一个define N 4 的含义。比如说我定义了一个标识符N 它的含义跟4是一样的，用一个通俗一点的词就是说，给4这个字面常量定义了一个马甲。 这个马甲呢名字就叫做N。那么只要在以后的程序里头见到了大N，无论它出现在什么地方，我都把这个大N当作4来看待，这就是这个程序的这个含义。通过这种方式我们也可以实现对数组大小的一个比较方便的修改。那么这是关于数组的定义我们想要补充给大家的。
  - 那么在我们定义完一个数组之后呢通常我们要对数组进行初始化。 比方说我定义了一个数组a[10]，把所有的元素 列举出来，那么这个定义过后呢我们就可以得到一个这样的数组了。 包括10个元素，然后每个元素都赋好了值，那么这个呢是数组的初始化的最基本的方法。 那么关于数组的初始化在这儿我们也有几点想要告诉大家的。
     - 第一，一个数组能不能不去初始化？比方说在这个数组里头我定义了一个数组。 a[4]，但是呢我没有对它进行任何的初始化，然后呢我就把它的各个元素打印出来。 你们觉得会打印出什么东西来？这个情况就很类似于我们以前讲过的 整数的定义了，因为这里头每一个元素都是一个整形的元素。 然后整形的元素不仅仅就是花了所得到的结果或是什么来着，然后是一个 这样的结果。每一个都是一个非常大的一个负数。 每一个都是一个非常大的负数。有同学可能要问了，那为什么是这样的一个数呢？那是因为在 VC底下对于一个没有进行任何初始化的一个整数，那么程序呢自动的给它赋一个初始的值。 赋这个值的目的就是为了对程序的安全性进行一个保护，以后讲到指针的部分，我们还会提及这一个问题。OK这是不进行初始化的说。 那有些同学说我还见过一些奇怪的初始化，比方说有些时候写成这样子。 
     - 我定义了一个数组，在这儿呢我没有写任何的常量表达式，在后面呢我把这个初始化的结果写出来了。 这样可以吗？这样完全可以，这样是允许的，因为你在后面，在初始化的部分 给出来了明确的数组元素的个数以及每个元素是什么，所以说在这儿 允许你不写任何值。当然你不写的时候你所得到 的那个数值的大小跟你初始化的元素的个数是一样的。 所以说这个程序执行完了以后你会得到一个这样的结果。一个数组放好值了，那有些同学可能立刻就会 想到了那如果我定义了一个数组并且指定了它的大小 但是初始化的时候呢我只指明了部分元素 那会怎样呢？我们来看一个程序。看这个程序。我定义了一个数组，它的大小是4。 但是呢初始化的时候我只给了两个值，那这样会怎样呢？ 首先告诉大家这一种方式也是很常见的一种方式。 那么在很多变异性底下它是这样来处理的。那么在这个数组里头前两个元素都进行了初始化。 那么剩下的元素统统被赋值为0。 也就是说当你只指定部分元素的时候，剩下的元素 将自动被指定为0。那么这是数组初始化的时候很常见的一种特性。 甚至在很多程序里头我们是利用这种特性对数组的所有元素 来进行初始化的，比方说我们看这个程序`int a[4] = {0};`。在这个程序里头我定义了一个数组a[4]。 然后呢我只指定了一个元素0，OK，通过这种方式我就会得到一个 这样的数组。也就是说这句程序执行的结果就使得我得到了一个数组，数组中的每一个元素 都被赋值为初始之0了。这是在程序里头 很常见的一种初始化方法，我们可以利用这种方法 把一个数组中所有的元素全部初始化为0。 
     - 那么说到这儿有的同学可能又要问了，你给的情况都是说 指定的元素比数组大小要少，那如果多了呢看一个程序，比方说在这个程序里头 我定义了一个数组a[4]，但是给值的时候，给它初始化的时候我初始化了123456。 多初始化了两个原素。那结果会怎样呢？ 结果也非常的简单。编辑错误，它会告诉你数组下标越界。 好，这是关于数组初始化的几个需要注意的地方。 各位，这是关于一维数组的初始化。 
## 2. 二维数组
- 有一维数组呀，也就有二维数组。什么叫一维 数组，二维数组呢？也就是说，以前我们所定义的这个数组啊， 都是用来存放一串数的。 这些数呢，是按照一个线性的排列放在这个数组里头的。 有的时候啊，我们很想定义一个结构来存放二维空间里边的一些序列。 比方说我们想定义一个这样的结构，就像一个表一样，把一些数啊， 排列在一个二维的空间里头。那怎样才能够定义一个这样的结构呢？ 很简单，我们就可以通过第一个二维数组来实现。在这儿呢，我们就定义了一个二维数组。 数组名字呢，是a。后面呢，出现了两个长列表达式， 写了一个3，4。 通过这种方式， 我们就定义了一个三行四列的一个二维数组。一个三行四列的二维数组，当然我可以存放十二个元素。 然后每一个元素呢，我都可以通过数组名加上下标的这种方式去访问。 数组的下标呢，仍然是从零开始的。
- 我们来观察一下，数组元素的 引用方式。看第一行，在第一行中啊，四个元素分别叫a[0][0]， a[0][1]，a[0][2]，a[0][3]。 看这个元素啊，我们就可以感觉得出来，实际上变化的只有后面一个括号里的东西。这就给我们一个提示，我们其实可以这样来看： 当我们定义一个三行四列的数组的时候，其实我们就得到了 三个一维数组。第一个一维数组的名字叫做a[0]，第二个一维数组的名字是a[1]， 第三个一维数组的名字是a[2]。 所以说，在第一个数组里头，那么数组的元素都是a[0][1]，a[0][2]，a[0][3]， 啊，是这样的。第二个数组里头，那么所有的四个元素就是 a[1][0]，a[1][1]，a[1][2]，a[1][3]. 所以说啊，其实二维数组也没什么特别的。它只不过是定义了三个一维数组而已。 那有的同学可能要问了，一**个二维的数组在内存里边，因该怎么去存呢？ 那我们来看这个图。一个二维数组在内存里边如何去存储呢？ 方法很简单。在内存里头存储的时候啊，它是把一个数组啊， 拉平了，拉成一个线性的一维的结构，来存储的。 比方说，对于这样一个数组，其实存储下来之后，就变成了这样一个序列。 这样的一个存储方式啊，我们也可以这样来理解： 正如我们刚才说讲过的， 这个二维数组就相当于三个一维数组。那么对于一维数的存储，我们很熟悉了，一维数组无非就是把它 一次排开，存放在内存里头。那么实际上呢，二维数组也是这样来存储的**。比方说，这个一维数组我就把 它一次排开，存在内存里头。 然后这个一维数组呢，我也把它一次排开， 存放在内存里头。这个也是，存放在内存里头。是这样的一种存放的方式。 也就是说，那么二维数组的存放，是把它拉成一条直线，然后呢，存放在内存内了。 Ok，这是关于二维数组的定义。 那么了解完了 二维数组的定义，我们再来了解一下二维数组的初始化。 先来看一段程序。其实二维数组的初始化呀，非常非常地简单。比方说， 我们定义一个三行四列的一个二维数组，我们完全可以通过这种方式，来进行初始化。也是用大括号来赋值，只不过在这个大括号里头我们明确的用 内层的大括号，说明了每一行包含那一些元素。通过这种方式我就 明确地指定了每一行的每一个数字，应该是多少。 
- 那么初始化完这个数组以后啊，我们再来看一下这个数组的输出。那大家都知道，我们在打印一个一维数组的时候是通过for循环 来完成的。 那么打印一个二维数组呢，也一样，我们通过两个互相嵌套的for循环就可以打印 出来。然后第一个循环，for，从0到3，表示对每一行。然后呢，第二个循环， j从0到4，表示对每一列。每一行每一列，这样的话我就可以把十二个数，全部都打印出来。在这儿，在这个程序里头，细心的同学可能观察到有几点跟以前我们看到的程序呢， 不太一样的地方。我们来分别说一下。第一个感觉不太一样的地方，是这儿。就是说，当我们去写一个循环 的时候，我们通常要定义一个临时的，用来记录循环次数的变量。比方说，我们习惯性的可以用i。 那么在这呢，我把这个变量的定义啊，放在for循环的这个括号里头了。 这样做可以吗？这样做可以。而且啊，在程序里头， 如果明确的有一个变量，比方说i，它只用在这个循环里头的话，那么， 很多程序也习惯性的，可以写成这样子。这样做的好处是什么呢？那么在C++ 的环境中， 当你按照这种方式来定义一个临时变量的时候，那么这个临时变量起作用的范围就在这个 for循环里头。这样呢，我就可以保证不同的for循环之间的临时变量都是 互相不干涉的，反正有这样一个好处。同理，在内层的循环里头，我也定义了一个 临时变量，int j 等于0。这个临时变量起作用的范围呢，就是这个for循环。 那在这儿呢，想告诉大家的就是， 这种方式呢，是很多程序员的一个习惯。你如果想这么做的话呢，也可以。 第二个想告诉大家的是通过这种方式来定义变量啊，它这个作用域，到底是不是 在这个for循环的范围之内？不同的编译器，可能有不同的结果。在有些编译器里头啊， 并不把它的作用范围啊，仅限于当前的这个for循环。有可能是 从这个变量定义的时刻开始往后，整个程序里面都会起作用。 有的编译器是这样的。所以，大家如果使用这种方式来定义变量的时候，一定要搞清楚 这个变量的作用范围。那么同学说，我怎么搞清楚啊？很简单，写一个程序，试试， 就知道了。那么第二个这个程序跟以前的程序不太一样的地方在这儿， setw（3）。 这什么东西呢？它是一个输出控制符。它的含义是什么呢？ 它的含义是说啊，要保证后面输出的这个 东西在屏幕上所占的字符宽度。 比方说在这儿，我设定了一个3，那也就意味着，后面输出的这个量，在屏幕上 至少要占三个字符位。比方说，如果我输出的是1的话， 其实我占了三个字符位。如果是2的话，我也占了三个字符位 。3，三个字符位， 4，三个字符位。使用这种方法有什么好处啊？ 好处很简单，就可以把输出排列地很整齐。 
- 那么回到刚才的话题，在这呢，我们给出了 一种用来对二维数组进行初始化的方法。就是用大括号，把它们明确地写出来。那么除了这种写法以外，还有一些写法， 也是允许的。 比方说，你不去写内层的大括号，也是可以的。当你指定了三行四列， 在这种情况下，即使你不把内层的大括号写出来，程序也非常清楚，你所给出来的这些数字 跟二维数组的元素之间的对应关系。所以说 这个时候呢，内层的大括号，你可以省略。 其实不单是内层的大括号可以省略，还有一个东西，就是这儿。 这个3， 你照样可以省略。那为什么它可以省略呢？首先，我在这儿给出来了初始化的所有数据的一个列表。 其次呢，我在这儿我又指明了每一行的元素的个数。 那么二维数组每一行中元素的个数应该是一样的。 于是初始化的过程就是这样来进行。 那么既然这儿写的是4，我就开始数，啊，四个元素呢给第一行，后面的四个元素呢，给第二行。 再数四个元素呢，给第三行。还有吗？啊，没有了。有的同学问，如果还有，怎么办？ 比方说，还有13，14，没关系，我就继续往后数，只剩两个元素的，我知道 这两个元素因该给第四行。而且第四行后面的两个元素应该是个空元素。 所以说在这种情况下，就算你不去指定二维数组的行数，我照样可以完成初始化。 所以说这种情况，也是允许的。那么除了这种情况之外啊， 我们还可以对二维数组中的部分元素进行初始化。比方说看这个程序。 在这个程序里头，二维数组的初始化被写成了这样子： 首先，在这个初始化的过程中，我指出了 二维数组中每一行中所包含元素的个数。 然后呢，我用内外层大括号说明了每一行因该包含哪些元素。 同时呢， 每一行里头我只给出了部分元素的值。那这种写法让我很清楚，这是第一行 的元素的值。那么，既然第一行元素的值给出了一个1，那么剩下的第一行的元素我就给它赋成了0。 这个呢，对应了第二行的元素。那么第二行给出了两个元素0，6， 那么剩下的就是0，0. 第三行呢，我们给出了三个元素，0，0，11。 那么对应了这儿，我就缺省的第四个元素我就把它值成了0.于是呢，通过这种方式 我们就对这个二维数组的部分元素进行了初始化。啊，这个是允许的。那说到这儿，既然我们可以通过这种 方式对二维数组中的部分元素进行初始化， 初始化完了以后呢，其他的元素就被赋值为零了。 那么，照样对于一个二维数组而言，我也有一 种简化的，把它的元素都赋零的方式，就是这样的： 定义一个二维数组，然后呢我在这儿直接用一个大括号写 出来，0。这种方式允许吗？当然是允许的。 因为我只给出了一个元素，那么，二维数组中其他所有的元素都被值成0， 这是它的结果。当然，在这种情况下我必须要清楚地说明这个二维数组的行数 和列数，否则的话程序根本就不可能计算得出来。 那么除了这一些，对二维数组进行初始化的方法以外呀，有的时候我们还 利用二维数组的下标，作一些文章。比方说，当我们想得到 一个这样的二维数组的时候，这个时候啊，我们就可以利用一下 二维数组的下标和你要赋的值之间的对应关系。比方说 这个程序可以写成这样子`int a[3][4] = {0};`。定义了一个三行四列的数组并且初始化成全0。 然后呢，通过两个循环的嵌套，完成对数组中每一个元素的一个初始化。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a[3][4] = {0};
        for(int i = 0; i < 3; i++)
            for(int j = 0; j < 4; j++)
                a[i][j] = 4 * i + j + 1;
        for(int i = 0; i < 3; i++) {
            for(int j = 0; j < 4; j++)
                cour << setw(3) << a[i][j];
            cout << endl;
        }
        return 0;
    }
    ```
  比方说在这儿的时候，为了把每一个元素都赋值成1 到12 之间的某一个数， 我就用了这样一个算式，4 乘以i 加上 j 再加上1。那么这一个算出来之后呢，恰好是对应着这里头的这些值。啊，这个例子就可以告诉我们，我们在初始化一个数组的时候啊，可以去利用数组下标的这样的一些变化关系。Ok，这是关于二维数组的定义和初始化。 
## 3. 三维数组
- 那么有了二维数组啊，我就可以在二维数组的基础上再去定义三维数组。 比方说啊，既然我们可以把二维数组看作 多个一维数组所组成的一个集合，那么， 三维数组也可以这样来看待。比方说，我先定义一个二维数组 a[3][4]，然后，接下来呢， 我再定义一个二维数组 a[3][4] ，再定义一个，再定义一个， 再定义一个，定义了五个二维数组。 然后呢，我给这些二维数组都取上名字，第一个数组命名为 a[0], 第二个数组 a[1]， 第三个数组 a[2], 第四个数组 a[3], 第五个数组 a[4]。 通过这种方式，其实我就完成了一个三维数组， int a[5][3][4] 的一个定义。也就是说我们就定义了一个 三维数组。那有的同学可能就困惑了， 说 a[3][4] 我很好理解啊，3 行 4 列的一个数组。那 a[5][3][4] 我怎么去理解呢? 也很好办，我们看一个图。 假设，这个立方体就对应着我们刚才所定义的这个三维数组。 这个立方体呢，它的高是 3 ， 它的宽呢，是 4 ， 它的深呢，是 5。 如果我们把 a[5][3][4] 这样一个数组看作这样一个立方体的话， 那么，这个立方体啊就可以被切成很多 ”片“ 。比方说像切豆腐一样，我就可以把第一块切下来。 那么这样一片呢，就对应了一个二维数组 a[3][4]。 也就是说啊，对于一个三维数组，我们可以这样来理解。 这第一维啊，表示了这个三维数组包含多少片。什么叫片呢? 这就是一片。然后呢，它的第二维说明了每一片里头包含 多少行，那么这个呢，就对应着二维数组里面的行数。 那么最后一个呢，是说每一行里头包含多少列。 啊，对应着这个 [4] . 。 这就是三维数组的一个含义。它的关键就在于，你完全可以把 这个定义为想象中很多片。所以说啊，对于一个这样的三维数组，我们完全可以把它切成很多片。比方说，看这个图。一下子我给它切成了五片。 那么每一片呢，都是一个三行四列的二维数组。 然后每一片呢，都有一个标识。第一片是 a[0], 第二片 a[1] ，第三片 a [2] ，第四片 a[3] ， 第五片 a[4]。 那三维数组跟二维数组之间，是这样的一种关系。
- 那么有了一个这样的数组以后， 我怎么在内存里头把三维数组给存下来呢? 那么有了刚才二维数组的存储方式， 同学们也就不难想象三维数组的存储方式了。比方说这样一个三维数组我就可以这样来把它存下来。 因为我可以切成二维数组，所以说我可以把每一个二维数组 都存放在一片区域里头。比方说，我们可以把这个二维数组，啊可以存放在这样的一个区域里头。 把第二个二维数组存放在这样的一个区域里头。 第三个二维数组呢，再存放在这样的一个区域里头。 第四个二维数组呢，存放在这个范围里，等等等等。啊，也就是说， 我把三维数组切成二维数组来存储。然后二维数组呢，我拉成一维数组来存储。于是在内存里头，无论你是一维数组，二维数组，三维数组，全部被拉成一条线来存储。啊， 这就是它的存储方式。
-那么了解了三维数组之后，有的同学可能就要问了，我能不能定义四维数组啊? 当然可以。你可以定义四维，五维， n 维数组，都可以。但是，你要知道， 定义维度更高的数组那一类的这个数组到底是怎样构成的将会更难以想象。于是，它会严重的影响程序的可读性。所以说，除非在非常特殊的情况下，真的不要去企图定义一个三维以上的数组。 啊，因为它非常的难以想象从而写的程序难以被别人读懂。而且，写这样的程序， 本身就是一个非常容易犯错误的过程。所以说， 至少在这个课程，我们不要去定义三维以上的数组。 而且，就算三维数组，在这个课程也要尽可能少的去使用。 因为我们的目的是要写出更有生命力的程序。 
## 4. 数组的作用之一
- 好，关于数组我们讲了这么多，那么数组到底有什么用呢？ 当然数组可以用来存储数据来用。当你想存储一串数的时候，多个数据的时候 那么你可以使用一个数组来完成。这是我们已经知道的作用。那么除了这个之外，还有一些什么样的作用呢？ 那么下面我们就通过几个例子 来看一下数组的另一种非常常见的使用方式。 
- 来看一个例子。第一个例子。这个例子是这样的，它是一道题目，在iii有非常类似的题目。 这个题目是这样的。输入20个0到9之间的整数。 当然在这儿为了简便我对原题做了一个简化。 原题应该是输入1000个0到50之间的整数。在这我们做一个简化。 那道理是一样的。输入20个0到9之间的整数，随机的在键盘上输入一些这样的数目。 然后呢请你统计每个数在输入数列中出现的次数。为了说明这个 提议，我们先来举个例子，看一个输出。 比方说，我在键盘上键入了一堆0到9之间的数， 这是我的输入。希望你输出什么呢？希望你输出一个统计的结果。这个统计的结果长成这样。 说2输入了多少次，3输入了多少次，等等等等。 也就是说每一个出现在输入序列里面的数字 分别出现了多少次，请你把它打印出来。没出现的就不用打印了。 理解这个提议了吗？这个提议还是比较简单，就是说在键盘上输入 0到9之间的一些数，请你统计一下每个数出现的次数。 怎么做呢？这个题并不难，我想大家很容易就可以想到一个解决方案。 至少我可以这么做。首先我们可以利用一个数组来记录 每个数都出现了多少次。比方说我们可以使用这样的一个数组来计算每个数出现的次数。 这个数组的下边呢就代表了相应的数字。然后在数组里头未来的这个值 就代表了每个数字出现的次数。这个是大家不难想到的。那么定义好这样一个数组之后呢 对于每一个数务的数，比方说这个5吧，我都去判定一下它到底是0到9之间的哪一个数啊？ 如果是最后判定出来，哦是5，那我就给这个5这个地方做一个++。可不可以呀？好这是一个最传统的方法。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int num, count[10] = {0};
        for(int i = 0; i < 20; i++) {
            cin >> num;
            count[num]++;
        }
        for(int i = 0; i < 10; i++) {
            if(count[i] != 0)
            cout << i << "输入了" << count[i] << "次" << endl;
        }
        return 0;
    }
    ```
  那么这个程序呢就可以写成这样子。 首先第一个数组，用它来存放每个数的输入次数。 然后呢对于输入的每一个数我都干什么呢？我都用一个循环来检测，看这个数跟10个数里边的哪个数是相等的呀？ 好如果它跟某个数是相等的，我就把 数组里头与这个数显对应的那个原数的值增加1。 那么这个程序执行完了之后在数组count 10里头我就存放好了 每一个输入的数它出现的次数。最后我就打印输出就可以了。这是我们 最容易想到的一个程序。 或许有些同学可能就已经察觉到了这个程序里头每输入一个数据就用这样一个循环 来判定跟哪个数相等，实在是太费劲了。其实这个地方完全可以以供就10个数嘛。 所以说我完全可以用switch语句来解决。比方说我可以写成这样子。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int num, count[10] = {0};
        for(int i = 0; i < 20; i++) {
            cin >> num;
            switch(num) {
            case 0:
                count[0]++;
                break;
            case 1:
                count[1]++;
                break;
            case 2:
                count[2]++;
                break;
            case 3:
                count[3]++;
                break;
            case 4:
                count[4]++;
                break;
            case 5:
                count[5]++;
                break;
            case 6:
                count[6]++;
                break;
            case 7:
                count[7]++;
                break;
            case 8:
                count[8]++;
                break;
            case 9:
                count[9]++;
                break;
            default:
                NULL;
            }
        }
        for(int i = 0; i < 10; i++) {
            if(count[i] != 0)
            cout << i << "输入了" << count[i] << "次" << endl;
        }
        return 0;
    }
    ```
   对于你输入的每一个数，我可以构造一个switch语句，把这个数放在switch后面的表达式里头。 然后呢，case，当这个数等于0的时候我就count 0 ++。当这个数等于1的时候，我就count 1 ++。 当这个数等于9的时候，我就count 9 ++，以此类推。 那么通过写10个case那我就可以解决这个问题了。 这样做行吗？行，非常好，而且这个程序它可读性还非常强。 效力呢也非常高，这是一个不错的程序。 那么还有的同学可能想到了更简单的方法。 这个更简单的方法是什么样呢？我们来看一下，看这个例子啊。比方说我现在输入的数据 是7，我读到的数据是7。那么我们最终要在哪进行 我们希望要在哪儿进行++？是不是我们就希望在a[7]这个地方进行++？ 对吧？所以说我们输入的数字是谁 我就希望对谁进行++运算。 这本身就是一个非常好的规律。这个规律完全可以用程序直接表达出来。那这个程序的主体呢就长成这样子，只有一句话。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int num, count[10] = {0};
        for(int i = 0; i < 20; i++) {
            cin >> num;
            count[num]++;
        }
        for(int i = 0; i < 10; i++) {
            if(count[i] != 0)
            cout << i << "输入了" << count[i] << "次" << endl;
        }
        return 0;
    }
    ```   
    for i 从 0， i 小于20，一共20个数嘛，然后读入这个数，然后读入了这个数 直接我就当作下标来使用，直接让count这个数去进行++运算。 这个程序非常非常的简单，而且它的易读性也不错呀，对不对？我们把那个程序写出来 那完整的程序就长成这个样子。定义一个count用来存放次数，然后呢 for从0到20，读入20个数，对于读入的每一个数读入什么数我就 让count多少来++。读入的7我就让count 7 ++，读入的是8我就让count 8 ++。 通过这种方式 我一下子就可以用这个数组记录下来了每个数输入的次数。 这是一个非常好的办法。然后呢我用一个for循环把这个结果直接打印出来就OK了。 那么通过这个程序我们可以看到通过 利用数组的下标跟数组原数之间的这种对应关系 我们完全可以用它来做统计，对于整数的统计。 那这是一种非常非常好的方法。 那这是这个题。
- 我们再来看一道题，仍然是关于数字统计的。 这题是这样的。某学校有1000位老师，这1000老师呢分布在20个 不同的学院里头。而且呢每个学院里头啊最多有12个系。 请你编写一个程序。这个程序干什么的 ？输入每位老师所在的 学院和系的编号，那么学院的编号呢用1到20来编号，系的编号呢因为不超过12个嘛 我们就用1到12来编号，我们按照这种方式我就会输入每一位老师所在的学院以及系。 需要你做什么呢？写一个程序，打印出来各个系里头老师的数量。 那么你思考一下，这样一道题我们应该怎么去解决呢？ 有些同学可能意识到了，哎呀这也是一个统计问题。没有错。 这的确是一个统计问题。 但是现在这样的一个问题跟刚才的问题有什么不同呢？ 输入的数据啊是两个，一个是学院，一个是系，而且呢这两个数据之间啊 还有一个从属关系，因为这个学院肯定是属于某一个系的。在我们的脑子里边我们立刻形成一个 两极的一个概念，20个学院，每一个学院下面呢最多又有12个系。 这是一个两极的一个概念。所以说我们直接可以感觉到我们 可以干嘛呀？我们可以利用一个二维数组来做这个统计。 比方说我们可以定一个这样的二维数组，teacher[21][13] 这就形成了一个二维数组，这个二维数组有多少行啊？有21行，每一行有13列。 iii说，你们是20个学院，学院里头12个系嘛，为什么要定义21、13呢？因为我想让它们形成一个对应关系 你不是20个学院吗？我刚好可以用1到20来表示。 你不是12个系吗？那我刚好可以用这13列里头的1到12来表示。 于是这个程序就很好写了。 
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int teacher[21][13];
        int school, department;
        int i, j;
        char name[30];
        for(i = 0; i < 1000; i++) {
            cin >> name >> school >> department;
            teacher[school][department]++;
        }
        for(i = 1; i < 21; i++)
            for(j = 1; j < 13; j++)
                cout << setw(4) << teacher[i][j];
        cout << endl;
        return 0;
    }
    ```  
  for循环，1000个老师嘛，从0开始到小于1000。 开始循环。读入每个老师的姓名和学院以及相应的系。 那姓名我们就不管了，我们只用学院和系来做统计。那么得到学院和系以后我做一个操作 这个操作就是teacher相应的学院和相应的系++，因为第一位表示学院 第二位表示系，我就让这个二维数组相应的元素进行++的运算。 那么输入完了这1000个以后，每一个学院里头每一个 系的老师的数量都被存在这样一个二维数组里头了。 然后呢我写一个程序把它打印输出就OK了。所以说啊通过这个程序我们可以看到不单是一维数组 二维数组也可以用来做统计。非常非常的好用。 所以说呢要形成这样的一个概念，数组不仅仅是用来存放数的，那么数组的 下标有很多的用途，其中呢比方说这种统计就是比较常用的一个用途。 OK这是这两个例子。 
## 5. 数组的作用之二
- 我们再来看一个例子。这个例子有意思啦。例子的名字叫做 找出素数。**那什么是素数，还记的吧？素数都是整数，这个整数有什么特点呢？ 它除了能表示成1和自己的乘积以外啊， 不能表示为任何其他两个正整数的乘积**。比方说，这个15。 这是一个素数吗？不是，因为它可以，它除了能表示成15x1以外，还可以表示成 3x5。这就不是一个素数。那7是一个素数吗？ 7当然是一个素数，因为它除了可以表示成7x1之外，其他没有任何数乘起来可以等于7。啊这就是素数。 这就是回顾一下。OK，那么现在我们的任务是干嘛呢？ 写一个程序，输出100以内的所有的素数。 首先对于这样的题啊，在作业里头啊我是不会考你的。如果想考你的话，我会让你输出， 请输出10000以内的素数。 为什么呀？因为好些同学100以内的素数，他完全可以记得出来或者背得出来，直接cout就行了。 对吧哈。所以说，我们在这哪我们只作为一个例子是没有问题的。输出100以内的 所有的素数。那对这样一个题啊其实也不难解，每个同学可能直接地就能想到一个解决方案。 那最直接的办法就是说构造一个循环，这个循环呢，从2，我们都知道2是最小的素数，那么从2到100啊作一个循环。那么对于2到100之间的每一个数呢，我都去写程序去检查一下这个数 是不是素数。如果是素数，我就把它输出出来，如果不是素数，我就换下一个再去检查。这是一个 整体的一个思路。那怎么去检查一个数是不是素数呢？也很好办。比方说对一个数，假设说37吧。 啊，我首先设定一个标志位p=0，啊这个标志位标志着看看这个数能不能被某个数 除尽。如果它能被某个数除尽的话，那么这个标志位将会被改变， 也就标示着它不是一个素数。否则的话，它就应该是一个素数。比方说， 我可以利用一个循环，j从2到i-1，也就是说在这个地方36，从2到36开始 我都去check。如果i 模 j它能够等于0的话，能够被j除尽的话， 那就意味着它不是一个素数。于是我就把这个标志位改成1。那如果经历过这个循环以后， 这个标志位仍然没有被改变，也就是说我没有 通过这样一个循环找到任何一个数可以除尽 这个数，那么这个i就应该是一个素数。于是我就输出这个i。这就是我们想到的最直观的一个办法。这个办法写成程序 就是这样的。在这个程序里头呢，首先我定义一个标志位 prime，就是我们刚才用来记录能不能整除的那个标志位。 然后对于0到100之间的每一个数，我都做这样一系列的操作。什么操作呢？先假定 它是true，再构造一个小的循环，从2到当前的这个数，比方说是 刚才我们例子里的36。如果i mode j能够等于0的话，我就把它置为 false。如果经历过这样一个循环，那么prime仍然是true，我就把这个i 打印出来。
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        bool flag = true;
        for(int i = 0; i < 100; i++) {
            flag = true;
            for(int j = 2; j < i; j++) {
                if(i % j == 0)
                    flag = false;
            }
            if(flag == true)
                cout << i << endl;
        }
        return 0;
    }
    ``` 
  啊是这样的一个程序。这样的一个程序呢完全可以。如果你写出来这样一个程序，我觉得非常好。 非常好， 已经是非常好了。如果同学们写一个这样的程序，我已经非常非常的满意了。 
- 那在这呢，我想让大家想一下有没有什么其他的办法。在这儿，我作为一个题外话说一句。 写程序啊，当然我们要直观地去表达你的解决方案。对吧。但是在思考解决方案 的时候，当然我们的思路是越多越好啊。 对不对。如果解决一个问题我们只有一个办法，那 太受局限了。对不对。思考这个解决方案的时候，我们要打开这个思路。 比方说啊，在这啊，我们是不是可以通过这样一种办法来求解。假设说啊， 我去定义一个数组，那么既然是要输出100以内 的所有的数，那这个数组的长度呢，我就给它设定到100。 当然在这呢，我就画出来了18个，因为屏幕没那么宽， 我就画了18个。那么有了这样一个数组啊， 我能不能通过这样一个办法来解决。 当我们定义完这样一个数组的时候，其实那100个数就摆在我们 面前了。那哪些是素数啊，我可能一眼看不出来，但是我有一个办法。我可以把 素数以外的数，也就是那些合数。 **素数以外的数被称为合数， 也就是说可以分解为某两个数乘积的那些数**。 我可以想办法把这些合数啊都从这个数组中删掉。 怎么删呢？既然一个合数可以表示成某两个数的乘积，比方说， 刚才我们举的例子，15，它可以表示成 3x5，那也就是意味着这个合数一定是3的倍数或者是5的倍数。 那我能不能这样做，既然100个数都摆在这了，我就把 2的倍数、3的倍数、4的倍数、5的倍数通通删掉。 一个简单的道理就是当我把从0到100中所有数的倍数都已经删掉了， 那么剩下的数肯定就是素数。比方说，我先把 2的倍数删掉。2的倍数有哪些啊？2的倍数有4，这个数一定不是素数， 有6一定不是素数，8一定不是素数，10不是， 12不是，14不是，16不是，18，都不是。 等等等等等一直删下去，删到100。删完了2的，我再去删3的。 啊从3开始。 谁是3的倍数啊？6是3的倍数，已经被删除过了，不理它。7不是， 8不是，9是3的倍数删掉。11，12又是， 但是已经删除过了，不理它。15又是3的倍数，删掉。 17，也不是。3的倍数又删完了。删完了3的倍数，我再去删4的倍数。4的倍数有多少啊，是8，啊已经被删过了。还有12，也被删过了。 四四一十六，也被删过了。 因为2的倍数被删过了，所以4的倍数肯定也被删过了。删完了4的，我再删5的。5的倍数10，已经被删过了，15也已经被删过了。 再删6的倍数，6的倍数12被删过了， 18也被删过了。以此类推，一直删下去。 这样的话我就可以在这个数组上把所有不是素数的数全部都标记出来。那么， 留在这个数组上尚未被标记过的数就是我们要求取的100以内的素数。 啊这是一个很好的办法。我把这个办法的思路写出来，其实就是这样的。
    ```C++
    #include <iostream>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int sum = 0;
        a[100] = {0};
        for(int i = 2; i < 100; i++) {
            sum = i;
            while(sum < 100) {
                sum += j;
                if(sum < 100)
                    a[sum] = 1;
            }
        }
        for(int i = 2; i < 100; i++) {
            if(a[i] == 0)
                cout << i << " ";
        }
        return 0;
    }
    ``` 
  将所有数组元素置成0。 然后呢，基本的思路就是筛出所有的合数，就像搞一个筛子一样，把这些合数都筛出去。怎么筛呢？我就 分别把2的倍数、3的倍数、4的倍数、5的倍数全部都 删掉。怎么删呢？很好办啊。想要求2的倍数， 就是不断地把2进行自我相加，我就得到了2的所有的倍数，对不对。不断地把3进行自我相加，我就得到了3的所有的倍数。 通过这种方法，我就可以得到每一个合数。对于我得到的 每一个合数，我在数组中就把这个合数标记为筛掉。 每次计算的过程中，只要结果没有达到100，我就继续自我相加。也就是说，你比方说求2的倍数， 只要没加到100，我就继续往上加，一直加到100。3的话就一直加到99。 ok，这个过程进行完了之后，其实留在数组里头没有被标记过， 也就是没有被筛掉的数就是素数。我们只要把这个数输出出来就可以了。 那么这样的一个程序呢，我们就可以写成这样。那么从2到100，我要求 这期间每一个数的所有的倍数，怎么求呢？ 那么搞一个临时变量sum用来记录这个数自我相加的结果。 然后呢在每次的循环里头我都给这个sum加上i，我因为我要求i的倍数嘛，我就不断地给自己 i加i再加i，我就得出了2倍3倍4倍，对吧。 这个结果呢存到sum里头，如果sum小于100，我就让 a[sum]=1。a[sum]=1，这就意味着我要标记了 这个数已经被删掉了。最后呢，我写一个循环， 只要这个数没有被删掉，也就是说这个数等于0，仍然等于0，那我就输出这个数。 因为它是一个素数。那我相信呢，大家只要稍微琢磨一下，就能明白这个程序的算法。它并不复杂。 其实啊，这样一种寻找素数的方法，在2000多年前就已经被提出来了。 在2000多年前有一个人叫做埃拉托斯特尼，他就提出来了这样一种寻找素数的方法。 于是人们把这样的一个算法又称为埃拉托斯特尼 筛子法。用这样的方法可以比较容易的求取出 哦，某个大范围之内的，所有的素数。比方说一千万以内， 那所采取的办法就是把所有的 和数，全部都删掉。那大家以后求解素数的时候啊， 可以采用这个办法。那么在这儿呢，做一个附加的内容。
- 啊，我们来讨论一下这个程序的 优化。有些同学说，哎，你不是说些程序最重要的是表达清楚吗？ 啊，我们不是不去考虑效率吗？Okay, 我们并不是在所有的情况下都不考虑效率。 因为素数的求解牵涉到了大运算。比方说我真的让你求解一千万以内的素数。 那么如果用这一个程序来求解的话，那可能它需要很长的时间。 但是呢，其实对这个程序而言，在某一些地方 稍微做一点点修改，就可以使程序的效率大幅的提升。 那么在这个情况下呢，我们还是要考虑一下效率。我们来看一下对这个程序， 在那儿进行修改才能提高它的效率呢？首先啊，同学们可能直观的能够意识到， 当我们想把100以内所有的素数的倍数删掉的时候啊， 我们并不须要去算到100。**比方说，最简单的一个设想就是 超过50，你就不须要再算了。因为超过50乘以2就已经超过一半了，对不对？ 那么如果我在这儿不须要求解从2到100之间所有数的倍数的话， 那我求解从2到多少的倍数就可以了呢？那么其实 这个答案啊，非常的明显。如果我们学过高等数学或者是初等数论的话，我们就有这样一个结论。 比如说在这个算法里头，我们只须要让2，3，4，5，一直到c啊。它中的每一个数来自我相加很多次，来求它们的倍数就行了。那这个c是多少呢？那么学过初等数论的我们就可以知道， 这个c它其实满足这样一个条件，c小于等于根号下n。 啊，也就是说在这里，如果n是100的话，c小于等于10啊。 也就是说我们只须要求取2到10的倍数就可以了**。 也就是说啊，刚才的那个程序完全可以修改成这样子。
    ```C++
    #include <iostream>
    #include <cmath>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int sum = 0;
        a[100] = {0};
        for(int i = 2; i < sqrt(100.0); i++) {
            sum = i;
            while(sum < 100) {
                sum += j;
                if(sum < 100)
                    a[sum] = 1;
            }
        }
        for(int i = 2; i < 100; i++) {
            if(a[i] == 0)
                cout << i << " ";
        }
        return 0;
    }
    ``` 
  我们只须要去求解2到根号下100 之间的所有数的倍数就可以了。 那么有的同学又再问了，你在这儿 为什么不直接写10呢？当然也可以啦。我在这儿呢，想告诉大家一点， sqrt是一个非常常用的函数。这个函数呢， 是在C程序已有的函数库cmath里面的函数。 这是我想告诉大家的第一点。那么cmath里面的这个函数呢，大家都可以去用。 那又有同学问，我怎么知道cmath里头包含了哪些函数？到网上去查，一下子就可以查得到，很容易。 那么在这儿我想说的第二点，有些同学可能第二个疑问，sqrt是求里面这个数的平方根了。 你要求100的平方根，你为什么在这儿写 100.0呢？那么其实这件事情呢， 跟函数部分的内容有关系。在这儿呢，我先做一个简单的 解释。因为我们去调用这个函的时候啊， 给它的参数必须
- 那么对这个程序还那么进行优化吗？ 那么细心的同学可能发现了，应该是可以优化了。为什么呢？对于这个程序而言啊，还有一点小问题， 还有一点小问题。这个小问题在那儿呢？在这儿。这段程序也就是 说，当我们对一个数的倍数进行标定的时候啊， 还有点小问题。那问题在那儿呢？其实是这样的，当我们标定了2的倍数，那么 是不是4的倍数我们不用再去标定了？当我们标定了3的倍数，那么6的倍数我们还 要去标定吗？不用了。也就是说啊，如果一个数，它自己已经是被标定 过的数了，那么这个数的倍数也就不须要再被标定了。 哎，所以说你明白了这一点之后呢，我们只须要做一个小小的改动，把这个程序啊， 加一行，把它变成这样子。把刚刚我们认为可能会重复的部分 给它放到一个if语句里头。如果 当前的这个数没有被标定过，那么我才会 去计算它的倍数。否则的话，我不须要再去计算它的倍数了。
    ```C++
    #include <iostream>
    #include <cmath>
    #include <iomanip>
    using namespace::std;
    int main()
    {
        int sum = 0;
        a[100] = {0};
        for(int i = 2; i < sqrt(100.0); i++) {
            sum = i;
            if(a[sum] == 0) {
                while(sum < 100) {
                    sum += j;
                    if(sum < 100)
                        a[sum] = 1;
                }
            }
        }
        for(int i = 2; i < 100; i++) {
            if(a[i] == 0)
                cout << i << " ";
        }
        return 0;
    }
    ``` 
   那么这个程序呢，经过这样的两次优化之后，我们得到了一个结果啊， 就是一个比较好的一个程序了。那么这个程序呢，它不会存在特别多的 重复的无用的这种计算。Okay, 这是关于删法求数术。 
- 那么说到这儿，我们就把我们这个课程，在C程序设计基础这部分，哦， 第二个iii周期，理性的程序。啊，这个部分呢，我们就基本讲完了。 还剩了一小部分内容， 就是关于字符串。啊，那么 这部分的内容呢，我们准备哦，在下一次跟函数放在一起， 推出给大家。因为我们要确保啊，每次推出的课程量不会太大。噢，这样呢，让大家接受起来 容易一些。当然因为受到课时量的限制，在这个过程中呢，我们省去了很 多的例题。我们希望嘛，在接下来的这个章节里头啊，我们能把 这个例题啊，穿插进行。那么在接下来的一个章节里头呢，我们会讲函数。 那么函数的这个部分呢，也是C程序里头比较重要的一个部分。而且这里头还有 的規。当然那么由于那个课时量的变动呢，我们在的規的这个章节 也把要求放低下来。不会要求，哦，像在北大的校内一样，这么高的一个要求啊。 那我相信呢，最关键的事情呢，是要帮助大家把基础打好。 而不是去学一些比较偏难的东西。所以说呢，把要求降低来也非常合理。 那么在讲完函数之后呢，我们再去看指针，或者其他的一些复杂的数据结构。 那么还须要跟大家交代的，就是从这一次课开始， 我们要逐渐的，把目前我们这种以抄程序为主的这种练习方式啊， 向正常的作业练习呢，做一个转换了。 我们会慢慢的去做一个转换。比方说我们会把一部分题让大家去抄， 啊，另一部分题呢，我们要求大家去做。那么还有一种 转换的方式就是说，就算是抄程序的题，我们也会把哦， 给出程序源代码的这个 结果的时间呢，稍微往后延一点，这样的话呢，给大家更多的时间去 尝试。哦，总而言之，我们要慢慢的过渡到正常的作业练习。Okay，那今天的课程呢， 就到这儿。谢谢大家！ 