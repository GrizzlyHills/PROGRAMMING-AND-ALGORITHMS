# [程序运行的基本原理](https://www.coursera.org/learn/jisuanji-biancheng/lecture/Ujn8I/wen-ti-de-ti-chu)
## 1. 问题的提出
- 大家好，现在开始我们这个课程的第三讲，程序运行的基本原理 之前我们解释了一个问题，计算机为什么能完成计算 这次课我们要解释的问题是计算机怎么完成计算的 计算在计算机里到底是如何进行的 这是我们这次课一个主要的目的。
- 首先我们来回顾一下以前讲过的内容 我们前面讲了一个非常重要但是容易被忽视的问题 计算机为什么能够进行计算呢？我们给出的答案是这样的 比方有两个数：123+321，这两个数要在计算机里进行计算的话首先要把这两个数转换成二进制的数 然后这两个二进制数字之间的运算 都可以用基本的布尔运算来完成 那么这些所有的基本的布尔运算又可以通过电路来实现 所以电路是能用来计算的 确实在计算机里也是这样的 计算机本身就是由这样的电路构成的。这是我们已经了解到的内容 ok我们稍作整理。把这个思路稍微再整理一下。我们已经知道的是电路能完成计算， 所以如果想完成一个计算任务，就可以设计相应的电路 比方说我可以设计加法减法乘法除法 等等各种电路，这是我们已经可以做到的一件事情 
- 那既然我可以设计电路来完成计算，那是不是 我就可以这样来做呢，当我需要完成某 项计算任务的时候，我就开始动手自己设计一个相应的电路。 好不好啊？太费劲了，因为世界上的计算有千万种， 你总不能给没一种计算都去设计一个相应的电路吧。 这个太费劲了 我们能不能这样做呢？ 我设计好多个原子电路，需要的时候我就把这些 原子电路临时组装在一起。 有一个机器就是这样做的，那就是 ENIAC，ENIAC就是这样的，有不同的电路，需要的时候我就把他们连接在一起。 所以说我们看到的ENIAC全都是一堆线。 这样做仍然仍然太费劲了，如果我以后编程序都通过这个办法来进行 那简直太费劲了，不但是我们觉得费劲，牛人也觉得费劲。 
- 比方说这个人，von Neumann（冯·诺依曼） 这是我们曾经介绍过的，冯·诺依曼在计算机领域 他的地位几乎可以和图灵并驾齐驱了。他也认为不能 通过重新组合不同电路的这种方式去完成新的计算任务，这是 这是太愚蠢的一个办法了。那怎么办呢？ 于是冯·诺依曼给出了一种新的计算方式。这是我们曾经讲过的。他说，可以这样来做呀，**首先我们可以通过某种命令来控制计算机， 让计算机按照这种命令来执行。 我们可以想办法把这个命令给他，当然这个命令是用电信号来表示的。 这个命令不是临时输入到计算机里面的， 这个命令是用电信号来表示的，它不是临时输入到计算机里面的，而是存放在某些地方 随时可以更改的。当你想要计算机完成新的功能的时候， 你不需要重新组装电路，你只需要修改命令就可以了。**
- 按照这种方式，冯·诺依曼制造了一台新的计算机，叫做EDVAC。 这是我们曾经讲过的。 
- 而且呢他提出了一种新的计算机模型， 这个模型成为当今所有计算机的范本。 这个模型叫做**存储程序式原理**。 所以，我们这次课要解释清楚程序在计算机里面到底是怎么运行的， 我们就要首先了解一下现在所有计算机的范本， 这个存储程序式计算机这个范本 到底是个什么东西？它包含哪些部分？ 其中我们所需要知道这个命令，这个命令在存储程序式计算机 到底长成什么样子，它是怎么去被执行的呢？ 再就是我们说到这个程序跟命令是不是一回事呢？ 程序长成什么样呢？计算机怎么样才可以认识并且运行程序呢？这是我们接下来要搞清楚的问题。 
## 2. 冯诺依曼式计算机
- 什么是存储程序式计算机？
  - 正如我们以前讲过的 世界上第一台存储程序式计算机是EDVAC 它是由冯诺依曼和他的团队制造出来的 那么在1945年的时候呢，冯诺依曼曾经发表了一篇技术报告 叫做关于EDVAC的技术草案 这个技术报告很长，有101页， 正是这篇101页的技术报告，使得EDVAC成为当今所有现代计算机的原型和范本 人们也为了纪念冯诺依曼 就把存储程序式计算机也称作冯诺依曼式计算机 那么冯诺依曼式计算机和传统计算机到底有什么不同呢 在冯诺依曼式计算机中 计算机被分成了5个具有相对独立性又互相联系的部分 分别称作**控制器、运算器、存储器、输入输出设备 他们之间由总线相连** 而且冯诺依曼清晰的定义了每个部分他们的职责 比方说，**控制器，就是用来协调和指挥其他部分工作的 运算器就是专门用来算算术运算，或者是逻辑运算 存储器呢专门用来存储要用来执行的命令和相关信息 输入输出设备**，非常熟悉了 
  - 那在冯诺依曼式计算机中，命令到底长成什么样子，每一条命令 它是怎么样被执行的呢 下面我们就来通过一个小例子，来说明一下冯诺依曼式计算机计算机的工作过程 首先看这个图，这个图跟刚刚那个图是对应的，只不过把有些地方做了细化 比方说它包含控制器运算器 存储器，输入输出设备，5个部分 那么其中控制器和运算器包含的一些 小的固件被画出来了，当然为了便于大家理解我用的名字 并不是规范的，规范的名字待会儿再说 我们先看一下在这样的计算机里面，命令长成什么样子。现在我画出的就是一条命令 一个长长的二进制的字符串 计算机最后能够接受的命令都是二进制的 那这条命令到底是怎么样被执行的呢。我们来看下这条命令的执行过程 首先我们来解释一下这条命令，我们假设。注意是假设，这条 命令执行这么一个动作，叫做add后面是两个数 123，这个是321，这是对应的二进制数 什么意思呢，前面表示要做的事情， 后面是两个数，参与相加的两个数 所以说这条命令的含义就是把这两个数加起来，获得 一个结果。我们来看下这条命令的执行过程 首先呢，在控制器里面有个很重要的东西叫做命令记录员 它的职责就是记录当前执行到哪条命令，接下来要执行哪条命令 首先呢，在命令记录员的指引之下，找到当前要执行的命令 并且呢把这条命令提取出来，放到控制器中的命令暂存处 把它放进去 那么接下来呢，控制器里面的命令解释器就会对这个命令进行解释 看看它要做什么事情，然后解释之后呢，把这个结果传递给控制信号产生器，产生相应的控制信号 那解释过之后我们发现这条命令需要加两个数 所以接下来在控制器的控制之下，把这两个数再从存储器中提取出来 分别放入到运算器的两个数据缓存区里头 放进去结果就是这样的 然后接下来呢，控制信号产生器产生一个信号 告诉计算电路，做这两个数的加法 于是呢，这两个数相加，并且得到一个计算结果 这就是一个简单的命令的执行过程 
  - 稍微总结一下，冯诺依曼式计算机的工作过程，就是这样的一个过程 就是不断的去执行这样一些操作的过程 循环的去不断执行这样的一些操作，在这个工作过程中 **控制器起到一个协调其他部件工作的作用 首先在控制器的指挥下，取出一条待执行的命令 然后对这个命令进行解析 按照命令的要求，再把相应的数据从存储器上取出来 放进运算器，然后呢，运算器运算获得结果 最后输出到这个设备上面。执行完这个过程后呢，再转向到下一条命令 继续执行，这个过程不断的循环 这就是冯诺依曼式计算机简要的一个工作过程**。
  - 那有的同学可能问了，冯诺依曼式计算机包含的五个部分 和实际计算机的对应关系又是怎样的呢？这五个部分，我能够在 实际的计算机里面找到吗？ 我们来看这样的一张图，这个是一个被打开的机器 在冯诺依曼式计算机当中，运算器，控制器 以及存储器的一部分 这些主要的部件 都被集中在这个位置 这个不是风扇， 在这个风扇的底下，埋藏着一颗心 这是打开风扇之后拿出来的东西 这就是那个CPU 待会儿我们会讲，中央处理器。
  - 其实呢，运算器控制器 以及存储器的一部分都被集中在CPU里头 可以看到CPU真的是整个计算机最重要最重要的 一个部分，那个存储器中除了CPU所包含的这个部分之外 还有些什么呢，存储器包含在CPU里头的，叫做告诉缓存 待会儿我们会提到，除此之外 还有内存和外存。内存在计算机中位置也非常明显 大家看这个位置，这有一些插槽 这个插槽插上去的都是内存。 这是内存所在的位置，一般的机器可以插两条，或者4条上去 一般的机器都可以插两条或者四条上去 除此之外还有一些设备也是用于存储的，大家看这里以及这里 底下呢是硬盘的位置，通常的这个是硬盘的位置，上面呢是光驱 这些都是用来做存储的设备，只不过呢他们跟计算机之间的连接比较松散，所以我们把它叫做外存 剩下的键盘呀，鼠标呀，都属于输入设备 显示器呀，打印机呀，都属于输出设备 这就是冯诺依曼式计算机和实际计算机之间的对应关系 OK，那接下来我们从这个部分开始， 先看一下存储器包含哪些种，他们的原理是什么，作用是什么。  
## 3. 存储器的种类与特点
- 好我们先来看一下存储器，在了解存储器之前呢我们先来了解一下 用于衡量存储空间大小的度量单位 
  - 大家都知道在计算机里头能够存储的最小数就是1或者0 那么在计算机里头我们把用来存储这一个1或者0的这个空间，称作一个位 位，叫bit 那么，通常呢为了便于使用和程序编写 我们把8个位连接起来，8个位连接起来 组成一个东西，叫字节。英文呢，是byte 啊被称为字节 在这呢先告诉大家，字节是我们在程序里头 能够控制的最小的内存单位了 
  - 那么通常呢我们在使用计算机的时候，我们会看到 一个文件的大小可能是什么几k，什么几兆，什么几G OK，这都是用来衡量存储空间大小的。那么这些单位之间是什么关系呢 那么可能大家比较常见是k，啊kb 那1kb呢就相当于 1024个字节。比k大的呢 叫兆，1兆呢，相当于1024k。比兆大的呢 叫G，1G呢，相当于1024兆。比G大的呢 叫T，1T呢，相当于1024G。那么比T大的呢叫做P 1P大概相当于1024T 那么比P更大的呢 还有EB,还有ZB,还有YB。
  - 随着计算机的使用不断深入 那么后面这些就会比较了解 那么在一些不是特别精确的情况下呢，我们也把 1kb简单的等同于1000byte 一兆B呢就相当于1000kb，然后1G呢就相当于1000兆 啊这样的一个数量关系。一个不准确的说法 那在一些不是那么精确的场合呢，也可以这么去说 
- 首先我们来看一下，计算机里头存储器的种类 我们先来看一下计算机里头存储器的种类。 计算机里头存储器的种类有很多种。比方说 有寄存器，有高速缓存 有内存还有外存，外存常见的就是硬盘了。不同的存储器呢存储速度也不一样 而且这些存储器呢，在计算机里头 存在的多少，也不一样 比方说，一个基本的规律就是说。
  - 越快的存储器在计算机里头存储的越少 比方说寄存器。寄存器一般只有在CPU的内部才会有。啊数量比较少 它是用于存放那些待操作的数和结果 用来暂存这个。它的工作频率跟CPU一样，是相当相当快 那么这个存储器稍微慢一点的，叫做高速缓存 那高速缓存呢，很多时候也会在CPU里头 有一些高速缓存呢也在外头。它的工作频率呢，接近CPU的工作频率，也非常非常快 比高速缓存更大一些的是内存 内存更大一些，但是它的读取速度会更慢一些 
  - 那么，最慢的呢，就是外存了，跟外存交互呢都是特别需要时间的 
- 除了这个速度和大小的这个关系之外呢，还有一个就是关于它这个造价 
  - 寄存器是最贵的，寄存器是最贵的 高速缓存呢次之，内存呢再次之，当然最便宜的就是硬盘了。现在的硬盘非常非常的便宜 那么先来看一下寄存器，那寄存器呢通常都在CPU的内部 它的工作节拍呢跟CPU也是一致的 一次读写大概需要零点几纳秒的时间，非常非常的快 当然，寄存器的制作成本是非常非常的高的 那么一般呢一个芯片里头只配备少数的这个寄存器 啊，有十几个，差不多啦 
- 第二类存储器呢，叫做高速缓存，CACHE 有一些高速缓存呢，在CPU的内部 被称为内部高速缓存，INTERNAL CACHE 比方说这是一个AMD， 64位的一个芯片 在这个芯片里头我们可以看到，有大量的 缓存。这个区域，高速的CACHE 直接被制造在CPU里头。还有一些告诉缓存是在外头 CPU的外头。比方说在主板上。叫做外部高速缓存 那么在这个主板上呢，高速缓存的位置大概在这 在离CPU不是特别远的一个地方。这就是，在外部的一个高速缓存 一般呢这个高速缓存它的读写速度也是非常快的 在纳秒里边也能完成。也就是说它的工作频率一般在1G 到 几G 的这个范围里头 随着计算机的发展，这个高速缓存也在不断的增加 从以前的几K，到现在的几兆。
- 啊，都有 除了高速缓存之外，最重要的存储零件，就是内存了 刚才我们看到这是一个主板，这是内存的一个位置 内存条呢都被一根一根的插在这里。内存呢就是主要它的作用就是用来存放CPU中那些准备用来处理的那些数据 还有一个很重要的作用就是负责存储那些与外界进行存储信息交换的那些数据 那随着内存的发展呢价格越来越低廉。当然它的工作频率跟CPU的工作频率还是有一些差别的 一般的内存的工作频率是跟前台总线的工作频率想匹配的 这个呢是我在网上查到的目前比较通用的一个内存 我们可以看它的型号。240pin就表示有240个引脚。类型是DDR3 工作频率，1600。啊这是非常快的一个速度了 
- 那么利用高速缓存，外部高速缓存和内存这样的一些存储机制呢 就相于形成了一个 给CPU提供数据的一个，供应链 那么网上有张图呢非常非常的形象，我觉得写的挺好 它把CPU呢比作一个工厂，然后这些缓存呢，分别都表示成仓库 仓库呢，提供给工厂数据。供它来分析。在这样一个数据供应链的机制之下呀 CPU 在访问数据的时候有这样的规律。它总是先从最近的缓存中开始找 如果找到了就直接去访问这个数据。如果没找到才会去check 离它更远的缓存。如果再更远的缓存里面找到了这个数据 它就把这整个数据块，加载到离他更近的缓存中。从而使得呢，最整个数据块的访问都可以在这个更高的缓存里头进行 不需要更速度更低的缓存，进行交互 通过这种措施，它想要达到的目的，就是尽量减少跟慢的缓存的，那些交互 从而提高处理速度。
- 其实CPU的这种工作呢，是符合一个基本原理的。叫做局部性原理 也就是说CPU对于数据的访问啊，通常具有一定的局部性。一个是指时间上的局部性 一个是指空间上的局部性。所谓时间上的局部性是指 就是如果一个内存地址 它正在被访问的话，那么，在近期内，这个内存地址，同样的内存地址，被再次访问的几率，就非常非常高了 空间局部性，最近可能会用到的信息 通常与当前正在使用的信息。空间上非常的临近 啊，这是两条。正因为有了这个局部性原理 所以我们可以使用这种多级缓存的机制来加快CPU的存储速度 
## 4. 存储器的原理与类型
- 那么在介绍完存储器的种类以后呢，我们来解释几个关于存储器的问题。我们相信这几个问题也是大家关心的。 
  - 第一个，存储器的工作原理是什么？为什么它能“存得住”数字？就是一个电路为什么能记得住？ 
  - 第二个就是，存储器的种类有哪些？这个种类是指技术上，技术实现上种类有哪些？ 然后，DDR是什么意思？ 内存老是提到DDR，那它到底是什么意思呀？ 
  - 第三个，为什么32位的CPU最多只能配备4G内存？
  - > 下面，我们逐一解答一下。先来看一下存储器的原理？ 它为什么能存得住数呢？下面，我们就通过一个简单的例子说明一下。 大家看到的这个线路图，看上去有点复杂，实际上很简单。 这个线路图，先说明一点，它只用来存一位数据。 存1或者0。 我们在解释这个电路图之前先解释一下三极管的一个特性。 三极管的特性之前讲过，当这个端是高电位的时候，那么这两端就是导通的。当这个端是低电位的时候，那么这两端就是截止的。这是三极管的一个特性。 OK，我们了解三极管的这个特性，我们就好办了。在这个电路里面，最重要的三极管有这两个：一个是T1，一个是T2。 T3、T4都是当电阻来用的。 因为在电路的制造里面，三极管制造是容易的，电阻呢有时候就使用一个三极管来代替。 看这个电路，我们假设A点此时为高电位，高电位表示1，B点是一个低电位，表示0。我们分析一下，为什么这个1或者0能够保持得住。 我们观察一下这个电路。当A点是高电位的时候， 正好造成这个三极管的导通，所以，这个B点接地。 从而使B点很好地保持住低电位。然而，由于B点是低电位，又造成A点下的三极管是截止的。 从而使A点很好地保持高电位。于是，就造成这样一种现象， 如果A点是高电位，就促使B点更好地保持低电位；如果B点是低电位，就促使A点更好地保持高电位。于是，这个状态就被稳定下来。从而A点的高电位和B点的低电位能够很好地保持住。这就是这个存储单元为什么能够存得下1或者0的原因。使用多个这样的存储单元，我们就得到一个存储阵列。用这个阵列就能够存储更多的数据。 在这样一个阵列中，我怎样读取某个存储单元里面的数据呢？ 很好办。这个阵列由一些行选择线和列选择线勾画而成。 当我们在这些选择线上赋不同的值的时候，比如，我要读取这一点的数据 就可以在这儿赋1，在这儿赋一个高电位。 在这儿赋一个高电位。 这两个高电位就使得这两条线交叉的存储单元被选中。 再来看一下这个图。当行选择线是高电位的时候， 列选择线也是高电位的时候，这个导通，这个导通，这个导通，这个导通。 于是，A点或B点的高电位或低电位就可以被读出来了。 当然，我们从这点读走的应该是高电位，我们从这点读走的应该是低电位。 你可以选择性的接受。这就是，存储器之能够存得住数据，并且读取出来的一个基本的原理。 
  - 现在我们看一下存储器的类型。也就是，从技术上，存储器可以分成多少种？ 从技术上，根据存储器能否被随即地写入和读取，可以分为两大类：
    - 一类叫RAM(Random Access Memory)，随机读取存储器，它既可以读也可以写。 
    - 一类叫ROM(Read Only Memory)，只读存储器。只能读，而不能写。毫无疑问，我们的存储器应该属于第一类，RAM。 
      - RAM又可以分成两类，一类是DRAM，一类是SRAM。DRAM必须周期性地用电流对整个存储阵列进行刷新， 才能够使得其中的存储内容被保存下来，否则，就会被丢失。那SRAM呢？ 它不需要周期性的刷新也能够保持住。看上去SRAM更好一些，但实际上DRAM具有更快的存取效率。所以，我们的内存通常会使用DRAM类型的存储器来制造。 这是第一大类。
      - 第二大类，就是ROM，只读的，这类存储器在最早的时候确实是只读的。就是说，存储器在制造的时候生产商把信息写进去，用户拿到以后不可以再修改存储器里面的内容。随着工艺的改进，人们发现这种存储器用起来不是特别方便。人们希望能不能生产空白的存储器，由用户写入相应的信息。随着这种要求的提出，人们研制出可编程的ROM。这个呢，就是生产的时候是空白的，用户可以根据自己的要求把信息写进去。但是，因为当时技术的限制，写入之后不能被修改。 那能不能写入之后也被更改呢？ 人们又研制出可擦除的PROM(Programmable ROM)。这些呢，可以被重复写入，但是要在紫外线照射下才能写入。必须使用专用设备，也不是很方便。人们又研制出电可擦除的EEPROM(Erasable PROM)，这样就方便多了。在这种电可擦除的ROM的基础上，人们研制出了Flash EPROM，这种快速的可擦除编程只读存储器。这种存储器就是我们今天广为使用的U盘的主要技术。 这是这两大类。
    - 接下来，我们重点讨论一下内存。因为内存也许是我们最为关注的一类存储器了。到目前为止，内存的技术被翻新了很多次，目前在市场上能够看到的存储技术就是这样的。 
      - EDO DRAM(Extended Data Out DRAM)，扩展数据动态输出动态存储器，这种存储器是在传统的DRAM基础上做了这样一个改进，当把数据发送给CPU的同时去访问下一个页面，从而提高了工作效率。随着技术的发展，这种存储器被SDRAM给取代了。
      - SDRAM(Synchronous DRAM)又称为同步的动态存储器。它的最大特点是可以同CPU外部总线工作在同一个频率上，这样的话，存取速度就快很多。
      - 在SDRAM基础上，发展出了双数据输出同步动态存储器。这就是我们通常说的DDR(Double Data Rate SDRAM)。最初的DDR可以把RAM的速度提升一倍，它的方法是，原来SDRAM只在时钟上升沿读取操作，那么DDR可以在上升沿和下降沿都可以去做这种读取操作。这样的话，效率就提升一倍。 所以，人们把它称作DDR。那么，随着技术的进步，DDR的技术也在不断地翻新。例如，目前常见的DDR类型就是DDR3。它的工作电压是1.5V，频率最高可以达到2000MHz。 而且它可以做8位预读。这样，就非常非常快。那么，接下来的，可能成为主流的是DDR4。它的工作电压只有1.2V，而数据传输速率可以达到3.2GT/s。这是非常非常大的一个数字了。OK, 那么我们接下来解释关于内存的一个问题。
    - 为什么32位的CPU最大只能管理4G的内存呢？ 不知道同学们想过没有。
      - 因为，32位CUP寻址空间的大小只能达到2的32次幂。32次幂恰好等于4G。所以说，它最大只能管理4G。 这就好比说，比方说，我告诉你，北大的宿舍号码，宿舍房间的编排号最多只有三位。那北大的宿舍房间数量不会超过10的三次幂，也就是小于1000。 这是一样的道理。也就是说，它所能访问的地址空间，最大就只有这么多。 所以，它只能管理4G的空间。
## 5. CPU指令的执行
- 接下来我们讨论下一个话题，在冯诺依曼式计算机中，命令，到底是如何被执行的? 
  - OK, 我们先整理我们的思路。通过刚才的学习，我們已经知道的东西是这样的，CPU的电路是能够进行计算的，对这一点我们是确定无疑的。 第二个呢我们也知道，冯诺依曼式计算机 不需要通过插电那种方式去组合那些线路 它是通过讀取存儲好的程序，來完成不能的功能的 。这就是冯诺依曼式计算机程序存储式计算机基本的一个道理 
  - 那这时候我就有一个问题 那是不是不管什么样的程序 CPU都能够识别并且执行呢？ 我猜好像不行 怎么可能呢? 不管什么样的程序，CPU都能执行，我猜应该不是的 那如果不是的话，CPU能执行哪些程序呢？ 然后这些程序的执行过程，到底又是怎样呢？ 接下来，我们就来讲述一下这几个小问题，
    - 首先我们可以肯定，CPU绝对不是什么程序都可以运行的，它只能执行指令集里面有的指令，所谓指令集呢，就是CPU能够执行的一套指令的集合。那这样的一套指令集呢，是在CPU设计的时候就已经设定好的，也是CPU性能的重要的一个标式。
      - 那么目前常见的指令集有两种。一种是Intel X86指令集，
      - 另一种很常见的就是ARM指令集，ARM是一个公司，他们有一套自己的CPU的设计框架，所以他们有自己的指令集，这套指令集倍受关注，很常用。
    - 那在指令集里头都包含一些什么样的指令呢？
      - 比方说在这呢，我给出了 Intel X86基本指令集的一个简单的目录。它包含了像整数运算，逻辑运算，位运算等等 一系列的一些基本的指令，那么随着Intel CPU产品 的不断革新，那它的指令集呢，也不断完善和发展 这个图就给出来了从1996年到2003年 Intel 指令集的发展变化的一张图 当然，不需要特别了解，感兴趣的同学可以去看一下 
    - 那指令集里的指令到底长什麽样子呢？ 
      - 我们来看一下，首先所有的指令都是一个长长的二进制chart 在这个二进制的chart里头包含两个部分 
      - 第一部分是表示这个指令是干什么的，叫做指令码 第二部分是执行这条指令要参与操作的操作数，这是两大部分 那我们曾经举过的一个例子就是，
      - 第二个，比方说这条指令它是用来执行加法运算的 前面这个指令码就表示要做一个加法 后面的这两个绿色的呢，就是操作数，合起来形成一条指令 根据指令所完成功能的不同呢，指令可以有一个操作数 也可以有两个，甚至三个，当然也可以没有操作数，都是可以的 Ok，**稍微做一个总结 我们可以知道，CPU不是什么程序都能够执行的 它能够执行规定的指令集中的指令 而且所有的指令都是二进制编码的。这就要求我们，当你想让CPU去做一些事情的时候 你要先把这些事情写下来，然後把它转换成ＣＰＵ能够接受的指令集中的指令 然后提交给CPU，让CPU去运行** 
    - 那么在了解CPU的指令集之后呢，接下来我们看一下 CPU中的指令到底是怎么被执行的，需要告诉大家的是这部分的内容是属于扩展内容 我们不要求掌握，只要了解就可以了 那么在介绍CPU指令的执行过程之前 我们先来看一下CPU有哪些核心的部件 我们先来了解一下运算器中所包含的一些部件 
      - 运算器中包含最核心的部件就是算数逻辑单元 简称ALU(Arithmetic Logic Unit)，它是专门进行算数和逻辑运算的电路 这是运算器的核心了 为了辅助ALU发挥作用，
      - 还有几个重要的寄存器 
        - 一个呢，缓冲寄存器 它用於存放準備進入ALU進行運算的一些數據 
        - 累加寄存器AC，它用来暂时存放运算结果 还有一个状态寄存器，它用来存放系统工作的状态信息 在我们例子中用不到这个寄存器 
      - 我们再来看一下控制器中所包含的一些部分。
        - 首先，程序计数器 程序计数器是一个非常重要的东西 在程序计数器中保存着将要执行的下一个指令的地址 程序计数器会把这个地址放到地址寄存器中 
        - 地址寄存器的作用就是来缓存这个地址的，除此之外还有指令寄存器 
        - 指令寄存器，是用来缓存从存储器中取出的指令的 拿到这个指令之后呢，指令寄存器会把它交给指令密码器 
        - 指令密码器的主要作用就是对指令的语意进行解析 根据这个解析的结果呢，交给操做控制器和逻辑产生器 來產生相應的控制信號 这些我们只需要知道大致的作用就可以了，不必做特别详细的了解 
    - 在了解了这些步件之後呢，我们通过一个例子来看一下 CPU的执行过程。在这个例子中，我们要执行这样一条指令 我先来解释这一条指令，这个指令跟普通CPU指令是一样的 它包含两个部分 一个是指令码，一个是操作数。这个操作数在这里是一个地址 这个地址指向这片地址区域 这片地址区域里头放了相应的数据，是一个数 这个指令要做的事情，就是对这个数，进行加一的操作，把它加一 这就是这指令要完成的内容，那么这个指令是如何被执行的呢？ 指令的执行从程序计数器开始，因为程序计数器中保存着指令的地址 首先程序计数器把指令的地址发送给地址寄存器 地址寄存器 到相应的存储单元中去把这条指令取出来，放入指令寄存器 指令寄存器拿到指令之后呢 交回指令密码器，对指令进行解码 看看这个指令要完成什么样的操作，经过分析发现 这个指令的操作数是一个地址，是一个地址，在这里 于是，控制器将这个地址传回地址寄存器 然后 在控制器的协调之下到相应的存储器空间中 取出这个数字，被操作数，将它送入 运算器的缓冲寄存器，第七步，而后，由缓冲寄存器送入ALU 由操作控制器，发送一个进行加一 操作的信号给算术逻辑单元ALU 由ALU完成运算，并把运算结果 放入累加器，运算结束 这就是这一条指令的执行过程 我们来回顾一下这条指令的执行过程，在这条指令的执行过程中 经历了按照地址取指令 然后按照地址再取数据，发送运算讯号，完成运算 这就是刚刚经历的主要过程 这就是一条指令大致的执行过程 这个部分我们仅仅给同学们参考 而不做任何要求，不需要你们掌握 
## 6. 程序的执行
- 在了解了指令执行过程之后，我们再来看一下程序的执行。首先什么是程序啊？程序长成什么样子啊?程序和指令有什么不同啊？ 那么既然CPU能够执行的指令都是二进制的代码，那程序会不会也要长成这个样子啊？ 写给计算机的命令不会就长成这样子吧？ 
- 如果是长成这样子，那写程序那简直是太痛苦的一件事情了。 当然，所幸它不会的。 计算机程序它没有这么恐怖。那在这儿呢,我给出了一个小的程序的一个片段。 这个程序非常简单，大家都能过看得懂。那么这个程序实现了求一个a*b+c的值， 然后把它传递给d这样的一个过程。那么，这样一个程序显然是我们不能直接把它交给CPU去运行的。 因为CPU是看不懂这样的程序的。 那要让CPU顺利运行这个程序，必须要把它转换成CPU能够看懂的指令代码。在计算机中，为了运行这段程序经历了这样几个过程。首先呢，我们需要把这个程序转换成这样的代码，我们把这个过程称作编译。 在编译之后呢，原本的程序代码变成了这种代码， 这种代码被称为汇编代码。在以后的学习中，同学们会接触到。 汇编代码仍然是CPU不能理解的。再对汇编代码再次进行转换，把它转换为机器码。那么,就可以交给CPU，让它运行这个程序了。
- 在这儿，我们举个小的例子，来看一下 程序运行到底是怎么来进行的。
  - 这是C++编程工具的一个界面，现在呢，暂时还不需要大家了解。 我们只需要理解红框之内的部分就可以了。 我们来看，这是刚才那段程序：a=4，b=3，c=a+b 非常简单的一段程序。经过C++编译器的编译，会把它编译成这样的一个结果：与每一句程序对应的我们都得到一个汇编的程序。比仿说， a=4，得到这一句，b=3，得到这一句，c=a+b，得到底下三句。 那么，这样一个结果呢，再转换成相应的二进制代码， 就可以交给CPU去运行了。 我们来看一下这个程序在运行中会发生什么？首先，我们看到这个界面， 这个界面看上去陌生，实际上非常熟悉。这是冯诺依曼式计算机基本的一个架构。 这是控制器，这是运算器，这是存储器。 我只不过把这个图呢竖过来画了。 那首先原始的程序在这里， 原始程序经过编译呢，得到一个编译后的代码。 这个代码转换成二进制就可以让CPU去跑了。 下面我们来解释一下程序的执行过程。 对于某个程序而言，会在内存中开辟两个区域供它们来使用。 一个是代码区，专门用来存放将要执行的代码；一个是数据区， 准备用来存放待处理的数据。 那么，这两个部分呢不在一个内存区域里面，所以说， 在这个图中，我们也分开画，把它体现出来。那么程序的执行过程是这样的： 首先，程序计数器指向待执行的第一条程序：mov a,4 这条程序的含义呢，是在数据区相应的区域给a赋值为4，程序的执行结果是这样的： 执行结果有两个：第一个， 在数据区开辟了一片空间，在里面存放了值4，把4这个值存放其中。 然后呢在控制器的控制下程序计数器指向下一条要执行的程序：mov b,3 然后这个含义是，在数据区内为变量b开辟一个区域，并且把3赋值给变量b。 程序执行的结果是这样的： 数据区中变量b被赋值为3 并且程序计数器在控制器的驱动下指向下一条要执行的程序：mov eax,a eax通常代表运算器中的累加计算器。所以，这条语句的含义是， 把变量a的值传递给运算器的累加器。 程序的执行结果是这样， 这条程序的执行过程需要控制器先去访问数据区中a的值， 然后把这个值取出，放入运算器的累加器。 程序的执行结果是这样的，程序计数器指向下一条语句， 并且把变量a的值放入到累加器。 现在程序指向一条新的语句，叫add eax,b 也就是说，要把运算器中累加器的值与变量b的值作一个相加。 要执行这个指令呢，需要控制器先去变量b的存储空间把变量3这个值取出来， 送给运算器的缓冲寄存器， 然后通过ALU完成相加的运算。 其结果呢，存放在累加器中。 执行的结果是这样的。 那么，现在计数器，控制器的计数器指向了最后的一条语句：mov c, eax 它的含义是， 把累加器的值传递给变量3所在的区域， 所以程序的执行结果变成这样： 那么，到现在为止，程序就执行完毕了。 因为程序就执行到最后一个语句了。 我们也获得了相应的结果，a=4，b=3，c=a+b，于是， c=7。我们也获得了这个结果。 这样呢，这个程序就执行完毕了。在这呢，我们对这个示例做一个小结。 
  - 通过刚才的例子呢，我们能够得到这样一些结论： 
    - 首先我们知道，程序必须要经过编译才转换成CPU所能接受的指令；因为程序是不可能直接被CPU读懂的。 
    - 再一个，我们看到，一句程序有可能转换为多句指令；
    - 那么这些指令的执行是 在控制器的协调下连续、依次执行的指令； 
    - 程序执行过程是在内存中完成的；我们呢，看到内存中这种数据的变化 
    - 那么程序在执行过程中，在内存中利用不同区域，分别存放代码和相关的数据。 
  - 这就是通过我们刚才的例子，我们能够得出的小结论。 
  - 最后呢，我们来总结一下，我们学到了哪些东西。
    - 首先，我们知道，计算机是能用电路来进行计算的。也就是，数可以转化为二进制数， 二进制数都可以用布尔运算来算，而且布尔运算都可以用电路实现。 所以，电路能算数。 
    - 第二个，我们知道，CPU是制造好的电路，它能完成指令集里面的运算。 CPU跟指令集是密切不可分的。那么指令呢是二进制码，CPU能看懂，并且能执行它。 
    - 第三个，我们想让CPU按照我们的想法做事， 我们就应该，把我们想做的事情写出来 这个写出来大概要用到某种语言吧，比方说，X++ 把这个写出来的东西，编译成CPU能看懂的二进制指令。然后，CPU就可以按照我们的想法运行了。 
  - 所以，我们接下来的事情就是，我们赶紧去学习一门X++语言吧 它能被翻译成CPU能看懂的指令。 于是，我们就可以利用我们的程序执行CPU如何去运转了。 从下节课开始，我们进入程序基础课的学习。 开始学C++语言。 







