# [C程序中的字符串](https://www.coursera.org/learn/jisuanji-biancheng/home/week/11)
> 在能够运用“数组”来解决问题的基础上，再来学习一下“字符串”的特性，在此基础上，我们将讲授C语言的中的“第四种成分”——输入输出成分。 本部分的重点在于：掌握“数组”与“字符串”的区别，理解“输入缓冲区”的基本机理，掌握cin和cout的使用技巧。
## 1. 字符数组和字符串
- 啊，说完了数组啊，我们再来说一下 字符数组和字符串。 那有的同学也要问了，为什么要专门说一下字符数组，还把它跟字符串放在一起。那我也回答一下，很简单，因为字符数组 在数组里面又是最常用的部分。 然后字符串呢，是常常和字符数组放在一起使用。所以说啊，我们把这两部分专门拿出来，再讨论一下。 
- ok，我们先来看一下程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char a[10] = {'a','b','c','d','e','f','g','h','i','j'};
        for(int i=0;i<10;i++)
            cout<<a[i];
        return 0;
    }
    ```
  在这个程序里头啊 ，我定义了一个字符数组，char a [10]， 明显能包含10个元素，然后呢，后面给了一个初始值 a，b，c，d，e，f，g，h，i，j，一共10个元素。 ok，这是大家非常熟悉的最标准的一个字符数组的定义了。 那么这个定义的结果呢，你就会得到一个这样的数组。这是毫无疑问的。 10个元素，每一个里头呢都放好了相应的字母。 这是我们熟悉的。那我现在想问，如果我只对 部分元素进行初始化呢，比方说，如果我写成这样， 数组大小仍然是10，但是呢，我只指定了其中的5个元素，那会怎样呢？ 那么你得到的结果啊，将是一个这样的数组。10个元素，前5个元素呢，都被初始化好了， 后面的5个元素，将被统一的初始化为 \0.有的同学问，为什么是\0啊？这个 \0啊，它其实是ASCII码表里面的第1个字符， 也是一个空字符，那么在这个地方呢，它被用作一个结束标志。所以说，当你只对字符数组中的 部分元素进行初始化的时候啊，剩下的元素将被初始化为\0，这是我们需要知道的第1点。 然后呢，我们再来初始化一个数组。跟我们前面讲过的数组定义一样，如果我定义一个数组c， 但是并不指定这个数组的大小，只给它赋予初始化的值，那这样行不行呢？当然也是可以的。 那么这个程序执行的结果，你会得到一个这样的数组，包含5个元素，每个元素呢都是 赋好值的。这并没有任何奇怪的。那么接下来呢，我想采用另一种方法。 我仍然定义一个数组，并且不指定它们大小。 然后呢，我利用用双引号引起来的 一个字符串，对这个数组进行初始化，这样可以吗？可以。 那这样得到的结果会是什么样子呢？得到的结果啊，是这样的。 我们可以对比一下，我们发现在数组的最后面， 多了一个\0，也就是说虽然我初始化的时候，指定了 5个字符，china，5个字符，但实际上赋值的时候， 程序却把6个值赋给了这个字符串数组， 也就是说这个字符串数组却有6个元素。 那么多出来那个元素呢，就是\0。那么通过这个定义啊， 我们发现了这样一个问题。你看是不是内容相同的字符串 就比同等内容的字符数组 多了一个\0。那么其实呀，我想通过这个对比告诉大家。 那么大家已经知道，如果用双引号引起来的一些字符，它是一个 字符串。**那我想告诉大家的是，所有的字符串，都是以 \0来结尾的。或者，在这个课上，我们可以这样认为， 所有以\0来结尾的 字符数组都可以被看作字符串。 那么这个话反过来也成立。什么意思呢？ 所有以\0结尾的字符数组， 都可以被看作字符串。 也就是说当你把一串字符写在双引号里面的时候， 你其实就默认的给这串字符加了一个\0**. ok，这是我想告诉大家的一点。 那么知道这一个信息之后，如果再写出这样的一句程序来， 定义一个字符数组，它包含5个元素， 然后呢，我给它赋初值为双引号引起来的5个字符，请问这样做行吗？ 有同学可能意识到了，这样做是不可以的。因为后面用双引号引起来的这个部分，其实是 6个元素。等于多了一个\0.通过这个，我们就可以知道 以\0结尾的字符数组和双引号引起来的字符串， 那么现在啊在这个课上，我们可以认为它们俩都是相同的。那么明确了这一点之后呢， 那么接下来我们会去讨论字符数组和字符串到底应该怎么去用。 在讨论这些问题之前呢，我们先说几点注意事项。第1个，关于赋值。 那么我们都知道啊，在定义一个字符数组的时候， 比方说，定义一个包含6个元素的字符数组的时候，我可以直接把一个字符串 或者是一个字符数组，用一个赋值符号直接赋给一个字符数组，但是我想强调的是，这种赋值方式仅仅能用在 数组定义并且初始化的环节。在程序的其他部分，是不允许这样来做的。 也就是说，我们不能用赋值语句 把一个字符串或者字符数组直接赋给另外一个字符数组，这是不允许的。 看几个例子。比方说我们有一个字符数组str1，这是一个字符数组。 我让它等于china这样的字符串，那么如果这句程序不是 出现在字符串定义的环节。那么是不允许这样来写的，这是不合法的。 同理，我更不能把一个字符串直接赋给一个字符数组的名字， 而且我也不能把两个字符数组的名字直接用赋值号连接起来， 这是不允许的，这都是非法的iii。那如果我想要在 两个字符串之间进行赋值，我应该怎么办呢？你可以写一个程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char str1[] = "C++ labguage", str2[20];
        int i = 0;
        while(str1[i] != '\0') {
            str2[i] = str1[i];
            i++;
        }
        str2[i] = '\0';
        cout << "String1:" << str1 << endl;
        cout << "String2:" << str2 << endl;
        return 0;
    }
    ```
  比方说，这有个程序，我定义了两个字符数组，一个叫str1，一个叫str2. 那么str1呢，我已经赋好值了，c++language，我想要啊 把str1的这个值，赋给str2， 我想要实现这样一个结果，那我应该怎么办呢？这个时候啊，我就得写一个程序。 用一个while循环，对于str1里头的每一个字符， 只要这个字符不等于\0，只要不是它的 最后一个元素，那我就把当前的这个元素赋值给 str2，也就是说我把str1里的每一个元素 都给它搬到str2里头来，等我把 \0之前的所有的元素全都考虑完了的时候，我再让 str2的最后一个元素等于\0， 否则的话，这就，它两个就不一样了对不对？因为都是以\0来结尾的。 赋完值以后啊，我想把这两个字符数组都打印出来，你看我这个打印是怎么来写的。 cout string 1直接在这写了字符数组的名字， 有同学可能就问了，以前啊，我们想输出一个数组 的时候，我们曾经强调过，可不能直接把数组的名字写在这。 那么在这你为什么可以直接写名字呢？ 对于一个字符数组而言，这样做是可以的，其他类型不可以，但字符数组是可以的。 这个待会儿呢我们还会专门提到。 
- 这是关于字符数组，当然，类似于普通的数组，有了一维的数组我就可以定义 二维的字符数组。比方说啊，我想储存7个 英文单词，Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday 7个英文单词，我就可以定义一个这样的二维字符数组， 包含7行11列。为什么是11列啊，我就是稍微做了点拢源iii。 那么对这样的二维数组进行赋值，跟一维数组的赋值情况 完全一样。比方说，我可以直接写一些字符串在这里， 因为字符串和字符数组只是差了一个\0，我就把它们都写在这，列举在这，没有问题。 通过这种方式啊，我就得到了这样的一个结果。该是字母的地方， 都赋成字母，不是字母的地方，全部都自动的赋了\0. ok，这是关于字符数组啊， 稍微的多说两句。 
## 2. 输入缓冲区
- 那么接下来我们有一个很主要的主题。 就是关于字符，字符数组，字符串的输入和 输出。啊为什么要再单独拿这个东西出来讲？ 还是那句话，太常用了，在程序里头太常用了。所以说我们单独 把它们拿出来讲一下。那么在这个部分啊，我想讲3个内容。 
  - 第1个内容呢，我介绍一个引子。在这部分，我想告诉大家， 当你想把一个数据从键盘上送到程序里头的时候，经历了一个什么样的过程。 
  - 第2个，我们讨论一下针对一个字符的输入和输出。 
  - 第3部分，我们再讨论针对字符串或者是字符数组的 输入和输出。啊这是接下来我们要讲的3部分内容。
- 首先我们来看一下输入的过程。 其实所谓输入的过程啊，我就是想让大家了解这么一个概念，这个概念叫做 输入缓冲区。
  - 什么叫输入缓冲区呢？我们来说明一下。 比方说啊，我们要从键盘上输入一些数据，给一个程序。 然后这个程序运行起来了，它需要接收一些数据的输入，啊Cin，运行到Cin了， 需要接收一些数据的输入，那这个时候，我们会怎么做呢？我们首先在键盘上， 键入了一些字母，比方说我们在键盘上输入how are you， 这是我们在键盘上敲的数，当我们敲完了这一串字符，按一下回车， 这串数据，连同这个回车，就会被送入到一个地方，这个地方就叫输入缓冲区。 啊，那么输入缓冲区啊，你可以把它想象成一个池子，或者是一个盒子， 在内存里面的一个池子或者是一个盒子，啊你一敲回车，我就把刚刚键入的字符全部都送到 输入缓冲区里头来。送到输入缓冲区里头来以后， 那么程序就会感知到，噢，有东西了，输入缓冲区里头有东西了， 于是程序就到这个输入缓冲区里头来 提取相应的字符。这就是 到目前为止，我们所接触过的 程序输入数据的一个过程。非常的简单，你只要知道，噢并不是在键盘上输入 完了之后就一下子扔给程序了，而是先送入到了一个输入缓冲区里头， 然后呢，程序再到这个输入缓冲区里头来获取相应的字符。 啊是这么一个过程。 明确了这个过程以后啊，我们有些事情就好解释了。那么在这儿呢，我还想说的一点， 既然啊这个程序要从输入缓冲区里头来读取字符， 那么我就得记住哪些字符是已经读取过得，哪些字符是尚未读取的。 所以说呢，在输入缓冲区里头啊，会有一个指针。 这个指针呢，专门来标明哪些字符 是已经被读走的，哪些字符是没有被读走的。 而且这个字，这个指针呢，它只能往后移动。啊因为它移动过去就意味着 前面的字符是已经被读走了的。比方说如果我们读到这儿了， 如果这个程序啊，第1次把how读走了，读到这儿了，第2 次再去读取的时候只能从这往后再去读取， 那边说可以把are再读懂，那这个指针就会被移到 这个地方来，然后再把you读走，那个指针就会被移到这儿来。 啊那你要记得，在输入的时候啊，会有这么一个指针来标定 我们读取到哪里了。ok，这就是输入缓冲区和缓冲区指针。 至于什么叫指针？别管它，你就直接把它看作一个标记就行了。 ok，这是一个输入缓冲区的概念。 那么有了这个概念之后啊，我们再去解释输入，那就容易多了。我们看几个例子。 比方说啊，有这么几个输入。我们在程序里头定义了2个变量，a 和b，啊，然后呢我们从键盘上要Cin a和b，要读入a和b。 我在键盘上输入什么呢？输入一个21，空格，22，回车。 啊，我们都知道一回车的话，这两个字符就被送到输入缓冲区里头来了。 那怎么去读取呢？很好办，Cin就负责去读取这串数据。那读到一个2，22之后， 它就把21送给a，22送给b。 有同学说，它怎么能区分得清楚哪个是21，22啊？ 中间有空格啊，啊，它用空格来区分不同的数，这是我们所熟悉的。 那有的同学可能问了，那我能不能这样啊，你要的是两个整数，我能不能输的时候输如一个 21，然后后面一个我就故意不给它一个22，我给它一个abc，行吗？ 不行。为什么呀？因为在这个地方啊，这个Cin啊， 是没办法实行类型转换的。它不可能把一个字符串直接转换成一个整数，这是不允许的。如果你比方说，我们想读取的是 3个数a，b，c，然后我们从键盘上输入的时候这么来输入， 21，空格22，然后回车，再输一遍23，然后再回车， 这样可以吗？这样可以，在这啊，对于Cin而言， 它会把空格和回车 都当作输入数据区分得标志，啊所以说呢，这样做是完全可以的。 啊这样做了以后就21给了a，22给b，23给了c。 啊这样输入是正确的。那么所以说呢，对这3种情况的输入，第1种呢， 是正确的，第2种呢，是错误的，第3种呢，也是正确的。 那么在这，我们还想说明的就是，如果啊Cin能够正确的读到结果的话，那么Cin将会返回1个非0的值，如果Cin不能够从缓冲区里读到正确的结果， 那么Cin就会返回1个0，从而代表发生了错误。 很多时候啊，我们可以利用Cin的这个特性，来书写一些支持连续输入的程序， 比方说这样的一个程序。ok我们来看这个程序， 那么我讲的这个时候，大家可能能够听到一点背景音乐， 啊这是外面呢，来了一个冰淇淋车，在，这个东西在美国是非常非常常见的，这个就像 我们在中国他们推着车子到处卖雪糕，一边走一边喊雪糕一样。 啊这就是一个冰淇淋车，那么小朋友们听到这个声音呢就会非常非常的高兴啊，出去买冰淇淋吃。 那么大家听到这个音乐呢，就是这个冰淇淋车的声音。ok我们不管它，我们来看一下这个程序。 那么这个程序所完成的功能呢，就是不断地从键盘上读入一个 乘积，啊这个乘积呢应该是一个float型的，一个，一个浮点数。 然后呢根据你的这个乘积，如果高于85分的话，等于good，如果低于60分的话， 等于fail。啊这是这个乘积的基本功能。那为了实现连续的一个输入，我采用了一个 这样的一个结构，while Cin grade，这是完全可以的，因为这就意味着 只要我能从键盘上读到一个合法的数字，并且把它 赋给了grade，那我就可以不断的去执行这个循环。那如果不能这么做的话， 那个循环就不能被执行了。如果我不能成功的读到一个float型的数字的话，那么这个程序就跳出这个循环。啊这是我们非常非常常用的一种从键盘上连续的输入数据的一种方式。啊这个呢，我们在open栈上面有很多的题，都要求这样去做，啊它基本的原理就是这样。
## 3. 一个字符的输入
- 那么了解关于输入缓冲区的知识以后呢，我们就来看一下字符和字符串的输入 首先我们来看一下，当我们想从键盘上输入一个字符的时候 我们可以怎样处理。
  - 首先，大家非常非常熟悉的 我们可以直接用cin来完成这个输入。比方说这有一段程序，
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char c;
        cout << "enter a sentence:"<<endl;
        while(cin>>c)
            cout<<c;
        return 0;
    }
    ```
    定义了一个字符变量c，打印一行提示，要求你输入一个句子，然后呢，后面有这样一段程序，while cin给c 也就是cout这个c，大家想象一下这个程序的执行会是怎样的一个过程啊 我提供两种选择。第一种选择是说，比方说我想输入ABC给这个程序 那我，当我从键盘上写一个a的时候 立刻程序就读到了这个a并且呢，在屏幕上立刻打印出这个a 然后我又敲入了一个b，那程序立刻就打印出一个b，然后我又敲入了一个c，那程序立刻打印出来一个c 这是一种运行方式。第二种运行方式是说：我在键盘上输入了abc 然后敲回车 这个时候，程序就会打印输出 abc。哪种方式？显然 第一种方式是错误的，如果你还是按照这种方式在想的话那么说明刚才输入缓冲区的这个概念 你把它忘记了，实际这个程序的执行方式肯定是这样的。就是说你不敲回车 这个数据是没办法送入输入缓冲区的 OK，那么知道了这一点就好办了。我们来看一下这个程序的执行结果，程序的执行结果是这样的 enter a sentence，打印输出，输入的是abc 然后空格，def，然后空格，g，然后呢，后面跟了一个回车 那么当我一敲这个回车的时候 程序就可以从缓冲区里头去读这一串的数字了，但是，在这我想说的是 对于cin这种输入方式而言 它在从输入缓冲区里读取数据的时候 它会把所有的空格和回车 都当做输入数据之间的间隔符 也就是它会把这个空格和回车都看做只是用来区分 不同数据的。我认为这些东西只是用来间隔不同的数据的 我不认为它是数据，于是呢，我在读取这些数据的时候，从这个输入缓冲区读取数据的时候 我不会把空格和回车当做数据读入进来 你比方说这个程序的输出，输出里头abcdefg 已经找不到所有的空格了，而且呢，输出完了以后它也没有把光标的位置放到下面来 没有把这个光标的位置放下来，说明在程序输出的最后它也没有输出 回车。**所以你一定要记得，对于cin它这个东西， 它会跳过空格并且跳过回车 跳过空格跳过回车**。 那有的同学可能问了，既然在这里呀，回车呀 空格呀，都被字符输入数据的间隔了 那我怎么终止这个输入呢。其实，当你想要终止一个输入的时候 你只要在后面敲一个这个东西 那么输入就被终止了，这是一个输入结束标志 别看好像是两个字符，其实这是一个字符。这个字符怎么输入呢？你只要摁住键盘上的control 然后摁一下Z这个字母就可以了 那么遇到这样一个标志的时候，那么cin的输入也就结束了 这是用cin来读取一个字符，那么除了这种方式之外还有什么方式可以读取一个字符呢？ 
  - 我们再来看一下 那么除了这种方式之外，你还可以用cin.get这个函数来读取一个字符 有的同学可能问了，这个函数名里头怎么还有一个点啊，稍作一个解释 这个函数是cin这个对象的一个方法 所以说这个地方会有一个点。你可以把它理解为cin里面的一个函数 然后这样来调用。当然，具体的东西以后你们学到面向对象的时候这个事情就清楚了 在这呢你只要记住把它当做一个函数来用就可以了 那么这个函数呢还有两种形式，一种形式呢是cin.get，这里边括号里边什么都不写 另一种是说，在这里面写一个变量，这个变量的类型是char类型的 下面我们用两个例子来看一下他们分别是怎么来用的 
    - 第一个，我们先来看一下cin.get 定义一个字符，然后呢打印一个提示 然后c=cin.get，那这个东西怎么理解呢？ 
        ```C++
        #include <iostream>
        using namespace::std;
        int main()
        {
            char c;
            cout << "enter a sentence:"<<endl;
            while((c=cin.get())!=EOF)
                cout<<c;
            return 0;
        }
        ```
      cin.get是一个函数，就像一个功能一样，你只要调用 你只要调用了一下这个功能，那它就会从缓冲区里边读一个字符把它付给c 这就是cin.get的含义。而且这还写了一个表达式。如果 赋值的部分。这个赋值表达式的值 不等于，EOF。EOF叫做文件结束标志 end of file。其实它的含义就是输入的结束。也就是说 如果函数给c赋的这个值 不等于end of file的时候 我就一直读取下去，这个while循环就是一直进行下去 否则我就可以跳出这个while循环，终止这个程序 跟刚才的这个程序非常非常像，我们来看一下这个程序的执行结果 来看一下。我从键盘上呢，输入了这样一行字符 abc空格，def空格，然后g，g后面呢敲入了一回车 当我敲完了这个之后，这一串字符就被送到了缓冲区里头 然后呢，cin.get这样的一个函数，就从缓冲区里头，去读取这行字符 那只要读到了一个字符，我就把这个字符打印出来，只要读到这个字符我就把它打印出来 我们可以看到啊，这个输出结果跟刚才我们用cin来输入数据的结果是不同的 你看在这里，它把所有的空格 全部都按照字符给输出出来了 其实啊，如果你运行这个程序的时候你会发现。它输完了这个话以后，程序的光标是在这闪烁的 也就是说，它还输出了一个回车 这也就是说，它能把 空格和回车 都当做字符给读取进来，并且把它给打印出来 也就是说，这种输入方式，跟cin最大的不同就在于 它不会跳过空格，也不会跳过回车 它会把空格和回车都当做 字符给读入进来，都当做普通字符去看待 这是用这种方式来输入的时候 的一个特点。 那有的同学还又问了。那我怎么结束呢？程序结束的方式跟上一个程序一样 我只要输入一个输入终止符号，我就可以结束这个程序了 这也是一个字符，当cin.get读到这样一个符号的时候，它就结束 我可以直接就用cin.get读取一个字符的情况 我们可以看到这种方式比cin要强大一些了，但有的同学可能说你这个表达式写起来太费劲了，一不小心就写错了 怎么办呢？没问题，你可以使用带参数的 这个程序就简单多了。
    - 看看，我们用cin.get(char) 这样的方式来读入一个字符，看看怎么去做的
        ```C++
        #include <iostream>
        using namespace::std;
        int main()
        {
            char c;
            cout << "enter a sentence:"<<endl;
            while(cin.get(c))  //读取一个字符赋给字符变量c
                cout<<c;
            return 0;
        }
        ```    
       定义一个字符变量，输出一行提示，然后while语句里头cin.get(c) get(c), cin.get(c)。那么get(c)的含义实际上就相当于 从键盘上读入一个字符并且把它赋值给c。 直接赋值给c，我们就不用判断了 而且呢，**如果我读入的是错误的时候，cin.get这个函数返回一个0 返回一个假。如果读入的是正确的，就像cin一样 返回一个真**。于是我们可以把它跟while语句放到一起使用 那么在这也一样，对于我读到的每一个字符，把它打印出来 把这个程序打印出来，我们来看一下它的运行结果。它的运行结果跟上一个 cin.get没有参数的这个情况是完全一样的。你看，当我从键盘上输入abc空格 def空格，g回车的时候。它会打印出来abc空格，def空格，g 也有一个回车，因为光标会在这闪烁。OK，而且呢 当我输入一个输入结束标志的时候，那么整个程序就结束了。也就是说它会把空格 回车，都当做普通字符来处理 什么东西是非普通字符啊？**只有这个结束标志是一个非普通字符** 这是这种方式 我们可以看到，总之用cin.get这种方式呢，就比cin，单纯用cin要强大一些 因为它会把空格和回车都当做字符来读取进来 那有的同学可能问了，有没有更强大的？ 
    - 有。那么还有一个函数，它甚至，能把输入结束标志 都当做数据给读取进来。我们来看一下这个 我们来看一下这个程序。
        ```C++
        #include <iostream>
        using namespace::std;
        int main()
        {
            char c;
            cout << "enter a sentence:"<<endl;
            while(c=getchar())  //读取一个字符赋给字符变量c
                cout<<c;
            return 0;
        }
        ```      
      在这个程序里头，仍然定义了一个变量c 然后呢，我用了这样一个函数，等于getchar，getchar 那么在这样一个函数前头不用写cin. 但是它仍然是输入输出库里边的函数 对于这样一个函数，它就会不跳过任何字符。我们来看它的输出 我们输入一个abc空格，然后def空格，g回车 它会输出abc空格，def空格，g回车 于是光标在这闪烁。如果我再回车然后敲入一个control Z 这个时候呢，它就会把control Z 直接也，当做一个字符给 读取进来，并且打印出来。如果你再次键入control Z的话它还会把它打印出来 就是不跳过任何字符 我可以用这种方式来实现连续的输入。OK，那么我们在写程序的过程中呢 这几种方式你都可以去使用 并不是说不跳过任何字符的方法就比以前的方法要好。no，要根据你自己的情况 来选择处理，ok这是关于一个字符的输入 
## 4. 一串字符的输入
- 下面我们再来看一下一串字符的处理。我们先来看一下一串字符的 输出。就当我想输出一串字符的时候我应该怎么办。 先来看一个程序。这个程序是这样的。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char a[10] = "Computer";
        cout << a;
        return 0;
    }
    ```   
  定义了一个字符数组a[10]， 然后呢，我用一个字符串给它赋了一个初始值。 那这个字符串是computer，我们数一下就知道了computer里面 其实只有8个字母，只有8个字母。 那么通过刚才的讲解我们都知道这个赋值的结果会得到这样的一个结果，就是computer， 前8个全部都赋好值了，最后的两个呢是两个\0. 是这样的一个结果。那现在呢我就把这样的一个字符数组啊直接给它输出出来， cout直接写到字符数组的名字，这样可以吗？刚才我们说过，这样完全可以。 那么通过这个程序，你得到的结果就会是一个这样的结果，它就会输出一个computer。 那么输入完了之后呢，光标将会在这个地方闪烁， 就会在computer后面闪烁着。其实呀，是这样的，当我们使用这样的方法来 输出一个字符数组的时候，那么程序会从这个字符数组的第1个元素 开始，一直往后输出，直到我碰到第1个\0， 那么就终止。 所以说它会打印出来computer。然后呢，终止在第1个\0上。 所以我们才可以用cout直接去输出一个字符数组。
- 那有的同学可能接着就要问了， 那如果后面没有\0会怎样呢？我们来看一个程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char a[8] = {'C','o','m','p','u','t','e','r'};
        cout << a;
        return 0;
    }
    ``` 
  在这个程序里头啊，我就定义了一个字符数组a8，然后呢，给它赋了 8个字符，那么这样的一个赋值的结果，我们会得到一个这样的数组。 那如果我想把这样的一个数组给打印输出的时候， 它会怎样呢？那在我的电脑里，它执行的结果是这样的。 也就说打印完了computer之后，后面接着出现的是一些乱码。 我们可以看到，在这种情况下，它仍然是会把这个数组啊，字符数组当作一个字符串来输出。 只不过呢，因为这个字符数组并不是以\0来结尾的， 所以说呢，它不会输出到这个地方就截止了， 它会一直往后输出，直到发现某一个\0。 于是在这个computer这些字符之外，那么就会打印出来一堆没有意义的字符。 啊这就是用cout输出，所以说啊，**当我们想用cout来输出一个字符数组的时候， 为了确保不会输出乱码，请你确保这个字符数组是以\0来结尾的**。 这是用cout来直接输出一个字符数组。 
- 那么既然可以输出一维的字符数组，我也可以用这种方法来输出一个二维的字符数组。比方说，对于刚才我们所定义的用来存放星期几的英文字母的那个字符数组， 二维字符数组而言，通过这种方式呢，我对二维数组进行了一个赋初值，把初值都赋好了， 然后呢，我直接底下写了这样一段程序，cout， weekday，然后写了一个下标i。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char weekday[7][11] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"};
        for(int i = 0;i < 7;i++)
            cout << weekday[i] << endl;
        return 0;
    }
    ``` 
  首先这种方式允许吗？这个程序是正确的。我首先告诉你这个程序是正确的。 有的同学会觉得，哎呀，那为什么会在这，这个weekday后面怎么只写了一半呢？ 还记得我们在讲二维数组的时候提到过的吗？ 定义一个二维数组实际上就相当于定义了多个一维数组。 而且呢，一维数组的名字可以表示成这样子。你比方说，我们定义了一个这样的二维数组的话，就相当于我们 定义了7个一维数组，这7个一维数组的名字分别是weekday0，weekday1，weekday2，weekday3，一直到weekday7. 所以说在这，我可以把某个一维数组的名字写在这。 那么weekdayi就代表着那么这7行里边的某一行。 我可以通过这种方式把它打印输出出来。我们看一下这个程序的运行结果。程序的运行结果是这样的。 它可以把Sunday打印完了之后光标在这，然后接着打印Monday，Tuesday， Wednesday，Thursday，Friday，Saturday，ok，通过这种方式把它打印出来。 这是非常常用的一种输出二维数组的方法。 说到这儿啊，让我们明显有一个感觉就是，看来输出一个字符数组比输出一个 这个整数数组要简单太多了啊。我们只需要把字符数组的名字写在 cout的后面，就可以了。
- 那么这种方法能不能用于普通的int型数组呢？ 我们来看一个程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int a[8] = {1,2,3,4,5,6};
        cout << a;
        return 0;
    }
    ``` 
  在这儿啊，我就定义了一个普通int型数组。然后a[8]等于1，2，3，4，5，6. 然后呢，我直接去输出这个a。程序允许你这么去做吗？首先它允许你 这么去做。这个程序在我的电脑上执行的结果是这样的，它会打印出来这样的一串数字。 啊，为什么是这样的一串数组呀？其实啊，我先告诉大家，在这输出的是a。 a呢，对于普通的这种数组而言， 数组的名字其实代表了数组的起始地址。 **在这你cout打印出来的，实际上是这个数组的起始地址的值，所以说并不是数组的值**。 那么关于这件事情，以后我们讲到指针的部分的时候我们会更详细的去介绍。 ok，这是关于呢， 一串字符的输出。
- 那么接下来呢我们再看一下，如何在程序里头啊， 输入一串字符。那么为什么把输入放在最后呢，因为它还稍微的有一点点麻烦。 
  - 首先我们想从键盘上输入一串字符，我们当然可以用传统的方法，就是直接 用cin去输入，这是我们的第1种方法。我们来看这个程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char str[10];
        cout << "enter a sentence" << endl;
        while(cin >> str)
            cout << str << endl;
        return 0;
    }
    ``` 
    在程序里头呢，我定义了一个字符数组，名字叫str，它有10个元素。 输出了一行提示，然后呢我在程序里头啊写了这样一串语句，cin，然后呢，直接把这个字符数组的名字呀放在这。大家都知道，这样一种方式对于普通的数组而言，是不允许的。你比方说你如果是一个整型的数组是不允许的。 但是对字符数组而言，这样做是允许的。那程序呢， 会从缓冲区里头读一段相应的字符，并且把这个字符呢 赋给字符数组str，我们来看一下这个程序的执行过程，对照执行过程我们来说一下。 运行起这个程序来以后啊，我就从键盘上输入了这样一串字符， abc，空格，df，空格，g，然后敲了一个回车。我们cin会怎么做呢？ cin是这样的。既然abc后面有一个空格，那cin就明白了， abc呢是一个独立的字符串，于是呢它就把abc先读取进来。 读取进来放给str，然后呢把str打印出来，并且打印一个换行。 于是我们得到了abc，这是第1个。打印完这个之后呢，接着我继续执行这个while的循环， 继续执行第2次while的循环，那么接着呢，又把def读取进来。 读取进来之后呢赋给str，然后接着再把str再打印出来，于是得到第2行的 def。同理结束之后呢，它再去读取第3个字符串， 也就是一个字符的g，然后再把这一个字符的g赋给str，然后再把它打印出来。 知道我们输入一个结束标志，ctrl z，这个while循环呢， 才被打破。那整个程序呢，才会结束。也就是说，当我们用 cin来输入一串字符的时候啊，程序怎么去界定一串字符的呀？它就会把 空格和回车来当作不同字符串之间的间隔标志， 并且呢通过这种方式把字符串读取进来，并且打印出来。这是一种非常常用的 用来读取字符串的一种方式。
  - 除了这种方式之外，还有什么办法啊？ 对于一串字符的输入啊，我们照样可以利用一个函数，就是cin.get 这个函数来输入。
  - `cin.get(ch,10,'\n')`
    - 读取10-1个字符（包括空格），赋给制定的字符数组
    - 如果在读取10-1个字符之前，遇到制定的终止字符'\n',则提前结束读取；(如果第3个参数没有制定，则默认为'n')
    - 读取成功返回非0值（真），如果失败（遇见文件结束符O）则返回0值（假）。
  - 那么这次呢，这个函数的用法就跟前面不太一样了。 这次呀，为了保证我们输入一串字符，我们需要给这个函数啊，填写3个参数。 比方说，我在这举了一个例子。在这个例子里头呀， ch是一个字符数组的名字。 然后在这输入的一个10，表示我 要从缓冲区里头读取多少个字符。 如果我这写的是10的话，那就标志着我每次要读取10减1，9个字符。 然后后面呢，还有单引号引起来一个\n，\n以前我们讲过，这个\n是一个 转义字符，它的含义就是换行。那么把这样的3个参数写进来，它表示什么意思呢？ 要通过这个函数啊，从键盘上读入10减1个字符， 然后把这些字符赋给名字为ch的一个字符数组。 那么如果在读取这9个10减一个字符之前， 遇到了你所给定的后面这个字符，那我们把这个字符称作 终止字符。因为如果我还没读到第9个字符就已经碰到了 你所指定的这个字符,那么这个读取就提前结束。 那如果碰不到这个结束字符那我就读取9个字符回来。 读完了以后呢,把它送给名字为ch的 字符数组。如果我能够成功地完成这个过程， 整个这个函数就会返回一个非0的值，表示真。那如果在读取的过程中碰到了 失败了，比方说遇到输入的结束标志，那么就返回0。啊，返回一个假。 这就是这个函数的基本的含义。我们下面看一个例子，啊，来说明一下。Ok， 我们来看这个例子，
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char ch[20];
        cout << "enter a sentence:" << endl;
        cin.get(ch,10,'o');  //指定终止符为'0'
        cout << ch << endl;
        return 0;
    }
    ``` 
    那么在这个例子里头呢，我定义了一个字符数组ch， 20个元素。 那么打印一行提示。接下来呢，我使用cin.get这个函数，来读取一串字符。 然后呢，我紧接着把读取到的这个字符啊，给它打印出来。在这个过程里头呢，我要求读取10减1 个字符，9个字符，并且呢，我指定字母o，为终止字符。也就是说，如果碰到o，我就终止。 我们来看一下这个程序的运行结果。程序运行起来之后啊，我输入这样一串字符We, 空格，are，空格， good，空格，friends，点。然后，回车。当我敲入回车把这一串字符送入缓冲区之后， cin.get 这个函数就来读取这一串字符了。那它怎么来读取的呢？ 从第一个字符开始，第一个字符，第二个字符，空格是第三个字符， 第四个，第五个，第六个，都没遇到终止字符。继续往后读，第七 个，第八个，第九个，我在读取第九个字符的时候，碰到了终止符， o。那本来如果不指定这个o的时候，我因该把这个o读进来，因为 它是第九字符，啊，因该读进来的。但是现在呢碰到了终止字符，所以说我就 终止，不要再读了。于是到目前为止我所读到的字符就是 We are g,看明白 这个过程了吧。就是说，如果不遇到终止字符，我就读取相应的个数。如果遇到了终止字符，我随时结束。 这是输入一串字符的第二个办法。
  - 除了这两个办法之外啊， 还有第三个办法，就是用另外一个函数，叫做cin.getline。 这也是cin 下面的一个函数。它的基本用法，跟 cin.get非常类似，我们来看这个程序。
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char ch[20];
        cout << "enter a sentence:" << endl;
        cin.getline(ch,10,'o');  //指定终止符为'0'
        cout << ch << endl;
        return 0;
    }
    ```   
    定义一个字符数组，啊， ch,然后包含20个元素，输出一行提示，然后呢， 利用这样的一个函数，来读入一串字符， cin.get。 紧接着把读到的这个字符数组再给它打印出来。啊，我们来看一下 这个程序的运行结果。这个运行结果看上去呢，跟刚才的运行结果完全一样。 我输入的是We are good friends.，回车。 然后程序去读取的时候呢，也是读第一个，第二个，第三个，第四个，第五个， 第六个，第七个，第八个，噢，第九个，读到第九个的时候碰到了终止字符 o，于是输入结束。所以说呢，这个函数读到的字符就是We are g， 最后把它打印出来。这个输入呢，很刚才的cin.get看上去完全一样。 
      - 那有的童鞋可能就问了，它们两个之间，有什么区别呢? ok, 它们两个的区别是我们今天要告诉大家的，要特别小心处理的一件事情。 它们两个有什么区别呢？
        - 它们的区别是这样的。 **首先这两个函数在输入的时候遇到终止字符都会停止， 但是，cin.getline 遇到终止字符停止的时候啊， 缓冲区的指针会移到终止字符之后。 但是如果是用get，cin.get 来读取的话， 那它的情况就是，遇到终止字符它立刻停止。这个指针呢，不再移动。它不会移到 终止字符之后去**。 
        - 那么对应于刚才的例子，我们来看一下， 如果你使用cin.get来读取，就像我们第一个例子那样， 当它碰到o的时候，那么这个输入， 缓冲区的指针呢，会停在这个字符的前面。终止字符的前面，它会停在这里， 啊，不会再动了。那么程序呢，读到的字符是We are g。 那如果你使用cin.getline来输入， 那么当碰到终止字符o的时候，那么缓冲区里的 指针呢,会一下子移到这个终止字符之后来。 当然，它所读到的字符串仍然是这个We are g,不包含这个o。所以说， 它们两个的区别就在于这个缓冲区指针停下的位置，是不一样的。这就是它们两个之间的区别。 这个同学说，哎呀，这真是费劲儿。这的确，啊，有点儿费劲儿。 但是我想问你一个问题，你觉得这两个函数对这个缓冲区啊，指针的 处理，哪一个更接近人们普通的思维方式呀？那恐怖怕很多同学跟我一样 都会觉得cin.get 更接近人们普通的思维方式。 因为你想，你给了我一个终止字符嘛，o，那我就停在这个终止字符的前面。 那看上去这种呢，更符合人们普通的这种思维方式。但是我想告诉你的是， cin.getline 确实比cin.get更常用的一种 输入方式。但是同学说，为什么呢？原因非常简单。 为什么呢？**因为人们在很多很多很多时候， 都会把终止字符设成换行。 那么在这样的情况下如果使用cin.getline 来读取的时候， 啊，就会方便得多**，我们举一个例子。
            ```C++
            #include <iostream>
            using namespace::std;
            int main()
            {
                char a[10][10];
                int n = 0;
                cin >> n;
                for(int i = 0;i < n;i++)
                    cin.getline(a[i],10);
                for(int i = 0;i < n;i++)
                    cout << a[i] << endl;
                return 0;
            }
            ```   
          这个程序的作用呢， 是从键盘上，读入n个长度不超过10 个字母的 一个单词。当然，n大小也不超过10。好，这个程序的开始啊，要求你 从键盘上输入一个n。啊，用这个n呢来说明，后面你要读入 多少个字符串。比方说，程序运行起来，在读入n的这个地方你输入 7，那就意味着你接下来想从键盘上输入7行的字符串。 输入7之后呢，接下来就构造了一个循环，从0开始到i，小于 7。我们用cin.getline 去一行一行地读入数据。 读入的每一行数据呢，存放在a[i] 这个字符数组里头。然后读完了之后呢，我再从0到 小于7，把我读入的这些字符串一行一行地打印出来。哎，从表面上看啊， 这个程序没有什么问题。但是当我们真正去运行这个程序的时候啊，你就会发现， 这个程序，是有问题的。比方说我们可以运行一下这个程序，来看一下它的输出结果。 我们来观察一些这个程序的输出结果。它的输出是这样的。当这个程序 运行起来之后呢，我输入7，然后呢，敲入一个回车。 啊这是我输入的第一行数据。然后呢，程序就把这个7读走了， 去执行这个for循环。从0开始到小于7， 不断地去getline, getline, getline,不断地去读入。于是呢，我就在这儿不断地输入，输入Sunday 回车，Monday，回车，Tuesday， 回车 Wednesday，回车，Thursday，回车，Friday，回车， 在我还没有键入Saturday的时候，这个程序一下子就进入了打印输出 的环节，立刻把刚才我键入的这一些单词一一 的全部都打印了出来。那这是为什么呢？ 在这个地方我明明地输入了一个7，为什么我敲入了6行，它就 开始打印了呢？这个问题啊，出现在第一行输入上， cin，n。 当我们在键盘上输入了一个7，并且，键入了一个回车，那么第一行数据， 7，连同这个回车，就被送入了缓冲区里。然后程序呢，就利用cin 来读取这个7。cin在把这个7读取 之后，缓冲区的指针在这个地方， 停了下来。缓冲区的指针，停在了这个地方。 也就是说，停在了7 的后面，回车的前面。 然后呢，当程序开始执行cin.getline的时候， 第一次执行cin.getline，它读到的是哪一行啊？ 因为cin.getline是以换行为终止符的，而 7 后面的这个回车符号， 是第一个cin.getline碰到的第一个换号符号。 于是，第一行的cin.getline，它起了个什么作用啊？ 它起了的作用，仅仅是跳过了第一行的这个和回车， 7后面的这个回车。 当它跳过这个回车之后，cin.getline剩下还会执行几次啊？只有执行6次了。 所以说，它的后面读取了6个单词之后，就进入了接下来的打印程序。 所以，这个程序之所以不能够像我们所预期的那样去执行，原因在哪里呀？ **在这里，第一行的这个回车上面。 因为你在程序中，首先使用了cin去读取了数字7。 然后呢，有使用了getline 去读取后面的字符串。就导致了这个问题的产生**。 这个问题啊，非常的普遍。因为在我们的open judge上啊，很多类似的这种题目。 有些同学呢，就写一个类似的程序，结果呢，发现程序就会报错了。 那这个程序应该怎么去纠正呢？啊，也非常的简单。 因为，问题出现在第一行的这个回车上面，所以说，我们只需要在第一行的cin后面，增加一条语句。 还记得吗？我们以前说过cin.get 可以读走换行符号， 所以说呢，我们在cin的后面增加了一行cin.get。 
          ```C++
            #include <iostream>
            using namespace::std;
            int main()
            {
                char a[10][10];
                int n = 0;
                cin >> n;
                cin.get();   //新添加
                for(int i = 0;i < n;i++)
                    cin.getline(a[i],10);
                for(int i = 0;i < n;i++)
                    cout << a[i] << endl;
                return 0;
            }
            ```   
          这句话的作用就是要读取多余的那一个换行符。 把这个换行符读走了以后呢，那么剩下的再去 利用cin.getline 读取数据，就不会出现问题了。 那么这个程序运行的结果呢，就是正常的。输入7， 然后呢，输入Sunday，Monday，Tuesday，Wednesday，Thursday，Friday，Saturday， 输入完这7行单词之后呢，程序就把它读入了进来。然后呢，进入了打印的这个程序。 啊，紧接着把这7行单词呢，再打印出来。那这个程序呢，就是正确的。 那么这个问题呢，就是我们在使用 输入的时候，需要特别注意的一个问题。 Ok，那么关于如何输入一串数据，我们就讲到这里。 接下来呢，我们通过几个例子，来看一下， 字符串这种数据类型的应用。 
## 5. 字符串应用例题
- ok，那么接下来呢我们来看几个字符串的例子。 
  - 好，我们来看第1个例子。这个例子名字叫做字符串加密。输入一串字符串，要求你把这个字符串里边的每个字符都变成它的后续字符。什么叫后续字符呢？看这个例子，比方说你输入的是hello， 好的后续字符就是i，e的后续字符呢就是f， l的后续字符呢就是m，o的后续字符呢，就是p。 所以说hello就被变成了ifmmp。 也就是说，每一个字符都被变成了字母表上的后续字符。 那当然了，如果你碰到大Z或者小z的话，就应该把它变成大A或者小a。 这是这样的一个规则，空格呢不变。然后这个程序呢，要求能够连续的输入。 然后呢，把每一个字符都变成它的后续字符之后，再打印输出。 那对于这个题，我们应该怎么做啊？这个思路还是比较直接的。 首先呢，我们要读入每一行的字符串，然后针对我们读入的每一行的字符串呢， 我们从头到尾对这个字符串的每一个字符啊，做这样一些操作。 那么如果呢，我碰到的是大Z，那我就直接把它变成大A。 如果碰到小z呢，我就直接把它变成小a。 碰到空格的话呢，我就不做任何的处理。 对于任何其他的字符，我都可以让这个字符做一个++的操作。 我们都知道，每一个字符其实对应着ASCII码表里边的一个整数。这个整数呢，如果做++运算的话，就变成了它的后续字符，通过这种方式，完成了后续字符的转换。 最后呢，我输出整个新的这个字符串。 这是一个非常直观的一个思路，我们来看一下这个程序。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char str[200];
        while(cin.getline(str,200)){
            for(int i=0;str[i]!='\0';i++){
                if(str[i]=='Z'){
                    str[i]='A';
                    continue;
                }
                if(str[i]=='z'){
                    str[i]='a';
                    continue;
                }
                if(str[i]==' '){
                    continue;
                }
                str[i]++;
            }
            cout << str << endl;
        }
        system("pause");
        return 0;
    }
    ```   
    我们利用一个while循环，来不断的读取 字符串。然后呢，在这个while循环里头呢，我们利用cin.getline来读取每一行字符串。对于我读到的每一个字符串从第1个字符 开始，只要碰不到\0，我就挨个去做这样一个转换。 碰到大Z的话，就变成大A，如果碰到小z的话，变成小a。如果碰到空格的话，那我就什么都不做。除此之外，其它所有的字符，我都做一个++的运算。 最后呢，我们再把这个字符串打印出来。于是啊，这个程序的输出就是这个样子的。这是这个题目的一个解法。那在这儿，我想多说一句，虽然这个题目的名字叫做字符串加密，但是向这样的加密是基本没有什么效果的。 所有利用字符串替换来做的这种加密都可以用一个办法去解决， 那就是对新的字符串在整个文章中的使用频率做一个统计，我就可以，我就可以识别出来， 每一个字符对应的原始字符是什么了。那是因为啊，每一个字母在英文的文章中出现的概率基本上是固定的。所以说我们可以利用这个概率来做一个统计的检验就可以了。 

  - 我们再来看第2个题目。这个例子是这样的，从键盘上输入两个字符串，要求你呢，把其中比较短的那个串接到比较长的那个串的后面。就是两个字符串长度是不同的，那么请你呢把短的字符串接到长的字符串的 后面。有一个要求，不允许你使用系统函数，比方说strcat， 不允许使用这样的字符串函数。而且呢，他告诉你输入的串呢长度不超过20. 首先啊，在这提到了字符串的函数，那么我们在这稍微 跟大家提一下，其实在c程序里头，有很多的字符串处理的函数，它们呢，大部分都被包括在这样的一个库里头，include <string>你就可以使用它们。这些字符串的函数呢，非常的好用。比方说刚才我们说的这个strcat， 它就是拼接两个字符串来使用的。那么还有一些呢，比方说strcpy， 其实就是用来做字符串赋值的。把一个字符串copy给另外一个字符串，还记得字符串赋值也是比较麻烦的，我们需要自己写程序的。 在这呢，使用这个函数就可以自动的让它去完成。那么在这儿呢，我也多说一句， 虽然在这道题里面，我们告诉大家不要去使用字符串函数， 但是无论是在我们作业还是在我们的考试里头，如果你知道有相应的字符串函数存在， 并且你想去使用，你随便用。 因为我觉得对于字符串函数的熟悉，这个事本身也是一个knowledge。 你有这个本事为什么不让你去用呢？随便用。ok那么在这个程序里头啊 ， 那么在这个程序里头呢，它不允许我们使用字符串函数，我们来看一下我们应该怎么去完成这个任务。 其实这个程序啊，也非常非常的直接，既然我们要把短的串接到长的串的后面，整个这个程序啊， 我们肯定是要分成两步来走。第1步，计算字符串的长度。第2步，拼接字符串。 我们来看一下这个思路。首先呢，我们要定义两个字符数组，用来存放输入的字符串。 因为每个字符串的长度不会超过20，所以说呢，我们可以把每个字符数组的长度啊， 定义到40。这样的话，拼接起来就不会超出数组的长度限制。 然后呢我们利用getline，把这两个字符串读入进来。接下来呢，我们要写一个程序来计算字符串的长度。这个程序也非常非常的简单，一行语句就可以完成了。一个for循环，分号，在这里。在这儿呢，我们定义两个变量，len1和len2，用来计录字符串的长度。 那在这个for循环里头呢，len1从0开始， 只要string1 len1不等于 \0，也就是说不到最后一个字符，那我len1就++。 那么运行完这个for循环之后，len1里面就放了 第1个字符串的长度。同理我们可以获得第2个字符串的长度。 在获得了两个字符串的长度以后呢，我们就可以再写一个for循环， 把长的，较长的那个字符串，不断的做++的运算， 把短的字符串中的字符一个一个的挪进来，挪到长的字符串里头。 这个程序就结束了。非常直观的一个程序。我们来看一下程序题。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        int len1,len2;
        char str1[40],str2[40];
        for(len1=0;str1[len1]!='\0';len1++);
        for(len2=0;str2[len2]!='\0';len2++);
        if(len1>=len2){
            for(len2=0;str2[len2]!='\0';len2++)
                str1[len1++]=str2[len2];
            str1[len1]='\0';
        }else{
            for(len1=0;str1[len1]!='\0';len1++)
                str2[len2++]=str1[len1];
            str2[len2]='\0';
        }
        cout << str1 << endl;
        cout << str2 << endl;
        system("pause");
        return 0;
    }
    ```     
    定义字符串，然后呢，利用len1和len2 记录字符串的长度。如果len1大于len2， 那么用一个for循环，把len2里面所有的字符移到len1的后面。 否则的话呢，我就把str1的字符移到str2的后面。 这就是最后打印输出来的字符。这个程序非常的直接。 
    
  - ok，我们再来看第3个例子，叫做统计单词数。 输入一个英文的句子，它们约定呢，不超过80个字母，统计其中有多少个单词。而且呢它告诉你，单词之间呢，用空格分开。这个题目怎么去解决呢？ok我们来看一个例子。这个例子是这样的，有这样一句话。Everything should be made as simple as possible, but not simpler。这个呢，是爱因斯坦的一句话，当然这是我非常喜欢的一句话了。那么关于这句话呢，在网上有不同的翻译。大家如果有兴趣的话呢，可以去查一下。那么在这儿呢，我们不去讨论这句话的内容，我们拿它呀，来当一个例子。有同学说，啊呀，既然要去找，有很多单词， 那我去数空格，不就完了吗？那么单词的数量就等于空格的数量加1。唉，好办法。但是你这个办法呀，有一个很强烈的前提，就是要要求 所有的单词之间只能有一个空格，不能有多个空格。 因为有多个空格你就错了。 但是呢，我们的题目并没有强调这一点，并没有说单词之间都只有一个空格，所以说你的这个办法可能还真的不太行。那怎么办呢？ 既然不能数空格，直接来数单词就好了。 怎么去数单词呢？比方说我们可以这么干。 我们定义一个变量，叫num。它呢，用来记录单词的数量。 然后对于这样的一句话，我就开始分析，比方说，我读到的任何一个字母， 如果呀，在读取这个字母之前，我读的也是一个字母， 那么这个字母肯定不是一个单词的开头，一定不是。 对吧，因为它前面还有其他的字母。 对吧。那相反如果当我读到一个字母，在读到这个字母之前我读取的是一个空格。无论前面有多少个空格，anyway，在读取这个字母之前我读到的是一个空格，那么 就意味着我找到了一个单词的开始，对吧？是这样的一个逻辑吧？ 于是呢，我们除了定义一个num 来存放单词的数量之外， 我还定义了一个标志位，比方说flag，这就是一个标志位。 这个标志位是什么意思呢？起初的时候它就等于0 啊，最初的时候等于0。如果我读到一个空格，我就把 flag 给它改成1， 赋值成1。 如果我读到一个空格我就赋值1。然后呢？我就从头到尾去读这个字符串。 如果我当前读到的是一个字母，比方说是这个 S，并 且呢，由这个 flag 我就可以知道在读取S之前我刚刚读到的是一个空格， 那我就知道了，S是一个单词的开始，于是呢这个时候我就给 num 进行＋＋ 的操作。是否可以这样处理啊？ 那么继续往后读，如果读到的是字母的话，我就把flag制成0 。如果再往后读的话，一看 flag，知道前面是一个字母，所以说这不是一个开始的一个位。再往后读，如果读到一个空格的话， 我就把flag值成1。再往后读，当我又读到一个字母的时候，我一看，这个时候flag等于1,于是我就可以让num进行加加。这就是这个程序的一个解法。思路就是这样的。所以说我们就需要定义两个变量，一个叫flag，一个叫num。 啊，如果在读到空格的时候，我就把flag制成1。那么如果读到的是字母的话，我就检查一下flag到底是1还是0 呢，如果是1，我就加加。 ok，这个程序呢，就可以写成这个样子。 
    ```C++
    #include <iostream>
    using namespace::std;
    int main()
    {
        char str[80];
        int num=0,flag=0;
        cin.getline(str,80);
        for(int i=0;str[i]!='\0';i++){
            if(str[i]==' ')
                flag = 0;
            else if(flag==0){
                flag=1;
                num++;
            }
        }
        cout << "字符串中有" << num << "个单词" << endl;
        system("pause");
        return 0;
    }
    ```  
    那有了刚才的那个分析啊，这个程序就变得容易了。首先呢，我定义一个变量，num 用来 记录单词的个数，flag 用来记录当前单词之前，我读到的是一个 空格，还是一个字符。然后呢，我利用getline，把整个这句话呢，读入进来。 然后构造一个循环，从第一个字符到最后一个字符，逐一进行分析。 那如果当前的这个字符是一个空格的话，我就把flag 制成0。那么，如果当前不是一个空格的话， 那我就要做一个分析了。如果当前读到的不是一个空格， 而且呢，flag 在这个时候呢还等于0，那就 意味着，在当前这个字符之前，我读到的应该是一个 空格。那也就意味着，这个时候我发现了一个新的单词。 于是呢，我就把num，进行了加加。同时呢，我把flag 制成1，那就意味着，现在读到的，不是一个空格了。啊，那么为下一次读取 再做好准备。那这样的一个操作呢，不断地循环，直到呢，把整个字符串， 分析完毕。那么最后，num中呢，就包含了，最后的单词的个数。 我们看一下这个程序的运行结果。我们输入He is one of my good friends。 啊那么，可以统计出来，这个字符串有7个单词。 ok，这就是这样的一个程序。
- 好，那么讲到这儿呢，我们就把 字符串部分相关的内容啊，给讲完了。那么到这个时间点为止，我们就把理性认识C＋＋程序所有的内容，都讲完了。啊，终于讲完了。 在这个部分的学习啊，不同与我们前面感性认识C＋＋部分的学习。为了能够帮助同学们建立一个比较密实的基础，所以说呢我们在这一部分，比较详细地讨论了一下C程序里面的一些细节。那么之所以在这个部分啊，要讲述这么一些细节， 它的原因呢，还是处于一个交流方面的考虑。 因为在北大的校内啊，我们这个课程呢，还配有相应的实验课。像很多琐碎的问题呢，其实我们可以放到实验课上面去给大家解答。但是在网络上面呢，我们就缺少了实验课的部分。 啊那么没办法，为了能够帮助大家在写程序的时候啊，少犯一些错误，所以说呢，我们在课程中啊，讲述了比较多的细节。那么虽然呢，我在讲述这些细节的时候，对这些细节出现的顺序做了一些设计，但是难免呢，还是稍微有一些枯燥。我希望呢，大家能够坚持一下。毕竟在了解了这些细节之后啊，会对我们以后的学习啊，有一个比较好的促进。ok，那么关于字符串这个部分啊，我们就讲到这里。 
## 6. 写在下一个部分之前的话
- 在学习完“理性认识C程序”之后，我们希望同学们能够自己动手编写一些简单的C程序了！如果你还没有具备这个能力，一个可能的原因是因为你还没有进行“足够的训练”。因为，学习一门程序语言，需要你获得的有两样东西——“知识”和“技巧”。“知识”可以通过讲授传递，但“技巧”却只能通过训练获得。因此，我们鼓励同学们在“理性认识C程序”这个迭代周期中，多多进行简单的编程练习，以便获得“技巧”。（注意：我们特别鼓励同学们多多进行“简单”的编程练习，因为，所有复杂的问题，都是简单问题的组合。我们的教学实践表明：多做简单练习，不但可以提升学习者的学习信心，也非常有助于编程技巧的提升！）

- 在完成“理性认识C程序”部分的学习之后，我们将开始新的迭代周期——“结构化的程序”。在这个部分，我们将讲授一种基本的、用于将程序组织成“模块”的语言成分——函数。函数实际上是C程序的基本组织单位，是C程序设计中的重要组成部分。

- 在这个迭代周期中，同学们不仅要学习函数的定义方式、调用方式，还要学习一种重要的函数使用方法——递归。我们将讲授递归调用的基本机理，并讲授“利用递归解决问题的技巧”。这部分，讲师本课程C程序设计部分的一个难点！不过，请同学们不要担心，我们将力图通过最简明的讲解方式，帮助大家掌握“递归”的使用方法，力争“化困难于无形”。我们一起努力吧：）
