# 计算机的基本原理
> 作为开篇的第一次课，我们先来了解一下现代计算机运行的基本原理。我们将从历史上的三次数学危机开始讲起，引出现代计算机的基本原型——图灵机的基本原理，进而解释支撑现代计算机技术的几个基础性理论（二进制、布尔代数、数字逻辑电路）及其解决的基本问题。本次课的主要目的：帮助同学们了解现代计算机的基本原理。本次课的焦点问题：计算机为什么能利用电路实现计算？
---
## 1. [从数学危机到图灵机](https://www.coursera.org/learn/jisuanji-biancheng/lecture/ieLnF/cong-shu-xue-wei-ji-dao-tu-ling-ji)
   - 讲述计算机的基本原理，我们从一只碗开始说起。 看到这只碗的时候，我被他优美的曲线所吸引。 这不是一只普通的碗，而是一只[图灵奖](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96)的奖杯，[图灵 A. M. Turing](https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5)是一个人。 那图灵是一个什么样的人？他做了些什么？ 跟计算机原理又有什么关系呢？
   - 这要从数学的危机开始说起。 在数学的发展史上，有多次数学危机。 这些数学危机既是对数学的挑战，也是对数学发展的推动。
      > **第一次数学危机**发生于公元前500年。 当时有一个非常著名的学派，叫做毕达哥拉斯学派。 毕达哥拉斯就是这个学派的代表人物。 拉斐尔有一幅画，画于1509年。 体现了当时的风情。 毕达哥拉斯学派有一个信仰，他们深信数是万物的本源， 所有事物的性质都可以由某种数量关系决定， 所有的事物都会按照一定的数量比例构成。 这是一个非常完美的信仰。 而且他们深信一切数均可以表示为整数或整数之比。 就在这个完美的信仰之下他们推动了数学的发展。 后来毕达哥拉斯证明了一个非常著名的定理， 就是我们所说的勾股定理，在西方人们把它称作毕达哥拉斯定理。 这是毕达哥拉斯做过的一件非常有名气的事情。 但是，恰巧在这个定理的证明过程中，毕达哥拉斯发现 某些直角三角形的三边之比是不能够用整数来表示的。 这件事情跟当时人们的信仰 之间产生了直接的矛盾， 就是对当时的数学的一个否定。 因为牵扯到信仰，毕达哥拉斯非常慎重， 他没有吭声，但是， 他的一个学生叫做西帕索斯也发现了这件事情，并且把它公布了出来。 他跟人们说，你看，边长为1的正方形， 如果有一个正方形，它的边长都是1， 那么它的对角线的长度是当时人们无法表示的。 我们现在知道这个对角线的长度是根号2。 根号2是一个无理数，当然是无法用整数之比来表示的。 这件事情的提出直接挑战了当时人们的信仰。 于是，两个结果： 第一个，第一次数学危机由此而产生，而且 人们把西帕索斯提出的这个问题称之为西帕索斯悖论， 永远的纪念他； 第二个是，西帕索斯因为挑战了人们的信仰被人们扔进了海里。 其实这次危机直到200年之后才得以缓解，当时有一个人 叫做欧多克索斯， 欧多克索斯是一个非常聪明的人，他建立起了一套比较完整的比例论。 这套理论巧妙的绕开了无理数， 从而才使得当时的数学得到了一个形式上的完美，缓解了当时的数学危机。 当然，欧多克索斯所使用的是一种几何学的方法， 他的这种几何学的应用使得人们意识到几何的巨大作用， 推动了几何学的巨大发展。 但是第一次数学危机真正的解决要等到十九世纪的下半叶， 也就是实数的真正确立之后，才算得到了真正的缓解。

      > **第二次数学危机**与**微积分**有关系，在17世纪**牛顿**和**莱布尼兹**各自发现了微积分。 他们构建微积分的基础都是基于**无穷小**这个东西的。 在微积分提出以后，很多人就开始反对这种事情，他们觉得无穷小这种东西是有问题的。 在所有的反对声音里，最为典型、被人们熟知的是这个人， 这个人叫**贝克莱**，他是英国的一个主教，这个人在1734年 写了一本题目非常长的书。 在这本书里，贝克莱嘲笑微积分中的无穷小， 说无穷小一会是0，一会不是0，那到底是还是不是？ 它就像一个幽灵一样困扰着微积分理论。 同时贝克莱还举了一个浅显易懂的例子， **比方说当我们求X方的导数的时候， 我们要用X加ΔX^2(平方)减去ΔX^2平方， 然后除以ΔX， 得到的结果是2X+ΔX。 最后我们说X^2的导数是2X。 在这个推理过程中我们可以发现， ΔX可以出现在分母上，说明它不能为0， 然而在最后的结论中， 我们又说ΔX可以等于0，于是X^2的导数可以等于2X。 那在同一个推导过程中，一会是不允许是0，一会又是0， 确实是有很大的问题。这就是贝克莱悖论，挑起了第二次数学危机**。 当人们认识到数学危机之后就开始想办法缓解。 其实直到19世纪70年代，**威尔斯特拉斯**等人创建了**实数理论**，并且在这个理论上重建起了整个微积分理论， 才使得这个危机得到了缓解，但是它并没有完美的解决这个问题。 **例如，威尔斯特拉斯提出了一个特殊的连续函数， 一个处处不可微的连续函数， 给出了这样一个例子。 这个例子说明了什么呢？说明虽然你们重建了微积分的基础， 但你们所使用的是几何学的考虑， 几何学的办法 是不可靠的，想要追求可靠，那必须诉诸严格的概念和推理才可以。** 于是人们就开始重新探讨数学的基础， 结果催生了一个伟大理论的诞生，这个理论就是集合论。 19世纪下半叶，有一个人叫**康托尔**，是一个伟大的数学家，康托尔创立了著名的**集合论**。 大家都知道，集合论对计算机理论而言是一个非常基础的理论。 康托尔在19世纪下半叶创立了这个理论。 当然这个理论在刚刚创建时受到了很多人猛烈的攻击， 甚至有的攻击使得康托尔一度精神抑郁。 但是很快人们意识到集合论是非常有用的，因为数学家们发现 从自然数与康托尔集合论出发，可以构建起整个数学大厦。 而且基于集合论 当时一切数学成果都可以成功被推证出来。 集合论是一个非常伟大的理论。 甚至于庞加莱，著名的法国数学家 在1900年国际数学家大会上宣称， 借助集合论概念，我们可以构建起整个数学大厦。 今天我们可以说绝对的严格性已经达到了， 这对数学家来说是一个非常完美的结果。 但是就在这个时期，有一个人 出来讲了一个通俗易懂的故事， 使更多的人意识到集合论也是有问题的，这个人就是**罗素。 罗素给大家讲了这样一个故事： 说塞尔维亚有一位理发师， 这个理发师说，他只给那些不给自己理发的人理发， 而不给那些给自己理发的人理发。 什么意思呢？其实很清楚，你想象一下，你会给自己理发吗？ 那个同学说，我不会给自己理发，那你就可以去找这个理发师了， 他会给你理发，如果你会动手给自己理发， 那请你不要去找他，因为他不会给你理发，也就是说， 当判断你自己属不属于可以找那个理发师去理发的时候 很清楚，但是 这个时候，罗素问，那请问这个理发师要不要给自己理发呢？ 这个结论可以想一下， 他如果给自己理发，他就不属于 给他理发的人的集合，如果他不给自己理发 他又属于那个集合，可他到底属于还是不属于那个集合呢？ 后来人们把罗素的这个表述 称作罗素悖论。 我们可以形式化的描述一下：S由一切不是自身元素的集合所组成。 那么罗素问：到底S属于不属于S呢？他既不能属于，也不能不属于。 通过这个例子我们发现，原来集合论也不是完美无缺的， 也是有它自身的缺憾的**，就像德国数学家、 著名的逻辑学家弗雷格曾经讲过一段话， 说一位科学家不会遇到比这更难堪的事情了， 在他的工作即将结束的时候，发现基础崩溃了。 罗素先生的一封信恰好把我置于这样的境地。我们可以看得到 罗素悖论对整个数学界的影响，好不容易我们在集合论的基础上 又重新构建起了数学大厦，结果发现集合论也是不完美的。
   - 这可怎么办呢？那能不能找到一个完备的系统， 从上面构建起整个数学大厦呢？ 这样的系统是否存在呢？
        > 有一位哲学家给出了结论，这个人就是哥德尔。 哥德尔在1931年成功的证明了，任何一个数学系统， 只要它从有限的公理和基本概念中推导出来， 第一个条件，并且 第二个条件，从中能够推证出自然数系统 那么我们就可以在其中找到一个命题，对于这个命题 我们既没办法证真，也没办法证伪。后来人们把哥德尔 在1931年的这个证明称为哥德尔的不完备性定理。 通过哥德尔的不完备性定理我们可以看到， 关于数学基础的讨论可以结束了。 因为想着把数学彻底形式化的愿望本身， 它就是不能够实现的，不存在这样一个完美的系统。 说到这里，我们就得到了一个这样的结论： 你不要试图去寻找一个完美的系统，不存在这样一个完美的系统。 那么是不是我们就接受了这个结果就可以了呢？ 有了这个结论，是不是我们就可以不往下去追索了呢？ 当然不是，那么接下来应该考虑一个什么样的问题呢？ 假设说这个圆 来代表一个系统。 在这个系统中，有些问题是既不能被证真，也不能被证伪的；有些问题是可以被证真 或证伪的。 那么这个边界到底在哪里？ 怎么去判定到底一个未解的问题是否真的有解？ 这是一个很强烈的问题，在计算机里 我们把这个问题归结为可计算问题，也就是说假设有一个函数， f它的定义域是D，值域是R， 如果存在一个算法，对于D中任意给定的x，都能够计算出f(x)的值。 存在一个算法，只要给出D中的一个x，我都能计算出f(x)的值， 那么就称为这个函数f(x)是可以计算的，否则 它就是不可计算的。 那么既然在一个系统里，既存在可计算的问题 也存在不可计算的问题， 当碰到一个未解的问题的时候，我如何判定这个问题是可计算的 还是不可计算的呢？这就成为人们所面临的一个很重要的问题。 后来数学逻辑学家 给出了一个研究思路，这个研究思路是这样的，为这个计算 建立一个数学模型。 就是我们用一个数学模型来模拟这个计算，这个模型当然被称为计算模型，然后我们来证明凡是这个计算模型能够完成的任务 都是能够计算的任务，凡是这个计算模型不能够完成的任务 那么都是不可计算的任务。 也就是说这个计算模型就像一个评价器一样， 它能够评价出哪些问题是可计算的， 哪些问题是不可计算的，我们现在需要寻找的就是这样一个模型。

        >  **图灵就提出了一个这样的模型，这个模型就是[图灵机](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA)。** 我们先来介绍一下图灵。 图灵是一个伟大的英国的数学家，逻辑学家。 他在1936年发表了一篇很著名的论文—— [《论可计算数在判定问题中的应用》 ](http://www.risc.jku.at/people/schreine/courses/compcomp/Turing1936.pdf)这样的一篇论文。在这个论文里头，他给出了一个数学模型， 就是图灵机。 这样的一个模型成为计算机的一个基本的原理模型。 为了纪念图灵卓越的成就， 美国计算机协会ACM，这是一个组织， 我们今后还会反复的提到它。 它在1966年专门建立了图灵奖， 是计算机领域的最高奖。 用图灵的名字来命名，我们足以见得图灵机对计算机领域的重要性。 我们会在下一节的内容里着重介绍图灵机。 在这作为一个附加内容，我们稍微介绍一下图灵这个人。 他1912年生于伦敦，中学时就获得了一个很重要的奖，叫国王爱德华六世数学金盾奖。 1935年时他就被选为剑桥大学国王学院的院士。 1936年的时候他提出了图灵机。 我们可以看到，那个时候他只不过才 24岁。 38年的时候他在美国普林斯顿大学获得了博士学位。 在二战期间，图灵为反法西斯战争做出了很重要的贡献， 他参加的工作是破译密码而且图灵是一个非常重要的人物。 他在后期曾担任了英美破译密码的总顾问， 并且在战后1946年获得了不列颠帝国勋章。 在1950年图灵还提出了[图灵测试](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95)，可能很多同学都知道图灵测试， 这是一个很重要的测试，他对人工智能领域有着深远的影响。 1950年10月发表了一篇很重要的论文叫做：[《机器能思考吗？》](http://cogprints.org/499/1/turing.HTML) 这篇论文的探讨开启了[人工智能](https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD)的研究。 1951年时图灵被选为英国皇家学会的会员。 需要说明的是，这是图灵家族中第四位英国皇家学会的会员， 所以说他们的家族有着非常光荣的科学的传统。 到1954年图灵去世，人们为了纪念图灵 在英国的曼彻斯特，人们把图灵的故居专门拿出来 加以纪念。 可以说图灵对于计算机领域的贡献非常大 如果不是英年早逝的话，那么计算机整个的发展史也许就要重写了。 那么在下一节的内容里，我们将着重介绍图灵机到底什么样？ 它的功能是什么？介绍这些内容。 

## 2. [图灵机的基本构成](https://www.coursera.org/learn/jisuanji-biancheng/lecture/5UYBE/tu-ling-ji-de-ji-ben-gou-cheng)
   - 前一节我们讲到了三次数学危机。 讲到了图灵在数学和其他方面的贡献， 并且提到了“图灵机”。那么这一节我们着重来讲述这样一些内容。 图灵机的构成，图灵机长得什么样子呀？它的运作机理，它怎么工作的呀？ 然后我们通过一个例子来看一下图灵机的具体工作的过程。 最后我们来概述图灵机的意义。 
     > 首先图灵机的构成：图灵机长得什么样子呀？其实图灵机 非常的简单。它主要包含两个部分。 第一个部分是一条带子， 就是存储带。 这条存储带非常非常的长。它有许多的特性。第一个，可以向两边无限的延伸。 第二个， 存储带上有很多的小方格，一个一个的小方格。 这些小方格里面都可以存储数字（1：00）或者字母。 这是关于这条带子，非常非常的简单。 那么第二个部分是一个控制器，就是这个方方的东西吧。 那么这个控制器又包含些什么呢？首先包含了一个读写头。 这个控制器里头有一个读写头。 这个读写头可以读或者写，当前所储的这个带子上， 这个方格里面的字母或者数据。 第二个， 这个控制器可以接受 设定好的程序语句。 这一张纸你要说是program,程序语句， 可以接受。 这是第二个。第三个，它可以存储一个当前的状态。由于这个控制器本身 可以记住一个状态的。 但它不能记无穷多的状态，它只能记有限的状态之一。 
     比方说，这个图上面所显示的， 这个控制器大概有十一个状态。其中它目前的状态是第四。 这是可以存储当前的状态。 而且这一个状态是可以变化的。根据其他的一些讯息来变化的， 能变，这就是它的一项功能。这个控制器 它可以沿着这个纸带向右或者向左， 或者是向前向后，看你怎么样看那个方向， 在这个存储带上一格一格的移动， 左移或者右移。这就是整个图灵机的一个构成。 概述一下就是，一条带子，一条无限延长的带子。上面有很多方格，方格里面可以存放 数字或者字母。 然后一个控制器， 这个控制器包含了一个读写头，可以读或者写 方格上面的数据。当然能写就能改了。 控制器可以记住当前的一个状态，可以接收程序的输入。 并且当前状态可以随条件而变化。 而且整个控制器可以右移或者左移，在这个带子上。 这就是图灵机的一个构成。 那么整个图灵机是怎么去工作的呢？ 在开始工作之前，图灵机要做一些准备。 哪些准备呢？首先在这存储带上要设定好符号。 

   - 再一个呢，这个控制器要有一个初始化的状态。 它总得有一个最初的状态。 处于某个状态之一， 那么设定好那个状态。 
   - 第三个, 这个控制器要放好位置。 在这个存储带上到底处于哪个位置？放好，比方说这个位置。 
   - 再一个呢，就是准备好程序。 
     > 准备好这些东西之后，图灵机就可以开始工作了。 图灵机到底怎么工作呢？ 图灵机工作过程是一个反复执行 这一些动作的一个过程：第一个动作，读写头读出 存储带上当前方格中的字母 或数字。比方说，当前处于这样的一个方格中 这是一个长长的一方格，这是一个立体的图。处于这样的一个方格中。 那么这样一个方格中就有一个数字或者字母，读写头 把它读出来。第二个， 根据自身的状态以及你所读到的信息，字母或者数字的信息， 锁定一条语句，相应的语句。 找到一个相应的语句，根据这两个信息找到一个相应的语句。 第三个动作，根据这个程序语句， 做三个小动作。 就是根据我所找的程序语句， 做三件事情。 哪三件事情呢？第一件事情， 要在当前的这个方格里头写入一个什么数据， 这是第一件事情。第二件事情，要变更当前的状态。 要变，变这个状态，这是第二件事情。 第三件事情，要决定往右还是往左，移动一格。 这是第三件事情。概括一下图灵机的工作过程。 读出当前方格里面的信息， 根据这个信息和自身的状态，确定一套程序。 根据这个程序做三件事情。第一件事情，往方格上写什么。 第二个，当前的这个状态应变换到下一个什么状态。 第三个，往右或者往左(6:00)移动一步。 反复的执行这个动作。图灵机就工作起来了。 那么我们通过一个例子来看一下具体的 工作过程。听不懂没关系，我们有个例子，很好的一个例子来帮助大家理解。 
## 3. [图灵机的运行机理](https://www.coursera.org/learn/jisuanji-biancheng/lecture/xiTdw/tu-ling-ji-de-yun-xing-ji-li)
   - OK，那么下面我用一个例子来看一下图灵机的工作原理。 
     > 首先大家看到的这个抽象的图呢，就是一个抽象版的图灵机了。 这个呢，就是那个存储带。这个呢，就是那个控制器。 控制器呢有一个读写头，它有一个当前状态。并且呢，可以输入一些程序。 这是那个图灵机，这是一个空白的图灵机。 那图灵机在工作之前呢，首先要进行准备，完成一系列的初始化。 

     > 第一个初始化呢，像刚才我们讲过的， 首先要在存储带上放入一些表示符号，比方说我们在这个存储带上放入这样一些符号。 我们只放1，其他的呢保持空白，也就是说， 在这个存储带上，所有出现的符号只有两种，要么是1，要么是b，b表示空白。  

     > 第二个呢，要设好这个控制器当前的状态。 当前的状态，那么我们假设呢，当前的状态是q1，而且呢，我们假设在这个图灵机里头， 控制器值处于3种状态之一，q1，q2，q3。只处于这三种状态之一。 

     > 第三个，要放好读写头，放好位置，比方说我们把它放在这个位置。 对准这个相应的存储空格。

     > 第四个呢要准备好相应的工作程序。 比方说我们在这个图灵机里头要放入相应的工作程序。 那么大家看到的这个程序呢，是由一些字符来构成的。 实际上呢，它是六条程序语句，因为每一行表示一条程序语句。 一条相应的程序语句。 那这六条程序语句的格式是一致的。所以说呢，我们拿出其中的一条来做一个讲解。 任何一条程序语句呢，都包含5个符号。1，2，3，4，5。 这五个符号呢，分别表示不同的含义。 那么前两个符号，表示条件。 后三个符号 表示动作。 那这个程序语句的含义就是，当满足这个条件的时候，我要执行这个动作。那具体来说呢， 比方说这个符号q1，表示当前机器的状态。 也就是说，如果当前机器状态时q1， 并且，当前读到的符号是1，这个1表示的含义是当前读到的符号。 那么，这个条件就满足了。就要执行后面的这个动作，什么动作呢？ 第一个，这个1表示当前应该写入的符号。 当前在图灵机所位于的这个存储格上应该写入的符号。 第二个R，表示图灵机要向右移动一步。 也就是说，在写完这个动作以后， 在写完这个1以后，它要往右移动一步。 那么第三个呢，q1表示机器应该转入的一个状态。 
   - OK，准备工作完毕以后呢，图灵机就开始运转了。那么根据我们刚才讲过的，图灵机怎么运转呢？
   
     > 首先， 读写头读出存储带上当前方格中的字母或者数字。 当前方格是这个方格，把这个字母读出来。 根据当前自身的状态，和所读到的字符，那么找到相应的程序语句。 根据自身的状态，以及所读到的字符，根据这两个信息， 我们要到程序集合里头去找相应的程序语句。 因为当前状态是q1，所以说我们只能， 这是表示当前状态，只能找到，哦，在这两条程序语句里头。 寻找其中的一条。 那么因为读到的字符是1，所以，我们再来看，读到的字符是1，那只有第一条语句是符合的。 所以接下来我们要按照第一条语句提供的信息来进行执行。 执行三个动作。哪三个动作呢？第一个， 这个1，刚才我们解释过，表示要在这个方格里面， 再写入1，当前方格里头再写入1。 写入一个1，这个R呢，表示写完1之后，读写头要向右移动一格。 这个q1呢，表示在做完这两个动作之后， 这个控制器的当前状态， 控制器的当前状态，要从q1变成这个状态，也是q1，那也就是保持不变。 那，在经历， 按照第一条语句运行完以后，当前的状态应该是这样一个状态，我们来看一下。 控制器向右移动了一格， 当前的状态仍然是q1，刚才呢写入了一个1，1也保持不变。 那么，根据现在的，根据现在的状态呢，当前状态q1，读到的是一个1， 那再继续匹配，再来选语句。 选到的是什么？当前状态q1，读到的是一个1，又匹配第一条语句。 又执行这条语句。 所以呢，再次在这儿写入一个1，根据这个，要右移一格， 根据这个，它要保持不变。于是这个执行完之后呢，状态应该是这个样子。 当前状态q1， 又读到一个1，那么又匹配这条语句， 依然按它执行，保持不变，写入1，右移，保持不变。写入1，右移，保持不变。执行完之后是这样子。 那么当前状态q1，又读到一个1，还是匹配原来这条语句， 于是继续写入1，右移。然后状态保持不变。 写入1，右移，状态保持不变。变成这样子。当前状态q1，读到的是一个空白， 匹配语句，当前状态q1，匹配这两条，读到是一个空白，只能匹配这条，于是这条语句被选中。 那接下来它要做什么呢？要在当前的这个位置写入一个1， 并且读写头的状态往右移动一格。并且呢，当前的状态要由q1变成q2。 这是要做的动作，那么执行完这个动作之后，结果就应该是这样子。 写入了一个1，往右移动了一格，状态变成了q2。 那么现在呢，当前状态q2，读到的是一个1，我们再来找相应的语句。 当前状态q2，写入的是一个1。哦，只有这句语句符合。 那我们接下来要做什么呢？当前写入一个1， 然后右移，然后当前状态保持不变。 保持q2不变，写入1，右移，状态保持不变。 执行完是这样的，当前状态q2读到的又是一个1，又是这条语句被符合。 那么写入一个1，右移，状态保持不变。 又得到这样，q2又读到一个1，继续匹配这条语句。 写入一个1，右移，状态保持不变。 OK，执行完是这样子。那么当前状态q2，读到的是一个空白， 那么我们根据这两个信息得到出来的匹配， 那么q2，读到的是一个空白，这条语句被匹配到，它要做什么呢？ 当前写入一个空白，并且左移一下， 并且，状态由q2变成q3。 这是它要做的动作，那么这条语句执行完之后， 图灵机的状态变成这样子。 当前状态q3，读到的又是一个1，我们根据这两条来匹配。 那么q3，读到的又是一个1，匹配好这一条， 那现在图灵机要做什么呢？要在当前写入一个空白。 在这儿写入一个空白。并且呢，H，H表示 不动，读写头的位置不动， 然后状态呢，从q3变成q3，也是q3保持不变，执行完之后， 状态变成这样子，就是说不要动。然后当前状态q3，读到的是一个空白，那我们再来匹配语句。哦，这条语句被匹配到 也就是说，如果当前状态是q3，并且读到了空白，那我做什么呢？ 在当前的这个状况，写入一个空白， 并且位置不变，状态也不变。 读到一个空白，我就写入一个空白，并且位置不变，状态不变。 那执行完这条语句之后，仍然保持现有的这个状况。 仍然是这样一个状况。 在这个状况下，又是q3，又是读到一个空白，OK，一直就会执行这条语句。 于是，这个状态进入停机的状态。 我们这个时候我们可以说，图灵机成功的停机了。 成功的停机了。那么回顾一下刚才我们所举的这个例子。 看看它做了什么样的一件事情呢，这个图灵机？ 当然，有很多种的解释，在这儿呢，那我给出来一个解释。 还记得吗？我们刚刚开始的时候，在这儿输入了四个1， 在这儿输入了三个1， 1，2，3，4。1，2，3。我能不能这样解释， 在一开始的时候，这4个1呢，表示数字4，后面的三个1呢表示数字3， 这是最开始的状态。那整个图灵机执行完以后呢？ 这些1都被连起来了，那我可不可以解释成，这是一个数字7。 所以说呢，刚才的图灵机做了这么一个加法。4+3=7。 有的同学说，哎呀这个太简单了吧！这么复杂， 这么费劲，结果就算了这么简单的一个数字。 那我想说，虽然这个数字是简单的，但是这台图灵机可以算所有的加法。 这就是图灵机的作用。那么还是很强大的。 
   - 那么一个图灵机成功停机，到底意味着什么呢？
   
     > 停机表示计算完毕。 也表示着当前存留在这个存储带上的值，就是一个计算结果。 所以我们可以说， 停机就意味着计算得出计算结果了。 图灵机是用来干嘛的？我们讲过，图灵机是用来判定一个问题到底可不可解的。 那么当你面临一个问题，比方说有一个输入A，问能不能算出B啊？ 图灵机可以帮你做一个判定。 那么如果你能找到这样的一台图灵机，那就意味着这个问题可解。 如果找不到，那这个问题就不可解。 判定这个问题是否可解的 这件事情，就等同于，去寻找一台图灵机。 如果你能证明，存在这样一台图灵机，那么它就能解。 如果找不到这样一台图灵机，这个问题就不可解。 OK，这作为一个小插曲，介绍一下图灵机的作用。 那图灵机这样一个东西为什么能够受到如此的重视呢？ 其实，探讨可计算性的这个模型有很多个，那么为什么唯独图灵机受到这样的重视呢？ 因为图灵机有三大特性。第一个，简单。 这样的一台机器，几乎任何一个人，花一些功夫，都能搞的懂。 第二个，功能强大。它非常非常的强大，可以完成各种各样的运算。 第三个，它是看得见、摸得着，可以实现的。 有些同学说，有些东西恐怕不好实现，什么纸带啊，什么之类的。 这些就看你怎么去做了。比方说有这样一个网站， 这个网站叫做aturingmachine.com。 你可以到这个网站上去看一下。 它呢提供了一个图灵机的一个实现，长成这样子。 并且呢这个网站上有一段视频，这段视频专门来介绍，这个图灵机到底是怎么来运转的。 所以说，这个模型真的是可实现。这是图灵机 之所以这么受到重视的一个很重要的原因。 
   - 那么图灵机在理论上有什么意义呢？ 
   
     > 当然，第一个意义是，当提出图灵机的时候， 所要解决的那个问题，就是可计算性的判定的问题。 除了这个之外，它还有很重要的意义。 首先，它给出了一个可以实现的 通用计算的一个模型。 这就意味着，按照这个模型，我们有可能， 制造出一台能够进行通用计算的机器。 第二点，它引入了通过”读写符号“ 和”状态改变“来进行运算的这种思想。 第三个，实现了基于简单字母表完成复杂运算的能力。 它直接给你展现出来了，你看基于一个简单的字母表，就像我们刚才， 只用1和空白，我们就实现了加法运算。 第四个，引入了存储区、程序以及控制器等等概念的原型。OK，关于图灵机的东西，我们就先介绍到这里。 那么在接下来的这个章节里面呢，我们将解释一个问题。 计算机为什么能够完成计算？ 什么意思呢？ 就是说，我们所用的计算机，是由一些线路，一些电器来构成的。 这样一个电器，它为什么就能算数呢？ 我想通过一个讲解，来给大家解释一下这个问题。OK。 
## 4. [数的二进制表示](https://www.coursera.org/learn/jisuanji-biancheng/lecture/ngJK4/shu-de-er-jin-zhi-biao-shi)
- 这次课我们讨论一个很重要但又容易被忽视的问题：计算机为什么能够进行计算？ 好像这个问题看上去非常非常的基础，但是很多同学好像 不怎么去考虑这个问题。计算机为什么能算数？ 它是一个电路，是一个机器。它有智能吗？为什么它能够进行计算？ 
  > 那我们今天来讨论一下，关于这个问题的讨论呢我想应该分成以下几步 首先我们来看，既然是算数，**那么数在计算机中是如何表示的** 如果一个数不能很好的被计算机接受并且存储下来，那么它就无法进行计算 第二步，**在逻辑上，对于数计算机是如何进行计算的**？是按照四则运算的法则进行计算吗？ 还是怎样，有什么其他的方式，这是第二个 第三个，**在物理上，这个计算是如何实现的**我想我们想探讨这三个问题，那我们先来看第一个
  
- 问题：数在计算机中是如何来表示的？ 
  > 其实关于这个问题的讨论我们已经在图灵机的那部分已经涉及到了 在图灵机的章节里头我举过一个例子 我们用空白和数字1填满存储袋 当时我们算了一个加法叫4+3最后结果是7，7个1 来表示的，那这也是一种表示方式 而且这种表示方式非常非常的简便，可以说真的是简便到家了 那么这种方式，可不可以采纳呢？在计算机里？当然是可以的 从理论上讲。但是它有一个问题。我算的是4+3=7，这个还好办，我移动4次或者移动3次 我就可以把4或3读入进来，但是如果我算的是 1999+2001，这个移动的次数可能就非常多了 也就是说，随着数量的增大，图灵机为了读取这个数字 所要移动和读取的次数就非常非常的多 这显然是不合理的 也是不实际的。那么有的同学说了， 造成你这个问题的原因非常简单 采用了太少的符号来表示数了 那如果我用十进制来表示，那这个问题就简单得多了。比方说1999+2001 用十进制表示的话，我最多只需读取8位我就可以把数读取进来了 随着字母表中符号的个数的增加，符号的表达能力也越来越强，所以你需要读取的字符数也会越来越少 但是又出现了另外一个问题 比方说仅有1和空格的图灵机里 为了表达某一个状态和某个输入字符之间的条件关系，我只需要一个或者两个 顶多两个语句我就可以覆盖所有的情况 但是如果在十进制的程序里，我就要给每一个字符增加一个状态描述 当前状态Q1，逢0的时候怎样，逢1的时候怎样，逢2的时候怎样 一下子增大了，程序语句的增加直接意味着 每次图灵机在确定程序语句的时候，它的搜索空间也变大了 搜索次数也上去了，这个代价也非常非常昂贵，所以由此可知 字母表中的符号越多，读入的移动次数就会越少，但是程序量就会越多 符号越少，程序量会减少，但是读入的移动次数就会越来越多 太多也不行，太少也不行，那怎么办呢?

  > 经过计算，有人提出 说最优的数量可能是欧拉常数，2.71828 这个数取整以后是3，**与具有2个状态的电子元器件相比想制造具有3个状态的电子元器件 从工艺上讲更困难，所以人们希望能使用2个状态在字母表上来表达状态 直接的一个结论就是我们要采用二进制** 在这我们对比十进制来专门说一下二进制，十进制我们大家都很习惯了它的计数符号有10个，0、1、2、3、4、5、6、7、8、9，它的基数是10也就是说逢10进1 那么二进制也一样，二进制的计数符号只有2个，0和1 它的基数是2，也就是说，对于任何一个二进制数，跟上面的式子相同 我们怎样去计算这个二进制数的大小呢？ 比方说对于10110这个数，0乘以2的0次幂 1乘以2的1次幂 1乘以2的2次幂，0乘以2的3次幂，最后1乘以2的4次幂 这样加起来，就把这样的一个二进制数转换成了十进制数 在这我们也提一下十六进制，十六进制计数符号 有十六个，从0到F 超过10之后，因为没有相应的阿拉伯数字来表示，我们就用字母A\B\C\D\E\F 分别代表10、11、12、13、14、15 这是十六进制数，那么基数是16，也就是说当我们把一个 十六进制的数，比方说ABCD转换成十进制数的话那怎么算呢？ D乘以16的0次幂，C乘以16的1次幂 B乘以16的2次幂，最后A乘以16的3次幂，通过这种方式 我们就把十六进制的数对应的十进制数计算出来了 
  
- 那当我有一个十进制的数，因为我们平常用十进制的数还是最多的 怎么把它转换成二进制数呢？

  > 在这我们给出一个最通用的办法，就是除二取余 比方说对于一个十进制数123, 我要求它的二进制数，这个计算过程是这样的 123除2得61，余1 把余数写在这里，结果写在这里，商写在这里 61再除以2，商写在这里，余数写在这里 30除以2得15余0，15除以2得7余1 7除以2得3余1 3除以2得1余1，在这我要特别提示大家一定要把商除到0 才可以算计算完毕，所以说1再除以2得0余1 我们见到0以后，这个计算就可以完毕了 我们就得到了这样一个序列 这个序列从下往上反着把它写出来 就是123所对应的二进制数，从下往上去写的话就是1111011 也就是说对应的二进制数就是1111011 在这我特别想提示大家的就是一定要除到0 我把这一点称作一定要触底反弹 不触底不要反弹，我们有些同学炒股票可能就知道了 一定要触底再反弹，除到0，这样便于大家记忆 除了二进制之外，我们还有一种进制 也是常用的，叫做八进制，连同刚才我们所介绍过的十六进制 八进制就是逢八进一，从二进制到八进制 有一种非常简便的转换方法 比方说对一个二进制数1111011，就是刚才我们算的这个二进制数 我们想把它转换成一个八进制的数，注意这个表示，当你想表示一个数是二进制数的话 你可以这样来表示，在这个数的末尾加一个小括号然后写一个2 如果你想表示某个数是八进制的数的话，在这个数的末尾加一个小括号 右下角，然后写一个8 怎么从这个二进制的数得到八进制的数呢？ 有一个非常简便的方法 就是从这个数的最右端开始向左，每三位截取一段 把这个截取下来的数字转换成相应的八进制数 就OK了，比方说011对应着3，我就把3写在这里 再数3位，111，对应的八进制数是7 把7写在这，再数三位，数不了三位了，只有一位了，一位把它写在这 那么就是173，这就是对应的八进制数 同理，我们可以把一个二进制数转换成一个十六进制数 转换成十六进制数的话我们不能数3位了，我们就要数4位 1011，所对应的 十六进制数应该是11 所以我们在这写B，剩下的111，三位 对应的是7，所以说我们最后答案写出来是7B，十六进制对应的数 说到这呢，我们已经解决的问题，我们归结一下 已解的问题是说：**数的表示，在计算机里头 我们知道了我们是倾向于二进制数，这样表示比较便捷，而且比较符合我们现在的工艺水平** 那未来的计算机可能不采用这种技术方法，我们在下一节课会讨论 待解的问题，接下来，已经解决的问题是说我们会采用二进制 
- 接下来的问题就是，**如果我们采用二进制数来表示数 那么对二进制的数应该怎么去计算**？是不是也用十进制数所用的那种四则运算法则去计算呢？还是有什么其他的办法? 
## 5. [二进制的布尔运算](https://www.coursera.org/learn/jisuanji-biancheng/lecture/KBSgp/er-jin-zhi-shu-de-bu-er-yun-suan)
- OK，说到这呢，我们已经解决的问题，我们归结一下 已解的问题呢是说数的表示，在计算机里头 我们知道了我们倾向于采用二进制数，这样子表示的话比较便捷，而且符合我们现在的工艺水平 那么未来的计算机呢，可能不采用这种记数方法，我们在下一节课会讨论 那，待解的问题，已经解决的问题是说我们可以采用二进制 接下来的问题就是，如果我们采用二进制来 表示数，那么对二进制的数 应该怎么去计算 是不是也用十进制数所用的那种四则运算法则去计算呢，还是有什么其他的办法？
  >在这里我们就要介绍一个著名的理论和一个著名的人英国的数学家布尔。布尔在1854年发表了两篇论文 这两篇论文奠定了一种新的学科的基础，就是**[布尔代数](https://zh.wikipedia.org/wiki/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0)。布尔代数直到现在 仍然是计算机领域非常基础的理论，它为计算机的电路设计提供了理论基础**，那么在布尔代数里头是不是也跟十进制一样用加减乘除呢？ 不是的。**布尔代数有几种基本的逻辑运算，最基本的逻辑运算有三种 与，或，非**，待会我们解释它的含义 那么**把与或非这些基本的逻辑运算不同的组合在一起又形成了一些复合的逻辑运算 常用的有同或，异或，还有一些其他的**，待会我们会讨论同或或者异或 那么什么叫与或非呢？作一个简单的介绍。

  > **[逻辑门](https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E9%96%98)**

  > 在这有一个电路 电路里头有两个开关，A和B和一个灯 我们可以非常清晰的看到 当A和B全部都闭合的时候，F才能亮起来 如果我们用1来表示F亮起来，用0表示F没有亮 用1来表示A闭合，用0来表示它开启 B也一样，那我们就会发现有这样一个真值表得出来 就是只有A和B都闭合的时候F才会亮 其他任何一种情况，只要A和B里头有一个是0，也就是有一个是打开的 那么F就不可以亮起来 在这种情况下，如果我们把A和B看做两个变量 F是这两个变量运算的结果的时候，如果按照这样的一个规律来进行运算 我们就可以把它称作A和B在作与运算 与运算 用一个圆点来表示，那么知道了与运算，或就容易表示了 A和B是一个并联的开关，F仍然是一盏灯 在这种情况下，A和B这两个变量只要有 一个是闭合的，就是1，那么F就会点亮 对于两个变量A和B，我们说 按照这种方式进行的运算，被称作或运算 我们用一个加号来表示或运算 第三个非运算，这个比较容易理解，当开关A闭合的时候 这个灯就不亮了，只有开关A打开的时候，这个灯才会亮 也就是说它们两个是相反的，A为0，F为1；A为1，F为0，我们把这种运算称为非运算 还有一种运算是刚才我们提到的，**一个叫做异或，一个叫做同或 异或的运算是说参与运算的两个数 如果它们相同，那么这个结果就是0 只有它们相异的时候，这个结果才是1 同或运算刚刚相反，只有参与运算的这两个数如果相同结果为1，如果不同，结果为0** 
- 接下来我们看对二进制表示的数 有什么方法可以来进行运算？是不是运用传统的十进制的四则运算法则也可以计算呢？ 
  > 看一个例子 A等于1101，B等于1001，把这两个数相加 看怎么来计算，我们仍然可以利用四则运算法则的方式来进行计算 11相加逢二进一得10 那么这千万不要再写2了，有一个笑话说世界上只有10种人 一种懂二进制，一种不懂，那么从现在开始 大家都是懂二进制的人了，我们知道这个10代表2 利用四则运算法则我们可以完成这个计算，结果是10110 那有没有其他方法也可以完成这个计算呢？ 我们来看一下没有进位的情况，一一观察 1（和）1相加得10,1（和）0相加得01 这是按照四则运算法则也可以的出来的结论，0（和）1相加得01,0（和）0相加得00 这是按照四则运算法则得出来的一个结论 那么按照布尔逻辑我们再来观察一下，有什么结论呢？

  > **1（加）1得0，0（加）0得0 1（加）0得1，0（加）1得1 那么我们发现，也就是说，这两个数字只要是一样的 那么与它相对应的本位都是0 如果这两个数字是不一样的，与它相对应的本位都是1 这很显然是一个什么运算的结果？这是一个异或运算的结果 异或运算的结果。我们再来观察这个进位 只要这两个数字都是1 只有这两个数字都是1的情况下 进位才是1，除此之外，只要参与运算的两个数字中只要有一个为零， 那么进位都是0 这是一个什么运算的结果？这是一个与运算的结果** 由此我们可以看出布尔代数的重要作用 于是我们可以得到这样一个结论 就是说，**如果有两个数相加，A和B相加 那么这个本位的结果永远是异或运算的结果，而进位运算的结果永远是与运算的结果** 
- 由此我们可以看出，我们不用再去沿用四则运算的那种方式 去进行计算了 我们用逻辑运算照样可以 把二进制的加法算出来 但是像这种情况，是不考虑进位下的情况 **我们把按照这种规律构造起来的这种东西叫做半加器 半加器是用来算加法的 但是由于不考虑进位，它只能算一半，所以它叫[半加器](https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8#.E5.8D.8A.E5.8A.A0.E5.99.A8) 有了半加器**，我们怎样算更复杂的运算呢？大家思考一下 利用半加器能不能完成带进位的运算呢？ 其实可以的 我们只需要把多个半加器串联起来就可以了 看这个例子。**两个半加器串联起来，然后一个半加器计算结果 作为另一个半加器计算结果的输入 通过这种方式我们就可以得出有进位的时候的计算结果，我们把这种 带进位的情况叫做[全加器](https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8#.E5.8D.8A.E5.8A.A0.E5.99.A8)**。全加器就可以用来计算带进位的情况 
- 到目前为止，我们来回顾一下我们解答了哪些问题 
  - 第一个，我们已经解决的问题：数的表示用二进制 
  
  - 第二个：二进制数的计算方法，我们可以用布尔代数 用布尔代数逻辑运算的计算方法来进行运算 
  
  - 那接下来的问题是，存在不存在一个电路或者机械装置 可以很容易的实现布尔代数的逻辑运算呢？ 

    > **[与门](https://zh.wikipedia.org/wiki/%E4%B8%8E%E9%97%A8)，[或门](https://zh.wikipedia.org/wiki/%E6%88%96%E9%97%A8)，[非门](https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%9B%B8%E5%99%A8),[异或门](https://zh.wikipedia.org/wiki/%E5%BC%82%E6%88%96%E9%97%A8),[同或门](https://zh.wikipedia.org/wiki/%E5%90%8C%E6%88%96%E9%97%A8)**

    > 我们来解答一下这个问题 看一张图，这张图列出了我们刚才在半加器和全加器中所用的所有逻辑运算的线路图。比方说这个叫异或门 是用来做异或运算的，A和B是输入，这有一个输出 完成了异或运算，电路很简单，全都是三极管 这个是专门用来与运算的，A和B进行与运算 得到Y，这个是或运算的结果，我们可以看到，这些电路都非常简单 也就是说，所有的基本的逻辑运算都可以用电路来实现 我们来总结一下刚刚得到的所有的结论 首先，所有参与运算的数都可以转换成二进制数 二进制数之间的运算都可以通过基本的布尔代数来实现 所有基本的布尔运算都可以用电路来实现 所以我们得到一个结论：电路是能算数的，也就是说计算机是能够进行计算的 这就是我们今天得到的结论 那实际的状况是不是这样呢？有的同学可能很感兴趣。我们看这张图 这张图是一个CPU在高倍显微镜下的一张图片 我们可以看到在CPU里面有纵横交错的电路 这些电路都是由一些不同的电路门连接而成的 我希望经过这次课，我们所有的学生又有一种感觉 我们可以看得到，电路可以经过组合，三极管可以经过组合，可以实现基本的布尔逻辑的电路 不同的布尔逻辑的电路组合到一起又可以实现加法器等等一些东西 那我们就可以有这样一种感觉或信念 给我足够的三极管，我就可以自己组装一个可以计算的电路 OK，我们今天的课就讲到这里，下节课我们将探讨 计算机的过去、现在和未来，谢谢大家！ 
